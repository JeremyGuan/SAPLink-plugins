<?xml version="1.0" encoding="utf-8"?>
<nugget name="ABAPGIT">
 <PROG NAME="ZABAPGIT_FULL" VARCL="X" SUBC="1" RMAND="200" RLOAD="1" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="1">
    <textElement ID="R" ENTRY="zabapgit" LENGTH="8 "/>
   </language>
  </textPool>
  <source>REPORT zabapgit_full LINE-SIZE 100.

* See http://www.abapgit.org

********************************************************************************
* The MIT License (MIT)
*
* Copyright (c) 2014 abapGit Contributors
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the &quot;Software&quot;), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
********************************************************************************

CLASS zcx_abapgit_2fa_error DEFINITION
  inheriting from CX_STATIC_CHECK
  create public .

public section.

  data MV_TEXT type STRING read-only .

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .

  methods IF_MESSAGE~GET_TEXT
    redefinition .
protected section.

  methods GET_DEFAULT_TEXT
    returning
      value(RV_TEXT) type STRING .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_ERROR IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
.
me-&gt;MV_TEXT = MV_TEXT .
  endmethod.
  METHOD get_default_text.

    rv_text = &apos;Error in two factor authentication.&apos; ##NO_TEXT.

  ENDMETHOD.
  METHOD if_message~get_text.

    IF mv_text IS NOT INITIAL.
      result = mv_text.
    ELSEIF get_default_text( ) IS NOT INITIAL.
      result = get_default_text( ).
    ELSE.
      result = super-&gt;get_text( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_auth_failed DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_AUTH_FAILED IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;Authentication failed using 2FA.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_comm_error DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_COMM_ERROR IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;Communication error.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_del_failed DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_DEL_FAILED IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;Deleting previous access tokens failed.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_gen_failed DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_GEN_FAILED IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;Two factor access token generation failed.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_illegal_state DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_ILLEGAL_STATE IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;Illegal state.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_2fa_unsupported DEFINITION
  inheriting from ZCX_ABAPGIT_2FA_ERROR
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !TEXTID like TEXTID optional
      !PREVIOUS like PREVIOUS optional
      !MV_TEXT type STRING optional .
protected section.

  methods GET_DEFAULT_TEXT
    redefinition .
private section.
ENDCLASS.
CLASS ZCX_ABAPGIT_2FA_UNSUPPORTED IMPLEMENTATION.
  method CONSTRUCTOR.
CALL METHOD SUPER-&gt;CONSTRUCTOR
EXPORTING
TEXTID = TEXTID
PREVIOUS = PREVIOUS
MV_TEXT = MV_TEXT
.
  endmethod.
  METHOD get_default_text.
    rv_text = &apos;The service is not supported for two factor authentication.&apos; ##NO_TEXT.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_cancel DEFINITION
  INHERITING FROM cx_static_check
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcx_abapgit_cancel IMPLEMENTATION.
ENDCLASS.
&quot;! abapGit general error
CLASS zcx_abapgit_exception DEFINITION
  INHERITING FROM cx_static_check
  CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES:
      if_t100_message.
    CLASS-METHODS:
      &quot;! Raise exception with text
      &quot;! @parameter iv_text | Text
      &quot;! @parameter ix_previous | Previous exception
      &quot;! @raising zcx_abapgit_exception | Exception
      raise IMPORTING iv_text     TYPE clike
                      ix_previous TYPE REF TO cx_root OPTIONAL
            RAISING   zcx_abapgit_exception,
      &quot;! Raise exception with T100 message
      &quot;! &lt;p&gt;
      &quot;! Will default to sy-msg* variables. These need to be set right before calling this method.
      &quot;! &lt;/p&gt;
      &quot;! @parameter iv_msgid | Message ID
      &quot;! @parameter iv_msgno | Message number
      &quot;! @parameter iv_msgv1 | Message variable 1
      &quot;! @parameter iv_msgv2 | Message variable 2
      &quot;! @parameter iv_msgv3 | Message variable 3
      &quot;! @parameter iv_msgv4 | Message variable 4
      &quot;! @raising zcx_abapgit_exception | Exception
      raise_t100 IMPORTING VALUE(iv_msgid) TYPE symsgid DEFAULT sy-msgid
                           VALUE(iv_msgno) TYPE symsgno DEFAULT sy-msgno
                           VALUE(iv_msgv1) TYPE symsgv DEFAULT sy-msgv1
                           VALUE(iv_msgv2) TYPE symsgv DEFAULT sy-msgv2
                           VALUE(iv_msgv3) TYPE symsgv DEFAULT sy-msgv3
                           VALUE(iv_msgv4) TYPE symsgv DEFAULT sy-msgv4
                 RAISING   zcx_abapgit_exception .
    METHODS:
      constructor  IMPORTING textid   LIKE if_t100_message=&gt;t100key OPTIONAL
                             previous LIKE previous OPTIONAL
                             msgv1    TYPE symsgv OPTIONAL
                             msgv2    TYPE symsgv OPTIONAL
                             msgv3    TYPE symsgv OPTIONAL
                             msgv4    TYPE symsgv OPTIONAL.
    DATA:
      subrc TYPE sysubrc READ-ONLY,
      msgv1 TYPE symsgv READ-ONLY,
      msgv2 TYPE symsgv READ-ONLY,
      msgv3 TYPE symsgv READ-ONLY,
      msgv4 TYPE symsgv READ-ONLY.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CONSTANTS:
      gc_generic_error_msg TYPE string VALUE `An error occured (ZCX_ABAPGIT_EXCEPTION)` ##NO_TEXT.
ENDCLASS.
CLASS zcx_abapgit_exception IMPLEMENTATION.
  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    super-&gt;constructor( previous = previous ).

    me-&gt;msgv1 = msgv1.
    me-&gt;msgv2 = msgv2.
    me-&gt;msgv3 = msgv3.
    me-&gt;msgv4 = msgv4.

    CLEAR me-&gt;textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=&gt;default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.

  METHOD raise.
    DATA: lv_msgv1    TYPE symsgv,
          lv_msgv2    TYPE symsgv,
          lv_msgv3    TYPE symsgv,
          lv_msgv4    TYPE symsgv,
          ls_t100_key TYPE scx_t100key,
          lv_text     TYPE string.

    IF iv_text IS INITIAL.
      lv_text = gc_generic_error_msg.
    ELSE.
      lv_text = iv_text.
    ENDIF.

    cl_message_helper=&gt;set_msg_vars_for_clike( lv_text ).

    ls_t100_key-msgid = sy-msgid.
    ls_t100_key-msgno = sy-msgno.
    ls_t100_key-attr1 = &apos;MSGV1&apos;.
    ls_t100_key-attr2 = &apos;MSGV2&apos;.
    ls_t100_key-attr3 = &apos;MSGV3&apos;.
    ls_t100_key-attr4 = &apos;MSGV4&apos;.
    lv_msgv1 = sy-msgv1.
    lv_msgv2 = sy-msgv2.
    lv_msgv3 = sy-msgv3.
    lv_msgv4 = sy-msgv4.

    RAISE EXCEPTION TYPE zcx_abapgit_exception
      EXPORTING
        textid   = ls_t100_key
        msgv1    = lv_msgv1
        msgv2    = lv_msgv2
        msgv3    = lv_msgv3
        msgv4    = lv_msgv4
        previous = ix_previous.
  ENDMETHOD.

  METHOD raise_t100.
    DATA: ls_t100_key TYPE scx_t100key.

    ls_t100_key-msgid = iv_msgid.
    ls_t100_key-msgno = iv_msgno.
    ls_t100_key-attr1 = &apos;MSGV1&apos;.
    ls_t100_key-attr2 = &apos;MSGV2&apos;.
    ls_t100_key-attr3 = &apos;MSGV3&apos;.
    ls_t100_key-attr4 = &apos;MSGV4&apos;.

    IF iv_msgid IS INITIAL.
      CLEAR ls_t100_key.
    ENDIF.

    RAISE EXCEPTION TYPE zcx_abapgit_exception
      EXPORTING
        textid = ls_t100_key
        msgv1  = iv_msgv1
        msgv2  = iv_msgv2
        msgv3  = iv_msgv3
        msgv4  = iv_msgv4.
  ENDMETHOD.
ENDCLASS.
CLASS zcx_abapgit_not_found DEFINITION
  INHERITING FROM cx_static_check
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcx_abapgit_not_found IMPLEMENTATION.
ENDCLASS.
INTERFACE zif_abapgit_version DEFERRED.
INTERFACE zif_abapgit_tadir DEFERRED.
INTERFACE zif_abapgit_stage_logic DEFERRED.
INTERFACE zif_abapgit_sap_package DEFERRED.
INTERFACE zif_abapgit_repo_srv DEFERRED.
INTERFACE zif_abapgit_repo_listener DEFERRED.
INTERFACE zif_abapgit_gui_page_hotkey DEFERRED.
INTERFACE zif_abapgit_git_operations DEFERRED.
INTERFACE zif_abapgit_exit DEFERRED.
INTERFACE zif_abapgit_ecatt DEFERRED.
INTERFACE zif_abapgit_dot_abapgit DEFERRED.
INTERFACE zif_abapgit_definitions DEFERRED.
INTERFACE zif_abapgit_cts_api DEFERRED.
INTERFACE zif_abapgit_code_inspector DEFERRED.
INTERFACE zif_abapgit_branch_overview DEFERRED.
INTERFACE zif_abapgit_auth DEFERRED.
INTERFACE zif_abapgit_tag_popups DEFERRED.
INTERFACE zif_abapgit_popups DEFERRED.
INTERFACE zif_abapgit_gui_router DEFERRED.
INTERFACE zif_abapgit_gui_page DEFERRED.
INTERFACE zif_abapgit_gui_asset_manager DEFERRED.
INTERFACE zif_abapgit_persistence DEFERRED.
INTERFACE zif_abapgit_persist_user DEFERRED.
INTERFACE zif_abapgit_persist_repo DEFERRED.
INTERFACE zif_abapgit_oo_object_fnc DEFERRED.
INTERFACE zif_abapgit_object_enhs DEFERRED.
INTERFACE zif_abapgit_object_enho DEFERRED.
INTERFACE zif_abapgit_object DEFERRED.
INTERFACE zif_abapgit_gui_functions DEFERRED.
INTERFACE zif_abapgit_comparison_result DEFERRED.
INTERFACE zif_abapgit_2fa_authenticator DEFERRED.
INTERFACE zif_abapgit_background DEFERRED.
CLASS zcl_abapgit_zlib_stream DEFINITION DEFERRED.
CLASS zcl_abapgit_zlib_huffman DEFINITION DEFERRED.
CLASS zcl_abapgit_zlib_convert DEFINITION DEFERRED.
CLASS zcl_abapgit_zlib DEFINITION DEFERRED.
CLASS zcl_abapgit_zip DEFINITION DEFERRED.
CLASS zcl_abapgit_transport_objects DEFINITION DEFERRED.
CLASS zcl_abapgit_transport_2_branch DEFINITION DEFERRED.
CLASS zcl_abapgit_transport DEFINITION DEFERRED.
CLASS zcl_abapgit_tadir DEFINITION DEFERRED.
CLASS zcl_abapgit_syntax_check DEFINITION DEFERRED.
CLASS zcl_abapgit_stage_logic DEFINITION DEFERRED.
CLASS zcl_abapgit_stage DEFINITION DEFERRED.
CLASS zcl_abapgit_skip_objects DEFINITION DEFERRED.
CLASS zcl_abapgit_settings DEFINITION DEFERRED.
CLASS zcl_abapgit_serialize DEFINITION DEFERRED.
CLASS zcl_abapgit_sap_package DEFINITION DEFERRED.
CLASS zcl_abapgit_repo_srv DEFINITION DEFERRED.
CLASS zcl_abapgit_repo_online DEFINITION DEFERRED.
CLASS zcl_abapgit_repo_offline DEFINITION DEFERRED.
CLASS zcl_abapgit_repo_content_list DEFINITION DEFERRED.
CLASS zcl_abapgit_repo DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_bridge DEFINITION DEFERRED.
CLASS zcl_abapgit_objects DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhc DEFINITION DEFERRED.
CLASS zcl_abapgit_news DEFINITION DEFERRED.
CLASS zcl_abapgit_migrations DEFINITION DEFERRED.
CLASS zcl_abapgit_merge DEFINITION DEFERRED.
CLASS zcl_abapgit_longtexts DEFINITION DEFERRED.
CLASS zcl_abapgit_injector DEFINITION DEFERRED.
CLASS zcl_abapgit_http_client DEFINITION DEFERRED.
CLASS zcl_abapgit_folder_logic DEFINITION DEFERRED.
CLASS zcl_abapgit_file_status DEFINITION DEFERRED.
CLASS zcl_abapgit_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_exit DEFINITION DEFERRED.
CLASS zcl_abapgit_dot_abapgit DEFINITION DEFERRED.
CLASS zcl_abapgit_dependencies DEFINITION DEFERRED.
CLASS zcl_abapgit_default_transport DEFINITION DEFERRED.
CLASS zcl_abapgit_cts_api DEFINITION DEFERRED.
CLASS zcl_abapgit_code_inspector DEFINITION DEFERRED.
CLASS zcl_abapgit_branch_overview DEFINITION DEFERRED.
CLASS zcl_abapgit_auth DEFINITION DEFERRED.
CLASS zcl_abapgit_adhoc_code_insp DEFINITION DEFERRED.
CLASS zcl_abapgit_abap_unit_tests DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_pretty DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_output DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_input DEFINITION DEFERRED.
CLASS zcl_abapgit_xml DEFINITION DEFERRED.
CLASS zcl_abapgit_user_master_record DEFINITION DEFERRED.
CLASS zcl_abapgit_url DEFINITION DEFERRED.
CLASS zcl_abapgit_time DEFINITION DEFERRED.
CLASS zcl_abapgit_state DEFINITION DEFERRED.
CLASS zcl_abapgit_requirement_helper DEFINITION DEFERRED.
CLASS zcl_abapgit_progress DEFINITION DEFERRED.
CLASS zcl_abapgit_path DEFINITION DEFERRED.
CLASS zcl_abapgit_login_manager DEFINITION DEFERRED.
CLASS zcl_abapgit_log DEFINITION DEFERRED.
CLASS zcl_abapgit_language DEFINITION DEFERRED.
CLASS zcl_abapgit_hash DEFINITION DEFERRED.
CLASS zcl_abapgit_diff DEFINITION DEFERRED.
CLASS zcl_abapgit_convert DEFINITION DEFERRED.
CLASS zcl_abapgit_ui_injector DEFINITION DEFERRED.
CLASS zcl_abapgit_ui_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_tag_popups DEFINITION DEFERRED.
CLASS zcl_abapgit_services_repo DEFINITION DEFERRED.
CLASS zcl_abapgit_services_git DEFINITION DEFERRED.
CLASS zcl_abapgit_services_abapgit DEFINITION DEFERRED.
CLASS zcl_abapgit_popups DEFINITION DEFERRED.
CLASS zcl_abapgit_password_dialog DEFINITION DEFERRED.
CLASS zcl_abapgit_html_toolbar DEFINITION DEFERRED.
CLASS zcl_abapgit_html_action_utils DEFINITION DEFERRED.
CLASS zcl_abapgit_html DEFINITION DEFERRED.
CLASS zcl_abapgit_hotkeys DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_view_tutorial DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_view_repo DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_router DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_tag DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_syntax DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_stage DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_settings DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_repo_sett DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_repo_over DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_merge_res DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_merge DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_main DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_explore DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_diff DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_debuginfo DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_commit DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_codi_base DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_code_insp DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_boverview DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_bkg_run DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_bkg DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_functions DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_chunk_lib DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_asset_manager DEFINITION DEFERRED.
CLASS zcl_abapgit_gui DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_db_edit DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_db_dis DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_page_db DEFINITION DEFERRED.
CLASS zcl_abapgit_test_serialize DEFINITION DEFERRED.
CLASS zcl_abapgit_syntax_xml DEFINITION DEFERRED.
CLASS zcl_abapgit_syntax_highlighter DEFINITION DEFERRED.
CLASS zcl_abapgit_syntax_abap DEFINITION DEFERRED.
CLASS zcl_abapgit_persistence_user DEFINITION DEFERRED.
CLASS zcl_abapgit_persistence_repo DEFINITION DEFERRED.
CLASS zcl_abapgit_persistence_db DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_settings DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_migrate DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_injector DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_background DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_serializer DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_interface DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_class_new DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_class DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_base DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_super DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_saxx_super DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_program DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_generic DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_files DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_activation DEFINITION DEFERRED.
CLASS zcl_abapgit_object_xslt DEFINITION DEFERRED.
CLASS zcl_abapgit_object_xinx DEFINITION DEFERRED.
CLASS zcl_abapgit_object_webi DEFINITION DEFERRED.
CLASS zcl_abapgit_object_wdyn DEFINITION DEFERRED.
CLASS zcl_abapgit_object_wdya DEFINITION DEFERRED.
CLASS zcl_abapgit_object_wapa DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3super DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3mi DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3ht DEFINITION DEFERRED.
CLASS zcl_abapgit_object_view DEFINITION DEFERRED.
CLASS zcl_abapgit_object_vcls DEFINITION DEFERRED.
CLASS zcl_abapgit_object_udmo DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ucsa DEFINITION DEFERRED.
CLASS zcl_abapgit_object_type DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ttyp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tran DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tobj DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl_valid DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl_dialog DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sxci DEFINITION DEFERRED.
CLASS zcl_abapgit_object_suso DEFINITION DEFERRED.
CLASS zcl_abapgit_object_susc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sucu DEFINITION DEFERRED.
CLASS zcl_abapgit_object_styl DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ssst DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ssfo DEFINITION DEFERRED.
CLASS zcl_abapgit_object_srfc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_splo DEFINITION DEFERRED.
CLASS zcl_abapgit_object_smim DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sicf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shma DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shlp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shi8 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shi5 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shi3 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sfsw DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sfpi DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sfpf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sfbs DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sfbf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_scp1 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sapc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_samc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_prog DEFINITION DEFERRED.
CLASS zcl_abapgit_object_prag DEFINITION DEFERRED.
CLASS zcl_abapgit_object_pinf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_para DEFINITION DEFERRED.
CLASS zcl_abapgit_object_nrob DEFINITION DEFERRED.
CLASS zcl_abapgit_object_msag DEFINITION DEFERRED.
CLASS zcl_abapgit_object_jobd DEFINITION DEFERRED.
CLASS zcl_abapgit_object_intf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_iext DEFINITION DEFERRED.
CLASS zcl_abapgit_object_idoc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_iatu DEFINITION DEFERRED.
CLASS zcl_abapgit_object_iasp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_iarp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_iamu DEFINITION DEFERRED.
CLASS zcl_abapgit_object_fugr DEFINITION DEFERRED.
CLASS zcl_abapgit_object_form DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ensc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enqu DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs_hook_d DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs_badi_d DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_wdyn DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_wdyc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_intf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_hook DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_fugr DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_clif DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_class DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_badi DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ecvo DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ectd DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ectc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ecsp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ecsd DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ecatt_super DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ecat DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dtel DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dsys DEFINITION DEFERRED.
CLASS zcl_abapgit_object_doma DEFINITION DEFERRED.
CLASS zcl_abapgit_object_docv DEFINITION DEFERRED.
CLASS zcl_abapgit_object_doct DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dial DEFINITION DEFERRED.
CLASS zcl_abapgit_object_devc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ddlx DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ddls DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dcls DEFINITION DEFERRED.
CLASS zcl_abapgit_object_cus2 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_cus1 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_cus0 DEFINITION DEFERRED.
CLASS zcl_abapgit_object_cmpt DEFINITION DEFERRED.
CLASS zcl_abapgit_object_clas_new DEFINITION DEFERRED.
CLASS zcl_abapgit_object_clas DEFINITION DEFERRED.
CLASS zcl_abapgit_object_char DEFINITION DEFERRED.
CLASS zcl_abapgit_object_avas DEFINITION DEFERRED.
CLASS zcl_abapgit_object_auth DEFINITION DEFERRED.
CLASS zcl_abapgit_object_asfc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_acid DEFINITION DEFERRED.
CLASS zcl_abapgit_comparison_null DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_val_obj_upl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_val_obj_down DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_system_upl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_system_downl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_sp_upload DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_sp_download DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_script_upl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_script_downl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_helper DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_data_upload DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_data_downl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_config_upl DEFINITION DEFERRED.
CLASS zcl_abapgit_ecatt_config_downl DEFINITION DEFERRED.
CLASS zcl_abapgit_proxy_config DEFINITION DEFERRED.
CLASS zcl_abapgit_proxy_auth DEFINITION DEFERRED.
CLASS zcl_abapgit_http_digest DEFINITION DEFERRED.
CLASS zcl_abapgit_http DEFINITION DEFERRED.
CLASS zcl_abapgit_2fa_github_auth DEFINITION DEFERRED.
CLASS zcl_abapgit_2fa_auth_registry DEFINITION DEFERRED.
CLASS zcl_abapgit_2fa_auth_base DEFINITION DEFERRED.
CLASS zcl_abapgit_tag DEFINITION DEFERRED.
CLASS zcl_abapgit_git_utils DEFINITION DEFERRED.
CLASS zcl_abapgit_git_transport DEFINITION DEFERRED.
CLASS zcl_abapgit_git_porcelain DEFINITION DEFERRED.
CLASS zcl_abapgit_git_pack DEFINITION DEFERRED.
CLASS zcl_abapgit_git_branch_list DEFINITION DEFERRED.
CLASS zcl_abapgit_git_add_patch DEFINITION DEFERRED.
CLASS zcl_abapgit_background_push_fi DEFINITION DEFERRED.
CLASS zcl_abapgit_background_push_au DEFINITION DEFERRED.
CLASS zcl_abapgit_background_pull DEFINITION DEFERRED.
CLASS zcl_abapgit_background DEFINITION DEFERRED.
INTERFACE zif_abapgit_background .
  TYPES:
    BEGIN OF ty_settings,
      key   TYPE string,
      value TYPE string,
    END OF ty_settings .
  TYPES:
    ty_settings_tt TYPE STANDARD TABLE OF ty_settings WITH DEFAULT KEY .

  CLASS-METHODS get_description
    RETURNING
      VALUE(rv_description) TYPE string .
  CLASS-METHODS get_settings
    CHANGING
      VALUE(ct_settings) TYPE ty_settings_tt .
  METHODS run
    IMPORTING
      !io_repo     TYPE REF TO zcl_abapgit_repo_online
      !io_log      TYPE REF TO zcl_abapgit_log
      !it_settings TYPE ty_settings_tt OPTIONAL
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.
INTERFACE zif_abapgit_2fa_authenticator.
  &quot;! Generate an access token
  &quot;! @parameter iv_url | Repository url
  &quot;! @parameter iv_username | Username
  &quot;! @parameter iv_password | Password
  &quot;! @parameter iv_2fa_token | Two factor token
  &quot;! @parameter rv_access_token | Generated access token
  &quot;! @raising zcx_abapgit_2fa_auth_failed | Authentication failed
  &quot;! @raising zcx_abapgit_2fa_gen_failed | Token generation failed
  METHODS authenticate
    IMPORTING
      !iv_url                TYPE string
      !iv_username           TYPE string
      !iv_password           TYPE string
      !iv_2fa_token          TYPE string
    RETURNING
      VALUE(rv_access_token) TYPE string
    RAISING
      zcx_abapgit_2fa_auth_failed
      zcx_abapgit_2fa_gen_failed
      zcx_abapgit_2fa_comm_error .
  &quot;! Check if this authenticator instance supports the given repository url
  &quot;! @parameter iv_url | Repository url
  &quot;! @parameter rv_supported | Is supported
  METHODS supports_url
    IMPORTING
      !iv_url             TYPE string
    RETURNING
      VALUE(rv_supported) TYPE abap_bool .
  &quot;! Check if two factor authentication is required
  &quot;! @parameter iv_url | Repository url
  &quot;! @parameter iv_username | Username
  &quot;! @parameter iv_password | Password
  &quot;! @parameter rv_required | 2FA is required
  METHODS is_2fa_required
    IMPORTING
      !iv_url            TYPE string
      !iv_username       TYPE string
      !iv_password       TYPE string
    RETURNING
      VALUE(rv_required) TYPE abap_bool
    RAISING
      zcx_abapgit_2fa_comm_error .
  &quot;! Delete all previously created access tokens for abapGit
  &quot;! @parameter iv_url | Repository url
  &quot;! @parameter iv_username | Username
  &quot;! @parameter iv_password | Password
  &quot;! @parameter iv_2fa_token | Two factor token
  &quot;! @raising zcx_abapgit_2fa_del_failed | Token deletion failed
  &quot;! @raising zcx_abapgit_2fa_auth_failed | Authentication failed
  METHODS delete_access_tokens
    IMPORTING
      !iv_url       TYPE string
      !iv_username  TYPE string
      !iv_password  TYPE string
      !iv_2fa_token TYPE string
    RAISING
      zcx_abapgit_2fa_del_failed
      zcx_abapgit_2fa_comm_error
      zcx_abapgit_2fa_auth_failed .
  &quot;! Begin an authenticator session that uses internal caching for authorizations
  &quot;! @raising zcx_abapgit_2fa_illegal_state | Session already started
  METHODS begin
    RAISING
      zcx_abapgit_2fa_illegal_state .
  &quot;! End an authenticator session and clear internal caches
  &quot;! @raising zcx_abapgit_2fa_illegal_state | Session not running
  METHODS end
    RAISING
      zcx_abapgit_2fa_illegal_state .
ENDINTERFACE.
INTERFACE zif_abapgit_comparison_result.

  METHODS:
    show_confirmation_dialog,
    is_result_complete_halt
      RETURNING VALUE(rv_response) TYPE abap_bool.

ENDINTERFACE.
INTERFACE zif_abapgit_gui_functions .

  METHODS:
    gui_is_available
      RETURNING
        VALUE(rv_gui_is_available) TYPE abap_bool.

ENDINTERFACE.
INTERFACE zif_abapgit_object_enho.

  METHODS:
    deserialize
      IMPORTING io_xml     TYPE REF TO zcl_abapgit_xml_input
                iv_package TYPE devclass
      RAISING   zcx_abapgit_exception,
    serialize
      IMPORTING io_xml      TYPE REF TO zcl_abapgit_xml_output
                ii_enh_tool TYPE REF TO if_enh_tool
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_object_enhs.

  METHODS:
    deserialize
      IMPORTING io_xml           TYPE REF TO zcl_abapgit_xml_input
                iv_package       TYPE devclass
                ii_enh_spot_tool TYPE REF TO if_enh_spot_tool
      RAISING   zcx_abapgit_exception,

    serialize
      IMPORTING io_xml           TYPE REF TO zcl_abapgit_xml_output
                ii_enh_spot_tool TYPE REF TO if_enh_spot_tool
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_gui_asset_manager .

  TYPES:
    BEGIN OF ty_web_asset,
      url     TYPE w3url,
      type    TYPE char50,
      subtype TYPE char50,
      content TYPE xstring,
    END OF ty_web_asset .
  TYPES:
    tt_web_assets TYPE STANDARD TABLE OF ty_web_asset WITH DEFAULT KEY .

  METHODS get_all_assets
    RETURNING
      VALUE(rt_assets) TYPE tt_web_assets
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_gui_page.

  METHODS on_event
    IMPORTING iv_action    TYPE clike
              iv_prev_page TYPE clike
              iv_getdata   TYPE clike OPTIONAL
              it_postdata  TYPE cnht_post_data_tab OPTIONAL
    EXPORTING ei_page      TYPE REF TO zif_abapgit_gui_page
              ev_state     TYPE i
    RAISING   zcx_abapgit_exception zcx_abapgit_cancel.

  METHODS render
    RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
    RAISING   zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_gui_router .

  METHODS on_event
    IMPORTING
      iv_action    TYPE clike
      iv_prev_page TYPE clike
      iv_getdata   TYPE clike OPTIONAL
      it_postdata  TYPE cnht_post_data_tab OPTIONAL
    EXPORTING
      ei_page      TYPE REF TO zif_abapgit_gui_page
      ev_state     TYPE i
    RAISING
      zcx_abapgit_exception
      zcx_abapgit_cancel.

ENDINTERFACE.
INTERFACE zif_abapgit_auth.

  TYPES: ty_authorization TYPE string.

  CONSTANTS: BEGIN OF gc_authorization,
               uninstall             TYPE ty_authorization VALUE &apos;UNINSTALL&apos;,
               transport_to_branch   TYPE ty_authorization VALUE &apos;TRANSPORT_TO_BRANCH&apos;,
               update_local_checksum TYPE ty_authorization VALUE &apos;UPDATE_LOCAL_CHECKSUM&apos;,
             END OF gc_authorization.

  METHODS:
    is_allowed
      IMPORTING iv_authorization  TYPE ty_authorization
                iv_param          TYPE string OPTIONAL
      RETURNING VALUE(rv_allowed) TYPE abap_bool.

ENDINTERFACE.
INTERFACE zif_abapgit_code_inspector.

  METHODS:
    run
      RETURNING
        VALUE(rt_list) TYPE scit_alvlist
      RAISING
        zcx_abapgit_exception,

    get_inspection
      RETURNING
        VALUE(ro_inspection) TYPE REF TO cl_ci_inspection.

ENDINTERFACE.
INTERFACE zif_abapgit_cts_api.
  METHODS:
    &quot;! Returns the transport request / task the object is currently locked in
    &quot;! @parameter iv_program_id | Program ID
    &quot;! @parameter iv_object_type | Object type
    &quot;! @parameter iv_object_name | Object name
    &quot;! @parameter iv_resolve_task_to_request | Return the transport request number if the object is locked in a task
    &quot;! @parameter rv_transport | Transport request / task
    &quot;! @raising zcx_abapgit_exception | Object is not locked in a transport
    get_current_transport_for_obj IMPORTING iv_program_id              TYPE pgmid DEFAULT &apos;R3TR&apos;
                                            iv_object_type             TYPE trobjtype
                                            iv_object_name             TYPE sobj_name
                                            iv_resolve_task_to_request TYPE abap_bool DEFAULT abap_true
                                  RETURNING VALUE(rv_transport)        TYPE trkorr
                                  RAISING   zcx_abapgit_exception,
    &quot;! Check if the object is currently locked in a transport
    &quot;! @parameter iv_program_id | Program ID
    &quot;! @parameter iv_object_type | Object type
    &quot;! @parameter iv_object_name | Object name
    &quot;! @parameter rv_locked | Object is locked
    &quot;! @raising zcx_abapgit_exception | Object type is not lockable
    is_object_locked_in_transport IMPORTING iv_program_id    TYPE pgmid DEFAULT &apos;R3TR&apos;
                                            iv_object_type   TYPE trobjtype
                                            iv_object_name   TYPE sobj_name
                                  RETURNING VALUE(rv_locked) TYPE abap_bool
                                  RAISING   zcx_abapgit_exception,
    &quot;! Check if the object type is lockable
    &quot;! @parameter iv_program_id | Program ID
    &quot;! @parameter iv_object_type | Object type
    &quot;! @parameter rv_lockable | Lockable
    is_object_type_lockable IMPORTING iv_program_id      TYPE pgmid DEFAULT &apos;R3TR&apos;
                                      iv_object_type     TYPE trobjtype
                            RETURNING VALUE(rv_lockable) TYPE abap_bool,
    &quot;! Check if change recording is possible for the given package
    &quot;! @parameter iv_package | Package
    &quot;! @parameter rv_possible | Change recording is possible
    &quot;! @raising zcx_abapgit_exception | Package could not be loaded
    is_chrec_possible_for_package IMPORTING iv_package         TYPE devclass
                                  RETURNING VALUE(rv_possible) TYPE abap_bool
                                  RAISING   zcx_abapgit_exception.
ENDINTERFACE.
INTERFACE zif_abapgit_definitions.

  TYPES:
    ty_type    TYPE c LENGTH 6 .
  TYPES:
    ty_bitbyte TYPE c LENGTH 8 .
  TYPES:
    ty_sha1    TYPE c LENGTH 40 .
  TYPES: ty_adler32 TYPE x LENGTH 4.
  TYPES:
    BEGIN OF ty_file_signature,
      path     TYPE string,
      filename TYPE string,
      sha1     TYPE zif_abapgit_definitions=&gt;ty_sha1,
    END OF ty_file_signature .
  TYPES:
    ty_file_signatures_tt TYPE STANDARD TABLE OF
           ty_file_signature WITH DEFAULT KEY .
  TYPES:
    ty_file_signatures_ts TYPE SORTED TABLE OF
           ty_file_signature WITH UNIQUE KEY path filename .
  TYPES:
    BEGIN OF ty_file.
      INCLUDE TYPE ty_file_signature.
  TYPES: data TYPE xstring,
         END OF ty_file .
  TYPES:
    ty_files_tt TYPE STANDARD TABLE OF ty_file WITH DEFAULT KEY .
  TYPES:
    ty_string_tt TYPE STANDARD TABLE OF string WITH DEFAULT KEY .

  TYPES: ty_repo_ref_tt TYPE STANDARD TABLE OF REF TO zcl_abapgit_repo WITH DEFAULT KEY.

  TYPES ty_git_branch_type TYPE char2 .
  TYPES:
    BEGIN OF ty_git_branch,
      sha1         TYPE zif_abapgit_definitions=&gt;ty_sha1,
      name         TYPE string,
      type         TYPE ty_git_branch_type,
      is_head      TYPE abap_bool,
      display_name TYPE string,
    END OF ty_git_branch .
  TYPES:
    ty_git_branch_list_tt TYPE STANDARD TABLE OF ty_git_branch WITH DEFAULT KEY .

  TYPES:
    BEGIN OF ty_git_tag,
      sha1         TYPE zif_abapgit_definitions=&gt;ty_sha1,
      object       TYPE zif_abapgit_definitions=&gt;ty_sha1,
      name         TYPE string,
      type         TYPE ty_git_branch_type,
      display_name TYPE string,
      tagger_name  TYPE string,
      tagger_email TYPE string,
      message      TYPE string,
      body         TYPE string,
    END OF ty_git_tag .
  TYPES:
    ty_git_tag_list_tt TYPE STANDARD TABLE OF ty_git_tag WITH DEFAULT KEY .

  TYPES:
    BEGIN OF ty_hotkey,
      sequence TYPE string,
      action   TYPE string,
    END OF ty_hotkey,
    tty_hotkey TYPE STANDARD TABLE OF ty_hotkey
                    WITH NON-UNIQUE DEFAULT KEY.

  CONSTANTS:
    BEGIN OF c_git_branch_type,
      branch          TYPE ty_git_branch_type VALUE &apos;HD&apos;,
      lightweight_tag TYPE ty_git_branch_type VALUE &apos;TG&apos;,
      annotated_tag   TYPE ty_git_branch_type VALUE &apos;AT&apos;,
      other           TYPE ty_git_branch_type VALUE &apos;ZZ&apos;,
    END OF c_git_branch_type .
  CONSTANTS c_head_name TYPE string VALUE &apos;HEAD&apos; ##NO_TEXT.

  TYPES:
    BEGIN OF ty_git_user,
      name  TYPE string,
      email TYPE string,
    END OF ty_git_user .
  TYPES:
    BEGIN OF ty_comment,
      committer TYPE ty_git_user,
      author    TYPE ty_git_user,
      comment   TYPE string,
    END OF ty_comment .
  TYPES:
    BEGIN OF ty_item,
      obj_type TYPE tadir-object,
      obj_name TYPE tadir-obj_name,
      devclass TYPE devclass,
      inactive TYPE abap_bool,
    END OF ty_item .
  TYPES:
    ty_items_tt TYPE STANDARD TABLE OF ty_item WITH DEFAULT KEY .
  TYPES:
    ty_items_ts TYPE SORTED TABLE OF ty_item WITH UNIQUE KEY obj_type obj_name .
  TYPES:
    BEGIN OF ty_file_item,
      file TYPE zif_abapgit_definitions=&gt;ty_file,
      item TYPE ty_item,
    END OF ty_file_item .
  TYPES:
    ty_files_item_tt TYPE STANDARD TABLE OF ty_file_item WITH DEFAULT KEY .

  TYPES: ty_yes_no TYPE c LENGTH 1.

  TYPES: BEGIN OF ty_overwrite.
      INCLUDE TYPE ty_item.
  TYPES: decision TYPE ty_yes_no,
         END OF ty_overwrite.

  TYPES: ty_overwrite_tt TYPE STANDARD TABLE OF ty_overwrite WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_requirements,
           met      TYPE ty_yes_no,
           decision TYPE ty_yes_no,
         END OF ty_requirements.

  TYPES: BEGIN OF ty_transport_type,
           request TYPE trfunction,
           task    TYPE trfunction,
         END OF ty_transport_type.

  TYPES: BEGIN OF ty_transport,
           required  TYPE abap_bool,
           transport TYPE trkorr,
           type      TYPE ty_transport_type,
         END OF ty_transport.
  TYPES: BEGIN OF ty_deserialize_checks,
           overwrite       TYPE ty_overwrite_tt,
           warning_package TYPE ty_overwrite_tt,
           requirements    TYPE ty_requirements,
           transport       TYPE ty_transport,
         END OF ty_deserialize_checks,
         BEGIN OF ty_delete_checks,
           transport TYPE ty_transport,
         END OF ty_delete_checks.

  TYPES:
    BEGIN OF ty_metadata,
      class        TYPE string,
      version      TYPE string,
      late_deser   TYPE abap_bool,
      delete_tadir TYPE abap_bool,
      ddic         TYPE abap_bool,
    END OF ty_metadata .
  TYPES:
    BEGIN OF ty_repo_file,
      path       TYPE string,
      filename   TYPE string,
      is_changed TYPE abap_bool,
      rstate     TYPE char1,
      lstate     TYPE char1,
    END OF ty_repo_file .
  TYPES:
    tt_repo_files TYPE STANDARD TABLE OF ty_repo_file WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_stage_files,
      local  TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
      remote TYPE zif_abapgit_definitions=&gt;ty_files_tt,
    END OF ty_stage_files .
  TYPES:
    ty_chmod TYPE c LENGTH 6 .
  TYPES:
    BEGIN OF ty_object,
      sha1    TYPE zif_abapgit_definitions=&gt;ty_sha1,
      type    TYPE zif_abapgit_definitions=&gt;ty_type,
      data    TYPE xstring,
      adler32 TYPE ty_adler32,
      index   TYPE i,
    END OF ty_object .
  TYPES:
    ty_objects_tt TYPE STANDARD TABLE OF ty_object WITH DEFAULT KEY
      WITH NON-UNIQUE SORTED KEY sha COMPONENTS sha1
      WITH NON-UNIQUE SORTED KEY type COMPONENTS type sha1.
  TYPES:
    BEGIN OF ty_tadir,
      pgmid    TYPE tadir-pgmid,
      object   TYPE tadir-object,
      obj_name TYPE tadir-obj_name,
      devclass TYPE tadir-devclass,
      korrnum  TYPE tadir-korrnum,
      delflag  TYPE tadir-delflag,
      path     TYPE string,
    END OF ty_tadir .
  TYPES:
    ty_tadir_tt TYPE STANDARD TABLE OF ty_tadir WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_result,
      obj_type TYPE tadir-object,
      obj_name TYPE tadir-obj_name,
      inactive TYPE abap_bool,
      path     TYPE string,
      filename TYPE string,
      package  TYPE devclass,
      match    TYPE sap_bool,
      lstate   TYPE char1,
      rstate   TYPE char1,
    END OF ty_result .
  TYPES:
    ty_results_tt TYPE STANDARD TABLE OF ty_result WITH DEFAULT KEY .
  TYPES:
    ty_sval_tt TYPE STANDARD TABLE OF sval WITH DEFAULT KEY .
  TYPES:
    ty_seocompotx_tt TYPE STANDARD TABLE OF seocompotx WITH DEFAULT KEY.
  TYPES:
    BEGIN OF ty_tpool.
      INCLUDE TYPE textpool.
  TYPES:   split TYPE c LENGTH 8.
  TYPES: END OF ty_tpool .
  TYPES:
    ty_tpool_tt TYPE STANDARD TABLE OF ty_tpool WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_sotr,
      header  TYPE sotr_head,
      entries TYPE sotr_text_tt,
    END OF ty_sotr .
  TYPES:
    ty_sotr_tt TYPE STANDARD TABLE OF ty_sotr WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_obj_attribute,
      cmpname   TYPE seocmpname,
      attkeyfld TYPE seokeyfld,
      attbusobj TYPE seobusobj,
    END OF ty_obj_attribute,
    ty_obj_attribute_tt TYPE STANDARD TABLE OF ty_obj_attribute WITH DEFAULT KEY
                             WITH NON-UNIQUE SORTED KEY cmpname COMPONENTS cmpname.
  TYPES:
    BEGIN OF ty_transport_to_branch,
      branch_name TYPE string,
      commit_text TYPE string,
    END OF ty_transport_to_branch .

  TYPES: BEGIN OF ty_create,
           name   TYPE string,
           parent TYPE string,
         END OF ty_create.

  TYPES: BEGIN OF ty_commit,
           sha1       TYPE ty_sha1,
           parent1    TYPE ty_sha1,
           parent2    TYPE ty_sha1,
           author     TYPE string,
           email      TYPE string,
           time       TYPE string,
           message    TYPE string,
           branch     TYPE string,
           merge      TYPE string,
           tags       TYPE stringtab,
           create     TYPE STANDARD TABLE OF ty_create WITH DEFAULT KEY,
           compressed TYPE abap_bool,
         END OF ty_commit.

  TYPES: ty_commit_tt TYPE STANDARD TABLE OF ty_commit WITH DEFAULT KEY.

  CONSTANTS: BEGIN OF c_diff,
               insert TYPE c LENGTH 1 VALUE &apos;I&apos;,
               delete TYPE c LENGTH 1 VALUE &apos;D&apos;,
               update TYPE c LENGTH 1 VALUE &apos;U&apos;,
             END OF c_diff.

  TYPES: BEGIN OF ty_diff,
           patch_flag TYPE abap_bool,
           new_num    TYPE c LENGTH 6,
           new        TYPE string,
           result     TYPE c LENGTH 1,
           old_num    TYPE c LENGTH 6,
           old        TYPE string,
           short      TYPE abap_bool,
           beacon     TYPE i,
         END OF ty_diff.
  TYPES:  ty_diffs_tt TYPE STANDARD TABLE OF ty_diff WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_count,
           insert TYPE i,
           delete TYPE i,
           update TYPE i,
         END OF ty_count.

  TYPES:
    BEGIN OF ty_expanded,
      path  TYPE string,
      name  TYPE string,
      sha1  TYPE ty_sha1,
      chmod TYPE ty_chmod,
    END OF ty_expanded .
  TYPES:
    ty_expanded_tt TYPE STANDARD TABLE OF ty_expanded WITH DEFAULT KEY .

  TYPES: BEGIN OF ty_ancestor,
           commit TYPE ty_sha1,
           tree   TYPE ty_sha1,
           time   TYPE string,
           body   TYPE string,
         END OF ty_ancestor.

  TYPES: BEGIN OF ty_merge,
           repo     TYPE REF TO zcl_abapgit_repo_online,
           source   TYPE ty_git_branch,
           target   TYPE ty_git_branch,
           common   TYPE ty_ancestor,
           stree    TYPE ty_expanded_tt,
           ttree    TYPE ty_expanded_tt,
           ctree    TYPE ty_expanded_tt,
           result   TYPE ty_expanded_tt,
           stage    TYPE REF TO zcl_abapgit_stage,
           conflict TYPE string,
         END OF ty_merge.

  TYPES: BEGIN OF ty_merge_conflict,
           path        TYPE string,
           filename    TYPE string,
           source_sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1,
           source_data TYPE xstring,
           target_sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1,
           target_data TYPE xstring,
           result_sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1,
           result_data TYPE xstring,
         END OF ty_merge_conflict,
         tt_merge_conflict TYPE STANDARD TABLE OF ty_merge_conflict WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_repo_item,
           obj_type TYPE tadir-object,
           obj_name TYPE tadir-obj_name,
           inactive TYPE abap_bool,
           sortkey  TYPE i,
           path     TYPE string,
           is_dir   TYPE abap_bool,
           changes  TYPE i,
           lstate   TYPE char1,
           rstate   TYPE char1,
           files    TYPE tt_repo_files,
         END OF ty_repo_item.
  TYPES tt_repo_items TYPE STANDARD TABLE OF ty_repo_item WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_s_user_settings,
           max_lines                  TYPE i,
           adt_jump_enabled           TYPE abap_bool,
           show_default_repo          TYPE abap_bool,
           link_hints_enabled         TYPE abap_bool,
           link_hint_key              TYPE char01,
           link_hint_background_color TYPE string,
           hotkeys                    TYPE tty_hotkey,
         END OF ty_s_user_settings.

  TYPES:
          tty_dokil TYPE STANDARD TABLE OF dokil
                         WITH NON-UNIQUE DEFAULT KEY.
  TYPES: tty_lines TYPE STANDARD TABLE OF i
                        WITH NON-UNIQUE DEFAULT KEY,
         BEGIN OF ty_patch,
           filename  TYPE string,
           lines_new TYPE tty_lines,
           lines_old TYPE tty_lines,
         END OF ty_patch,
         tty_patch TYPE HASHED TABLE OF ty_patch
                        WITH UNIQUE KEY filename.

  CONSTANTS:
    BEGIN OF c_type,
      commit TYPE zif_abapgit_definitions=&gt;ty_type VALUE &apos;commit&apos;, &quot;#EC NOTEXT
      tree   TYPE zif_abapgit_definitions=&gt;ty_type VALUE &apos;tree&apos;, &quot;#EC NOTEXT
      ref_d  TYPE zif_abapgit_definitions=&gt;ty_type VALUE &apos;ref_d&apos;, &quot;#EC NOTEXT
      tag    TYPE zif_abapgit_definitions=&gt;ty_type VALUE &apos;tag&apos;, &quot;#EC NOTEXT
      blob   TYPE zif_abapgit_definitions=&gt;ty_type VALUE &apos;blob&apos;, &quot;#EC NOTEXT
    END OF c_type .
  CONSTANTS:
    BEGIN OF c_state, &quot; https://git-scm.com/docs/git-status
      unchanged TYPE char1 VALUE &apos;&apos;,
      added     TYPE char1 VALUE &apos;A&apos;,
      modified  TYPE char1 VALUE &apos;M&apos;,
      deleted   TYPE char1 VALUE &apos;D&apos;, &quot;For future use
      mixed     TYPE char1 VALUE &apos;*&apos;,
    END OF c_state .
  CONSTANTS:
    BEGIN OF c_chmod,
      file       TYPE ty_chmod VALUE &apos;100644&apos;,
      executable TYPE ty_chmod VALUE &apos;100755&apos;,
      dir        TYPE ty_chmod VALUE &apos;40000 &apos;,
    END OF c_chmod .
  CONSTANTS:
    BEGIN OF c_event_state,
      not_handled         VALUE 0,
      re_render           VALUE 1,
      new_page            VALUE 2,
      go_back             VALUE 3,
      no_more_act         VALUE 4,
      new_page_w_bookmark VALUE 5,
      go_back_to_bookmark VALUE 6,
      new_page_replacing  VALUE 7,
    END OF c_event_state .
  CONSTANTS:
    BEGIN OF c_html_opt,
      strong   TYPE c VALUE &apos;E&apos;,
      cancel   TYPE c VALUE &apos;C&apos;,
      crossout TYPE c VALUE &apos;X&apos;,
    END OF c_html_opt .
  CONSTANTS:
    BEGIN OF c_action_type,
      sapevent  TYPE c VALUE &apos;E&apos;,
      url       TYPE c VALUE &apos;U&apos;,
      onclick   TYPE c VALUE &apos;C&apos;,
      separator TYPE c VALUE &apos;S&apos;,
      dummy     TYPE c VALUE &apos;_&apos;,
    END OF c_action_type .
  CONSTANTS c_crlf TYPE abap_cr_lf VALUE cl_abap_char_utilities=&gt;cr_lf ##NO_TEXT.
  CONSTANTS c_newline TYPE abap_char1 VALUE cl_abap_char_utilities=&gt;newline ##NO_TEXT.
  CONSTANTS c_english TYPE spras VALUE &apos;E&apos; ##NO_TEXT.
  CONSTANTS c_root_dir TYPE string VALUE &apos;/&apos; ##NO_TEXT.
  CONSTANTS c_dot_abapgit TYPE string VALUE &apos;.abapgit.xml&apos; ##NO_TEXT.
  CONSTANTS c_author_regex TYPE string VALUE &apos;^([\\\w\s\.\*\,\#@\-_1-9\(\) ]+) &lt;(.*)&gt; (\d{10})\s?.\d{4}$&apos; ##NO_TEXT.
  CONSTANTS:
    BEGIN OF c_action,
      repo_refresh             TYPE string VALUE &apos;repo_refresh&apos;,
      repo_remove              TYPE string VALUE &apos;repo_remove&apos;,
      repo_settings            TYPE string VALUE &apos;repo_settings&apos;,
      repo_purge               TYPE string VALUE &apos;repo_purge&apos;,
      repo_newonline           TYPE string VALUE &apos;repo_newonline&apos;,
      repo_newoffline          TYPE string VALUE &apos;repo_newoffline&apos;,
      repo_remote_attach       TYPE string VALUE &apos;repo_remote_attach&apos;,
      repo_remote_detach       TYPE string VALUE &apos;repo_remote_detach&apos;,
      repo_remote_change       TYPE string VALUE &apos;repo_remote_change&apos;,
      repo_refresh_checksums   TYPE string VALUE &apos;repo_refresh_checksums&apos;,
      repo_toggle_fav          TYPE string VALUE &apos;repo_toggle_fav&apos;,
      repo_transport_to_branch TYPE string VALUE &apos;repo_transport_to_branch&apos;,
      repo_syntax_check        TYPE string VALUE &apos;repo_syntax_check&apos;,
      repo_code_inspector      TYPE string VALUE &apos;repo_code_inspector&apos;,
      repo_open_in_master_lang TYPE string VALUE &apos;repo_open_in_master_lang&apos;,

      abapgit_home             TYPE string VALUE &apos;abapgit_home&apos;,
      abapgit_install          TYPE string VALUE &apos;abapgit_install&apos;,

      zip_import               TYPE string VALUE &apos;zip_import&apos;,
      zip_export               TYPE string VALUE &apos;zip_export&apos;,
      zip_package              TYPE string VALUE &apos;zip_package&apos;,
      zip_transport            TYPE string VALUE &apos;zip_transport&apos;,
      zip_object               TYPE string VALUE &apos;zip_object&apos;,

      git_pull                 TYPE string VALUE &apos;git_pull&apos;,
      git_reset                TYPE string VALUE &apos;git_reset&apos;,
      git_branch_create        TYPE string VALUE &apos;git_branch_create&apos;,
      git_branch_switch        TYPE string VALUE &apos;git_branch_switch&apos;,
      git_branch_delete        TYPE string VALUE &apos;git_branch_delete&apos;,
      git_tag_create           TYPE string VALUE &apos;git_tag_create&apos;,
      git_tag_delete           TYPE string VALUE &apos;git_tag_delete&apos;,
      git_tag_switch           TYPE string VALUE &apos;git_tag_switch&apos;,
      git_commit               TYPE string VALUE &apos;git_commit&apos;,

      db_display               TYPE string VALUE &apos;db_display&apos;,
      db_edit                  TYPE string VALUE &apos;db_edit&apos;,
      bg_update                TYPE string VALUE &apos;bg_update&apos;,

      go_main                  TYPE string VALUE &apos;go_main&apos;,
      go_explore               TYPE string VALUE &apos;go_explore&apos;,
      go_repo_overview         TYPE string VALUE &apos;go_repo_overview&apos;,
      go_db                    TYPE string VALUE &apos;go_db&apos;,
      go_background            TYPE string VALUE &apos;go_background&apos;,
      go_background_run        TYPE string VALUE &apos;go_background_run&apos;,
      go_diff                  TYPE string VALUE &apos;go_diff&apos;,
      go_stage                 TYPE string VALUE &apos;go_stage&apos;,
      go_commit                TYPE string VALUE &apos;go_commit&apos;,
      go_branch_overview       TYPE string VALUE &apos;go_branch_overview&apos;,
      go_tag_overview          TYPE string VALUE &apos;go_tag_overview&apos;,
      go_playground            TYPE string VALUE &apos;go_playground&apos;,
      go_debuginfo             TYPE string VALUE &apos;go_debuginfo&apos;,
      go_settings              TYPE string VALUE &apos;go_settings&apos;,
      go_tutorial              TYPE string VALUE &apos;go_tutorial&apos;,
      go_patch                 TYPE string VALUE &apos;go_patch&apos;,

      jump                     TYPE string VALUE &apos;jump&apos;,
      jump_pkg                 TYPE string VALUE &apos;jump_pkg&apos;,
      jump_transport           TYPE string VALUE &apos;jump_transport&apos;,

      url                      TYPE string VALUE &apos;url&apos;,
    END OF c_action .
  CONSTANTS:
    BEGIN OF c_version,
      active   TYPE r3state VALUE &apos;A&apos;,
      inactive TYPE r3state VALUE &apos;I&apos;,
    END OF c_version .
  CONSTANTS c_tag_prefix TYPE string VALUE &apos;refs/tags/&apos; ##NO_TEXT.
  CONSTANTS c_spagpa_param_repo_key TYPE char20 VALUE &apos;REPO_KEY&apos;.
  CONSTANTS c_spagpa_param_package TYPE char20 VALUE &apos;PACKAGE&apos;.

ENDINTERFACE.
INTERFACE zif_abapgit_object.

  METHODS:
    serialize
      IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING   zcx_abapgit_exception,
    deserialize
      IMPORTING iv_package TYPE devclass
                io_xml     TYPE REF TO zcl_abapgit_xml_input
      RAISING   zcx_abapgit_exception,
    delete
      RAISING zcx_abapgit_exception,
    exists
      RETURNING VALUE(rv_bool) TYPE abap_bool
      RAISING   zcx_abapgit_exception,
    is_locked
      RETURNING VALUE(rv_is_locked) TYPE abap_bool
      RAISING   zcx_abapgit_exception,
    is_active
      RETURNING VALUE(rv_active) TYPE abap_bool
      RAISING   zcx_abapgit_exception,
    changed_by
      RETURNING VALUE(rv_user) TYPE xubname
      RAISING   zcx_abapgit_exception,
    jump
      RAISING zcx_abapgit_exception,
    get_metadata
      RETURNING VALUE(rs_metadata) TYPE zif_abapgit_definitions=&gt;ty_metadata,
    has_changed_since
      IMPORTING iv_timestamp      TYPE timestamp
      RETURNING VALUE(rv_changed) TYPE abap_bool
      RAISING   zcx_abapgit_exception.
  METHODS:
    compare_to_remote_version
      IMPORTING io_remote_version_xml       TYPE REF TO zcl_abapgit_xml_input
      RETURNING VALUE(ro_comparison_result) TYPE REF TO zif_abapgit_comparison_result
      RAISING   zcx_abapgit_exception.

  DATA: mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDINTERFACE.
INTERFACE zif_abapgit_oo_object_fnc.

  TYPES: BEGIN OF ty_includes,
           programm TYPE programm,
         END OF ty_includes,
         ty_includes_tt TYPE STANDARD TABLE OF ty_includes WITH DEFAULT KEY.

  METHODS:
    create
      IMPORTING
        iv_package    TYPE devclass
        iv_overwrite  TYPE seox_boolean DEFAULT seox_true
        it_attributes TYPE zif_abapgit_definitions=&gt;ty_obj_attribute_tt OPTIONAL
      CHANGING
        cg_properties TYPE any
      RAISING
        zcx_abapgit_exception,
    generate_locals
      IMPORTING
        is_key                   TYPE seoclskey
        iv_force                 TYPE seox_boolean DEFAULT seox_true
        it_local_definitions     TYPE seop_source_string OPTIONAL
        it_local_implementations TYPE seop_source_string OPTIONAL
        it_local_macros          TYPE seop_source_string OPTIONAL
        it_local_test_classes    TYPE seop_source_string OPTIONAL
      RAISING
        zcx_abapgit_exception,
    deserialize_source
      IMPORTING
        is_key    TYPE seoclskey
        it_source TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error,
    insert_text_pool
      IMPORTING
        iv_class_name TYPE seoclsname
        it_text_pool  TYPE textpool_table
        iv_language   TYPE spras
      RAISING
        zcx_abapgit_exception,
    update_descriptions
      IMPORTING
        is_key          TYPE seoclskey
        it_descriptions TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
    add_to_activation_list
      IMPORTING
        is_item TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING
        zcx_abapgit_exception,
    create_sotr
      IMPORTING
        iv_package TYPE devclass
        it_sotr    TYPE zif_abapgit_definitions=&gt;ty_sotr_tt
      RAISING
        zcx_abapgit_exception,
    create_documentation
      IMPORTING
        it_lines       TYPE tlinetab
        iv_object_name TYPE dokhl-object
        iv_language    TYPE spras
      RAISING
        zcx_abapgit_exception,
    get_includes
      IMPORTING
        iv_object_name     TYPE sobj_name
      RETURNING
        VALUE(rt_includes) TYPE ty_includes_tt
      RAISING
        zcx_abapgit_exception,
    exists
      IMPORTING
        is_object_name   TYPE seoclskey
      RETURNING
        VALUE(rv_exists) TYPE abap_bool,
    serialize_abap
      IMPORTING
        is_class_key     TYPE seoclskey
        iv_type          TYPE seop_include_ext_app OPTIONAL
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error,
    get_skip_test_classes
      RETURNING
        VALUE(rv_skip) TYPE abap_bool,
    get_class_properties
      IMPORTING
        is_class_key               TYPE seoclskey
      RETURNING
        VALUE(rs_class_properties) TYPE vseoclass
      RAISING
        zcx_abapgit_exception,
    get_interface_properties
      IMPORTING
        is_interface_key               TYPE seoclskey
      RETURNING
        VALUE(rs_interface_properties) TYPE vseointerf
      RAISING
        zcx_abapgit_exception,
    read_text_pool
      IMPORTING
        iv_class_name       TYPE seoclsname
        iv_language         TYPE spras
      RETURNING
        VALUE(rt_text_pool) TYPE textpool_table,
    read_documentation
      IMPORTING
        iv_class_name   TYPE seoclsname
        iv_language     TYPE spras
      RETURNING
        VALUE(rt_lines) TYPE tlinetab,
    read_sotr
      IMPORTING
        iv_object_name TYPE sobj_name
      RETURNING
        VALUE(rt_sotr) TYPE zif_abapgit_definitions=&gt;ty_sotr_tt
      RAISING
        zcx_abapgit_exception,
    read_descriptions
      IMPORTING
        iv_obejct_name         TYPE seoclsname
      RETURNING
        VALUE(rt_descriptions) TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
    delete
      IMPORTING
        is_deletion_key TYPE seoclskey
      RAISING
        zcx_abapgit_exception,
    read_superclass
      IMPORTING
        iv_classname         TYPE seoclsname
      RETURNING
        VALUE(rv_superclass) TYPE seoclsname,
    read_attributes
      IMPORTING
        iv_object_name       TYPE seoclsname
      RETURNING
        VALUE(rt_attributes) TYPE zif_abapgit_definitions=&gt;ty_obj_attribute_tt.
ENDINTERFACE.
INTERFACE zif_abapgit_tag_popups.

  METHODS:
    tag_list_popup
      IMPORTING
        io_repo       TYPE REF TO zcl_abapgit_repo_online
      RETURNING
        VALUE(rs_tag) TYPE zif_abapgit_definitions=&gt;ty_git_tag
      RAISING
        zcx_abapgit_exception,

    tag_select_popup
      IMPORTING
        io_repo       TYPE REF TO zcl_abapgit_repo_online
      RETURNING
        VALUE(rs_tag) TYPE zif_abapgit_definitions=&gt;ty_git_tag
      RAISING
        zcx_abapgit_exception .

ENDINTERFACE.
INTERFACE zif_abapgit_branch_overview .

  METHODS:
    get_branches
      RETURNING VALUE(rt_branches) TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt,

    get_tags
      RETURNING VALUE(rt_tags) TYPE zif_abapgit_definitions=&gt;ty_git_tag_list_tt,

    get_commits
      RETURNING
        VALUE(rt_commits) TYPE zif_abapgit_definitions=&gt;ty_commit_tt,

    compress
      IMPORTING it_commits        TYPE zif_abapgit_definitions=&gt;ty_commit_tt
      RETURNING VALUE(rt_commits) TYPE zif_abapgit_definitions=&gt;ty_commit_tt
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_dot_abapgit.

  TYPES:
    BEGIN OF ty_requirement,
      component   TYPE dlvunit,
      min_release TYPE saprelease,
      min_patch   TYPE sappatchlv,
    END OF ty_requirement .
  TYPES:
    ty_requirement_tt TYPE STANDARD TABLE OF ty_requirement WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_dot_abapgit,
      master_language              TYPE spras,
      starting_folder              TYPE string,
      folder_logic                 TYPE string,
      ignore                       TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      requirements                 TYPE ty_requirement_tt,
    END OF ty_dot_abapgit .

  CONSTANTS:
    BEGIN OF c_folder_logic,
      prefix TYPE string VALUE &apos;PREFIX&apos;,
      full   TYPE string VALUE &apos;FULL&apos;,
    END OF c_folder_logic .

ENDINTERFACE.
INTERFACE zif_abapgit_persistence.

  TYPES:
    ty_type  TYPE c LENGTH 12 .
  TYPES:
    ty_value TYPE c LENGTH 12 .
  TYPES:
    BEGIN OF ty_content,
      type     TYPE ty_type,
      value    TYPE ty_value,
      data_str TYPE string,
    END OF ty_content .
  TYPES:
    tt_content TYPE SORTED TABLE OF ty_content WITH UNIQUE KEY type value .

  TYPES: BEGIN OF ty_local_checksum,
           item  TYPE zif_abapgit_definitions=&gt;ty_item,
           files TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt,
         END OF ty_local_checksum.

  TYPES:
    BEGIN OF ty_local_settings,
      ignore_subpackages           TYPE abap_bool,
      write_protected              TYPE abap_bool,
      only_local_objects           TYPE abap_bool,
      code_inspector_check_variant TYPE sci_chkv,
      block_commit                 TYPE abap_bool,
    END OF ty_local_settings.

  TYPES: ty_local_checksum_tt TYPE STANDARD TABLE OF ty_local_checksum WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_repo_xml,
           url             TYPE string,
           branch_name     TYPE string,
           package         TYPE devclass,
           created_by      TYPE xubname,
           created_at      TYPE timestampl,
           deserialized_by TYPE xubname,
           deserialized_at TYPE timestampl,
           offline         TYPE sap_bool,
           local_checksums TYPE ty_local_checksum_tt,
           dot_abapgit     TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit,
           head_branch     TYPE string,   &quot; HEAD symref of the repo, master branch
           local_settings  TYPE ty_local_settings,
         END OF ty_repo_xml.

  TYPES:
    BEGIN OF ty_repo_meta_mask,
      url             TYPE abap_bool,
      branch_name     TYPE abap_bool,
      package         TYPE abap_bool,
      created_by      TYPE abap_bool,
      created_at      TYPE abap_bool,
      deserialized_by TYPE abap_bool,
      deserialized_at TYPE abap_bool,
      offline         TYPE abap_bool,
      local_checksums TYPE abap_bool,
      dot_abapgit     TYPE abap_bool,
      head_branch     TYPE abap_bool,
      local_settings  TYPE abap_bool,
    END OF ty_repo_meta_mask.

  TYPES: BEGIN OF ty_repo,
           key TYPE zif_abapgit_persistence=&gt;ty_value.
      INCLUDE TYPE ty_repo_xml.
  TYPES: END OF ty_repo.
  TYPES: tt_repo TYPE STANDARD TABLE OF ty_repo WITH DEFAULT KEY.
  TYPES: tt_repo_keys TYPE STANDARD TABLE OF ty_repo-key WITH DEFAULT KEY.

ENDINTERFACE.
INTERFACE zif_abapgit_persist_repo .
  METHODS add
    IMPORTING
      !iv_url         TYPE string
      !iv_branch_name TYPE string
      !iv_branch      TYPE zif_abapgit_definitions=&gt;ty_sha1 OPTIONAL
      !iv_package     TYPE devclass
      !iv_offline     TYPE sap_bool DEFAULT abap_false
      !is_dot_abapgit TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit
    RETURNING
      VALUE(rv_key)   TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS delete
    IMPORTING
      !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS list
    RETURNING
      VALUE(rt_repos) TYPE zif_abapgit_persistence=&gt;tt_repo
    RAISING
      zcx_abapgit_exception .
  METHODS lock
    IMPORTING
      !iv_mode TYPE enqmode
      !iv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS read
    IMPORTING
      !iv_key        TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RETURNING
      VALUE(rs_repo) TYPE zif_abapgit_persistence=&gt;ty_repo
    RAISING
      zcx_abapgit_exception
      zcx_abapgit_not_found .
  METHODS update_metadata
    IMPORTING
      !iv_key         TYPE zif_abapgit_persistence=&gt;ty_repo-key
      !is_meta        TYPE zif_abapgit_persistence=&gt;ty_repo_xml
      !is_change_mask TYPE zif_abapgit_persistence=&gt;ty_repo_meta_mask
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.
INTERFACE zif_abapgit_persist_user .

  TYPES tt_favorites TYPE zif_abapgit_persistence=&gt;tt_repo_keys .

  METHODS get_changes_only
    RETURNING
      VALUE(rv_changes_only) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS get_default_git_user_email
    RETURNING
      VALUE(rv_email) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_default_git_user_name
    RETURNING
      VALUE(rv_username) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_diff_unified
    RETURNING
      VALUE(rv_diff_unified) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS get_favorites
    RETURNING
      VALUE(rt_favorites) TYPE tt_favorites
    RAISING
      zcx_abapgit_exception .
  METHODS get_hide_files
    RETURNING
      VALUE(rv_hide) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS get_repo_git_user_email
    IMPORTING
      !iv_url         TYPE zif_abapgit_persistence=&gt;ty_repo-url
    RETURNING
      VALUE(rv_email) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_repo_git_user_name
    IMPORTING
      !iv_url            TYPE zif_abapgit_persistence=&gt;ty_repo-url
    RETURNING
      VALUE(rv_username) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_repo_last_change_seen
    IMPORTING
      !iv_url           TYPE zif_abapgit_persistence=&gt;ty_repo-url
    RETURNING
      VALUE(rv_version) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_repo_login
    IMPORTING
      !iv_url         TYPE zif_abapgit_persistence=&gt;ty_repo-url
    RETURNING
      VALUE(rv_login) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS get_repo_show
    RETURNING
      VALUE(rv_key) TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS is_favorite_repo
    IMPORTING
      !iv_repo_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RETURNING
      VALUE(rv_yes) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS set_default_git_user_email
    IMPORTING
      !iv_email TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_default_git_user_name
    IMPORTING
      !iv_username TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_repo_git_user_email
    IMPORTING
      !iv_url   TYPE zif_abapgit_persistence=&gt;ty_repo-url
      !iv_email TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_repo_git_user_name
    IMPORTING
      !iv_url      TYPE zif_abapgit_persistence=&gt;ty_repo-url
      !iv_username TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_repo_last_change_seen
    IMPORTING
      !iv_url     TYPE zif_abapgit_persistence=&gt;ty_repo-url
      !iv_version TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_repo_login
    IMPORTING
      !iv_url   TYPE zif_abapgit_persistence=&gt;ty_repo-url
      !iv_login TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS set_repo_show
    IMPORTING
      !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS toggle_changes_only
    RETURNING
      VALUE(rv_changes_only) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS toggle_diff_unified
    RETURNING
      VALUE(rv_diff_unified) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS toggle_favorite
    IMPORTING
      !iv_repo_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
    RAISING
      zcx_abapgit_exception .
  METHODS toggle_hide_files
    RETURNING
      VALUE(rv_hide) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS get_settings
    RETURNING
      VALUE(rs_user_settings) TYPE zif_abapgit_definitions=&gt;ty_s_user_settings
    RAISING
      zcx_abapgit_exception.
  METHODS set_settings
    IMPORTING
      is_user_settings TYPE zif_abapgit_definitions=&gt;ty_s_user_settings
    RAISING
      zcx_abapgit_exception.
ENDINTERFACE.
INTERFACE zif_abapgit_popups .
  TYPES:
    BEGIN OF ty_popup,
      url         TYPE string,
      package     TYPE devclass,
      branch_name TYPE string,
      cancel      TYPE abap_bool,
    END OF ty_popup .

  CONSTANTS c_new_branch_label TYPE string VALUE &apos;+ create new ...&apos; ##NO_TEXT.

  METHODS popup_package_export
    EXPORTING
      !ev_package      TYPE devclass
      !ev_folder_logic TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS popup_folder_logic
    RETURNING
      VALUE(rv_folder_logic) TYPE string
    RAISING
      zcx_abapgit_exception .
  METHODS popup_object
    RETURNING
      VALUE(rs_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir
    RAISING
      zcx_abapgit_exception .
  METHODS create_branch_popup
    EXPORTING
      !ev_name   TYPE string
      !ev_cancel TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS run_page_class_popup
    EXPORTING
      !ev_name   TYPE string
      !ev_cancel TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS repo_new_offline
    RETURNING
      VALUE(rs_popup) TYPE zif_abapgit_popups=&gt;ty_popup
    RAISING
      zcx_abapgit_exception .
  METHODS branch_list_popup
    IMPORTING
      !iv_url             TYPE string
      !iv_default_branch  TYPE string OPTIONAL
      !iv_show_new_option TYPE abap_bool OPTIONAL
      !iv_hide_branch     TYPE zif_abapgit_persistence=&gt;ty_repo-branch_name OPTIONAL
      !iv_hide_head       TYPE abap_bool OPTIONAL
    RETURNING
      VALUE(rs_branch)    TYPE zif_abapgit_definitions=&gt;ty_git_branch
    RAISING
      zcx_abapgit_exception .
  METHODS repo_popup
    IMPORTING
      !iv_url            TYPE string
      !iv_package        TYPE devclass OPTIONAL
      !iv_branch         TYPE string DEFAULT &apos;refs/heads/master&apos;
      !iv_freeze_package TYPE abap_bool OPTIONAL
      !iv_freeze_url     TYPE abap_bool OPTIONAL
      !iv_title          TYPE clike DEFAULT &apos;New Online Project&apos;
    RETURNING
      VALUE(rs_popup)    TYPE zif_abapgit_popups=&gt;ty_popup
    RAISING
      zcx_abapgit_exception ##NO_TEXT.
  METHODS popup_to_confirm
    IMPORTING
      !iv_titlebar              TYPE clike
      !iv_text_question         TYPE clike
      !iv_text_button_1         TYPE clike DEFAULT &apos;Yes&apos;
      !iv_icon_button_1         TYPE icon-name DEFAULT space
      !iv_text_button_2         TYPE clike DEFAULT &apos;No&apos;
      !iv_icon_button_2         TYPE icon-name DEFAULT space
      !iv_default_button        TYPE char1 DEFAULT &apos;1&apos;
      !iv_display_cancel_button TYPE char1 DEFAULT abap_true
    RETURNING
      VALUE(rv_answer)          TYPE char1
    RAISING
      zcx_abapgit_exception .
  METHODS popup_to_inform
    IMPORTING
      !iv_titlebar     TYPE clike
      !iv_text_message TYPE clike
    RAISING
      zcx_abapgit_exception .
  METHODS popup_to_create_package
    EXPORTING
      !es_package_data TYPE scompkdtln
      !ev_create       TYPE boolean
    RAISING
      zcx_abapgit_exception .
  METHODS popup_to_create_transp_branch
    IMPORTING
      !it_transport_headers      TYPE trwbo_request_headers
    RETURNING
      VALUE(rs_transport_branch) TYPE zif_abapgit_definitions=&gt;ty_transport_to_branch
    RAISING
      zcx_abapgit_exception
      zcx_abapgit_cancel .
  METHODS popup_to_select_transports
    RETURNING
      VALUE(rt_trkorr) TYPE trwbo_request_headers .
  METHODS popup_to_select_from_list
    IMPORTING
      !it_list               TYPE STANDARD TABLE
      !iv_header_text        TYPE csequence
      !iv_select_column_text TYPE csequence
      !it_columns_to_display TYPE stringtab
    EXPORTING
      VALUE(et_list)         TYPE STANDARD TABLE
    RAISING
      zcx_abapgit_cancel
      zcx_abapgit_exception .
  METHODS branch_popup_callback
    IMPORTING
      !iv_code       TYPE clike
    CHANGING
      !ct_fields     TYPE zif_abapgit_definitions=&gt;ty_sval_tt
      !cs_error      TYPE svale
      !cv_show_popup TYPE char01
    RAISING
      zcx_abapgit_exception .
  METHODS package_popup_callback
    IMPORTING
      !iv_code       TYPE clike
    CHANGING
      !ct_fields     TYPE zif_abapgit_definitions=&gt;ty_sval_tt
      !cs_error      TYPE svale
      !cv_show_popup TYPE char01
    RAISING
      zcx_abapgit_exception .
  METHODS popup_transport_request
    IMPORTING
      !is_transport_type  TYPE zif_abapgit_definitions=&gt;ty_transport_type
    RETURNING
      VALUE(rv_transport) TYPE trkorr
    RAISING
      zcx_abapgit_exception
      zcx_abapgit_cancel .
ENDINTERFACE.
INTERFACE zif_abapgit_ecatt .

  &quot; downport missing types

  TYPES:
    etvo_invert_validation TYPE c LENGTH 1,
    etvo_error_prio        TYPE n LENGTH 1,
    etvo_impl_name         TYPE c LENGTH 30,
    etvo_impl_type         TYPE c LENGTH 1,
    etvo_impl_subtype      TYPE c LENGTH 4,
    etvo_package           TYPE c LENGTH 255,
    BEGIN OF etvoimpl_det,
      impl_name    TYPE etvo_impl_name,
      impl_type    TYPE etvo_impl_type,
      impl_subtype TYPE etvo_impl_subtype,
      impl_package TYPE etvo_package,
    END OF etvoimpl_det.

  TYPES:
    BEGIN OF ecvo_bus_msg.
      INCLUDE TYPE etobj_key.
  TYPES:
    bus_msg_no   TYPE c LENGTH 1, &quot; etvo_msg_no
    arbgb        TYPE arbgb,
    msgnr        TYPE msgnr,
    bus_msg_text TYPE string, &quot;etvo_bus_msg_text
    otr_key      TYPE sotr_conc,
    msg_type     TYPE c LENGTH 4, &quot;etvo_msg_type
    END OF ecvo_bus_msg,

    etvo_bus_msg_tabtype TYPE STANDARD TABLE OF ecvo_bus_msg.

ENDINTERFACE.
INTERFACE zif_abapgit_exit .
  TYPES:
    ty_icm_sinfo2_tt TYPE STANDARD TABLE OF icm_sinfo2 WITH DEFAULT KEY .

  METHODS change_local_host
    CHANGING
      !ct_hosts TYPE ty_icm_sinfo2_tt .
  METHODS allow_sap_objects
    RETURNING
      VALUE(rv_allowed) TYPE abap_bool .
  METHODS change_proxy_url
    IMPORTING
      !iv_repo_url  TYPE csequence
    CHANGING
      !cv_proxy_url TYPE string .
  METHODS change_proxy_port
    IMPORTING
      !iv_repo_url   TYPE csequence
    CHANGING
      !cv_proxy_port TYPE string .
  METHODS change_proxy_authentication
    IMPORTING
      !iv_repo_url             TYPE csequence
    CHANGING
      !cv_proxy_authentication TYPE abap_bool .
  METHODS create_http_client
    IMPORTING
      !iv_url          TYPE string
    RETURNING
      VALUE(ri_client) TYPE REF TO if_http_client
    RAISING
      zcx_abapgit_exception .
  METHODS http_client
    IMPORTING
      !ii_client TYPE REF TO if_http_client .
  METHODS change_tadir
    IMPORTING
      !iv_package TYPE devclass
      !io_log     TYPE REF TO zcl_abapgit_log
    CHANGING
      !ct_tadir   TYPE zif_abapgit_definitions=&gt;ty_tadir_tt .
  METHODS get_ssl_id
    RETURNING
      VALUE(rv_ssl_id) TYPE ssfapplssl .
ENDINTERFACE.
INTERFACE zif_abapgit_git_operations .

  METHODS push
    IMPORTING
      !is_comment TYPE zif_abapgit_definitions=&gt;ty_comment
      !io_stage   TYPE REF TO zcl_abapgit_stage
    RAISING
      zcx_abapgit_exception .

  METHODS create_branch
    IMPORTING
      !iv_name TYPE string
      !iv_from TYPE zif_abapgit_definitions=&gt;ty_sha1 OPTIONAL
    RAISING
      zcx_abapgit_exception .

ENDINTERFACE.
INTERFACE zif_abapgit_gui_page_hotkey.

  TYPES:
    BEGIN OF ty_hotkey_action,
      name           TYPE string,
      action         TYPE string,
      default_hotkey TYPE string,
    END OF ty_hotkey_action,
    tty_hotkey_action TYPE STANDARD TABLE OF ty_hotkey_action
                           WITH NON-UNIQUE DEFAULT KEY
                           WITH NON-UNIQUE SORTED KEY action
                                COMPONENTS action.

  CLASS-METHODS
    get_hotkey_actions
      RETURNING
        VALUE(rt_hotkey_actions) TYPE tty_hotkey_action.

ENDINTERFACE.
INTERFACE zif_abapgit_repo_listener .
  INTERFACE zif_abapgit_persistence LOAD .
  METHODS on_meta_change
    IMPORTING
      !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      !is_meta TYPE zif_abapgit_persistence=&gt;ty_repo_xml
      !is_change_mask TYPE zif_abapgit_persistence=&gt;ty_repo_meta_mask
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.
INTERFACE zif_abapgit_repo_srv .
  METHODS delete
    IMPORTING
      !io_repo TYPE REF TO zcl_abapgit_repo
    RAISING
      zcx_abapgit_exception .
  METHODS get
    IMPORTING
      !iv_key        TYPE zif_abapgit_persistence=&gt;ty_value
    RETURNING
      VALUE(ro_repo) TYPE REF TO zcl_abapgit_repo
    RAISING
      zcx_abapgit_exception .
  METHODS is_repo_installed
    IMPORTING
      !iv_url             TYPE string
      !iv_target_package  TYPE devclass OPTIONAL
    RETURNING
      VALUE(rv_installed) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS list
    RETURNING
      VALUE(rt_list) TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt
    RAISING
      zcx_abapgit_exception .
  METHODS new_offline
    IMPORTING
      !iv_url        TYPE string
      !iv_package    TYPE devclass
    RETURNING
      VALUE(ro_repo) TYPE REF TO zcl_abapgit_repo_offline
    RAISING
      zcx_abapgit_exception .
  METHODS new_online
    IMPORTING
      !iv_url         TYPE string
      !iv_branch_name TYPE string
      !iv_package     TYPE devclass
    RETURNING
      VALUE(ro_repo)  TYPE REF TO zcl_abapgit_repo_online
    RAISING
      zcx_abapgit_exception .
  METHODS purge
    IMPORTING
      !io_repo  TYPE REF TO zcl_abapgit_repo
      is_checks TYPE zif_abapgit_definitions=&gt;ty_delete_checks
    RAISING
      zcx_abapgit_exception .
  METHODS validate_package
    IMPORTING
      !iv_package TYPE devclass
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.
INTERFACE zif_abapgit_sap_package.

  TYPES: ty_devclass_tt TYPE STANDARD TABLE OF devclass WITH DEFAULT KEY.
  METHODS:
    create
      IMPORTING is_package TYPE scompkdtln
      RAISING   zcx_abapgit_exception,
    create_local
      RAISING   zcx_abapgit_exception,
    list_subpackages
      RETURNING VALUE(rt_list) TYPE ty_devclass_tt,
    list_superpackages
      RETURNING VALUE(rt_list) TYPE ty_devclass_tt,
    read_parent
      RETURNING VALUE(rv_parentcl) TYPE tdevc-parentcl,
    create_child
      IMPORTING iv_child TYPE devclass
      RAISING   zcx_abapgit_exception,
    exists
      RETURNING VALUE(rv_bool) TYPE abap_bool,
    are_changes_recorded_in_tr_req
      RETURNING VALUE(rv_are_changes_rec_in_tr_req) TYPE abap_bool
      RAISING   zcx_abapgit_exception,
    get_transport_type
      RETURNING VALUE(rv_transport_type) TYPE zif_abapgit_definitions=&gt;ty_transport_type
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.
INTERFACE zif_abapgit_stage_logic .

  METHODS get
    IMPORTING
      !io_repo        TYPE REF TO zcl_abapgit_repo_online
    RETURNING
      VALUE(rs_files) TYPE zif_abapgit_definitions=&gt;ty_stage_files
    RAISING
      zcx_abapgit_exception .

ENDINTERFACE.
INTERFACE zif_abapgit_tadir .
  METHODS get_object_package
    IMPORTING
      !iv_pgmid          TYPE tadir-pgmid DEFAULT &apos;R3TR&apos;
      !iv_object         TYPE tadir-object
      !iv_obj_name       TYPE tadir-obj_name
    RETURNING
      VALUE(rv_devclass) TYPE tadir-devclass
    RAISING
      zcx_abapgit_exception .
  METHODS read
    IMPORTING
      !iv_package            TYPE tadir-devclass
      !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
      !iv_only_local_objects TYPE abap_bool DEFAULT abap_false
      !io_dot                TYPE REF TO zcl_abapgit_dot_abapgit OPTIONAL
      !io_log                TYPE REF TO zcl_abapgit_log OPTIONAL
    RETURNING
      VALUE(rt_tadir)        TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
    RAISING
      zcx_abapgit_exception .
  METHODS read_single
    IMPORTING
      !iv_pgmid       TYPE tadir-pgmid DEFAULT &apos;R3TR&apos;
      !iv_object      TYPE tadir-object
      !iv_obj_name    TYPE tadir-obj_name
    RETURNING
      VALUE(rs_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.
INTERFACE zif_abapgit_version .

  CONSTANTS gc_xml_version TYPE string VALUE &apos;v1.0.0&apos; ##NO_TEXT.
  CONSTANTS gc_abap_version TYPE string VALUE &apos;1.80.0&apos; ##NO_TEXT.

ENDINTERFACE.
CLASS zcl_abapgit_background DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES: BEGIN OF ty_methods,
             class       TYPE seoclsname,
             description TYPE string,
           END OF ty_methods.

    TYPES: ty_methods_tt TYPE SORTED TABLE OF ty_methods WITH UNIQUE KEY class.

    CLASS-METHODS run
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS list_methods
      RETURNING VALUE(rt_methods) TYPE ty_methods_tt.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_background_pull DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_background .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_background_push_au DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_background .
  PROTECTED SECTION.

    DATA mo_log TYPE REF TO zcl_abapgit_log .

    METHODS build_comment
      IMPORTING
        !is_files         TYPE zif_abapgit_definitions=&gt;ty_stage_files
      RETURNING
        VALUE(rv_comment) TYPE string .
    METHODS push_auto
      IMPORTING
        !io_repo TYPE REF TO zcl_abapgit_repo_online
      RAISING
        zcx_abapgit_exception .
    METHODS determine_user_details
      IMPORTING
        !iv_changed_by TYPE xubname
      RETURNING
        VALUE(rs_user) TYPE zif_abapgit_definitions=&gt;ty_git_user .
    METHODS push_deletions
      IMPORTING
        !io_repo  TYPE REF TO zcl_abapgit_repo_online
        !is_files TYPE zif_abapgit_definitions=&gt;ty_stage_files
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_background_push_fi DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_background .
  PROTECTED SECTION.

    CONSTANTS:
      BEGIN OF c_settings,
        name  TYPE string VALUE &apos;NAME&apos;,
        email TYPE string VALUE &apos;EMAIL&apos;,
      END OF c_settings .
    DATA mo_log TYPE REF TO zcl_abapgit_log .

    METHODS build_comment
      IMPORTING
        !is_files         TYPE zif_abapgit_definitions=&gt;ty_stage_files
      RETURNING
        VALUE(rv_comment) TYPE string .
    METHODS push_fixed
      IMPORTING
        !io_repo  TYPE REF TO zcl_abapgit_repo_online
        !iv_name  TYPE string
        !iv_email TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_git_add_patch DEFINITION
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          it_diff TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,

      get_patch
        RETURNING
          VALUE(rt_patch) TYPE stringtab
        RAISING
          zcx_abapgit_exception,

      get_patch_binary
        RETURNING
          VALUE(rv_patch_binary) TYPE xstring
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA:
      mt_diff  TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
      mt_patch TYPE stringtab.

    METHODS:
      calculate_patch
        RETURNING
          VALUE(rt_patch) TYPE stringtab
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_git_branch_list DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_data TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS find_by_name
      IMPORTING
        !iv_branch_name  TYPE clike
      RETURNING
        VALUE(rs_branch) TYPE zif_abapgit_definitions=&gt;ty_git_branch
      RAISING
        zcx_abapgit_exception .
    METHODS get_head     &quot; For potential future use
      RETURNING
        VALUE(rs_branch) TYPE zif_abapgit_definitions=&gt;ty_git_branch
      RAISING
        zcx_abapgit_exception .
    METHODS get_head_symref
      RETURNING
        VALUE(rv_head_symref) TYPE string .
    METHODS get_branches_only
      RETURNING
        VALUE(rt_branches) TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt
      RAISING
        zcx_abapgit_exception .
    METHODS get_tags_only     &quot; For potential future use
      RETURNING
        VALUE(rt_tags) TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_ignored
      IMPORTING
        !iv_branch_name  TYPE clike
      RETURNING
        VALUE(rv_ignore) TYPE abap_bool .
    CLASS-METHODS get_display_name
      IMPORTING
        !iv_branch_name        TYPE clike
      RETURNING
        VALUE(rv_display_name) TYPE string .
    CLASS-METHODS get_type
      IMPORTING
        !iv_branch_name       TYPE clike
        !it_result            TYPE stringtab OPTIONAL
        !iv_current_row_index TYPE sytabix OPTIONAL
      RETURNING
        VALUE(rv_type)        TYPE zif_abapgit_definitions=&gt;ty_git_branch_type .
    CLASS-METHODS complete_heads_branch_name
      IMPORTING
        !iv_branch_name TYPE clike
      RETURNING
        VALUE(rv_name)  TYPE string .
    CLASS-METHODS normalize_branch_name
      IMPORTING
        !iv_branch_name TYPE clike
      RETURNING
        VALUE(rv_name)  TYPE string .
  PRIVATE SECTION.

    DATA mt_branches TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt .
    DATA mv_head_symref TYPE string .

    CLASS-METHODS skip_first_pkt
      IMPORTING
        !iv_data       TYPE string
      RETURNING
        VALUE(rv_data) TYPE string .
    METHODS find_tag_by_name
      IMPORTING
        !iv_branch_name  TYPE string
      RETURNING
        VALUE(rs_branch) TYPE zif_abapgit_definitions=&gt;ty_git_branch
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS parse_branch_list
      IMPORTING
        !iv_data        TYPE string
      EXPORTING
        !et_list        TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt
        !ev_head_symref TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS parse_head_params
      IMPORTING
        !iv_data              TYPE string
      RETURNING
        VALUE(rv_head_symref) TYPE string .
ENDCLASS.
CLASS zcl_abapgit_git_pack DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_node,
        chmod TYPE zif_abapgit_definitions=&gt;ty_chmod,
        name  TYPE string,
        sha1  TYPE zif_abapgit_definitions=&gt;ty_sha1,
      END OF ty_node .
    TYPES:
      ty_nodes_tt TYPE STANDARD TABLE OF ty_node WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_commit,
        tree      TYPE zif_abapgit_definitions=&gt;ty_sha1,
        parent    TYPE zif_abapgit_definitions=&gt;ty_sha1,
        parent2   TYPE zif_abapgit_definitions=&gt;ty_sha1,
        author    TYPE string,
        committer TYPE string,
        body      TYPE string,
      END OF ty_commit .
    TYPES:
      BEGIN OF ty_tag,
        object       TYPE string,
        type         TYPE string,
        tag          TYPE string,
        tagger_name  TYPE string,
        tagger_email TYPE string,
        message      TYPE string,
        body         TYPE string,
      END OF ty_tag .

    CLASS-METHODS decode
      IMPORTING
        !iv_data          TYPE xstring
      RETURNING
        VALUE(rt_objects) TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS decode_tree
      IMPORTING
        !iv_data        TYPE xstring
      RETURNING
        VALUE(rt_nodes) TYPE ty_nodes_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS decode_commit
      IMPORTING
        !iv_data         TYPE xstring
      RETURNING
        VALUE(rs_commit) TYPE ty_commit
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS decode_tag
      IMPORTING
        !iv_data      TYPE xstring
      RETURNING
        VALUE(rs_tag) TYPE ty_tag
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS encode
      IMPORTING
        !it_objects    TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RETURNING
        VALUE(rv_data) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS encode_tree
      IMPORTING
        !it_nodes      TYPE ty_nodes_tt
      RETURNING
        VALUE(rv_data) TYPE xstring .
    CLASS-METHODS encode_commit
      IMPORTING
        !is_commit     TYPE ty_commit
      RETURNING
        VALUE(rv_data) TYPE xstring .
    CLASS-METHODS encode_tag
      IMPORTING
        !is_tag        TYPE zcl_abapgit_git_pack=&gt;ty_tag
      RETURNING
        VALUE(rv_data) TYPE xstring
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CONSTANTS:
      c_pack_start TYPE x LENGTH 4 VALUE &apos;5041434B&apos; ##NO_TEXT.
    CONSTANTS:
      c_zlib       TYPE x LENGTH 2 VALUE &apos;789C&apos; ##NO_TEXT.
    CONSTANTS:
      c_zlib_hmm   TYPE x LENGTH 2 VALUE &apos;7801&apos; ##NO_TEXT.
    CONSTANTS:                                                  &quot; PACK
      c_version    TYPE x LENGTH 4 VALUE &apos;00000002&apos; ##NO_TEXT.

    CLASS-METHODS decode_deltas
      CHANGING
        !ct_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delta
      IMPORTING
        !is_object  TYPE zif_abapgit_definitions=&gt;ty_object
      CHANGING
        !ct_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delta_header
      EXPORTING
        !ev_header TYPE i
      CHANGING
        !cv_delta  TYPE xstring .
    CLASS-METHODS sort_tree
      IMPORTING
        !it_nodes       TYPE ty_nodes_tt
      RETURNING
        VALUE(rt_nodes) TYPE ty_nodes_tt .
    CLASS-METHODS get_type
      IMPORTING
        !iv_x          TYPE x
      RETURNING
        VALUE(rv_type) TYPE zif_abapgit_definitions=&gt;ty_type
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_length
      EXPORTING
        !ev_length TYPE i
      CHANGING
        !cv_data   TYPE xstring .
    CLASS-METHODS type_and_length
      IMPORTING
        !iv_type          TYPE zif_abapgit_definitions=&gt;ty_type
        !iv_length        TYPE i
      RETURNING
        VALUE(rv_xstring) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS zlib_decompress
      CHANGING
        !cv_data         TYPE xstring
        !cv_decompressed TYPE xstring
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_git_porcelain DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_pull_result,
        files   TYPE zif_abapgit_definitions=&gt;ty_files_tt,
        objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
        branch  TYPE zif_abapgit_definitions=&gt;ty_sha1,
      END OF ty_pull_result .
    TYPES:
      BEGIN OF ty_push_result,
        new_files     TYPE zif_abapgit_definitions=&gt;ty_files_tt,
        branch        TYPE zif_abapgit_definitions=&gt;ty_sha1,
        updated_files TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt,
        new_objects   TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
      END OF ty_push_result .

    CLASS-METHODS pull
      IMPORTING
        !iv_url          TYPE string
        !iv_branch_name  TYPE string
      RETURNING
        VALUE(rs_result) TYPE ty_pull_result
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS push
      IMPORTING
        !is_comment      TYPE zif_abapgit_definitions=&gt;ty_comment
        !io_stage        TYPE REF TO zcl_abapgit_stage
        !it_old_objects  TYPE zif_abapgit_definitions=&gt;ty_objects_tt
        !iv_parent       TYPE zif_abapgit_definitions=&gt;ty_sha1
        !iv_url          TYPE string
        !iv_branch_name  TYPE string
      RETURNING
        VALUE(rs_result) TYPE ty_push_result
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS create_branch
      IMPORTING
        !iv_url  TYPE string
        !iv_name TYPE string
        !iv_from TYPE zif_abapgit_definitions=&gt;ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS create_tag
      IMPORTING
        !iv_url TYPE string
        !is_tag TYPE zif_abapgit_definitions=&gt;ty_git_tag
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delete_branch
      IMPORTING
        !iv_url    TYPE string
        !is_branch TYPE zif_abapgit_definitions=&gt;ty_git_branch
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delete_tag
      IMPORTING
        !iv_url TYPE string
        !is_tag TYPE zif_abapgit_definitions=&gt;ty_git_tag
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS full_tree
      IMPORTING
        !it_objects        TYPE zif_abapgit_definitions=&gt;ty_objects_tt
        !iv_branch         TYPE zif_abapgit_definitions=&gt;ty_sha1
      RETURNING
        VALUE(rt_expanded) TYPE zif_abapgit_definitions=&gt;ty_expanded_tt
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_tree,
        path TYPE string,
        data TYPE xstring,
        sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1,
      END OF ty_tree .
    TYPES:
      ty_trees_tt TYPE STANDARD TABLE OF ty_tree WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_folder,
        path  TYPE string,
        count TYPE i,
        sha1  TYPE zif_abapgit_definitions=&gt;ty_sha1,
      END OF ty_folder .
    TYPES:
      ty_folders_tt TYPE STANDARD TABLE OF ty_folder WITH DEFAULT KEY .

    CONSTANTS c_zero TYPE zif_abapgit_definitions=&gt;ty_sha1 VALUE &apos;0000000000000000000000000000000000000000&apos; ##NO_TEXT.

    CLASS-METHODS build_trees
      IMPORTING
        !it_expanded    TYPE zif_abapgit_definitions=&gt;ty_expanded_tt
      RETURNING
        VALUE(rt_trees) TYPE ty_trees_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS find_folders
      IMPORTING
        !it_expanded      TYPE zif_abapgit_definitions=&gt;ty_expanded_tt
      RETURNING
        VALUE(rt_folders) TYPE ty_folders_tt .
    CLASS-METHODS walk
      IMPORTING
        !it_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
        !iv_sha1    TYPE zif_abapgit_definitions=&gt;ty_sha1
        !iv_path    TYPE string
      CHANGING
        !ct_files   TYPE zif_abapgit_definitions=&gt;ty_files_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS walk_tree
      IMPORTING
        !it_objects        TYPE zif_abapgit_definitions=&gt;ty_objects_tt
        !iv_tree           TYPE zif_abapgit_definitions=&gt;ty_sha1
        !iv_base           TYPE string
      RETURNING
        VALUE(rt_expanded) TYPE zif_abapgit_definitions=&gt;ty_expanded_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS receive_pack_push
      IMPORTING
        !is_comment     TYPE zif_abapgit_definitions=&gt;ty_comment
        !it_trees       TYPE ty_trees_tt
        !it_blobs       TYPE zif_abapgit_definitions=&gt;ty_files_tt
        !iv_parent      TYPE zif_abapgit_definitions=&gt;ty_sha1
        !iv_parent2     TYPE zif_abapgit_definitions=&gt;ty_sha1 OPTIONAL
        !iv_url         TYPE string
        !iv_branch_name TYPE string
      EXPORTING
        !ev_new_commit  TYPE zif_abapgit_definitions=&gt;ty_sha1
        !et_new_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
        !ev_new_tree    TYPE zif_abapgit_definitions=&gt;ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS receive_pack_create_tag
      IMPORTING
        !is_tag TYPE zif_abapgit_definitions=&gt;ty_git_tag
        !iv_url TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS create_annotated_tag
      IMPORTING
        !is_tag TYPE zif_abapgit_definitions=&gt;ty_git_tag
        !iv_url TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS create_lightweight_tag
      IMPORTING
        !is_tag TYPE zif_abapgit_definitions=&gt;ty_git_tag
        !iv_url TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_git_transport DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
* remote to local
    CLASS-METHODS upload_pack
      IMPORTING iv_url         TYPE string
                iv_branch_name TYPE string
                iv_deepen      TYPE abap_bool DEFAULT abap_true
                it_branches    TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt OPTIONAL
      EXPORTING et_objects     TYPE zif_abapgit_definitions=&gt;ty_objects_tt
                ev_branch      TYPE zif_abapgit_definitions=&gt;ty_sha1
                eo_branch_list TYPE REF TO zcl_abapgit_git_branch_list
      RAISING   zcx_abapgit_exception.

* local to remote
    CLASS-METHODS receive_pack
      IMPORTING iv_url         TYPE string
                iv_old         TYPE zif_abapgit_definitions=&gt;ty_sha1
                iv_new         TYPE zif_abapgit_definitions=&gt;ty_sha1
                iv_branch_name TYPE string
                iv_pack        TYPE xstring
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS branches
      IMPORTING iv_url                TYPE string
      RETURNING VALUE(ro_branch_list) TYPE REF TO zcl_abapgit_git_branch_list
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    CONSTANTS: BEGIN OF c_service,
                 receive TYPE string VALUE &apos;receive&apos;,       &quot;#EC NOTEXT
                 upload  TYPE string VALUE &apos;upload&apos;,        &quot;#EC NOTEXT
               END OF c_service.
    CONSTANTS: BEGIN OF c_smart_response_check,
                 BEGIN OF get_refs,
                   content_regex TYPE string VALUE &apos;^[0-9a-f]{4}#&apos;,
                   content_type  TYPE string VALUE &apos;application/x-git-&lt;service&gt;-pack-advertisement&apos;,
                 END OF get_refs,
               END OF c_smart_response_check.

    CLASS-METHODS branch_list
      IMPORTING iv_url         TYPE string
                iv_service     TYPE string
      EXPORTING eo_client      TYPE REF TO zcl_abapgit_http_client
                eo_branch_list TYPE REF TO zcl_abapgit_git_branch_list
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS find_branch
      IMPORTING iv_url         TYPE string
                iv_service     TYPE string
                iv_branch_name TYPE string
      EXPORTING eo_client      TYPE REF TO zcl_abapgit_http_client
                ev_branch      TYPE zif_abapgit_definitions=&gt;ty_sha1
                eo_branch_list TYPE REF TO zcl_abapgit_git_branch_list
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS parse
      EXPORTING ev_pack TYPE xstring
      CHANGING  cv_data TYPE xstring
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_git_utils DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS get_null
      RETURNING VALUE(rv_c) TYPE char1.

    CLASS-METHODS pkt_string
      IMPORTING iv_string     TYPE string
      RETURNING VALUE(rv_pkt) TYPE string
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS length_utf8_hex
      IMPORTING iv_data       TYPE xstring
      RETURNING VALUE(rv_len) TYPE i
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_tag DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS:
      add_tag_prefix
        IMPORTING
          iv_text        TYPE csequence
        RETURNING
          VALUE(rv_text) TYPE string,

      remove_tag_prefix
        IMPORTING
          iv_text        TYPE string
        RETURNING
          VALUE(rv_text) TYPE string.

ENDCLASS.
&quot;! Default {@link ZIF_ABAPGIT_2FA_AUTHENTICATOR} implementation
CLASS zcl_abapgit_2fa_auth_base DEFINITION
  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_2fa_authenticator.
    ALIASES:
      authenticate FOR zif_abapgit_2fa_authenticator~authenticate,
      supports_url FOR zif_abapgit_2fa_authenticator~supports_url,
      is_2fa_required FOR zif_abapgit_2fa_authenticator~is_2fa_required,
      delete_access_tokens FOR zif_abapgit_2fa_authenticator~delete_access_tokens,
      begin FOR zif_abapgit_2fa_authenticator~begin,
      end FOR zif_abapgit_2fa_authenticator~end.
    METHODS:
      &quot;! @parameter iv_supported_url_regex | Regular expression to check if a repository url is
      &quot;!                                     supported, used for default implementation of
      &quot;!                                     {@link .METH:supports_url}
      constructor IMPORTING iv_supported_url_regex TYPE clike.
  PROTECTED SECTION.
    CLASS-METHODS:
      &quot;! Helper method to raise class based exception after traditional exception was raised
      &quot;! &lt;p&gt;
      &quot;! &lt;em&gt;sy-msg...&lt;/em&gt; must be set right before calling!
      &quot;! &lt;/p&gt;
      raise_comm_error_from_sy RAISING zcx_abapgit_2fa_comm_error.
    METHODS:
      &quot;! @parameter rv_running | Internal session is currently active
      is_session_running RETURNING VALUE(rv_running) TYPE abap_bool,
      &quot;! Returns HTTP client configured with proxy (where required) for the given URL
      get_http_client_for_url
        IMPORTING iv_url           TYPE string
        RETURNING VALUE(ri_client) TYPE REF TO if_http_client
        RAISING   zcx_abapgit_2fa_comm_error.
  PRIVATE SECTION.
    DATA:
      mo_url_regex       TYPE REF TO cl_abap_regex,
      mv_session_running TYPE abap_bool.
ENDCLASS.
&quot;! Static registry class to find {@link ZIF_ABAPGIT_2FA_AUTHENTICATOR} instances
CLASS zcl_abapgit_2fa_auth_registry DEFINITION
  FINAL
  CREATE PRIVATE .

  PUBLIC SECTION.
    CLASS-METHODS:
      class_constructor,
      &quot;! Retrieve an authenticator instance by url
      &quot;! @parameter iv_url | Url of the repository / service
      &quot;! @parameter ri_authenticator | Found authenticator instance
      &quot;! @raising zcx_abapgit_2fa_unsupported | No authenticator found that supports the service
      get_authenticator_for_url IMPORTING iv_url                  TYPE string
                                RETURNING VALUE(ri_authenticator) TYPE REF TO zif_abapgit_2fa_authenticator
                                RAISING   zcx_abapgit_2fa_unsupported,
      &quot;! Check if there is a two factor authenticator available for the url
      &quot;! @parameter iv_url | Url of the repository / service
      &quot;! @parameter rv_supported | 2FA is supported
      is_url_supported IMPORTING iv_url              TYPE string
                       RETURNING VALUE(rv_supported) TYPE abap_bool,
      &quot;! Offer to use two factor authentication if supported and required
      &quot;! &lt;p&gt;
      &quot;! This uses GUI functionality to display a popup to request the user to enter a two factor
      &quot;! token. Also an dummy authentication request might be used to find out if two factor
      &quot;! authentication is required for the account.
      &quot;! &lt;/p&gt;
      &quot;! @parameter iv_url | Url of the repository / service
      &quot;! @parameter cv_username | Username
      &quot;! @parameter cv_password | Password, will be replaced by an access token if two factor
      &quot;!                          authentication succeeds
      &quot;! @raising zcx_abapgit_exception | Error in two factor authentication
      use_2fa_if_required IMPORTING iv_url      TYPE string
                          CHANGING  cv_username TYPE string
                                    cv_password TYPE string
                          RAISING   zcx_abapgit_exception.
    CLASS-DATA:
      &quot;! All authenticators managed by the registry
      gt_registered_authenticators TYPE HASHED TABLE OF REF TO zif_abapgit_2fa_authenticator
                                        WITH UNIQUE KEY table_line READ-ONLY.
  PRIVATE SECTION.
    CLASS-METHODS:
      popup_token
        RETURNING VALUE(rv_token) TYPE string
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_2fa_github_auth DEFINITION
  INHERITING FROM zcl_abapgit_2fa_auth_base
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_override TYPE string OPTIONAL .

    METHODS zif_abapgit_2fa_authenticator~authenticate
        REDEFINITION .
    METHODS zif_abapgit_2fa_authenticator~delete_access_tokens
        REDEFINITION .
    METHODS zif_abapgit_2fa_authenticator~end
        REDEFINITION .
    METHODS zif_abapgit_2fa_authenticator~is_2fa_required
        REDEFINITION .
  PROTECTED SECTION.

    DATA mv_github_api_url TYPE string VALUE `https://api.github.com/` ##NO_TEXT.
  PRIVATE SECTION.

    CONSTANTS c_otp_header_name TYPE string VALUE `X-Github-OTP` ##NO_TEXT.
    CONSTANTS c_restendpoint_authorizations TYPE string VALUE `/authorizations` ##NO_TEXT.
    DATA mi_authenticated_session TYPE REF TO if_http_client .

    CLASS-METHODS set_new_token_request
      IMPORTING
        !ii_request TYPE REF TO if_http_request .
    CLASS-METHODS get_token_from_response
      IMPORTING
        !ii_response    TYPE REF TO if_http_response
      RETURNING
        VALUE(rv_token) TYPE string .
    CLASS-METHODS set_list_token_request
      IMPORTING
        !ii_request TYPE REF TO if_http_request .
    CLASS-METHODS get_tobedel_tokens_from_resp
      IMPORTING
        !ii_response  TYPE REF TO if_http_response
      RETURNING
        VALUE(rt_ids) TYPE stringtab .
    CLASS-METHODS set_del_token_request
      IMPORTING
        !ii_request  TYPE REF TO if_http_request
        !iv_token_id TYPE string .
    METHODS get_authenticated_client
      IMPORTING
        !iv_username     TYPE string
        !iv_password     TYPE string
        !iv_2fa_token    TYPE string
      RETURNING
        VALUE(ri_client) TYPE REF TO if_http_client
      RAISING
        zcx_abapgit_2fa_auth_failed
        zcx_abapgit_2fa_comm_error .
ENDCLASS.
CLASS zcl_abapgit_http DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CONSTANTS:
      BEGIN OF c_scheme,
        digest TYPE string VALUE &apos;Digest&apos;,
      END OF c_scheme .

    CLASS-METHODS get_agent
      RETURNING
        VALUE(rv_agent) TYPE string .
    CLASS-METHODS create_by_url
      IMPORTING
        !iv_url          TYPE string
        !iv_service      TYPE string
      RETURNING
        VALUE(ro_client) TYPE REF TO zcl_abapgit_http_client
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

    CLASS-METHODS check_auth_requested
      IMPORTING
        !ii_client               TYPE REF TO if_http_client
      RETURNING
        VALUE(rv_auth_requested) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_local_system
      IMPORTING
        !iv_url        TYPE string
      RETURNING
        VALUE(rv_bool) TYPE abap_bool .
    CLASS-METHODS acquire_login_details
      IMPORTING
        !ii_client       TYPE REF TO if_http_client
        !io_client       TYPE REF TO zcl_abapgit_http_client
        !iv_url          TYPE string
      RETURNING
        VALUE(rv_scheme) TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_http_digest DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !ii_client   TYPE REF TO if_http_client
        !iv_username TYPE string
        !iv_password TYPE string
      RAISING
        zcx_abapgit_exception.
    METHODS run
      IMPORTING
        !ii_client TYPE REF TO if_http_client
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA: mv_ha1      TYPE string,
          mv_username TYPE string,
          mv_realm    TYPE string,
          mv_qop      TYPE string,
          mv_nonce    TYPE string.

    CLASS-DATA: gv_nc TYPE n LENGTH 8.

    CLASS-METHODS:
      md5
        IMPORTING
                  iv_data        TYPE string
        RETURNING
                  VALUE(rv_hash) TYPE string
        RAISING   zcx_abapgit_exception.

    METHODS:
      hash
        IMPORTING
                  iv_qop             TYPE string
                  iv_nonce           TYPE string
                  iv_uri             TYPE string
                  iv_method          TYPE string
                  iv_cnonse          TYPE string
        RETURNING
                  VALUE(rv_response) TYPE string
        RAISING   zcx_abapgit_exception,
      parse
        IMPORTING
          ii_client TYPE REF TO if_http_client.

ENDCLASS.
CLASS zcl_abapgit_proxy_auth DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS:
      run
        IMPORTING ii_client TYPE REF TO if_http_client
        RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    CLASS-DATA: gv_username TYPE string,
                gv_password TYPE string.

    CLASS-METHODS: enter RAISING zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_proxy_config DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS:
      constructor,

      get_proxy_url
        IMPORTING
          iv_repo_url         TYPE csequence OPTIONAL
        RETURNING
          VALUE(rv_proxy_url) TYPE string,

      get_proxy_port
        IMPORTING
          iv_repo_url    TYPE csequence OPTIONAL
        RETURNING
          VALUE(rv_port) TYPE string,

      get_proxy_authentication
        IMPORTING
          iv_repo_url    TYPE csequence OPTIONAL
        RETURNING
          VALUE(rv_auth) TYPE abap_bool.

  PRIVATE SECTION.
    DATA: mo_settings TYPE REF TO zcl_abapgit_settings,
          mi_exit     TYPE REF TO zif_abapgit_exit.

ENDCLASS.
CLASS zcl_abapgit_ecatt_config_downl DEFINITION
  INHERITING FROM cl_apl_ecatt_config_download
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      download REDEFINITION,

      get_xml_stream
        RETURNING
          VALUE(rv_xml_stream) TYPE xstring,

      get_xml_stream_size
        RETURNING
          VALUE(rv_xml_stream_size) TYPE int4.

  PROTECTED SECTION.
    METHODS:
      download_data REDEFINITION.

  PRIVATE SECTION.
    DATA:
      mv_xml_stream      TYPE xstring,
      mv_xml_stream_size TYPE int4.

ENDCLASS.
CLASS zcl_abapgit_ecatt_config_upl DEFINITION
  INHERITING FROM cl_apl_ecatt_config_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION.

  PRIVATE SECTION.
    DATA: mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_ecatt_data_downl DEFINITION
  INHERITING FROM cl_apl_ecatt_data_download
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS get_xml_stream
      RETURNING
        VALUE(rv_xml_stream) TYPE xstring .
    METHODS get_xml_stream_size
      RETURNING
        VALUE(rv_xml_stream_size) TYPE int4 .

    METHODS download
        REDEFINITION .
  PROTECTED SECTION.
    METHODS:
      download_data REDEFINITION.

  PRIVATE SECTION.

    DATA mv_xml_stream TYPE xstring .
    DATA mv_xml_stream_size TYPE int4 .
ENDCLASS.
CLASS zcl_abapgit_ecatt_data_upload DEFINITION
  INHERITING FROM cl_apl_ecatt_data_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION.

  PRIVATE SECTION.
    DATA: mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_ecatt_helper DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS:
      build_xml_of_object
        IMPORTING
          im_object_name     TYPE  etobj_name
          im_object_version  TYPE  etobj_ver
          im_object_type     TYPE  etobj_type
          io_download        TYPE REF TO cl_apl_ecatt_download
        EXPORTING
          ex_xml_stream      TYPE  xstring
          ex_xml_stream_size TYPE  int4
        RAISING
          zcx_abapgit_exception,

      download_data
        IMPORTING
          ii_template_over_all TYPE REF TO if_ixml_document
        EXPORTING
          ev_xml_stream        TYPE xstring
          ev_xml_stream_size   TYPE i,

      upload_data_from_stream
        IMPORTING
          iv_xml_stream               TYPE xstring
        RETURNING
          VALUE(ri_template_over_all) TYPE REF TO if_ixml_document
        RAISING
          cx_ecatt_apl_xml.

  PRIVATE SECTION.
    CONSTANTS:
      co_xml TYPE int4 VALUE 1. &quot; downport of if_apl_ecatt_xml=&gt;co_xml

ENDCLASS.
CLASS zcl_abapgit_ecatt_script_downl DEFINITION
  INHERITING FROM cl_apl_ecatt_script_download
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      download REDEFINITION,

      get_xml_stream
        RETURNING
          VALUE(rv_xml_stream) TYPE xstring,

      get_xml_stream_size
        RETURNING
          VALUE(rv_xml_stream_size) TYPE int4.

  PROTECTED SECTION.
    METHODS:
      download_data REDEFINITION.

  PRIVATE SECTION.
    DATA:
      mv_xml_stream      TYPE xstring,
      mv_xml_stream_size TYPE int4,
      mi_script_node     TYPE REF TO if_ixml_element.

    METHODS:
      set_script_to_template
        RAISING
          cx_ecatt_apl_util,

      set_control_data_for_tcd
        IMPORTING
          is_param  TYPE etpar_gui
          io_params TYPE REF TO cl_apl_ecatt_params
        RAISING
          cx_ecatt_apl,

      escape_control_data
        IMPORTING
          ii_element TYPE REF TO if_ixml_element
          iv_tabname TYPE string
          iv_node    TYPE string
        RAISING
          cx_ecatt_apl_util,

      set_blob_to_template
        RAISING
          cx_ecatt_apl_util,

      set_artmp_to_template
        RAISING
          cx_ecatt_apl_util.

ENDCLASS.
CLASS zcl_abapgit_ecatt_script_upl DEFINITION
  INHERITING FROM cl_apl_ecatt_script_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION.

  PRIVATE SECTION.
    DATA: mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_ecatt_sp_download DEFINITION
  INHERITING FROM cl_apl_ecatt_download
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      download REDEFINITION,

      get_xml_stream
        RETURNING
          VALUE(rv_xml_stream) TYPE xstring,

      get_xml_stream_size
        RETURNING
          VALUE(rv_xml_stream_size) TYPE int4.

  PROTECTED SECTION.
    METHODS:
      download_data REDEFINITION.

  PRIVATE SECTION.
    DATA:
      mv_xml_stream      TYPE xstring,
      mv_xml_stream_size TYPE int4.

    METHODS:
      set_sp_data_to_template.

ENDCLASS.
CLASS zcl_abapgit_ecatt_sp_upload DEFINITION
  INHERITING FROM cl_apl_ecatt_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring,

      upload
        REDEFINITION.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION,

      get_ecatt_sp
        RAISING
          cx_ecatt_apl .

  PRIVATE SECTION.
    DATA: mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_ecatt_system_downl DEFINITION
  INHERITING FROM cl_apl_ecatt_systems_download
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      download REDEFINITION,

      get_xml_stream
        RETURNING
          VALUE(rv_xml_stream) TYPE xstring,

      get_xml_stream_size
        RETURNING
          VALUE(rv_xml_stream_size) TYPE int4.

  PROTECTED SECTION.
    METHODS:
      download_data REDEFINITION.

  PRIVATE SECTION.
    DATA:
      mv_xml_stream      TYPE xstring,
      mv_xml_stream_size TYPE int4.

    METHODS:
      set_systems_data_to_template.

ENDCLASS.
CLASS zcl_abapgit_ecatt_system_upl DEFINITION
  INHERITING FROM cl_apl_ecatt_systems_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION.

  PRIVATE SECTION.
    DATA: mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_ecatt_val_obj_down DEFINITION
  INHERITING FROM cl_apl_ecatt_download
  CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS:
      download REDEFINITION,

      get_xml_stream
        RETURNING
          VALUE(rv_xml_stream) TYPE xstring,

      get_xml_stream_size
        RETURNING
          VALUE(rv_xml_stream_size) TYPE int4.

  PROTECTED SECTION.
    DATA:
      mi_objects_node TYPE REF TO if_ixml_element.

    METHODS:
      download_data REDEFINITION.
  PRIVATE SECTION.
    DATA:
      mv_xml_stream      TYPE xstring,
      mv_xml_stream_size TYPE int4.

    METHODS:
      set_ecatt_impl_detail,
      set_ecatt_flags,
      set_business_msgs.

ENDCLASS.
CLASS zcl_abapgit_ecatt_val_obj_upl DEFINITION
  INHERITING FROM cl_apl_ecatt_upload
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      z_set_stream_for_upload
        IMPORTING
          iv_xml TYPE xstring,

      upload REDEFINITION.

  PROTECTED SECTION.
    METHODS:
      upload_data_from_stream REDEFINITION,

      get_business_msgs_from_dom
        RAISING
          cx_ecatt_apl,

      get_impl_detail_from_dom
        RAISING
          cx_ecatt_apl,

      get_vo_flags_from_dom
        RAISING
          cx_ecatt_apl.

  PRIVATE SECTION.
    DATA:
      mv_external_xml TYPE xstring.

ENDCLASS.
CLASS zcl_abapgit_comparison_null DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_comparison_result .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_object_enho_badi DEFINITION.

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=&gt;ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=&gt;ty_item.

ENDCLASS.
CLASS zcl_abapgit_object_enho_class DEFINITION.

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          is_item  TYPE zif_abapgit_definitions=&gt;ty_item
          io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item TYPE zif_abapgit_definitions=&gt;ty_item.
    DATA: mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.
CLASS zcl_abapgit_object_enho_clif DEFINITION.

  PUBLIC SECTION.
    CLASS-METHODS:
      deserialize
        IMPORTING io_xml  TYPE REF TO zcl_abapgit_xml_input
                  io_clif TYPE REF TO cl_enh_tool_clif
        RAISING   zcx_abapgit_exception
                  cx_enh_root,
      serialize
        IMPORTING io_xml   TYPE REF TO zcl_abapgit_xml_output
                  io_files TYPE REF TO zcl_abapgit_objects_files
                  io_clif  TYPE REF TO cl_enh_tool_clif
        RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    CLASS-METHODS: serialize_includes
      IMPORTING io_files TYPE REF TO zcl_abapgit_objects_files
                io_clif  TYPE REF TO cl_enh_tool_clif
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_enho_fugr DEFINITION.

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=&gt;ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=&gt;ty_item,
          mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.
CLASS zcl_abapgit_object_enho_hook DEFINITION.
  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=&gt;ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.

    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_spaces,
             full_name TYPE string.
    TYPES: spaces TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
           END OF ty_spaces.

    TYPES: ty_spaces_tt TYPE STANDARD TABLE OF ty_spaces WITH DEFAULT KEY.

    DATA: ms_item TYPE zif_abapgit_definitions=&gt;ty_item.
    DATA: mo_files TYPE REF TO zcl_abapgit_objects_files.

    METHODS hook_impl_deserialize
      IMPORTING it_spaces TYPE ty_spaces_tt
      CHANGING  ct_impl   TYPE enh_hook_impl_it
      RAISING   zcx_abapgit_exception.

    METHODS hook_impl_serialize
      EXPORTING et_spaces TYPE ty_spaces_tt
      CHANGING  ct_impl   TYPE enh_hook_impl_it
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_enho_intf DEFINITION.

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          is_item  TYPE zif_abapgit_definitions=&gt;ty_item
          io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=&gt;ty_item,
          mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.
CLASS zcl_abapgit_object_enho_wdyc DEFINITION.

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=&gt;ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=&gt;ty_item.

ENDCLASS.
CLASS zcl_abapgit_object_enho_wdyn DEFINITION.

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=&gt;ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=&gt;ty_item.

ENDCLASS.
CLASS zcl_abapgit_object_enhs_badi_d DEFINITION.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_object_enhs.

ENDCLASS.
CLASS zcl_abapgit_object_enhs_hook_d DEFINITION.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_object_enhs.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_hook_defifnition,
             pgmid     TYPE pgmid,
             obj_name  TYPE trobj_name,
             obj_type  TYPE trobjtype,
             main_type TYPE trobjtype,
             main_name TYPE eu_aname,
             program   TYPE progname,
             def_hooks TYPE enh_hook_def_ext_it,
           END OF ty_hook_defifnition.

ENDCLASS.
CLASS zcl_abapgit_object_tabl_dialog DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          iv_message TYPE string.
    INTERFACES: zif_abapgit_comparison_result.

  PRIVATE SECTION.
    DATA mv_message TYPE string.
    DATA mv_halt TYPE string.

ENDCLASS.
CLASS zcl_abapgit_object_tabl_valid DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS validate
      IMPORTING
        io_remote_version TYPE REF TO zcl_abapgit_xml_input
        io_local_version  TYPE REF TO zcl_abapgit_xml_input
      RETURNING
        VALUE(rv_message) TYPE string
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.
    TYPES:
      tty_founds  TYPE STANDARD TABLE OF rsfindlst
                       WITH NON-UNIQUE DEFAULT KEY,
      tty_seu_obj TYPE STANDARD TABLE OF seu_obj
                       WITH NON-UNIQUE DEFAULT KEY.

    METHODS:
      get_where_used_recursive
        IMPORTING
          iv_object_name       TYPE csequence
          iv_depth             TYPE i
          iv_object_type       TYPE euobj-id
          it_scope             TYPE tty_seu_obj
        RETURNING
          VALUE(rt_founds_all) TYPE tty_founds
        RAISING
          zcx_abapgit_exception,

      is_structure_used_in_db_table
        IMPORTING
          iv_object_name                        TYPE dd02v-tabname
        RETURNING
          VALUE(rv_is_structure_used_in_db_tab) TYPE abap_bool
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_objects_activation DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS add
      IMPORTING iv_type   TYPE trobjtype
                iv_name   TYPE clike
                iv_delete TYPE abap_bool DEFAULT abap_false
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS add_item
      IMPORTING is_item TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS activate
      IMPORTING iv_ddic TYPE abap_bool DEFAULT abap_false
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS clear.

  PRIVATE SECTION.

    CLASS-DATA:
      gt_classes TYPE STANDARD TABLE OF seoclsname WITH DEFAULT KEY,
      gt_objects TYPE TABLE OF dwinactiv.

    CLASS-METHODS update_where_used .
    CLASS-METHODS fix_class_methods
      IMPORTING
        !iv_obj_name TYPE trobj_name
      CHANGING
        !ct_objects  TYPE dwinactiv_tab .
    CLASS-METHODS use_new_activation_logic
      RETURNING
        VALUE(rv_use_new_activation_logic) TYPE abap_bool .
    CLASS-METHODS activate_new
      IMPORTING
        !iv_ddic TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS activate_old
      IMPORTING
        !iv_ddic TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS activate_ddic
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS show_activation_errors
      IMPORTING
        !iv_logname TYPE ddmass-logname
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_objects_files DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING is_item TYPE zif_abapgit_definitions=&gt;ty_item
                  iv_path TYPE string OPTIONAL,
      add_string
        IMPORTING iv_extra  TYPE clike OPTIONAL
                  iv_ext    TYPE string
                  iv_string TYPE string
        RAISING   zcx_abapgit_exception,
      read_string
        IMPORTING iv_extra         TYPE clike OPTIONAL
                  iv_ext           TYPE string
        RETURNING VALUE(rv_string) TYPE string
        RAISING   zcx_abapgit_exception,
      add_xml
        IMPORTING iv_extra     TYPE clike OPTIONAL
                  io_xml       TYPE REF TO zcl_abapgit_xml_output
                  iv_normalize TYPE sap_bool DEFAULT abap_true
                  is_metadata  TYPE zif_abapgit_definitions=&gt;ty_metadata OPTIONAL
        RAISING   zcx_abapgit_exception,
* needed since type-check during dynamic call fails even if the object is compatible
      add_xml_from_plugin
        IMPORTING iv_extra     TYPE clike OPTIONAL
                  io_xml       TYPE REF TO object
                  iv_normalize TYPE sap_bool DEFAULT abap_true
        RAISING   zcx_abapgit_exception ##called,
      read_xml
        IMPORTING iv_extra      TYPE clike OPTIONAL
        RETURNING VALUE(ro_xml) TYPE REF TO zcl_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      read_abap
        IMPORTING iv_extra       TYPE clike OPTIONAL
                  iv_error       TYPE sap_bool DEFAULT abap_true
        RETURNING VALUE(rt_abap) TYPE abaptxt255_tab
        RAISING   zcx_abapgit_exception,
      add_abap
        IMPORTING iv_extra TYPE clike OPTIONAL
                  it_abap  TYPE STANDARD TABLE
        RAISING   zcx_abapgit_exception,
      add
        IMPORTING is_file TYPE zif_abapgit_definitions=&gt;ty_file,
      add_raw
        IMPORTING iv_extra TYPE clike OPTIONAL
                  iv_ext   TYPE string
                  iv_data  TYPE xstring
        RAISING   zcx_abapgit_exception,
      read_raw
        IMPORTING iv_extra       TYPE clike OPTIONAL
                  iv_ext         TYPE string
        RETURNING VALUE(rv_data) TYPE xstring
        RAISING   zcx_abapgit_exception,
      get_files
        RETURNING VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_files_tt,
      set_files
        IMPORTING it_files TYPE zif_abapgit_definitions=&gt;ty_files_tt,
      get_accessed_files
        RETURNING VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt.

  PRIVATE SECTION.
    DATA: ms_item           TYPE zif_abapgit_definitions=&gt;ty_item,
          mt_accessed_files TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt,
          mt_files          TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          mv_path           TYPE string.

    METHODS:
      read_file
        IMPORTING iv_filename TYPE string
                  iv_error    TYPE abap_bool DEFAULT abap_true
        EXPORTING ev_data     TYPE xstring
        RAISING   zcx_abapgit_exception,
      filename
        IMPORTING iv_extra           TYPE clike OPTIONAL
                  iv_ext             TYPE string
        RETURNING VALUE(rv_filename) TYPE string.

ENDCLASS.
CLASS zcl_abapgit_objects_generic DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING
        zcx_abapgit_exception .
    METHODS delete
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize
      IMPORTING
        !iv_package TYPE devclass
        !io_xml     TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS exists
      RETURNING
        VALUE(rv_bool) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS serialize
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_s_objkey,
        num   TYPE numc3,
        value TYPE char128,
      END OF ty_s_objkey .
    TYPES:
      ty_t_objkey TYPE SORTED TABLE OF ty_s_objkey WITH UNIQUE KEY num .

    DATA ms_object_header TYPE objh .
    DATA:
      mt_object_table                TYPE STANDARD TABLE OF objsl WITH DEFAULT KEY .
    DATA:
      mt_object_method               TYPE STANDARD TABLE OF objm WITH DEFAULT KEY .
    DATA ms_item TYPE zif_abapgit_definitions=&gt;ty_item .

    METHODS after_import .
    METHODS before_export .
    METHODS corr_insert
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_data
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS distribute_name_to_components
      IMPORTING
        !it_key_component TYPE ddfields
      CHANGING
        !ct_objkey        TYPE ty_t_objkey
        !cs_objkey        TYPE ty_s_objkey
        !cv_non_value_pos TYPE numc3 .
    METHODS get_key_fields
      IMPORTING
        !iv_table      TYPE objsl-tobj_name
      RETURNING
        VALUE(rt_keys) TYPE ddfields
      RAISING
        zcx_abapgit_exception .
    METHODS get_primary_table
      RETURNING
        VALUE(rv_table) TYPE objsl-tobj_name
      RAISING
        zcx_abapgit_exception .
    METHODS get_where_clause
      IMPORTING
        !iv_tobj_name   TYPE objsl-tobj_name
      RETURNING
        VALUE(rv_where) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_data
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS split_value_to_keys
      IMPORTING
        !it_key_component TYPE ddfields
      CHANGING
        !ct_objkey        TYPE ty_t_objkey
        !cs_objkey        TYPE ty_s_objkey
        !cv_non_value_pos TYPE numc3 .
    METHODS validate
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_objects_super DEFINITION ABSTRACT.

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

    CLASS-METHODS:
      jump_adt
        IMPORTING iv_obj_name     TYPE zif_abapgit_definitions=&gt;ty_item-obj_name
                  iv_obj_type     TYPE zif_abapgit_definitions=&gt;ty_item-obj_type
                  iv_sub_obj_name TYPE zif_abapgit_definitions=&gt;ty_item-obj_name OPTIONAL
                  iv_sub_obj_type TYPE zif_abapgit_definitions=&gt;ty_item-obj_type OPTIONAL
                  iv_line_number  TYPE i OPTIONAL
        RAISING   zcx_abapgit_exception.

    CONSTANTS: c_user_unknown TYPE xubname VALUE &apos;UNKNOWN&apos;.

  PROTECTED SECTION.

    DATA ms_item TYPE zif_abapgit_definitions=&gt;ty_item .
    DATA mv_language TYPE spras .

    METHODS check_timestamp
      IMPORTING
        !iv_timestamp     TYPE timestamp
        !iv_date          TYPE datum
        !iv_time          TYPE uzeit
      RETURNING
        VALUE(rv_changed) TYPE abap_bool .
    METHODS get_metadata
      RETURNING
        VALUE(rs_metadata) TYPE zif_abapgit_definitions=&gt;ty_metadata .
    METHODS corr_insert
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS tadir_insert
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS jump_se11
      IMPORTING
        !iv_radio TYPE string
        !iv_field TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS exists_a_lock_entry_for
      IMPORTING
        !iv_lock_object               TYPE string
        !iv_argument                  TYPE seqg3-garg OPTIONAL
      RETURNING
        VALUE(rv_exists_a_lock_entry) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS set_default_package
      IMPORTING
        !iv_package TYPE devclass .
    METHODS serialize_longtexts
      IMPORTING
        !io_xml         TYPE REF TO zcl_abapgit_xml_output
        !iv_longtext_id TYPE dokil-id OPTIONAL
        !it_dokil       TYPE zif_abapgit_definitions=&gt;tty_dokil OPTIONAL
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_longtexts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS delete_longtexts
      IMPORTING
        !iv_longtext_id TYPE dokil-id
      RAISING
        zcx_abapgit_exception .
    METHODS is_active
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-METHODS:
      is_adt_jump_possible
        IMPORTING io_object                      TYPE REF TO cl_wb_object
                  io_adt                         TYPE REF TO object
        RETURNING VALUE(rv_is_adt_jump_possible) TYPE abap_bool
        RAISING   zcx_abapgit_exception.
    CLASS-METHODS:
      get_adt_objects_and_names
        IMPORTING
          iv_obj_name       TYPE zif_abapgit_definitions=&gt;ty_item-obj_name
          iv_obj_type       TYPE zif_abapgit_definitions=&gt;ty_item-obj_type
        EXPORTING
          eo_adt_uri_mapper TYPE REF TO object
          eo_adt_objectref  TYPE REF TO object
          ev_program        TYPE progname
          ev_include        TYPE progname
        RAISING
          zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_object_acid DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS: create_object
      RETURNING VALUE(ro_aab) TYPE REF TO cl_aab_id
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_asfc DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_object_auth DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.
  PRIVATE SECTION.
    DATA: mv_fieldname TYPE authx-fieldname.

ENDCLASS.
CLASS zcl_abapgit_object_avas DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_header,
        guid      TYPE guid_32,
        attribute TYPE cls_attribute_name,
        object    TYPE pak_object_key,
      END OF ty_header .
    TYPES:
      BEGIN OF ty_avas,
        header TYPE ty_header,
        values TYPE cls_value_assignments,
        links  TYPE cls_linked_objects,
      END OF ty_avas .

    METHODS insert_assignments
      IMPORTING
        !is_avas TYPE ty_avas
      RAISING
        zcx_abapgit_exception .
    METHODS insert_links
      IMPORTING
        !is_avas TYPE ty_avas .
    METHODS instantiate
      RETURNING
        VALUE(ro_avas) TYPE REF TO cl_cls_attr_value_assignment
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_object_char DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_char,
        cls_attribute   TYPE cls_attribute,
        cls_attributet  TYPE STANDARD TABLE OF cls_attributet WITH DEFAULT KEY,
        cls_attr_value  TYPE STANDARD TABLE OF cls_attr_value WITH DEFAULT KEY,
        cls_attr_valuet TYPE STANDARD TABLE OF cls_attr_valuet WITH DEFAULT KEY,
      END OF ty_char .

    METHODS instantiate_char
      IMPORTING
        !iv_type_group TYPE cls_object_type_group
      RETURNING
        VALUE(ro_char) TYPE REF TO cl_cls_attribute
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_object_cmpt DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    DATA: mo_cmp_db TYPE REF TO object,
          mv_name   TYPE c LENGTH 30.

ENDCLASS.
CLASS zcl_abapgit_object_cus0 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES: tty_img_activity_texts TYPE STANDARD TABLE OF cus_imgact
                                       WITH NON-UNIQUE DEFAULT KEY,
           BEGIN OF ty_img_activity,
             header TYPE cus_imgach,
             texts  TYPE tty_img_activity_texts,
           END OF ty_img_activity.
    DATA: mv_img_activity TYPE cus_img_ac.

ENDCLASS.
CLASS zcl_abapgit_object_cus1 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES: tty_activity_titles TYPE STANDARD TABLE OF cus_actt
                                    WITH NON-UNIQUE DEFAULT KEY,

           tty_objects         TYPE STANDARD TABLE OF cus_actobj
                            WITH NON-UNIQUE DEFAULT KEY,

           tty_objects_title   TYPE STANDARD TABLE OF cus_actobt
                                  WITH NON-UNIQUE DEFAULT KEY,

           BEGIN OF ty_customzing_activity,
             activity_header        TYPE cus_acth,
             activity_customer_exit TYPE cus_actext,
             activity_title         TYPE tty_activity_titles,
             objects                TYPE tty_objects,
             objects_title          TYPE tty_objects_title,
           END OF ty_customzing_activity.

    DATA: mv_customizing_activity TYPE cus_img_ac.

ENDCLASS.
CLASS zcl_abapgit_object_cus2 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES: tty_attribute_titles        TYPE STANDARD TABLE OF cus_atrt
                                            WITH NON-UNIQUE DEFAULT KEY,
           tty_attribute_countries     TYPE STANDARD TABLE OF cus_atrcou
                                            WITH NON-UNIQUE DEFAULT KEY,
           tty_attribute_components    TYPE STANDARD TABLE OF tfm18
                                            WITH NON-UNIQUE DEFAULT KEY,
           tty_attribute_comp_variants TYPE STANDARD TABLE OF cus_atrvco
                                            WITH NON-UNIQUE DEFAULT KEY.

    TYPES: BEGIN OF ty_customizing_attribute,
             header              TYPE cus_atrh,
             titles              TYPE tty_attribute_titles,
             countries           TYPE tty_attribute_countries,
             components          TYPE tty_attribute_components,
             components_variants TYPE tty_attribute_comp_variants,
           END OF ty_customizing_attribute.

    DATA: mv_img_attribute TYPE cus_atr.

ENDCLASS.
CLASS zcl_abapgit_object_dcls DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_ddls DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PROTECTED SECTION.
    METHODS open_adt_stob
      IMPORTING iv_ddls_name TYPE tadir-obj_name
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_ddlx DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    DATA: mo_persistence TYPE REF TO if_wb_object_persist.

  PRIVATE SECTION.
    METHODS:
      get_persistence
        RETURNING
          VALUE(ri_persistence) TYPE REF TO if_wb_object_persist
        RAISING
          zcx_abapgit_exception,

      clear_fields
        CHANGING
          cs_data TYPE any,

      clear_field
        IMPORTING
          iv_fieldname TYPE csequence
        CHANGING
          cs_metadata  TYPE any.

ENDCLASS.
CLASS zcl_abapgit_object_devc DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  FINAL.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_object.
    ALIASES:
      mo_files FOR zif_abapgit_object~mo_files.
    METHODS:
      constructor IMPORTING is_item     TYPE zif_abapgit_definitions=&gt;ty_item
                            iv_language TYPE spras.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS:
      get_package RETURNING VALUE(ri_package) TYPE REF TO if_package
                  RAISING   zcx_abapgit_exception,
      update_pinf_usages IMPORTING ii_package    TYPE REF TO if_package
                                   it_usage_data TYPE scomppdata
                         RAISING   zcx_abapgit_exception,
      set_lock IMPORTING ii_package TYPE REF TO if_package
                         iv_lock    TYPE abap_bool
               RAISING   zcx_abapgit_exception,
      is_empty
        IMPORTING iv_package_name    TYPE devclass
        RETURNING VALUE(rv_is_empty) TYPE abap_bool
        RAISING   zcx_abapgit_exception,
      load_package
        IMPORTING iv_package_name   TYPE devclass
        RETURNING VALUE(ri_package) TYPE REF TO if_package
        RAISING   zcx_abapgit_exception.

    DATA:
      mv_local_devclass TYPE devclass.
ENDCLASS.
CLASS zcl_abapgit_object_dial DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_dialog_module,
             tdct     TYPE tdct,
             dia_pars TYPE STANDARD TABLE OF diapar
                           WITH NON-UNIQUE DEFAULT KEY,
           END OF ty_dialog_module.

    METHODS:
      _read_tdct
        RETURNING
          VALUE(rs_tdct) TYPE tdct.

ENDCLASS.
CLASS zcl_abapgit_object_doct DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    CONSTANTS: c_id      TYPE dokhl-id VALUE &apos;TX&apos;,
               c_typ     TYPE dokhl-typ VALUE &apos;E&apos;,
               c_version TYPE dokhl-dokversion VALUE &apos;0001&apos;,
               c_name    TYPE string VALUE &apos;DOC&apos;.

    TYPES: BEGIN OF ty_data,
             doctitle TYPE dsyst-doktitle,
             head     TYPE thead,
             lines    TYPE tline_tab,
           END OF ty_data.

    METHODS: read
      RETURNING VALUE(rs_data) TYPE ty_data.

ENDCLASS.
CLASS zcl_abapgit_object_docv DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    CONSTANTS: c_typ     TYPE dokhl-typ VALUE &apos;E&apos;,
               c_version TYPE dokhl-dokversion VALUE &apos;0001&apos;,
               c_name    TYPE string VALUE &apos;DOC&apos;.

    TYPES: BEGIN OF ty_data,
             doctitle TYPE dsyst-doktitle,
             head     TYPE thead,
             lines    TYPE tline_tab,
           END OF ty_data.

    METHODS: read
      RETURNING VALUE(rs_data) TYPE ty_data.

ENDCLASS.
CLASS zcl_abapgit_object_doma DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.

    TYPES: BEGIN OF ty_dd01_texts,
             ddlanguage TYPE dd01v-ddlanguage,
             ddtext     TYPE dd01v-ddtext,
           END OF ty_dd01_texts,
           BEGIN OF ty_dd07_texts,
             valpos     TYPE dd07v-valpos,
             ddlanguage TYPE dd07v-ddlanguage,
             domvalue_l TYPE dd07v-domvalue_l,
             domvalue_h TYPE dd07v-domvalue_h,
             ddtext     TYPE dd07v-ddtext,
             domval_ld  TYPE dd07v-domval_ld,
             domval_hd  TYPE dd07v-domval_hd,
           END OF ty_dd07_texts,
           tt_dd01_texts TYPE STANDARD TABLE OF ty_dd01_texts,
           tt_dd07_texts TYPE STANDARD TABLE OF ty_dd07_texts.
    CONSTANTS: c_longtext_id_doma TYPE dokil-id VALUE &apos;DO&apos;.

    METHODS:
      serialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      deserialize_texts
        IMPORTING io_xml   TYPE REF TO zcl_abapgit_xml_input
                  is_dd01v TYPE dd01v
                  it_dd07v TYPE dd07v_tab
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_dsys DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    CONSTANTS: c_typ     TYPE dokhl-typ VALUE &apos;E&apos;,
               c_version TYPE dokhl-dokversion VALUE &apos;0001&apos;,
               c_id      TYPE dokhl-id VALUE &apos;HY&apos;,
               c_dokclas TYPE doku_class VALUE &apos;SIMG&apos;.
    DATA: mv_object  TYPE dokhl-object,
          mv_dokname TYPE doku_obj.

    TYPES: BEGIN OF ty_data,
             doctitle TYPE dsyst-doktitle,
             head     TYPE thead,
             lines    TYPE tline_tab,
           END OF ty_data.

    METHODS: read
      RETURNING VALUE(rs_data) TYPE ty_data.

ENDCLASS.
CLASS zcl_abapgit_object_dtel DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.

    TYPES: BEGIN OF ty_dd04_texts,
             ddlanguage TYPE dd04t-ddlanguage,
             ddtext     TYPE dd04t-ddtext,
             reptext    TYPE dd04t-reptext,
             scrtext_s  TYPE dd04t-scrtext_s,
             scrtext_m  TYPE dd04t-scrtext_m,
             scrtext_l  TYPE dd04t-scrtext_l,
           END OF ty_dd04_texts,
           tt_dd04_texts TYPE STANDARD TABLE OF ty_dd04_texts.
    CONSTANTS: c_longtext_id_dtel TYPE dokil-id VALUE &apos;DE&apos;.

    METHODS:
      serialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      deserialize_texts
        IMPORTING io_xml   TYPE REF TO zcl_abapgit_xml_input
                  is_dd04v TYPE dd04v
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_ecatt_super DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    ALIASES mo_files
      FOR zif_abapgit_object~mo_files .

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras .

  PROTECTED SECTION.
    METHODS:
      get_object_type ABSTRACT
        RETURNING VALUE(rv_object_type) TYPE etobj_type,

      get_upload ABSTRACT
        RETURNING
          VALUE(ro_upload) TYPE REF TO cl_apl_ecatt_upload,

      get_download ABSTRACT
        RETURNING
          VALUE(ro_download) TYPE REF TO cl_apl_ecatt_download,

      get_lock_object ABSTRACT
        RETURNING
          VALUE(rv_lock_object) TYPE eqeobj.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_last_changed,
        luser TYPE xubname,
        ldate TYPE datum,
        ltime TYPE uzeit,
      END OF ty_last_changed.

    CONSTANTS:
      BEGIN OF co_name,
        version  TYPE string VALUE &apos;VERSION&apos; ##NO_TEXT,
        versions TYPE string VALUE &apos;VERSIONS&apos; ##NO_TEXT,
      END OF co_name,
      co_default_version TYPE etobj_ver VALUE &apos;1&apos; ##NO_TEXT.

    CLASS-METHODS:
      is_change_more_recent_than
        IMPORTING
          is_currently_changed            TYPE ty_last_changed
          is_last_changed                 TYPE ty_last_changed
        RETURNING
          VALUE(rv_is_change_more_recent) TYPE abap_bool.

    DATA:
      mv_object_name TYPE etobj_name.

    METHODS:
      get_changed_date
        IMPORTING
          ii_document            TYPE REF TO if_ixml_document
        RETURNING
          VALUE(rv_changed_date) TYPE d,

      get_changed_time
        IMPORTING
          ii_document            TYPE REF TO if_ixml_document
        RETURNING
          VALUE(rv_changed_time) TYPE t,

      get_changed_by_user
        IMPORTING
          ii_document               TYPE REF TO if_ixml_document
        RETURNING
          VALUE(rv_changed_by_user) TYPE xubname,

      get_change_information
        IMPORTING
          is_version_info              TYPE etversinfo
        RETURNING
          VALUE(rs_change_information) TYPE ty_last_changed
        RAISING
          cx_ecatt_apl
          zcx_abapgit_exception,

      clear_attributes
        CHANGING
          ci_document TYPE REF TO if_ixml_document,

      clear_elements
        CHANGING
          ci_document TYPE REF TO if_ixml_document,

      get_version_from_node
        IMPORTING
          ii_node           TYPE REF TO if_ixml_node
        RETURNING
          VALUE(rv_version) TYPE string,

      deserialize_version
        IMPORTING
          ii_version_node TYPE REF TO if_ixml_node
          iv_package      TYPE devclass
        RAISING
          zcx_abapgit_exception,

      serialize_version
        IMPORTING
          iv_version TYPE etversinfo-version
        CHANGING
          ci_node    TYPE REF TO if_ixml_element
        RAISING
          cx_ecatt
          zcx_abapgit_exception,

      clear_element
        IMPORTING
          iv_name     TYPE csequence
        CHANGING
          ci_document TYPE REF TO if_ixml_document,

      serialize_versions
        IMPORTING
          it_version_info TYPE etversinfo_tabtype
        CHANGING
          ci_document     TYPE REF TO if_ixml_document
        RAISING
          cx_ecatt
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_ecat DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_ecsd DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_ecsp DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_ectc DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_ectd DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_ecvo DEFINITION
  INHERITING FROM zcl_abapgit_object_ecatt_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING
          !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          !iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS:
      get_object_type REDEFINITION,
      get_upload REDEFINITION,
      get_download REDEFINITION,
      get_lock_object REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_enho DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.

    METHODS:
      factory
        IMPORTING
          iv_tool        TYPE enhtooltype
        RETURNING
          VALUE(ri_enho) TYPE REF TO zif_abapgit_object_enho
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_enhs DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      factory
        IMPORTING
          iv_tool        TYPE enhtooltype
        RETURNING
          VALUE(ri_enho) TYPE REF TO zif_abapgit_object_enhs
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_enqu DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
  PRIVATE SECTION.
    TYPES: tyt_dd27p TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.
    METHODS _clear_dd27p_fields CHANGING ct_dd27p TYPE tyt_dd27p.

ENDCLASS.
CLASS zcl_abapgit_object_ensc DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_form DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    CONSTANTS: c_objectname_form    TYPE thead-tdobject VALUE &apos;FORM&apos; ##NO_TEXT.
    CONSTANTS: c_objectname_tdlines TYPE thead-tdobject VALUE &apos;TDLINES&apos; ##NO_TEXT.
    CONSTANTS: c_extension_xml      TYPE string         VALUE &apos;xml&apos; ##NO_TEXT.
    DATA: mv_form_name  TYPE itcta-tdform.

    TYPES: BEGIN OF tys_form_data,
             form_header   TYPE itcta,
             text_header   TYPE thead,
             orig_language TYPE sy-langu,
             pages         TYPE STANDARD TABLE OF itctg WITH DEFAULT KEY,
             page_windows  TYPE STANDARD TABLE OF itcth WITH DEFAULT KEY,
             paragraphs    TYPE STANDARD TABLE OF itcdp WITH DEFAULT KEY,
             strings       TYPE STANDARD TABLE OF itcds WITH DEFAULT KEY,
             tabs          TYPE STANDARD TABLE OF itcdq WITH DEFAULT KEY,
             windows       TYPE STANDARD TABLE OF itctw WITH DEFAULT KEY,
           END OF tys_form_data,
           tyt_form_data   TYPE STANDARD TABLE OF tys_form_data WITH DEFAULT KEY,
           tyt_form_header TYPE STANDARD TABLE OF itcta WITH DEFAULT KEY,
           tys_form_header TYPE LINE OF tyt_form_header,
           tyt_text_header TYPE STANDARD TABLE OF thead WITH DEFAULT KEY,
           tys_text_header TYPE LINE OF tyt_text_header,
           tyt_lines       TYPE tline_tab.

    METHODS get_last_changes
      IMPORTING
        iv_form_name           TYPE zif_abapgit_definitions=&gt;ty_item-obj_name
      RETURNING
        VALUE(rs_last_changed) TYPE tys_form_header.

    METHODS build_extra_from_header
      IMPORTING
        is_header        TYPE tys_form_header
      RETURNING
        VALUE(rv_result) TYPE string.

    METHODS build_extra_from_header_old
      IMPORTING
        is_header        TYPE tys_form_header
      RETURNING
        VALUE(rv_result) TYPE string.

    METHODS _save_form
      IMPORTING
        it_lines     TYPE zcl_abapgit_object_form=&gt;tyt_lines
      CHANGING
        cs_form_data TYPE zcl_abapgit_object_form=&gt;tys_form_data.

    METHODS extract_tdlines
      IMPORTING
        is_form_data    TYPE zcl_abapgit_object_form=&gt;tys_form_data
      RETURNING
        VALUE(rt_lines) TYPE zcl_abapgit_object_form=&gt;tyt_lines
      RAISING
        zcx_abapgit_exception.

    METHODS _clear_changed_fields
      CHANGING
        cs_form_data TYPE zcl_abapgit_object_form=&gt;tys_form_data.

    METHODS compress_lines
      IMPORTING
        is_form_data TYPE zcl_abapgit_object_form=&gt;tys_form_data
        it_lines     TYPE zcl_abapgit_object_form=&gt;tyt_lines
      RAISING
        zcx_abapgit_exception.

    METHODS find_form
      IMPORTING
        iv_object_name        TYPE zif_abapgit_definitions=&gt;ty_item-obj_name
      RETURNING
        VALUE(rt_text_header) TYPE zcl_abapgit_object_form=&gt;tyt_text_header.

    METHODS _read_form
      IMPORTING
        is_text_header TYPE zcl_abapgit_object_form=&gt;tys_text_header
      EXPORTING
        ev_form_found  TYPE flag
        es_form_data   TYPE zcl_abapgit_object_form=&gt;tys_form_data
        et_lines       TYPE zcl_abapgit_object_form=&gt;tyt_lines.

    METHODS order_check_and_insert
      RAISING
        zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_iamu DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_internet_appl_comp_binary,
             attributes TYPE w3mimeattr,
             source     TYPE w3mimetabtype,
             length     TYPE i,
           END OF ty_internet_appl_comp_binary.

    DATA: mo_mime_api TYPE REF TO if_w3_api_mime.

    METHODS:
      load_mime_api
        RAISING
          zcx_abapgit_exception,

      read
        RETURNING
          VALUE(rs_internet_appl_comp_binary) TYPE ty_internet_appl_comp_binary
        RAISING
          zcx_abapgit_exception,

      save
        IMPORTING
          is_internet_appl_comp_binary TYPE ty_internet_appl_comp_binary
        RAISING
          zcx_abapgit_exception,

      release_lock
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_iarp DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      read
        EXPORTING es_attr       TYPE w3resoattr
                  et_parameters TYPE w3resopara_tabletype
        RAISING   zcx_abapgit_exception,
      save
        IMPORTING is_attr       TYPE w3resoattr
                  it_parameters TYPE w3resopara_tabletype
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_iasp DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      read
        EXPORTING es_attr       TYPE w3servattr
                  et_parameters TYPE w3servpara_tabletype
        RAISING   zcx_abapgit_exception,
      save
        IMPORTING is_attr       TYPE w3servattr
                  it_parameters TYPE w3servpara_tabletype
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_iatu DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      read
        EXPORTING es_attr   TYPE w3tempattr
                  ev_source TYPE string
        RAISING   zcx_abapgit_exception,
      save
        IMPORTING is_attr   TYPE w3tempattr
                  iv_source TYPE string
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_idoc DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_idoc,
        attributes TYPE edi_iapi01,
        t_syntax   TYPE STANDARD TABLE OF edi_iapi02 WITH NON-UNIQUE DEFAULT KEY,
      END OF ty_idoc.

    DATA:
      mv_idoctyp TYPE edi_iapi00-idoctyp.

ENDCLASS.
CLASS zcl_abapgit_object_iext DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_extention,
        attributes TYPE edi_iapi01,
        t_syntax   TYPE STANDARD TABLE OF edi_iapi03 WITH NON-UNIQUE DEFAULT KEY,
      END OF ty_extention.

    DATA:
      mv_extension TYPE edi_cimtyp.

ENDCLASS.
CLASS zcl_abapgit_object_jobd DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: ty_jd_name TYPE c LENGTH 32.

ENDCLASS.
CLASS zcl_abapgit_object_msag DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_t100_texts,
             sprsl TYPE t100-sprsl,
             msgnr TYPE t100-msgnr,
             text  TYPE t100-text,
           END OF ty_t100_texts,
           tt_t100_texts TYPE STANDARD TABLE OF ty_t100_texts,
           tty_t100      TYPE STANDARD TABLE OF t100
                         WITH NON-UNIQUE DEFAULT KEY,
           BEGIN OF ty_longtext,
             dokil TYPE dokil,
             head  TYPE thead,
             lines TYPE tline_tab,
           END OF ty_longtext,
           tty_longtexts TYPE STANDARD TABLE OF ty_longtext
                              WITH NON-UNIQUE DEFAULT KEY.

    METHODS:
      serialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      deserialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      serialize_longtexts_msag
        IMPORTING it_t100 TYPE zcl_abapgit_object_msag=&gt;tty_t100
                  io_xml  TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      delete_msgid IMPORTING iv_message_id TYPE arbgb,
      free_access_permission
        IMPORTING
          iv_message_id TYPE arbgb,
      delete_documentation
        IMPORTING
          iv_message_id TYPE arbgb.

ENDCLASS.
CLASS zcl_abapgit_object_nrob DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      delete_intervals IMPORTING iv_object TYPE inri-object
                       RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_para DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_pinf DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_pinf,
             attributes TYPE scompidtln,
             elements   TYPE STANDARD TABLE OF scomeldtln WITH DEFAULT KEY,
           END OF ty_pinf.

    TYPES: ty_elements TYPE STANDARD TABLE OF tpak_package_interf_elem_ref WITH DEFAULT KEY.

    METHODS:
      create_or_load
        IMPORTING is_pinf             TYPE ty_pinf
                  iv_package          TYPE devclass
        RETURNING VALUE(ri_interface) TYPE REF TO if_package_interface
        RAISING   zcx_abapgit_exception,
      delete_elements
        IMPORTING ii_interface TYPE REF TO if_package_interface
        RAISING   zcx_abapgit_exception,
      update_attributes
        IMPORTING is_pinf      TYPE ty_pinf
                  ii_interface TYPE REF TO if_package_interface
        RAISING   zcx_abapgit_exception,
      update_elements
        IMPORTING is_pinf      TYPE ty_pinf
                  ii_interface TYPE REF TO if_package_interface
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_prag DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_pragma,
             pragma      TYPE c LENGTH 40,
             extension   TYPE c LENGTH 1,
             signature   TYPE c LENGTH 10,
             description TYPE c LENGTH 255,
           END OF ty_pragma.

    METHODS:
      _raise_pragma_not_exists
        RAISING
          zcx_abapgit_exception,

      _raise_pragma_exists
        RAISING
          zcx_abapgit_exception,

      _raise_pragma_enqueue
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_scp1 DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_scp1,
        scprattr TYPE scprattr,
        scprtext TYPE STANDARD TABLE OF scprtext WITH DEFAULT KEY,
        scprvals TYPE STANDARD TABLE OF scprvals WITH DEFAULT KEY,
        scprvall TYPE STANDARD TABLE OF scprvall WITH DEFAULT KEY,
        scprreca TYPE STANDARD TABLE OF scprreca WITH DEFAULT KEY,
        scprfldv TYPE STANDARD TABLE OF scprfldv WITH DEFAULT KEY,
      END OF ty_scp1 .

    METHODS dequeue .
    METHODS enqueue
      RAISING
        zcx_abapgit_exception .
    METHODS save
      IMPORTING
        !is_scp1 TYPE ty_scp1
      RAISING
        zcx_abapgit_exception .
    METHODS adjust_inbound
      CHANGING
        !cs_scp1 TYPE ty_scp1 .
    METHODS adjust_outbound
      CHANGING
        !cs_scp1 TYPE ty_scp1 .
    METHODS load
      CHANGING
        !cs_scp1 TYPE ty_scp1 .
    METHODS call_delete_fms
      IMPORTING iv_profile_id TYPE scpr_id
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_object_sfbf DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    METHODS:
      get
        RETURNING VALUE(ro_bf) TYPE REF TO cl_sfw_bf
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_sfbs DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    METHODS:
      get
        RETURNING VALUE(ro_bfs) TYPE REF TO cl_sfw_bfs
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_sfpf DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    CLASS-METHODS:
      fix_oref
        IMPORTING ii_document TYPE REF TO if_ixml_document.

  PRIVATE SECTION.
    METHODS:
      load
        RETURNING VALUE(ri_wb_form) TYPE REF TO if_fp_wb_form
        RAISING   zcx_abapgit_exception,
      form_to_xstring
        RETURNING VALUE(rv_xstr) TYPE xstring
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_sfpi DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      load
        RETURNING VALUE(ri_wb_interface) TYPE REF TO if_fp_wb_interface
        RAISING   zcx_abapgit_exception,
      interface_to_xstring
        RETURNING VALUE(rv_xstr) TYPE xstring
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_sfsw DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    METHODS:
      get
        RETURNING VALUE(ro_switch) TYPE REF TO cl_sfw_sw
        RAISING   zcx_abapgit_exception,
      wait_for_background_job,
      wait_for_deletion
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_shi3 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PROTECTED SECTION.
    METHODS has_authorization
      IMPORTING iv_devclass     TYPE devclass
                iv_object_type  TYPE seu_objid
                iv_structure_id TYPE hier_guid
                iv_activity     TYPE activ_auth
      RAISING   zcx_abapgit_exception.
    METHODS is_used
      IMPORTING iv_structure_id TYPE hier_guid
      RAISING   zcx_abapgit_exception.
    METHODS delete_tree_structure
      IMPORTING iv_structure_id TYPE hier_guid.

  PRIVATE SECTION.
    DATA: mv_tree_id TYPE ttree-id.

    METHODS jump_se43
      RAISING zcx_abapgit_exception.

    METHODS clear_fields
      CHANGING cs_head  TYPE ttree
               ct_nodes TYPE hier_iface_t.

ENDCLASS.
CLASS zcl_abapgit_object_shi5 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.
  PRIVATE SECTION.
    TYPES: tty_ttree_extt TYPE STANDARD TABLE OF ttree_extt
                               WITH NON-UNIQUE DEFAULT KEY,
           BEGIN OF ty_extension,
             header TYPE ttree_ext,
             texts  TYPE tty_ttree_extt,
           END OF ty_extension.

    DATA: mv_extension TYPE hier_names.

ENDCLASS.
CLASS zcl_abapgit_object_shi8 DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PRIVATE SECTION.
    DATA: mv_assignment_id  TYPE hier_sfw_id.

ENDCLASS.
CLASS zcl_abapgit_object_shlp DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_shma DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

ENDCLASS.
CLASS zcl_abapgit_object_sicf DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    ALIASES mo_files
      FOR zif_abapgit_object~mo_files .

    CLASS-METHODS read_tadir_sicf
      IMPORTING
        !iv_pgmid       TYPE tadir-pgmid DEFAULT &apos;R3TR&apos;
        !iv_obj_name    TYPE tadir-obj_name
      RETURNING
        VALUE(rs_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS read_sicf_url
      IMPORTING
        !iv_obj_name   TYPE tadir-obj_name
      RETURNING
        VALUE(rv_hash) TYPE text25
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    TYPES:
      ty_icfhandler_tt TYPE STANDARD TABLE OF icfhandler WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_sicf_key,
        icf_name   TYPE icfservice-icf_name,
        icfparguid TYPE icfservice-icfparguid,
      END OF ty_sicf_key .

    METHODS read
      IMPORTING
        !iv_clear      TYPE abap_bool DEFAULT abap_true
      EXPORTING
        !es_icfservice TYPE icfservice
        !es_icfdocu    TYPE icfdocu
        !et_icfhandler TYPE ty_icfhandler_tt
        !ev_url        TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS insert_sicf
      IMPORTING
        !is_icfservice TYPE icfservice
        !is_icfdocu    TYPE icfdocu
        !it_icfhandler TYPE ty_icfhandler_tt
        !iv_package    TYPE devclass
        !iv_url        TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS change_sicf
      IMPORTING
        !is_icfservice TYPE icfservice
        !is_icfdocu    TYPE icfdocu
        !it_icfhandler TYPE ty_icfhandler_tt
        !iv_package    TYPE devclass
        !iv_parent     TYPE icfparguid
      RAISING
        zcx_abapgit_exception .
    METHODS to_icfhndlist
      IMPORTING
        !it_list       TYPE ty_icfhandler_tt
      RETURNING
        VALUE(rt_list) TYPE icfhndlist .
    METHODS find_parent
      IMPORTING
        !iv_url          TYPE string
      RETURNING
        VALUE(rv_parent) TYPE icfparguid
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_object_smim DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS get_filename
      IMPORTING iv_url             TYPE string
      RETURNING VALUE(rv_filename) TYPE string.

    METHODS find_content
      IMPORTING iv_url            TYPE string
      RETURNING VALUE(rv_content) TYPE xstring
      RAISING   zcx_abapgit_exception.

    METHODS build_filename
      IMPORTING iv_filename        TYPE string
      RETURNING VALUE(rv_filename) TYPE string.

    METHODS get_url_for_io
      EXPORTING ev_url       TYPE string
                ev_is_folder TYPE boole_d
      RAISING   zcx_abapgit_not_found
                zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_splo DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_srfc DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

ENDCLASS.
CLASS zcl_abapgit_object_ssfo DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: ty_string_range TYPE RANGE OF string.

    CLASS-DATA: gt_range_node_codes TYPE ty_string_range.
    CONSTANTS: attrib_abapgit_leadig_spaces TYPE string VALUE &apos;abapgit-leadig-spaces&apos; ##NO_TEXT.

    METHODS fix_ids IMPORTING ii_xml_doc TYPE REF TO if_ixml_document.
    METHODS set_attribute_leading_spaces IMPORTING iv_name                TYPE string
                                                   ii_node                TYPE REF TO if_ixml_node
                                         CHANGING  cv_within_code_section TYPE abap_bool.
    METHODS handle_attrib_leading_spaces IMPORTING iv_name                TYPE string
                                                   ii_node                TYPE REF TO if_ixml_node
                                         CHANGING  cv_within_code_section TYPE abap_bool.
    METHODS get_range_node_codes RETURNING VALUE(rt_range_node_codes) TYPE ty_string_range.
    METHODS code_item_section_handling IMPORTING iv_name                TYPE string
                                                 ii_node                TYPE REF TO if_ixml_node
                                       EXPORTING ei_code_item_element   TYPE REF TO if_ixml_element
                                       CHANGING  cv_within_code_section TYPE abap_bool
                                       RAISING   zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_object_ssst DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    CONSTANTS: c_style_active TYPE tdactivate VALUE &apos;A&apos;.

  PRIVATE SECTION.
    METHODS validate_font
      IMPORTING iv_tdfamily TYPE tdfamily
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_styl DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_style,
             header     TYPE itcda,
             paragraphs TYPE STANDARD TABLE OF itcdp WITH DEFAULT KEY,
             strings    TYPE STANDARD TABLE OF itcds WITH DEFAULT KEY,
             tabs       TYPE STANDARD TABLE OF itcdq WITH DEFAULT KEY,
           END OF ty_style.

ENDCLASS.
CLASS zcl_abapgit_object_sucu DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_object_susc DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
  PROTECTED SECTION.
    CONSTANTS transobjecttype_class TYPE char1 VALUE &apos;C&apos; ##NO_TEXT.

    METHODS has_authorization
      IMPORTING iv_object_type TYPE seu_objid
                iv_class       TYPE tobc-oclss
                iv_activity    TYPE activ_auth
      RAISING   zcx_abapgit_exception.
    METHODS is_used
      IMPORTING iv_auth_object_class TYPE tobc-oclss
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    METHODS delete_class
      IMPORTING iv_auth_object_class TYPE tobc-oclss.
    METHODS put_delete_to_transport
      IMPORTING iv_auth_object_class TYPE tobc-oclss
                iv_object_type       TYPE seu_objid
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_suso DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

  PRIVATE SECTION.
    DATA:
      mv_objectname TYPE tobj-objct.

    METHODS:
      delete_documentation
        RAISING
          zcx_abapgit_exception,

      pre_check
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_sxci DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_classic_badi_implementation,
             implementation_data TYPE impl_data,
             function_codes      TYPE seex_fcode_table,
             control_composites  TYPE seex_coco_table,
             customer_includes   TYPE seex_table_table,
             screens             TYPE seex_screen_table,
             filters             TYPE seex_filter_table,
           END OF ty_classic_badi_implementation.
ENDCLASS.
CLASS zcl_abapgit_object_tabl DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS c_longtext_id_tabl TYPE dokil-id VALUE &apos;TB&apos; ##NO_TEXT.

    TYPES: ty_dd03p_tt TYPE STANDARD TABLE OF dd03p.

    METHODS clear_dd03p_fields
      CHANGING ct_dd03p TYPE ty_dd03p_tt.
ENDCLASS.
CLASS zcl_abapgit_object_tobj DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_tobj,
             tddat TYPE tddat,
             tvdir TYPE tvdir,
             tvimf TYPE STANDARD TABLE OF tvimf WITH DEFAULT KEY,
           END OF ty_tobj.

    METHODS:
      read_extra IMPORTING iv_tabname     TYPE vim_name
                 RETURNING VALUE(rs_tobj) TYPE ty_tobj,
      update_extra IMPORTING is_tobj TYPE ty_tobj,
      delete_extra IMPORTING iv_tabname TYPE vim_name.

ENDCLASS.
CLASS zcl_abapgit_object_tran DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      tty_param_values TYPE STANDARD TABLE OF rsparam
                                   WITH NON-UNIQUE DEFAULT KEY .

    CONSTANTS:
      c_oo_program(9) VALUE &apos;\PROGRAM=&apos; ##NO_TEXT.
    CONSTANTS:
      c_oo_class(7) VALUE &apos;\CLASS=&apos; ##NO_TEXT.
    CONSTANTS:
      c_oo_method(8) VALUE &apos;\METHOD=&apos; ##NO_TEXT.
    CONSTANTS c_oo_tcode TYPE tcode VALUE &apos;OS_APPLICATION&apos; ##NO_TEXT.
    CONSTANTS:
      c_oo_frclass(30) VALUE &apos;CLASS&apos; ##NO_TEXT.
    CONSTANTS:
      c_oo_frmethod(30) VALUE &apos;METHOD&apos; ##NO_TEXT.
    CONSTANTS:
      c_oo_frupdtask(30) VALUE &apos;UPDATE_MODE&apos; ##NO_TEXT.
    CONSTANTS c_oo_synchron TYPE c VALUE &apos;S&apos; ##NO_TEXT.
    CONSTANTS c_oo_asynchron TYPE c VALUE &apos;U&apos; ##NO_TEXT.
    CONSTANTS c_true TYPE c VALUE &apos;X&apos; ##NO_TEXT.
    CONSTANTS c_false TYPE c VALUE space ##NO_TEXT.
    DATA:
      mt_bcdata TYPE STANDARD TABLE OF bdcdata .

    METHODS add_data
      IMPORTING
        !iv_fnam TYPE bdcdata-fnam
        !iv_fval TYPE clike .
    METHODS call_se93
      RAISING
        zcx_abapgit_exception .
    METHODS set_oo_parameters
      IMPORTING
        !it_rsparam TYPE s_param
      CHANGING
        !cs_rsstcd  TYPE rsstcd .
    METHODS split_parameters
      CHANGING
        !ct_rsparam TYPE s_param
        !cs_rsstcd  TYPE rsstcd
        !cs_tstcp   TYPE tstcp
        !cs_tstc    TYPE tstc .
    METHODS split_parameters_comp
      IMPORTING
        !ig_type  TYPE any
        !ig_param TYPE any
      CHANGING
        !cg_value TYPE any .
    METHODS serialize_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_oo_transaction
      IMPORTING
        !iv_package      TYPE devclass
        !is_tstc         TYPE tstc
        !is_tstcc        TYPE tstcc
        !is_tstct        TYPE tstct
        !is_tstcp        TYPE tstcp
        !it_param_values TYPE zcl_abapgit_object_tran=&gt;tty_param_values
        !is_rsstcd       TYPE rsstcd
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_object_ttyp DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_type DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    CONSTANTS: c_prefix TYPE c LENGTH 3 VALUE &apos;%_C&apos;.

    METHODS read
      EXPORTING ev_ddtext TYPE ddtypet-ddtext
                et_source TYPE abaptxt255_tab
      RAISING   zcx_abapgit_exception
                zcx_abapgit_not_found.

    METHODS create
      IMPORTING iv_ddtext   TYPE ddtypet-ddtext
                it_source   TYPE abaptxt255_tab
                iv_devclass TYPE devclass
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_ucsa DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES:
      ty_id TYPE c LENGTH 30.

    METHODS:
      get_persistence
        IMPORTING
          iv_id                 TYPE ty_id
        RETURNING
          VALUE(ro_persistence) TYPE REF TO object,

      clear_dynamic_fields
        CHANGING
          cg_complete_comm_assembly TYPE any,

      clear_field
        IMPORTING
          iv_fieldname TYPE csequence
        CHANGING
          cg_header    TYPE any.

ENDCLASS.
CLASS zcl_abapgit_object_udmo DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    METHODS constructor
      IMPORTING
        !is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        !iv_language TYPE spras .
  PROTECTED SECTION.

    METHODS corr_insert
         REDEFINITION .
  PRIVATE SECTION.

    TYPES:
      &quot; You are reminded that the text serialisation / de-serialisation methods depend upon a common type.
      &quot; To make the dependency explicit, there is one common definition.
      BEGIN OF ty_udmo_text_type.
    TYPES sprache TYPE dm40t-sprache.
    TYPES dmoid TYPE dm40t-dmoid.
    TYPES langbez TYPE dm40t-langbez.
    TYPES as4local TYPE dm40t-as4local.
    TYPES END OF ty_udmo_text_type .
    DATA mv_data_model TYPE uddmodl .
    DATA mv_text_object TYPE doku_obj .
    DATA mv_lxe_text_name TYPE lxeobjname .
    DATA mv_activation_state TYPE as4local .
    DATA ms_object_type TYPE rsdeo .
    CONSTANTS c_transport_object_class TYPE trobjtype VALUE &apos;SUDM&apos; ##NO_TEXT.
    CONSTANTS c_lxe_text_type TYPE lxeobjtype VALUE &apos;IM&apos; ##NO_TEXT.
    CONSTANTS c_correction_object_type TYPE rsdeo-objtype VALUE &apos;UDMO&apos; ##NO_TEXT.
    CONSTANTS c_active_state TYPE as4local VALUE &apos;A&apos; ##NO_TEXT.

    METHODS is_name_permitted
      RAISING
        zcx_abapgit_exception .
    METHODS update_tree .
    METHODS serialize_short_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_short_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_long_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_long_texts
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_entities
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_entities
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS access_modify
      RETURNING
        VALUE(rv_result) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS access_free
      RETURNING
        VALUE(rv_result) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_model
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_model
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_object_vcls DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
* See include MTOBJCON:
    CONSTANTS: c_cluster_type TYPE c VALUE &apos;C&apos;.
    CONSTANTS: c_mode_insert  TYPE obj_para-maint_mode VALUE &apos;I&apos;.

ENDCLASS.
CLASS zcl_abapgit_object_view DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

ENDCLASS.
CLASS zcl_abapgit_object_w3super DEFINITION INHERITING FROM zcl_abapgit_objects_super ABSTRACT.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

    TYPES ty_wwwparams_tt TYPE STANDARD TABLE OF wwwparams WITH DEFAULT KEY.

    CONSTANTS: BEGIN OF c_param_names,
                 version  TYPE w3_name VALUE &apos;version&apos;,
                 fileext  TYPE w3_name VALUE &apos;fileextension&apos;,
                 filesize TYPE w3_name VALUE &apos;filesize&apos;,
                 filename TYPE w3_name VALUE &apos;filename&apos;,
                 mimetype TYPE w3_name VALUE &apos;mimetype&apos;,
               END OF c_param_names.

    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PROTECTED SECTION.
    TYPES tty_bdcdata TYPE STANDARD TABLE OF bdcdata
                           WITH NON-UNIQUE DEFAULT KEY.

    METHODS get_metadata REDEFINITION.

    METHODS change_bdc_jump_data ABSTRACT
      CHANGING
        ct_bdcdata TYPE tty_bdcdata.

  PRIVATE SECTION.

    DATA ms_key TYPE wwwdatatab.

    METHODS get_ext
      IMPORTING it_params     TYPE ty_wwwparams_tt
      RETURNING VALUE(rv_ext) TYPE string
      RAISING   zcx_abapgit_exception.

    METHODS normalize_params
      IMPORTING iv_size   TYPE i
      CHANGING  ct_params TYPE ty_wwwparams_tt  &quot; Param table to patch
      RAISING   zcx_abapgit_exception.

    METHODS strip_params
      CHANGING ct_params TYPE ty_wwwparams_tt
      RAISING  zcx_abapgit_exception.

    METHODS find_param
      IMPORTING it_params       TYPE ty_wwwparams_tt
                iv_name         TYPE w3_name
      RETURNING VALUE(rv_value) TYPE string
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_w3ht DEFINITION INHERITING FROM zcl_abapgit_object_w3super FINAL.

  PROTECTED SECTION.
    METHODS: change_bdc_jump_data REDEFINITION.
ENDCLASS.
CLASS zcl_abapgit_object_w3mi DEFINITION INHERITING FROM zcl_abapgit_object_w3super FINAL.

  PROTECTED SECTION.
    METHODS: change_bdc_jump_data REDEFINITION.
ENDCLASS.
CLASS zcl_abapgit_object_wapa DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_page,
             attributes     TYPE o2pagattr,
             event_handlers TYPE o2pagevh_tabletype,
             parameters     TYPE o2pagpar_tabletype,
             types          TYPE rswsourcet,
           END OF ty_page.

    TYPES: ty_pages_tt TYPE STANDARD TABLE OF ty_page WITH DEFAULT KEY.

    CONSTANTS: c_active TYPE so2_version VALUE &apos;A&apos;.

    METHODS:
      get_page_content
        IMPORTING io_page           TYPE REF TO cl_o2_api_pages
        RETURNING VALUE(rv_content) TYPE xstring
        RAISING   zcx_abapgit_exception,
      to_page_content
        IMPORTING iv_content        TYPE xstring
        RETURNING VALUE(rt_content) TYPE o2pageline_table,
      read_page
        IMPORTING is_page        TYPE o2pagattr
        RETURNING VALUE(rs_page) TYPE ty_page
        RAISING   zcx_abapgit_exception,
      create_new_application
        IMPORTING is_attributes TYPE o2applattr
                  it_nodes      TYPE o2applnode_table
                  it_navgraph   TYPE o2applgrap_table
        RETURNING VALUE(ro_bsp) TYPE REF TO cl_o2_api_application
        RAISING   zcx_abapgit_exception,
      create_new_page
        IMPORTING
          is_page_attributes TYPE o2pagattr
        RETURNING
          VALUE(ro_page)     TYPE REF TO cl_o2_api_pages
        RAISING
          zcx_abapgit_exception,
      delete_superfluous_pages
        IMPORTING
          it_local_pages  TYPE o2pagelist
          it_remote_pages TYPE zcl_abapgit_object_wapa=&gt;ty_pages_tt
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_wdya DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS read
      EXPORTING es_app        TYPE wdy_application
                et_properties TYPE wdy_app_property_table
      RAISING   zcx_abapgit_exception.

    METHODS save
      IMPORTING is_app        TYPE wdy_application
                it_properties TYPE wdy_app_property_table
                iv_package    TYPE devclass
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_wdyn DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.

    DATA:
      mt_components TYPE TABLE OF wdy_ctlr_compo_vrs,
      mt_sources    TYPE TABLE OF wdy_ctlr_compo_source_vrs.

    METHODS:
      get_limu_objects
        RETURNING VALUE(rt_objects) TYPE wdy_md_transport_keys,
      read
        RETURNING VALUE(rs_component) TYPE wdy_component_metadata
        RAISING   zcx_abapgit_exception,
      read_controller
        IMPORTING is_key               TYPE wdy_md_controller_key
        RETURNING VALUE(rs_controller) TYPE wdy_md_controller_meta_data
        RAISING   zcx_abapgit_exception,
      read_definition
        IMPORTING is_key               TYPE wdy_md_component_key
        RETURNING VALUE(rs_definition) TYPE wdy_md_component_meta_data
        RAISING   zcx_abapgit_exception,
      read_view
        IMPORTING is_key         TYPE wdy_md_view_key
        RETURNING VALUE(rs_view) TYPE wdy_md_view_meta_data
        RAISING   zcx_abapgit_exception,
      recover_controller
        IMPORTING is_controller TYPE wdy_md_controller_meta_data
        RAISING   zcx_abapgit_exception,
      recover_definition
        IMPORTING is_definition TYPE wdy_md_component_meta_data
                  iv_package    TYPE devclass
        RAISING   zcx_abapgit_exception,
      recover_view
        IMPORTING is_view TYPE wdy_md_view_meta_data
        RAISING   zcx_abapgit_exception,
      delta_controller
        IMPORTING is_controller   TYPE wdy_md_controller_meta_data
        RETURNING VALUE(rs_delta) TYPE svrs2_xversionable_object
        RAISING   zcx_abapgit_exception,
      delta_definition
        IMPORTING is_definition     TYPE wdy_md_component_meta_data
                  VALUE(iv_package) TYPE devclass
        RETURNING VALUE(rs_delta)   TYPE svrs2_xversionable_object
        RAISING   zcx_abapgit_exception,
      delta_view
        IMPORTING is_view         TYPE wdy_md_view_meta_data
        RETURNING VALUE(rs_delta) TYPE svrs2_xversionable_object
        RAISING   zcx_abapgit_exception,
      add_fm_param_exporting
        IMPORTING iv_name  TYPE string
                  ig_value TYPE any
        CHANGING  ct_param TYPE abap_func_parmbind_tab,
      add_fm_param_tables
        IMPORTING iv_name  TYPE string
        CHANGING  ct_value TYPE ANY TABLE
                  ct_param TYPE abap_func_parmbind_tab,
      add_fm_exception
        IMPORTING iv_name      TYPE string
                  iv_value     TYPE i
        CHANGING  ct_exception TYPE abap_func_excpbind_tab.

ENDCLASS.
CLASS zcl_abapgit_object_webi DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_webi,
             veptext         TYPE veptext,
             pvepheader      TYPE STANDARD TABLE OF vepheader WITH DEFAULT KEY,
             pvepfunction    TYPE STANDARD TABLE OF vepfunction WITH DEFAULT KEY,
             pvepfault       TYPE STANDARD TABLE OF vepfault WITH DEFAULT KEY,
             pvepparameter   TYPE STANDARD TABLE OF vepparameter WITH DEFAULT KEY,
             pveptype        TYPE STANDARD TABLE OF veptype WITH DEFAULT KEY,
             pvepelemtype    TYPE STANDARD TABLE OF vepelemtype WITH DEFAULT KEY,
             pveptabletype   TYPE STANDARD TABLE OF veptabletype WITH DEFAULT KEY,
             pvepstrutype    TYPE STANDARD TABLE OF vepstrutype WITH DEFAULT KEY,
             pveptypesoapext TYPE STANDARD TABLE OF veptypesoapext WITH DEFAULT KEY,
             pvepeletypsoap  TYPE STANDARD TABLE OF vepeletypsoap WITH DEFAULT KEY,
             pveptabtypsoap  TYPE STANDARD TABLE OF veptabtypsoap WITH DEFAULT KEY,
             pvepfuncsoapext TYPE STANDARD TABLE OF vepfuncsoapext WITH DEFAULT KEY,
             pvepfieldref    TYPE STANDARD TABLE OF vepfieldref WITH DEFAULT KEY,
             pvependpoint    TYPE STANDARD TABLE OF vependpoint WITH DEFAULT KEY,
             pvepvisoapext   TYPE STANDARD TABLE OF vepvisoapext WITH DEFAULT KEY,
             pvepparasoapext TYPE STANDARD TABLE OF vepparasoapext WITH DEFAULT KEY,
           END OF ty_webi.

    DATA: mi_vi TYPE REF TO if_ws_md_vif.

    METHODS:
      handle_endpoint
        IMPORTING is_webi TYPE ty_webi
        RAISING   zcx_abapgit_exception
                  cx_ws_md_exception,
      handle_types
        IMPORTING is_webi TYPE ty_webi
        RAISING   zcx_abapgit_exception
                  cx_ws_md_exception,
      handle_soap
        IMPORTING is_webi TYPE ty_webi
        RAISING   zcx_abapgit_exception
                  cx_ws_md_exception,
      handle_function
        IMPORTING is_webi TYPE ty_webi
        RAISING   zcx_abapgit_exception
                  cx_ws_md_exception.

ENDCLASS.
CLASS zcl_abapgit_object_xinx DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_extension_index,
             dd12v   TYPE dd12v,
             t_dd17v TYPE STANDARD TABLE OF dd17v
                          WITH NON-UNIQUE DEFAULT KEY,
           END OF ty_extension_index.
    DATA:
      mv_name TYPE ddobjname,
      mv_id   TYPE ddobjectid.

ENDCLASS.
CLASS zcl_abapgit_object_xslt DEFINITION INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    METHODS:
      get
        RETURNING VALUE(ro_xslt) TYPE REF TO cl_o2_api_xsltdesc
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_objects_program DEFINITION INHERITING FROM zcl_abapgit_objects_super.

  PUBLIC SECTION.
    TYPES: BEGIN OF ty_progdir,
             name    TYPE progdir-name,
             state   TYPE progdir-state,
             sqlx    TYPE progdir-sqlx,
             edtx    TYPE progdir-edtx,
             varcl   TYPE progdir-varcl,
             dbapl   TYPE progdir-dbapl,
             dbna    TYPE progdir-dbna,
             clas    TYPE progdir-clas,
             type    TYPE progdir-type,
             occurs  TYPE progdir-occurs,
             subc    TYPE progdir-subc,
             appl    TYPE progdir-appl,
             secu    TYPE progdir-secu,
             cnam    TYPE progdir-cnam,
             cdat    TYPE progdir-cdat,
             unam    TYPE progdir-unam,
             udat    TYPE progdir-udat,
             vern    TYPE progdir-vern,
             levl    TYPE progdir-levl,
             rstat   TYPE progdir-rstat,
             rmand   TYPE progdir-rmand,
             rload   TYPE progdir-rload,
             fixpt   TYPE progdir-fixpt,
             sset    TYPE progdir-sset,
             sdate   TYPE progdir-sdate,
             stime   TYPE progdir-stime,
             idate   TYPE progdir-idate,
             itime   TYPE progdir-itime,
             ldbname TYPE progdir-ldbname,
             uccheck TYPE progdir-uccheck,
           END OF ty_progdir.

    METHODS serialize_program
      IMPORTING io_xml     TYPE REF TO zcl_abapgit_xml_output OPTIONAL
                is_item    TYPE zif_abapgit_definitions=&gt;ty_item
                io_files   TYPE REF TO zcl_abapgit_objects_files
                iv_program TYPE programm OPTIONAL
                iv_extra   TYPE clike OPTIONAL
      RAISING   zcx_abapgit_exception.

    METHODS read_progdir
      IMPORTING iv_program        TYPE programm
      RETURNING VALUE(rs_progdir) TYPE ty_progdir.

    METHODS deserialize_program
      IMPORTING is_progdir TYPE ty_progdir
                it_source  TYPE abaptxt255_tab
                it_tpool   TYPE textpool_table
                iv_package TYPE devclass
      RAISING   zcx_abapgit_exception.

  PROTECTED SECTION.

    TYPES: ty_spaces_tt TYPE STANDARD TABLE OF i WITH DEFAULT KEY.

    TYPES: BEGIN OF ty_dynpro,
             header     TYPE rpy_dyhead,
             containers TYPE dycatt_tab,
             fields     TYPE dyfatc_tab,
             flow_logic TYPE swydyflow,
             spaces     TYPE ty_spaces_tt,
           END OF ty_dynpro.

    TYPES: ty_dynpro_tt TYPE STANDARD TABLE OF ty_dynpro WITH DEFAULT KEY.

    TYPES: BEGIN OF ty_cua,
             adm TYPE rsmpe_adm,
             sta TYPE STANDARD TABLE OF rsmpe_stat WITH DEFAULT KEY,
             fun TYPE STANDARD TABLE OF rsmpe_funt WITH DEFAULT KEY,
             men TYPE STANDARD TABLE OF rsmpe_men WITH DEFAULT KEY,
             mtx TYPE STANDARD TABLE OF rsmpe_mnlt WITH DEFAULT KEY,
             act TYPE STANDARD TABLE OF rsmpe_act WITH DEFAULT KEY,
             but TYPE STANDARD TABLE OF rsmpe_but WITH DEFAULT KEY,
             pfk TYPE STANDARD TABLE OF rsmpe_pfk WITH DEFAULT KEY,
             set TYPE STANDARD TABLE OF rsmpe_staf WITH DEFAULT KEY,
             doc TYPE STANDARD TABLE OF rsmpe_atrt WITH DEFAULT KEY,
             tit TYPE STANDARD TABLE OF rsmpe_titt WITH DEFAULT KEY,
             biv TYPE STANDARD TABLE OF rsmpe_buts WITH DEFAULT KEY,
           END OF ty_cua.

    METHODS serialize_dynpros
      IMPORTING iv_program_name  TYPE programm
      RETURNING VALUE(rt_dynpro) TYPE ty_dynpro_tt
      RAISING   zcx_abapgit_exception.

    METHODS serialize_cua
      IMPORTING iv_program_name TYPE programm
      RETURNING VALUE(rs_cua)   TYPE ty_cua
      RAISING   zcx_abapgit_exception.

    METHODS deserialize_dynpros
      IMPORTING it_dynpros TYPE ty_dynpro_tt
      RAISING   zcx_abapgit_exception.

    METHODS deserialize_textpool
      IMPORTING iv_program    TYPE programm
                it_tpool      TYPE textpool_table
                iv_language   TYPE langu OPTIONAL
                iv_is_include TYPE abap_bool DEFAULT abap_false
      RAISING   zcx_abapgit_exception.

    METHODS deserialize_cua
      IMPORTING iv_program_name TYPE programm
                is_cua          TYPE ty_cua
      RAISING   zcx_abapgit_exception.

    METHODS check_prog_changed_since
      IMPORTING iv_program        TYPE programm
                iv_timestamp      TYPE timestamp
                iv_skip_gui       TYPE abap_bool DEFAULT abap_false
      RETURNING VALUE(rv_changed) TYPE abap_bool.

    METHODS is_any_dynpro_locked
      IMPORTING iv_program                     TYPE programm
      RETURNING VALUE(rv_is_any_dynpro_locked) TYPE abap_bool
      RAISING   zcx_abapgit_exception.

    METHODS is_cua_locked
      IMPORTING iv_program              TYPE programm
      RETURNING VALUE(rv_is_cua_locked) TYPE abap_bool
      RAISING   zcx_abapgit_exception.

    METHODS is_text_locked
      IMPORTING iv_program               TYPE programm
      RETURNING VALUE(rv_is_text_locked) TYPE abap_bool
      RAISING   zcx_abapgit_exception.
    CLASS-METHODS:
      add_tpool
        IMPORTING it_tpool        TYPE textpool_table
        RETURNING VALUE(rt_tpool) TYPE zif_abapgit_definitions=&gt;ty_tpool_tt,
      read_tpool
        IMPORTING it_tpool        TYPE zif_abapgit_definitions=&gt;ty_tpool_tt
        RETURNING VALUE(rt_tpool) TYPE zif_abapgit_definitions=&gt;ty_tpool_tt.

  PRIVATE SECTION.
    METHODS:
      condense_flow
        EXPORTING et_spaces TYPE ty_spaces_tt
        CHANGING  ct_flow   TYPE swydyflow,
      uncondense_flow
        IMPORTING it_flow        TYPE swydyflow
                  it_spaces      TYPE ty_spaces_tt
        RETURNING VALUE(rt_flow) TYPE swydyflow.

    CLASS-METHODS auto_correct_cua_adm
      IMPORTING
        is_cua TYPE zcl_abapgit_objects_program=&gt;ty_cua
      CHANGING
        cs_adm TYPE rsmpe_adm.
ENDCLASS.
CLASS zcl_abapgit_object_clas DEFINITION INHERITING FROM zcl_abapgit_objects_program.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS: constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.

  PROTECTED SECTION.
    DATA: mi_object_oriented_object_fct TYPE REF TO zif_abapgit_oo_object_fnc,
          mv_skip_testclass             TYPE abap_bool.
    METHODS:
      deserialize_abap
        IMPORTING io_xml     TYPE REF TO zcl_abapgit_xml_input
                  iv_package TYPE devclass
        RAISING   zcx_abapgit_exception,
      deserialize_docu
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_tpool
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_sotr
        IMPORTING io_xml     TYPE REF TO zcl_abapgit_xml_input
                  iv_package TYPE devclass
        RAISING   zcx_abapgit_exception,
      serialize_xml
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    METHODS:
      is_class_locked
        RETURNING VALUE(rv_is_class_locked) TYPE abap_bool
        RAISING   zcx_abapgit_exception.
ENDCLASS.
&quot;! This class is just a different name for zcl_zabapgit_object_clas.
&quot;! It has been created to heal repositories of the brave ones who uses abapGit
&quot;! experimental features &quot;! and had the luck to serialize their CLAS objects with
&quot;! the serializer LCL_OBJECT_CLAS_NEW.
&quot;! It can be removed on 2019-04 where we expect all CLAS object being
&quot;! re-serialized with the serializer LCL_OBJECT_CLAS.
&quot;! References: https://github.com/larshp/abapGit/pull/1311
CLASS zcl_abapgit_object_clas_new DEFINITION INHERITING FROM zcl_abapgit_object_clas.

  PROTECTED SECTION.
    METHODS:
      get_metadata REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_fugr DEFINITION INHERITING FROM zcl_abapgit_objects_program FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.

    TYPES:
      ty_rs38l_incl_tt TYPE STANDARD TABLE OF rs38l_incl WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_function,
        funcname          TYPE rs38l_fnam,
        global_flag       TYPE rs38l-global,
        remote_call       TYPE rs38l-remote,
        update_task       TYPE rs38l-utask,
        short_text        TYPE tftit-stext,
        remote_basxml     TYPE rs38l-basxml_enabled,
        import            TYPE STANDARD TABLE OF rsimp WITH DEFAULT KEY,
        changing          TYPE STANDARD TABLE OF rscha WITH DEFAULT KEY,
        export            TYPE STANDARD TABLE OF rsexp WITH DEFAULT KEY,
        tables            TYPE STANDARD TABLE OF rstbl WITH DEFAULT KEY,
        exception         TYPE STANDARD TABLE OF rsexc WITH DEFAULT KEY,
        documentation     TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY,
        exception_classes TYPE abap_bool,
      END OF ty_function .
    TYPES:
      ty_function_tt TYPE STANDARD TABLE OF ty_function WITH DEFAULT KEY .

    TYPES: ty_sobj_name_tt TYPE STANDARD TABLE OF sobj_name  WITH DEFAULT KEY .

    METHODS update_where_used
      IMPORTING
        !it_includes TYPE ty_sobj_name_tt .
    METHODS main_name
      RETURNING
        VALUE(rv_program) TYPE program
      RAISING
        zcx_abapgit_exception .
    METHODS functions
      RETURNING
        VALUE(rt_functab) TYPE ty_rs38l_incl_tt
      RAISING
        zcx_abapgit_exception .
    METHODS includes
      RETURNING
        VALUE(rt_includes) TYPE ty_sobj_name_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_functions
      RETURNING
        VALUE(rt_functions) TYPE ty_function_tt
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_functions
      IMPORTING
        !it_functions TYPE ty_function_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_xml
      IMPORTING
        !io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_xml
      IMPORTING
        !io_xml     TYPE REF TO zcl_abapgit_xml_input
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_includes
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_includes
      IMPORTING
        !io_xml     TYPE REF TO zcl_abapgit_xml_input
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS are_exceptions_class_based
      IMPORTING
        !iv_function_name TYPE rs38l_fnam
      RETURNING
        VALUE(rv_return)  TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_function_group_locked
      RETURNING
        VALUE(rv_is_functions_group_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_any_include_locked
      RETURNING
        VALUE(rv_is_any_include_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_any_function_module_locked
      RETURNING
        VALUE(rv_any_function_module_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS get_abap_version
      IMPORTING
        io_xml                 TYPE REF TO zcl_abapgit_xml_input
      RETURNING
        VALUE(rv_abap_version) TYPE progdir-uccheck
      RAISING
        zcx_abapgit_exception .
    METHODS update_func_group_short_text
      IMPORTING
        iv_group      TYPE rs38l-area
        iv_short_text TYPE tftit-stext.
ENDCLASS.
CLASS zcl_abapgit_object_intf DEFINITION FINAL INHERITING FROM zcl_abapgit_objects_program.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.
    METHODS constructor
      IMPORTING
        is_item     TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language TYPE spras.
  PROTECTED SECTION.
    METHODS deserialize_abap
      IMPORTING io_xml     TYPE REF TO zcl_abapgit_xml_input
                iv_package TYPE devclass
      RAISING   zcx_abapgit_exception.

    METHODS deserialize_docu
      IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_input
      RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA mi_object_oriented_object_fct TYPE REF TO zif_abapgit_oo_object_fnc.

    METHODS serialize_xml
      IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_object_prog DEFINITION INHERITING FROM zcl_abapgit_objects_program FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_tpool_i18n,
             language TYPE langu,
             textpool TYPE zif_abapgit_definitions=&gt;ty_tpool_tt,
           END OF ty_tpool_i18n,
           tt_tpool_i18n TYPE STANDARD TABLE OF ty_tpool_i18n.
    CONSTANTS: c_longtext_id_prog TYPE dokil-id VALUE &apos;RE&apos;.

    METHODS:
      serialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      deserialize_texts
        IMPORTING io_xml TYPE REF TO zcl_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      is_program_locked
        RETURNING
          VALUE(rv_is_program_locked) TYPE abap_bool
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_objects_saxx_super DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  ABSTRACT
  CREATE PUBLIC .

* common class for SAPC and SAMC objects
  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.

    METHODS get_persistence_class_name
          ABSTRACT
      RETURNING
        VALUE(rv_persistence_class_name) TYPE seoclsname .
    METHODS get_data_class_name
          ABSTRACT
      RETURNING
        VALUE(rv_data_class_name) TYPE seoclsname .
    METHODS get_data_structure_name
          ABSTRACT
      RETURNING
        VALUE(rv_data_structure_name) TYPE string .
  PRIVATE SECTION.

    DATA mo_persistence TYPE REF TO if_wb_object_persist .
    DATA mo_appl_obj_data TYPE REF TO if_wb_object_data_model .
    DATA mv_data_structure_name TYPE string .
    DATA mv_appl_obj_cls_name TYPE seoclsname .
    DATA mv_persistence_cls_name TYPE seoclsname .

    METHODS create_channel_objects
      RAISING
        zcx_abapgit_exception .
    METHODS get_data
      EXPORTING
        !eg_data TYPE any
      RAISING
        zcx_abapgit_exception .
    METHODS lock
      RAISING
        zcx_abapgit_exception .
    METHODS unlock
      RAISING
        zcx_abapgit_exception .
    METHODS get_names .
ENDCLASS.
CLASS zcl_abapgit_object_samc DEFINITION INHERITING FROM zcl_abapgit_objects_saxx_super FINAL.

  PROTECTED SECTION.
    METHODS:
      get_persistence_class_name REDEFINITION,
      get_data_class_name REDEFINITION,
      get_data_structure_name REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_object_sapc DEFINITION INHERITING FROM zcl_abapgit_objects_saxx_super FINAL.

  PROTECTED SECTION.
    METHODS:
      get_persistence_class_name REDEFINITION,
      get_data_class_name REDEFINITION,
      get_data_structure_name REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_oo_base DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES: zif_abapgit_oo_object_fnc.

  PROTECTED SECTION.
    CLASS-METHODS:
      convert_attrib_to_vseoattrib
        IMPORTING iv_clsname           TYPE seoclsname
                  it_attributes        TYPE zif_abapgit_definitions=&gt;ty_obj_attribute_tt
        RETURNING VALUE(rt_vseoattrib) TYPE seoo_attributes_r.

  PRIVATE SECTION.
    DATA mv_skip_test_classes TYPE abap_bool.

    METHODS deserialize_abap_source_old
      IMPORTING is_clskey TYPE seoclskey
                it_source TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING   zcx_abapgit_exception.

    METHODS deserialize_abap_source_new
      IMPORTING is_clskey TYPE seoclskey
                it_source TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING   zcx_abapgit_exception
                cx_sy_dyn_call_error.
ENDCLASS.
CLASS zcl_abapgit_oo_class DEFINITION INHERITING FROM zcl_abapgit_oo_base.

  PUBLIC SECTION.
    METHODS:
      zif_abapgit_oo_object_fnc~create REDEFINITION,
      zif_abapgit_oo_object_fnc~generate_locals REDEFINITION,
      zif_abapgit_oo_object_fnc~insert_text_pool REDEFINITION,
      zif_abapgit_oo_object_fnc~create_sotr REDEFINITION,
      zif_abapgit_oo_object_fnc~get_includes REDEFINITION,
      zif_abapgit_oo_object_fnc~get_class_properties REDEFINITION,
      zif_abapgit_oo_object_fnc~read_text_pool REDEFINITION,
      zif_abapgit_oo_object_fnc~read_sotr REDEFINITION,
      zif_abapgit_oo_object_fnc~delete REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_oo_class_new DEFINITION INHERITING FROM zcl_abapgit_oo_class.

  PUBLIC SECTION.
    METHODS:
      zif_abapgit_oo_object_fnc~create REDEFINITION,
      zif_abapgit_oo_object_fnc~generate_locals REDEFINITION,
      zif_abapgit_oo_object_fnc~deserialize_source REDEFINITION.

  PRIVATE SECTION.

    CLASS-METHODS update_source_index
      IMPORTING
        !iv_clsname TYPE csequence
        !io_scanner TYPE REF TO cl_oo_source_scanner_class .
    CLASS-METHODS update_report
      IMPORTING
        !iv_program       TYPE programm
        !it_source        TYPE string_table
      RETURNING
        VALUE(rv_updated) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS generate_classpool
      IMPORTING
        !iv_name TYPE seoclsname
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_meta
      IMPORTING
        !iv_name     TYPE seoclsname
        !iv_exposure TYPE seoexpose
        !it_source   TYPE rswsourcet
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS determine_method_include
      IMPORTING
        !iv_name          TYPE seoclsname
        !iv_method        TYPE seocpdname
      RETURNING
        VALUE(rv_program) TYPE programm
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS init_scanner
      IMPORTING
        !it_source        TYPE zif_abapgit_definitions=&gt;ty_string_tt
        !iv_name          TYPE seoclsname
      RETURNING
        VALUE(ro_scanner) TYPE REF TO cl_oo_source_scanner_class
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_full_class_include
      IMPORTING
        !iv_classname TYPE seoclsname
        !it_source    TYPE string_table
        !it_methods   TYPE cl_oo_source_scanner_class=&gt;type_method_implementations .
    CLASS-METHODS create_report
      IMPORTING
        !iv_program      TYPE programm
        !it_source       TYPE string_table
        !iv_extension    TYPE sychar02
        !iv_program_type TYPE sychar01
        !iv_version      TYPE r3state .
    CLASS-METHODS update_cs_number_of_methods
      IMPORTING
        !iv_classname              TYPE seoclsname
        !iv_number_of_impl_methods TYPE i .
ENDCLASS.
CLASS zcl_abapgit_oo_factory DEFINITION.

  PUBLIC SECTION.
    CLASS-METHODS:
      make
        IMPORTING
          iv_object_type                   TYPE tadir-object
        RETURNING
          VALUE(ro_object_oriented_object) TYPE REF TO zif_abapgit_oo_object_fnc.
  PRIVATE SECTION.

    CLASS-DATA gi_object_oriented_object TYPE REF TO zif_abapgit_oo_object_fnc .
ENDCLASS.
CLASS zcl_abapgit_oo_interface DEFINITION
  INHERITING FROM zcl_abapgit_oo_base.
  PUBLIC SECTION.
    METHODS:
      zif_abapgit_oo_object_fnc~create REDEFINITION,
      zif_abapgit_oo_object_fnc~get_includes REDEFINITION,
      zif_abapgit_oo_object_fnc~get_interface_properties REDEFINITION,
      zif_abapgit_oo_object_fnc~delete REDEFINITION.
ENDCLASS.
CLASS zcl_abapgit_oo_serializer DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS serialize_abap_clif_source
      IMPORTING
        !is_class_key    TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error .
    METHODS are_test_classes_skipped
      RETURNING
        VALUE(rv_return) TYPE abap_bool .
    METHODS serialize_locals_imp
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_locals_def
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_testclasses
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_macros
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS calculate_skip_testclass
      IMPORTING
        !it_source               TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RETURNING
        VALUE(rv_skip_testclass) TYPE abap_bool .
  PRIVATE SECTION.
    DATA mv_skip_testclass TYPE abap_bool.
    METHODS serialize_abap_old
      IMPORTING is_clskey        TYPE seoclskey
      RETURNING VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING   zcx_abapgit_exception.

    METHODS serialize_abap_new
      IMPORTING is_clskey        TYPE seoclskey
      RETURNING VALUE(rt_source) TYPE zif_abapgit_definitions=&gt;ty_string_tt
      RAISING   zcx_abapgit_exception
                cx_sy_dyn_call_error.
    METHODS remove_signatures
      CHANGING ct_source TYPE zif_abapgit_definitions=&gt;ty_string_tt.

    METHODS read_include
      IMPORTING is_clskey        TYPE seoclskey
                iv_type          TYPE seop_include_ext_app
      RETURNING VALUE(rt_source) TYPE seop_source_string.
    METHODS reduce
      CHANGING ct_source TYPE zif_abapgit_definitions=&gt;ty_string_tt.
ENDCLASS.
CLASS zcl_abapgit_persist_background DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES: BEGIN OF ty_xml,
             method   TYPE string,
             username TYPE string,
             password TYPE string,
             settings TYPE zif_abapgit_background=&gt;ty_settings_tt,
           END OF ty_xml.

    TYPES: BEGIN OF ty_background,
             key TYPE zif_abapgit_persistence=&gt;ty_value.
        INCLUDE TYPE ty_xml.
    TYPES: END OF ty_background.
    TYPES: tt_background TYPE STANDARD TABLE OF ty_background WITH DEFAULT KEY.

    METHODS constructor.

    METHODS list
      RETURNING VALUE(rt_list) TYPE tt_background
      RAISING   zcx_abapgit_exception.

    METHODS modify
      IMPORTING is_data TYPE ty_background
      RAISING   zcx_abapgit_exception.

    METHODS delete
      IMPORTING iv_key TYPE ty_background-key
      RAISING   zcx_abapgit_exception.

    METHODS exists
      IMPORTING iv_key        TYPE ty_background-key
      RETURNING VALUE(rv_yes) TYPE abap_bool
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    DATA: mo_db   TYPE REF TO zcl_abapgit_persistence_db,
          mt_jobs TYPE tt_background.

    METHODS from_xml
      IMPORTING iv_string     TYPE string
      RETURNING VALUE(rs_xml) TYPE ty_xml
      RAISING   zcx_abapgit_exception.

    METHODS to_xml
      IMPORTING is_background    TYPE ty_background
      RETURNING VALUE(rv_string) TYPE string.

ENDCLASS.
CLASS zcl_abapgit_persist_factory DEFINITION
  CREATE PRIVATE

  FRIENDS ZCL_ABAPGIT_persist_injector .

  PUBLIC SECTION.

    CLASS-METHODS get_repo
      RETURNING
        VALUE(ri_repo) TYPE REF TO zif_abapgit_persist_repo .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gi_repo TYPE REF TO zif_abapgit_persist_repo .
ENDCLASS.
CLASS zcl_abapgit_persist_injector DEFINITION
  CREATE PRIVATE
  FOR TESTING .

  PUBLIC SECTION.

    CLASS-METHODS set_repo
      IMPORTING
        !ii_repo TYPE REF TO zif_abapgit_persist_repo .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_persist_migrate DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS: run RAISING zcx_abapgit_exception.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_settings_to_migrate,
             name  TYPE string,
             value TYPE string,
           END OF ty_settings_to_migrate,
           tty_settings_to_migrate TYPE STANDARD TABLE OF ty_settings_to_migrate
                                        WITH NON-UNIQUE DEFAULT KEY.

    CONSTANTS c_text TYPE string VALUE &apos;Generated by abapGit&apos; ##NO_TEXT.

    CLASS-METHODS table_create
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS table_exists
      RETURNING
        VALUE(rv_exists) TYPE abap_bool .
    CLASS-METHODS lock_create
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS lock_exists
      RETURNING
        VALUE(rv_exists) TYPE abap_bool .
    CLASS-METHODS migrate_settings
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS migrate_setting
      IMPORTING
        iv_name                TYPE string
      CHANGING
        ct_settings_to_migrate TYPE tty_settings_to_migrate
        ci_document            TYPE REF TO if_ixml_document.
    CLASS-METHODS distribute_settings_to_users
      IMPORTING
        it_settings_to_migrate TYPE tty_settings_to_migrate
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS update_global_settings
      IMPORTING
        ii_document TYPE REF TO if_ixml_document
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS read_global_settings_xml
      RETURNING
        VALUE(rv_global_settings_xml) TYPE string
      RAISING
        zcx_abapgit_not_found.
    CLASS-METHODS get_global_settings_document
      RETURNING
        VALUE(ri_global_settings_dom) TYPE REF TO if_ixml_document
      RAISING
        zcx_abapgit_not_found.

ENDCLASS.
CLASS zcl_abapgit_persist_settings DEFINITION
  CREATE PRIVATE .

  PUBLIC SECTION.

    METHODS modify
      IMPORTING
        !io_settings TYPE REF TO zcl_abapgit_settings
      RAISING
        zcx_abapgit_exception .
    METHODS read
      RETURNING
        VALUE(ro_settings) TYPE REF TO zcl_abapgit_settings .
    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_settings) TYPE REF TO zcl_abapgit_persist_settings .
  PRIVATE SECTION.

    DATA mo_settings TYPE REF TO zcl_abapgit_settings .
    CLASS-DATA go_persist TYPE REF TO zcl_abapgit_persist_settings .
ENDCLASS.
CLASS zcl_abapgit_persistence_db DEFINITION
  CREATE PRIVATE .

  PUBLIC SECTION.
    CONSTANTS c_tabname TYPE tabname VALUE &apos;ZABAPGIT&apos; ##NO_TEXT.
    CONSTANTS c_lock TYPE viewname VALUE &apos;EZABAPGIT&apos; ##NO_TEXT.

    CONSTANTS:
      c_type_settings   TYPE zif_abapgit_persistence=&gt;ty_type VALUE &apos;SETTINGS&apos; ##NO_TEXT,
      c_type_repo       TYPE zif_abapgit_persistence=&gt;ty_type VALUE &apos;REPO&apos; ##NO_TEXT,
      c_type_background TYPE zif_abapgit_persistence=&gt;ty_type VALUE &apos;BACKGROUND&apos; ##NO_TEXT,
      c_type_user       TYPE zif_abapgit_persistence=&gt;ty_type VALUE &apos;USER&apos; ##NO_TEXT.

    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_db) TYPE REF TO zcl_abapgit_persistence_db .
    METHODS add
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value TYPE zif_abapgit_persistence=&gt;ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=&gt;ty_content-data_str
      RAISING
        zcx_abapgit_exception .
    METHODS delete
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value TYPE zif_abapgit_persistence=&gt;ty_content-value
      RAISING
        zcx_abapgit_exception .
    METHODS list
      RETURNING
        VALUE(rt_content) TYPE zif_abapgit_persistence=&gt;tt_content .
    METHODS list_by_type
      IMPORTING
        !iv_type          TYPE zif_abapgit_persistence=&gt;ty_type
      RETURNING
        VALUE(rt_content) TYPE zif_abapgit_persistence=&gt;tt_content .
    METHODS lock
      IMPORTING
        !iv_mode  TYPE enqmode DEFAULT &apos;E&apos;
        !iv_type  TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value TYPE zif_abapgit_persistence=&gt;ty_content-value
      RAISING
        zcx_abapgit_exception .
    METHODS modify
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value TYPE zif_abapgit_persistence=&gt;ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=&gt;ty_content-data_str
      RAISING
        zcx_abapgit_exception .
    METHODS read
      IMPORTING
        !iv_type       TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value      TYPE zif_abapgit_persistence=&gt;ty_content-value
      RETURNING
        VALUE(rv_data) TYPE zif_abapgit_persistence=&gt;ty_content-data_str
      RAISING
        zcx_abapgit_not_found .
    METHODS update
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=&gt;ty_type
        !iv_value TYPE zif_abapgit_persistence=&gt;ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=&gt;ty_content-data_str
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-DATA go_db TYPE REF TO zcl_abapgit_persistence_db .
    DATA: mv_update_function TYPE funcname.

    METHODS get_update_function RETURNING VALUE(rv_funcname) TYPE funcname.

    METHODS validate_and_unprettify_xml
      IMPORTING
        !iv_xml       TYPE string
      RETURNING
        VALUE(rv_xml) TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_persistence_repo DEFINITION
  CREATE PROTECTED

  FRIENDS ZCL_ABAPGIT_persist_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_persist_repo .

    METHODS constructor .
  PROTECTED SECTION.

    ALIASES list
      FOR zif_abapgit_persist_repo~list .
    ALIASES read
      FOR zif_abapgit_persist_repo~read .
  PRIVATE SECTION.

    DATA mt_meta_fields TYPE STANDARD TABLE OF abap_compname.
    DATA mo_db TYPE REF TO zcl_abapgit_persistence_db .

    METHODS from_xml
      IMPORTING
        !iv_repo_xml_string TYPE string
      RETURNING
        VALUE(rs_repo)      TYPE zif_abapgit_persistence=&gt;ty_repo_xml
      RAISING
        zcx_abapgit_exception .
    METHODS to_xml
      IMPORTING
        !is_repo                  TYPE zif_abapgit_persistence=&gt;ty_repo
      RETURNING
        VALUE(rv_repo_xml_string) TYPE string .
    METHODS get_next_id
      RETURNING
        VALUE(rv_next_repo_id) TYPE zif_abapgit_persistence=&gt;ty_content-value
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_persistence_user DEFINITION
  CREATE PRIVATE .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_persist_user .

    TYPES tt_favorites TYPE zif_abapgit_persistence=&gt;tt_repo_keys .

    CLASS-METHODS get_instance
      IMPORTING
        !iv_user       TYPE xubname DEFAULT sy-uname
      RETURNING
        VALUE(ri_user) TYPE REF TO zif_abapgit_persist_user .
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_repo_config,
        url              TYPE zif_abapgit_persistence=&gt;ty_repo-url,
        login            TYPE string,
        git_user         TYPE zif_abapgit_definitions=&gt;ty_git_user,
        last_change_seen TYPE string,
      END OF ty_repo_config .
    TYPES:
      ty_repo_config_tt TYPE STANDARD TABLE OF ty_repo_config WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_user,
        default_git_user TYPE zif_abapgit_definitions=&gt;ty_git_user,
        repo_show        TYPE zif_abapgit_persistence=&gt;ty_repo-key,
        hide_files       TYPE abap_bool,
        changes_only     TYPE abap_bool,
        diff_unified     TYPE abap_bool,
        favorites        TYPE tt_favorites,
        repo_config      TYPE ty_repo_config_tt,
        settings         TYPE zif_abapgit_definitions=&gt;ty_s_user_settings,
      END OF ty_user .

    DATA mv_user TYPE xubname .
    CLASS-DATA gi_current_user TYPE REF TO zif_abapgit_persist_user .

    METHODS constructor
      IMPORTING
        !iv_user TYPE xubname DEFAULT sy-uname .
    METHODS from_xml
      IMPORTING
        !iv_xml        TYPE string
      RETURNING
        VALUE(rs_user) TYPE ty_user
      RAISING
        zcx_abapgit_exception .
    METHODS read
      RETURNING
        VALUE(rs_user) TYPE ty_user
      RAISING
        zcx_abapgit_exception .
    METHODS read_repo_config
      IMPORTING
        !iv_url               TYPE zif_abapgit_persistence=&gt;ty_repo-url
      RETURNING
        VALUE(rs_repo_config) TYPE ty_repo_config
      RAISING
        zcx_abapgit_exception .
    METHODS to_xml
      IMPORTING
        !is_user      TYPE ty_user
      RETURNING
        VALUE(rv_xml) TYPE string .
    METHODS update
      IMPORTING
        !is_user TYPE ty_user
      RAISING
        zcx_abapgit_exception .
    METHODS update_repo_config
      IMPORTING
        !iv_url         TYPE zif_abapgit_persistence=&gt;ty_repo-url
        !is_repo_config TYPE ty_repo_config
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_syntax_highlighter DEFINITION
  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS create
      IMPORTING
        !iv_filename       TYPE string
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_syntax_highlighter .
    METHODS process_line
      IMPORTING
        !iv_line       TYPE string
      RETURNING
        VALUE(rv_line) TYPE string .
  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_match,
        token    TYPE char1,  &quot; Type of matches
        offset   TYPE i,      &quot; Beginning position of the string that should be formatted
        length   TYPE i,      &quot; Length of the string that should be formatted
        text_tag TYPE string, &quot; Type of text tag
      END OF ty_match.

    TYPES:
      ty_match_tt  TYPE STANDARD TABLE OF ty_match WITH DEFAULT KEY.

    TYPES:
      BEGIN OF ty_rule,
        regex             TYPE REF TO cl_abap_regex,
        token             TYPE char1,
        style             TYPE string,
        relevant_submatch TYPE i,
      END OF ty_rule.

    CONSTANTS c_token_none TYPE c VALUE &apos;.&apos;.

    DATA mt_rules TYPE STANDARD TABLE OF ty_rule.

    METHODS add_rule
      IMPORTING
        iv_regex    TYPE string
        iv_token    TYPE c
        iv_style    TYPE string
        iv_submatch TYPE i OPTIONAL.

    METHODS parse_line
      IMPORTING iv_line    TYPE string
      EXPORTING et_matches TYPE ty_match_tt.

    METHODS order_matches ABSTRACT
      IMPORTING iv_line    TYPE string
      CHANGING  ct_matches TYPE ty_match_tt.

    METHODS extend_matches
      IMPORTING iv_line    TYPE string
      CHANGING  ct_matches TYPE ty_match_tt.

    METHODS format_line
      IMPORTING iv_line        TYPE string
                it_matches     TYPE ty_match_tt
      RETURNING VALUE(rv_line) TYPE string.

    METHODS apply_style
      IMPORTING iv_line        TYPE string
                iv_class       TYPE string
      RETURNING VALUE(rv_line) TYPE string.
ENDCLASS.
CLASS zcl_abapgit_syntax_abap DEFINITION
  INHERITING FROM zcl_abapgit_syntax_highlighter
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS class_constructor.
    METHODS constructor.

    CONSTANTS:
      BEGIN OF c_css,
        keyword TYPE string VALUE &apos;keyword&apos;,                &quot;#EC NOTEXT
        text    TYPE string VALUE &apos;text&apos;,                   &quot;#EC NOTEXT
        comment TYPE string VALUE &apos;comment&apos;,                &quot;#EC NOTEXT
      END OF c_css,

      BEGIN OF c_token,
        keyword TYPE c VALUE &apos;K&apos;,                           &quot;#EC NOTEXT
        text    TYPE c VALUE &apos;T&apos;,                           &quot;#EC NOTEXT
        comment TYPE c VALUE &apos;C&apos;,                           &quot;#EC NOTEXT
      END OF c_token,

      BEGIN OF c_regex,
        comment TYPE string VALUE &apos;##|&quot;|^\*&apos;,
        text    TYPE string VALUE &apos;`|&apos;&apos;|\||\{|\}&apos;,
        keyword TYPE string VALUE &apos;&amp;&amp;|\b[-_a-z0-9]+\b&apos;,
      END OF c_regex.

  PROTECTED SECTION.

    CLASS-DATA gt_keywords TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line.

    CLASS-METHODS init_keywords.
    CLASS-METHODS is_keyword
      IMPORTING iv_chunk      TYPE string
      RETURNING VALUE(rv_yes) TYPE abap_bool.

    METHODS order_matches REDEFINITION.
    METHODS parse_line REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_syntax_xml DEFINITION
  INHERITING FROM zcl_abapgit_syntax_highlighter
  CREATE PUBLIC .

  PUBLIC SECTION.

    CONSTANTS:
      BEGIN OF c_css,
        xml_tag  TYPE string VALUE &apos;xml_tag&apos;,               &quot;#EC NOTEXT
        attr     TYPE string VALUE &apos;attr&apos;,                  &quot;#EC NOTEXT
        attr_val TYPE string VALUE &apos;attr_val&apos;,              &quot;#EC NOTEXT
      END OF c_css .
    CONSTANTS:
      BEGIN OF c_token,
        xml_tag  TYPE c VALUE &apos;X&apos;,                          &quot;#EC NOTEXT
        attr     TYPE c VALUE &apos;A&apos;,                          &quot;#EC NOTEXT
        attr_val TYPE c VALUE &apos;V&apos;,                          &quot;#EC NOTEXT
      END OF c_token .
    CONSTANTS:
      BEGIN OF c_regex,
        &quot;for XML tags, we will use a submatch
        &quot; main pattern includes quoted strings so we can ignore &lt; and &gt; in attr values
        xml_tag  TYPE string VALUE &apos;(?:&quot;[^&quot;]*&quot;)|(?:&apos;&apos;[^&apos;&apos;]*&apos;&apos;)|([&lt;&gt;])&apos;,    &quot;#EC NOTEXT
        attr     TYPE string VALUE &apos;(?:^|\s)[-a-z:_0-9]+\s*(?==)&apos;, &quot;#EC NOTEXT
        attr_val TYPE string VALUE &apos;(&quot;[^&quot;]*&quot;)|(&apos;&apos;[^&apos;&apos;]*&apos;&apos;)&apos;,     &quot;#EC NOTEXT
      END OF c_regex .

    METHODS constructor .
  PROTECTED SECTION.

    METHODS order_matches REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_test_serialize DEFINITION
  CREATE PUBLIC
  FOR TESTING .

  PUBLIC SECTION.

    CLASS-METHODS check
      IMPORTING VALUE(is_item) TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING
                zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_gui DEFINITION
  FINAL .

  PUBLIC SECTION.

    METHODS go_home
      RAISING zcx_abapgit_exception.

    METHODS back
      IMPORTING iv_to_bookmark TYPE abap_bool DEFAULT abap_false
      RETURNING VALUE(rv_exit) TYPE xfeld
      RAISING   zcx_abapgit_exception.

    METHODS on_event FOR EVENT sapevent OF cl_gui_html_viewer
      IMPORTING action frame getdata postdata query_table.

    METHODS constructor
      IMPORTING
        ii_router    TYPE REF TO zif_abapgit_gui_router
        ii_asset_man TYPE REF TO zif_abapgit_gui_asset_manager
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.

    TYPES: BEGIN OF ty_page_stack,
             page     TYPE REF TO zif_abapgit_gui_page,
             bookmark TYPE abap_bool,
           END OF ty_page_stack.

    DATA: mi_cur_page    TYPE REF TO zif_abapgit_gui_page,
          mt_stack       TYPE STANDARD TABLE OF ty_page_stack,
          mi_router      TYPE REF TO zif_abapgit_gui_router,
          mi_asset_man   TYPE REF TO zif_abapgit_gui_asset_manager,
          mo_html_viewer TYPE REF TO cl_gui_html_viewer.

    METHODS startup
      RAISING zcx_abapgit_exception.

    METHODS cache_html
      IMPORTING iv_text       TYPE string
      RETURNING VALUE(rv_url) TYPE w3url.

    METHODS cache_asset
      IMPORTING iv_text       TYPE string OPTIONAL
                iv_xdata      TYPE xstring OPTIONAL
                iv_url        TYPE w3url OPTIONAL
                iv_type       TYPE c
                iv_subtype    TYPE c
      RETURNING VALUE(rv_url) TYPE w3url.

    METHODS render
      RAISING zcx_abapgit_exception.

    METHODS get_current_page_name
      RETURNING VALUE(rv_page_name) TYPE string.

    METHODS call_page
      IMPORTING ii_page          TYPE REF TO zif_abapgit_gui_page
                iv_with_bookmark TYPE abap_bool DEFAULT abap_false
                iv_replacing     TYPE abap_bool DEFAULT abap_false
      RAISING   zcx_abapgit_exception.

    METHODS handle_action
      IMPORTING iv_action      TYPE c
                iv_frame       TYPE c OPTIONAL
                iv_getdata     TYPE c OPTIONAL
                it_postdata    TYPE cnht_post_data_tab OPTIONAL
                it_query_table TYPE cnht_query_table OPTIONAL.

ENDCLASS.
CLASS zcl_abapgit_gui_asset_manager DEFINITION FINAL CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_gui_asset_manager.

    CLASS-METHODS string_to_xstring
      IMPORTING
        iv_str         TYPE string
      RETURNING
        VALUE(rv_xstr) TYPE xstring.

    CLASS-METHODS base64_to_xstring
      IMPORTING
        iv_base64      TYPE string
      RETURNING
        VALUE(rv_xstr) TYPE xstring.

    CLASS-METHODS bintab_to_xstring
      IMPORTING
        it_bintab      TYPE lvc_t_mime
        iv_size        TYPE i
      RETURNING
        VALUE(rv_xstr) TYPE xstring.

    CLASS-METHODS xstring_to_bintab
      IMPORTING
        iv_xstr   TYPE xstring
      EXPORTING
        ev_size   TYPE i
        et_bintab TYPE lvc_t_mime.

  PRIVATE SECTION.

    METHODS get_textlike_asset
      IMPORTING
        iv_asset_url    TYPE string
      RETURNING
        VALUE(rs_asset) TYPE zif_abapgit_gui_asset_manager=&gt;ty_web_asset
      RAISING
        zcx_abapgit_exception.

    METHODS get_mime_asset
      IMPORTING
        iv_mime_name    TYPE c
      RETURNING
        VALUE(rv_xdata) TYPE xstring
      RAISING
        zcx_abapgit_exception.

    METHODS get_inline_images
      RETURNING VALUE(rt_images) TYPE zif_abapgit_gui_asset_manager=&gt;tt_web_assets.

ENDCLASS.
CLASS zcl_abapgit_gui_chunk_lib DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS render_error
      IMPORTING ix_error       TYPE REF TO zcx_abapgit_exception OPTIONAL
                iv_error       TYPE string OPTIONAL
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

    CLASS-METHODS render_repo_top
      IMPORTING io_repo               TYPE REF TO zcl_abapgit_repo
                iv_show_package       TYPE abap_bool DEFAULT abap_true
                iv_show_branch        TYPE abap_bool DEFAULT abap_true
                iv_interactive_branch TYPE abap_bool DEFAULT abap_false
                iv_branch             TYPE string OPTIONAL
                io_news               TYPE REF TO zcl_abapgit_news OPTIONAL
      RETURNING VALUE(ro_html)        TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS render_item_state
      IMPORTING iv_lstate      TYPE char1
                iv_rstate      TYPE char1
      RETURNING VALUE(rv_html) TYPE string.

    CLASS-METHODS render_branch_span
      IMPORTING iv_branch      TYPE string
                io_repo        TYPE REF TO zcl_abapgit_repo_online
                iv_interactive TYPE abap_bool
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS render_js_error_banner
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS render_news
      IMPORTING
                io_news        TYPE REF TO zcl_abapgit_news
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS render_hotkey_overview
      IMPORTING
        io_page        TYPE REF TO zcl_abapgit_gui_page
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS render_infopanel
      IMPORTING
        iv_div_id      TYPE string
        iv_title       TYPE string
        iv_hide        TYPE abap_bool DEFAULT abap_true
        iv_hint        TYPE string OPTIONAL
        iv_scrollable  TYPE abap_bool DEFAULT abap_true
        io_content     TYPE REF TO zcl_abapgit_html
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_gui_functions DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_gui_functions.

ENDCLASS.
CLASS zcl_abapgit_gui_page DEFINITION ABSTRACT CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_gui_page.

    CONSTANTS:
      BEGIN OF c_global_page_action,
        showhotkeys TYPE string VALUE `showHotkeys` ##NO_TEXT,
      END OF c_global_page_action.

    CLASS-METHODS:
      get_hotkey_actions
        RETURNING
          VALUE(rt_hotkey_actions) TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action.

  PROTECTED SECTION.

    TYPES: BEGIN OF ty_control,
             redirect_url TYPE string,
             page_title   TYPE string,
             page_menu    TYPE REF TO zcl_abapgit_html_toolbar,
           END OF  ty_control.

    DATA: ms_control TYPE ty_control.

    METHODS render_content ABSTRACT
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

    METHODS scripts
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    METHODS html_head
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

    METHODS title
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

    METHODS footer
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

    METHODS redirect
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

    METHODS link_hints
      IMPORTING
        io_html TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.

    METHODS add_hotkeys
      IMPORTING
        io_html TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.

    METHODS render_hotkey_overview
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.

    METHODS call_browser
      IMPORTING
        iv_url TYPE csequence
      RAISING
        zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_gui_page_db DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.

    METHODS render_content
        REDEFINITION .
  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_action,
        delete TYPE string VALUE &apos;delete&apos;,
      END OF c_action .

    CLASS-METHODS delete
      IMPORTING
        !is_key TYPE zif_abapgit_persistence=&gt;ty_content
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS explain_content
      IMPORTING
        !is_data       TYPE zif_abapgit_persistence=&gt;ty_content
      RETURNING
        VALUE(rv_text) TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_gui_page_db_dis DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS: constructor
      IMPORTING is_key TYPE zif_abapgit_persistence=&gt;ty_content.

    CLASS-METHODS: render_record_banner
      IMPORTING is_key         TYPE zif_abapgit_persistence=&gt;ty_content
      RETURNING VALUE(rv_html) TYPE string.

  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

  PRIVATE SECTION.
    DATA: ms_key TYPE zif_abapgit_persistence=&gt;ty_content.

ENDCLASS.
CLASS zcl_abapgit_gui_page_db_edit DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor
      IMPORTING
        is_key TYPE zif_abapgit_persistence=&gt;ty_content .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.

    CLASS-METHODS dbcontent_decode
      IMPORTING
        !it_postdata      TYPE cnht_post_data_tab
      RETURNING
        VALUE(rs_content) TYPE zif_abapgit_persistence=&gt;ty_content .

    METHODS render_content
        REDEFINITION .
  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_action,
        update TYPE string VALUE &apos;update&apos;,
      END OF c_action .
    DATA ms_key TYPE zif_abapgit_persistence=&gt;ty_content .

    CLASS-METHODS update
      IMPORTING
        !is_content TYPE zif_abapgit_persistence=&gt;ty_content
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_gui_page_bkg DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor
      IMPORTING
        iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.

    METHODS read_persist
      IMPORTING
        !io_repo          TYPE REF TO zcl_abapgit_repo_online
      RETURNING
        VALUE(rs_persist) TYPE zcl_abapgit_persist_background=&gt;ty_background
      RAISING
        zcx_abapgit_exception .
    METHODS render_methods
      IMPORTING
        !is_per        TYPE zcl_abapgit_persist_background=&gt;ty_background
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_settings
      IMPORTING
        !is_per        TYPE zcl_abapgit_persist_background=&gt;ty_background
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS build_menu
      RETURNING
        VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar .
    CLASS-METHODS update
      IMPORTING
        !is_bg_task TYPE zcl_abapgit_persist_background=&gt;ty_background
      RAISING
        zcx_abapgit_exception .
    METHODS render
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception .
    METHODS decode
      IMPORTING
        !iv_getdata      TYPE clike
      RETURNING
        VALUE(rs_fields) TYPE zcl_abapgit_persist_background=&gt;ty_background .

    METHODS render_content
        REDEFINITION .
  PRIVATE SECTION.

    DATA mv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key .
ENDCLASS.
CLASS zcl_abapgit_gui_page_bkg_run DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.
    METHODS render_content        REDEFINITION.

  PRIVATE SECTION.
    DATA: mt_text TYPE TABLE OF string.

    METHODS: run.

ENDCLASS.
CLASS zcl_abapgit_gui_page_boverview DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS:
      constructor
        IMPORTING io_repo TYPE REF TO zcl_abapgit_repo_online
        RAISING   zcx_abapgit_exception,
      zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

  PRIVATE SECTION.
    DATA: mo_repo            TYPE REF TO zcl_abapgit_repo_online,
          mv_compress        TYPE abap_bool VALUE abap_false,
          mt_commits         TYPE zif_abapgit_definitions=&gt;ty_commit_tt,
          mi_branch_overview TYPE REF TO zif_abapgit_branch_overview.

    CONSTANTS: BEGIN OF c_actions,
                 uncompress TYPE string VALUE &apos;uncompress&apos; ##NO_TEXT,
                 compress   TYPE string VALUE &apos;compress&apos; ##NO_TEXT,
                 refresh    TYPE string VALUE &apos;refresh&apos; ##NO_TEXT,
                 merge      TYPE string VALUE &apos;merge&apos; ##NO_TEXT,
               END OF c_actions.

    TYPES: BEGIN OF ty_merge,
             source TYPE string,
             target TYPE string,
           END OF ty_merge.

    METHODS:
      refresh
        RAISING zcx_abapgit_exception,
      body
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      form_select
        IMPORTING iv_name        TYPE string
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,
      render_merge
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      decode_merge
        IMPORTING it_postdata     TYPE cnht_post_data_tab
        RETURNING VALUE(rs_merge) TYPE ty_merge
        RAISING   zcx_abapgit_exception,
      build_menu
        RETURNING VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar,
      escape_branch
        IMPORTING iv_string        TYPE string
        RETURNING VALUE(rv_string) TYPE string,
      escape_message
        IMPORTING iv_string        TYPE string
        RETURNING VALUE(rv_string) TYPE string.
ENDCLASS.
CLASS zcl_abapgit_gui_page_codi_base DEFINITION ABSTRACT INHERITING FROM zcl_abapgit_gui_page.
  PUBLIC SECTION.
    METHODS:
      zif_abapgit_gui_page~on_event
        REDEFINITION.

  PROTECTED SECTION.
    DATA: mo_repo TYPE REF TO zcl_abapgit_repo.
    DATA:
      mt_result TYPE scit_alvlist.

    METHODS:
      render_result IMPORTING io_html   TYPE REF TO zcl_abapgit_html
                              iv_result TYPE scir_alvlist,
      jump
        IMPORTING
          is_item        TYPE zif_abapgit_definitions=&gt;ty_item
          is_sub_item    TYPE zif_abapgit_definitions=&gt;ty_item
          iv_line_number TYPE i
        RAISING
          zcx_abapgit_exception.
  PRIVATE SECTION.
    CONSTANTS: c_object_separator TYPE char1 VALUE &apos;|&apos;.

ENDCLASS.
CLASS zcl_abapgit_gui_page_code_insp DEFINITION FINAL CREATE PUBLIC
    INHERITING FROM zcl_abapgit_gui_page_codi_base.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS:
      constructor
        IMPORTING
          io_repo  TYPE REF TO zcl_abapgit_repo
          io_stage TYPE REF TO zcl_abapgit_stage OPTIONAL
        RAISING
          zcx_abapgit_exception,

      zif_abapgit_gui_page~on_event
        REDEFINITION,

      zif_abapgit_gui_page~render
        REDEFINITION.

  PROTECTED SECTION.

    METHODS:
      render_content   REDEFINITION.

  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF c_actions,
        stage  TYPE string VALUE &apos;stage&apos; ##NO_TEXT,
        commit TYPE string VALUE &apos;commit&apos; ##NO_TEXT,
        rerun  TYPE string VALUE &apos;rerun&apos; ##NO_TEXT,
      END OF c_actions.
    DATA:
      mo_stage  TYPE REF TO zcl_abapgit_stage.

    METHODS:
      build_menu
        RETURNING
          VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar
        RAISING
          zcx_abapgit_exception,

      run_code_inspector
        RAISING
          zcx_abapgit_exception,

      has_inspection_errors
        RETURNING
          VALUE(rv_has_inspection_errors) TYPE abap_bool,

      is_stage_allowed
        RETURNING
          VALUE(rv_is_stage_allowed) TYPE abap_bool.

ENDCLASS.
CLASS zcl_abapgit_gui_page_commit DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    CONSTANTS:
      BEGIN OF c_action,
        commit_post   TYPE string VALUE &apos;commit_post&apos;,
        commit_cancel TYPE string VALUE &apos;commit_cancel&apos;,
      END OF c_action .

    METHODS constructor
      IMPORTING
        io_repo  TYPE REF TO zcl_abapgit_repo_online
        io_stage TYPE REF TO zcl_abapgit_stage
      RAISING
        zcx_abapgit_exception.

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.

    CLASS-METHODS parse_commit_request
      IMPORTING
        !it_postdata TYPE cnht_post_data_tab
      EXPORTING
        !eg_fields   TYPE any .

    METHODS render_content
        REDEFINITION .
    METHODS scripts
        REDEFINITION .
  PRIVATE SECTION.
    DATA: mo_repo  TYPE REF TO zcl_abapgit_repo_online,
          mo_stage TYPE REF TO zcl_abapgit_stage.

    METHODS:
      render_menu
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,
      render_stage
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      render_form
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      render_text_input
        IMPORTING iv_name        TYPE string
                  iv_label       TYPE string
                  iv_value       TYPE string OPTIONAL
                  iv_max_length  TYPE string OPTIONAL
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

ENDCLASS.
CLASS zcl_abapgit_gui_page_debuginfo DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor .
  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION,
      scripts        REDEFINITION.

  PRIVATE SECTION.
    METHODS render_debug_info
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING   zcx_abapgit_exception.
    METHODS render_supported_object_types
      RETURNING VALUE(rv_html) TYPE string.

ENDCLASS.
CLASS zcl_abapgit_gui_page_diff DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_gui_page_hotkey .

    TYPES:
      BEGIN OF ty_file_diff,
        path       TYPE string,
        filename   TYPE string,
        lstate     TYPE char1,
        rstate     TYPE char1,
        fstate     TYPE char1, &quot; FILE state - Abstraction for shorter ifs
        o_diff     TYPE REF TO zcl_abapgit_diff,
        changed_by TYPE xubname,
        type       TYPE string,
      END OF ty_file_diff .
    TYPES:
      tt_file_diff TYPE STANDARD TABLE OF ty_file_diff .

    CONSTANTS:
      BEGIN OF c_fstate,
        local  TYPE char1 VALUE &apos;L&apos;,
        remote TYPE char1 VALUE &apos;R&apos;,
        both   TYPE char1 VALUE &apos;B&apos;,
      END OF c_fstate .

    METHODS constructor
      IMPORTING
        !iv_key        TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !is_file       TYPE zif_abapgit_definitions=&gt;ty_file OPTIONAL
        !is_object     TYPE zif_abapgit_definitions=&gt;ty_item OPTIONAL
        !io_stage      TYPE REF TO zcl_abapgit_stage OPTIONAL
        !iv_patch_mode TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION,
      scripts REDEFINITION.

  PRIVATE SECTION.
    TYPES: ty_patch_action TYPE string.

    CONSTANTS: BEGIN OF c_actions,
                 stage          TYPE string VALUE &apos;patch_stage&apos;,
                 toggle_unified TYPE string VALUE &apos;toggle_unified&apos;,
               END OF c_actions,
               BEGIN OF c_patch_action,
                 add    TYPE ty_patch_action VALUE &apos;add&apos;,
                 remove TYPE ty_patch_action VALUE &apos;remove&apos;,
               END OF c_patch_action.

    DATA: mt_diff_files    TYPE tt_file_diff,
          mt_delayed_lines TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
          mv_unified       TYPE abap_bool VALUE abap_true,
          mv_repo_key      TYPE zif_abapgit_persistence=&gt;ty_repo-key,
          mv_seed          TYPE string, &quot; Unique page id to bind JS sessionStorage
          mv_patch_mode    TYPE abap_bool,
          mo_stage         TYPE REF TO zcl_abapgit_stage.

    METHODS render_diff
      IMPORTING is_diff        TYPE ty_file_diff
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_diff_head
      IMPORTING is_diff        TYPE ty_file_diff
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_table_head
      IMPORTING is_diff        TYPE ty_file_diff
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_lines
      IMPORTING is_diff        TYPE ty_file_diff
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_beacon
      IMPORTING is_diff_line   TYPE zif_abapgit_definitions=&gt;ty_diff
                is_diff        TYPE ty_file_diff
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_line_split
      IMPORTING is_diff_line   TYPE zif_abapgit_definitions=&gt;ty_diff
                iv_filename    TYPE string
                iv_fstate      TYPE char1
                iv_index       TYPE sytabix
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_line_unified
      IMPORTING is_diff_line   TYPE zif_abapgit_definitions=&gt;ty_diff OPTIONAL
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS append_diff
      IMPORTING it_remote TYPE zif_abapgit_definitions=&gt;ty_files_tt
                it_local  TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
                is_status TYPE zif_abapgit_definitions=&gt;ty_result
      RAISING   zcx_abapgit_exception.
    METHODS build_menu
      RETURNING VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar.
    METHODS is_binary
      IMPORTING iv_d1         TYPE xstring
                iv_d2         TYPE xstring
      RETURNING VALUE(rv_yes) TYPE abap_bool.
    METHODS add_to_stage
      RAISING
        zcx_abapgit_exception.
    METHODS render_patch
      IMPORTING
        io_html                TYPE REF TO zcl_abapgit_html
        iv_patch_line_possible TYPE abap_bool
        iv_filename            TYPE string
        is_diff_line           TYPE zif_abapgit_definitions=&gt;ty_diff
        iv_index               TYPE sytabix.
    METHODS start_staging
      IMPORTING
        it_postdata TYPE cnht_post_data_tab
      RAISING
        zcx_abapgit_exception .
    METHODS apply_patch_all
      IMPORTING
        iv_action     TYPE ty_patch_action
        iv_patch      TYPE string
        iv_patch_flag TYPE abap_bool
      RAISING
        zcx_abapgit_exception.
    METHODS render_patch_head
      IMPORTING
        io_html TYPE REF TO zcl_abapgit_html
        is_diff TYPE zcl_abapgit_gui_page_diff=&gt;ty_file_diff.
    METHODS apply_patch_for
      IMPORTING
        iv_filename   TYPE string
        iv_line_index TYPE string
        iv_patch_flag TYPE abap_bool
      RAISING
        zcx_abapgit_exception.
    METHODS get_diff_object
      IMPORTING
        iv_filename    TYPE string
      RETURNING
        VALUE(ro_diff) TYPE REF TO zcl_abapgit_diff
      RAISING
        zcx_abapgit_exception.
    METHODS get_diff_line
      IMPORTING
        io_diff        TYPE REF TO zcl_abapgit_diff
        iv_line_index  TYPE string
      RETURNING
        VALUE(rs_diff) TYPE zif_abapgit_definitions=&gt;ty_diff
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS get_patch_data
      IMPORTING
        iv_patch      TYPE string
        iv_action     TYPE string
      EXPORTING
        ev_filename   TYPE string
        ev_line_index TYPE string
      RAISING
        zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_gui_page_explore DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    CONSTANTS c_explore_url TYPE string
      VALUE &apos;https://dotabap.github.io/explore.html&apos;.

    METHODS constructor.

  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_gui_page_main DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.
    METHODS:
      constructor
        RAISING zcx_abapgit_exception,
      zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION.

  PRIVATE SECTION.
    CONSTANTS: BEGIN OF c_actions,
                 show          TYPE string VALUE &apos;show&apos; ##NO_TEXT,
                 changed_by    TYPE string VALUE &apos;changed_by&apos;,
                 overview      TYPE string VALUE &apos;overview&apos;,
                 documentation TYPE string VALUE &apos;documentation&apos;,
               END OF c_actions.

    DATA: mv_show         TYPE zif_abapgit_persistence=&gt;ty_value,
          mo_repo_content TYPE REF TO zcl_abapgit_gui_view_repo.

    METHODS:
      test_changed_by
        RAISING zcx_abapgit_exception,
      retrieve_active_repo
        RAISING zcx_abapgit_exception,
      render_toc
        IMPORTING it_repo_list   TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      build_main_menu
        RETURNING VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar,
      render_repo
        IMPORTING io_repo        TYPE REF TO zcl_abapgit_repo
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_gui_page_merge DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor
      IMPORTING
        io_repo   TYPE REF TO zcl_abapgit_repo_online
        iv_source TYPE string
        iv_target TYPE string
      RAISING
        zcx_abapgit_exception .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION.
  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

  PRIVATE SECTION.

    DATA mo_repo TYPE REF TO zcl_abapgit_repo_online .
    DATA mo_merge TYPE REF TO zcl_abapgit_merge .
    CONSTANTS:
      BEGIN OF c_actions,
        merge         TYPE string VALUE &apos;merge&apos; ##NO_TEXT,
        res_conflicts TYPE string VALUE &apos;res_conflicts&apos; ##NO_TEXT,
      END OF c_actions .

    METHODS build_menu
      IMPORTING
        VALUE(iv_with_conflict) TYPE boolean OPTIONAL
      RETURNING
        VALUE(ro_menu)          TYPE REF TO zcl_abapgit_html_toolbar .
ENDCLASS.
CLASS zcl_abapgit_gui_page_merge_res DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor
      IMPORTING
        io_repo       TYPE REF TO zcl_abapgit_repo_online
        io_merge_page TYPE REF TO zcl_abapgit_gui_page_merge
        io_merge      TYPE REF TO zcl_abapgit_merge
      RAISING
        zcx_abapgit_exception.

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .
  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_file_diff,
        path       TYPE string,
        filename   TYPE string,
        lstate     TYPE char1,
        rstate     TYPE char1,
        fstate     TYPE char1, &quot; FILE state - Abstraction for shorter ifs
        o_diff     TYPE REF TO zcl_abapgit_diff,
        changed_by TYPE xubname,
        type       TYPE string,
      END OF ty_file_diff .

    CONSTANTS:
      BEGIN OF c_actions,
        toggle_mode  TYPE string VALUE &apos;toggle_mode&apos; ##NO_TEXT,
        apply_merge  TYPE string VALUE &apos;apply_merge&apos; ##NO_TEXT,
        apply_source TYPE string VALUE &apos;apply_source&apos; ##NO_TEXT,
        apply_target TYPE string VALUE &apos;apply_target&apos; ##NO_TEXT,
        cancel       TYPE string VALUE &apos;cancel&apos; ##NO_TEXT,
      END OF c_actions .
    CONSTANTS:
      BEGIN OF c_merge_mode,
        selection TYPE string VALUE &apos;selection&apos; ##NO_TEXT,
        merge     TYPE string VALUE &apos;merge&apos; ##NO_TEXT,
      END OF c_merge_mode .
    DATA mo_merge TYPE REF TO zcl_abapgit_merge .
    DATA mo_merge_page TYPE REF TO zcl_abapgit_gui_page_merge .
    DATA mo_repo TYPE REF TO zcl_abapgit_repo_online .
    DATA ms_diff_file TYPE ty_file_diff .
    DATA mv_current_conflict_index TYPE sytabix .
    DATA mv_merge_mode TYPE string .
    DATA mt_conflicts TYPE zif_abapgit_definitions=&gt;tt_merge_conflict .

    METHODS apply_merged_content
      IMPORTING
        !it_postdata TYPE cnht_post_data_tab
      RAISING
        zcx_abapgit_exception .
    METHODS build_menu
      IMPORTING
        VALUE(iv_with_conflict) TYPE boolean OPTIONAL
      RETURNING
        VALUE(ro_menu)          TYPE REF TO zcl_abapgit_html_toolbar .
    METHODS is_binary
      IMPORTING
        !iv_d1        TYPE xstring
        !iv_d2        TYPE xstring
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS render_beacon
      IMPORTING
        !is_diff_line  TYPE zif_abapgit_definitions=&gt;ty_diff
        !is_diff       TYPE ty_file_diff
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_diff
      IMPORTING
        !is_diff       TYPE ty_file_diff
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception .
    METHODS render_diff_head
      IMPORTING
        !is_diff       TYPE ty_file_diff
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_lines
      IMPORTING
        !is_diff       TYPE ty_file_diff
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_line_split
      IMPORTING
        !is_diff_line  TYPE zif_abapgit_definitions=&gt;ty_diff
        !iv_fstate     TYPE char1
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_table_head
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS resolve_diff
      RAISING
        zcx_abapgit_exception .
    METHODS toggle_merge_mode .
ENDCLASS.
CLASS zcl_abapgit_gui_page_repo_over DEFINITION
  INHERITING FROM zcl_abapgit_gui_page
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS constructor .

    METHODS zif_abapgit_gui_page~on_event
        REDEFINITION .

  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION,
      scripts REDEFINITION.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_overview,
        favorite        TYPE string,
        type            TYPE string,
        key             TYPE string,
        name            TYPE string,
        url             TYPE string,
        package         TYPE string,
        branch          TYPE string,
        created_by      TYPE string,
        created_at      TYPE string,
        deserialized_by TYPE string,
        deserialized_at TYPE string,
      END OF ty_overview,
      tty_overview TYPE STANDARD TABLE OF ty_overview
                   WITH NON-UNIQUE DEFAULT KEY.
    CONSTANTS:
      BEGIN OF c_action,
        delete          TYPE string VALUE &apos;delete&apos;,
        select          TYPE string VALUE &apos;select&apos;,
        change_order_by TYPE string VALUE &apos;change_order_by&apos;,
        direction       TYPE string VALUE &apos;direction&apos;,
        apply_filter    TYPE string VALUE &apos;apply_filter&apos;,
      END OF c_action .

    DATA:
      mv_order_by         TYPE string,
      mv_order_descending TYPE char01,
      mv_filter           TYPE string,
      mv_time_zone        TYPE timezone.

    METHODS:
      render_text_input
        IMPORTING iv_name        TYPE string
                  iv_label       TYPE string
                  iv_value       TYPE string OPTIONAL
                  iv_max_length  TYPE string OPTIONAL
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,

      parse_change_order_by
        IMPORTING
          it_postdata TYPE cnht_post_data_tab,

      parse_direction
        IMPORTING
          it_postdata TYPE cnht_post_data_tab,

      parse_filter
        IMPORTING
          it_postdata TYPE cnht_post_data_tab,

      add_order_by_option
        IMPORTING
          iv_option TYPE string
          io_html   TYPE REF TO zcl_abapgit_html,

      add_direction_option
        IMPORTING
          iv_option   TYPE string
          io_html     TYPE REF TO zcl_abapgit_html
          iv_selected TYPE abap_bool,

      apply_order_by
        CHANGING
          ct_overview TYPE zcl_abapgit_gui_page_repo_over=&gt;tty_overview,

      apply_filter
        CHANGING
          ct_overview TYPE zcl_abapgit_gui_page_repo_over=&gt;tty_overview,

      map_repo_list_to_overview
        IMPORTING
          it_repo_list       TYPE zif_abapgit_persistence=&gt;tt_repo
        RETURNING
          VALUE(rt_overview) TYPE zcl_abapgit_gui_page_repo_over=&gt;tty_overview
        RAISING
          zcx_abapgit_exception,

      render_table_header
        IMPORTING
          io_html TYPE REF TO zcl_abapgit_html,

      render_table
        IMPORTING
          io_html     TYPE REF TO zcl_abapgit_html
          it_overview TYPE zcl_abapgit_gui_page_repo_over=&gt;tty_overview,

      render_table_body
        IMPORTING
          io_html     TYPE REF TO zcl_abapgit_html
          it_overview TYPE zcl_abapgit_gui_page_repo_over=&gt;tty_overview,

      render_order_by
        IMPORTING
          io_html TYPE REF TO zcl_abapgit_html,

      render_order_by_direction
        IMPORTING
          io_html TYPE REF TO zcl_abapgit_html,

      render_header_bar
        IMPORTING
          io_html TYPE REF TO zcl_abapgit_html.

ENDCLASS.
CLASS zcl_abapgit_gui_page_repo_sett DEFINITION FINAL
    CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS:
      constructor
        IMPORTING io_repo TYPE REF TO zcl_abapgit_repo,
      zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.

    CONSTANTS:
      BEGIN OF c_action,
        save_settings TYPE string VALUE &apos;save_settings&apos;,
      END OF c_action .
    DATA mo_repo TYPE REF TO zcl_abapgit_repo.

    METHODS render_dot_abapgit
      IMPORTING
        !io_html TYPE REF TO zcl_abapgit_html .
    METHODS render_local_settings
      IMPORTING
        !io_html TYPE REF TO zcl_abapgit_html .
    METHODS save
      IMPORTING
        !it_postdata TYPE cnht_post_data_tab
      RAISING
        zcx_abapgit_exception .
    METHODS save_dot_abap
      IMPORTING
        !it_post_fields TYPE tihttpnvp
      RAISING
        zcx_abapgit_exception .
    METHODS save_local_settings
      IMPORTING
        !it_post_fields TYPE tihttpnvp
      RAISING
        zcx_abapgit_exception .
    METHODS parse_post
      IMPORTING
        !it_postdata          TYPE cnht_post_data_tab
      RETURNING
        VALUE(rt_post_fields) TYPE tihttpnvp .

    METHODS render_content
        REDEFINITION .

  PRIVATE SECTION.

ENDCLASS.
CLASS zcl_abapgit_gui_page_settings DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    CONSTANTS:
      BEGIN OF c_action,
        save_settings TYPE string VALUE &apos;save_settings&apos;,
      END OF c_action.

    METHODS constructor.
    METHODS zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.
    METHODS render_content REDEFINITION.

  PRIVATE SECTION.

    DATA:
      mo_settings    TYPE REF TO zcl_abapgit_settings,
      mv_error       TYPE abap_bool,
      mt_post_fields TYPE tihttpnvp.

    METHODS render_proxy
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_development_internals
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_form_begin
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_form_end
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_max_lines
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_adt_jump_enabled
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_commit_msg
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS build_settings
      IMPORTING
        it_post_fields TYPE tihttpnvp.
    METHODS validate_settings.
    METHODS parse_post
      IMPORTING
        it_postdata           TYPE cnht_post_data_tab
      RETURNING
        VALUE(rt_post_fields) TYPE tihttpnvp.
    METHODS persist_settings
      RAISING
        zcx_abapgit_exception.
    METHODS read_settings.
    METHODS render_section_begin
      IMPORTING
                iv_header      TYPE csequence
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_section_end
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_start_up
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html.
    METHODS render_link_hints
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.
    METHODS render_hotkeys
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html
      RAISING
        zcx_abapgit_exception.
    METHODS get_possible_hotkey_actions
      RETURNING
        VALUE(rt_hotkey_actions) TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action
      RAISING
        zcx_abapgit_exception.

    METHODS get_default_hotkeys
      RETURNING
        VALUE(rt_default_hotkeys) TYPE zif_abapgit_definitions=&gt;tty_hotkey
      RAISING
        zcx_abapgit_exception.
    METHODS is_post_field_checked
      IMPORTING
        iv_name          TYPE string
      RETURNING
        VALUE(rv_return) TYPE abap_bool.

ENDCLASS.
CLASS zcl_abapgit_gui_page_stage DEFINITION
  FINAL
  CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    CONSTANTS: BEGIN OF c_action,
                 stage_all    TYPE string VALUE &apos;stage_all&apos;,
                 stage_commit TYPE string VALUE &apos;stage_commit&apos;,
                 stage_filter TYPE string VALUE &apos;stage_filter&apos;,
               END OF c_action.

    METHODS:
      constructor
        IMPORTING
                  io_repo TYPE REF TO zcl_abapgit_repo_online
                  iv_seed TYPE string OPTIONAL
        RAISING   zcx_abapgit_exception,
      zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION,
      scripts        REDEFINITION.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_changed_by,
        item TYPE zif_abapgit_definitions=&gt;ty_item,
        name TYPE xubname,
      END OF ty_changed_by .
    TYPES:
      ty_changed_by_tt TYPE SORTED TABLE OF ty_changed_by WITH UNIQUE KEY item.
    TYPES:
      BEGIN OF ty_transport,
        item      TYPE zif_abapgit_definitions=&gt;ty_item,
        transport TYPE trkorr,
      END OF ty_transport,
      ty_transport_tt TYPE SORTED TABLE OF ty_transport WITH UNIQUE KEY item.

    DATA mo_repo TYPE REF TO zcl_abapgit_repo_online .
    DATA ms_files TYPE zif_abapgit_definitions=&gt;ty_stage_files .
    DATA mv_seed TYPE string .   &quot; Unique page id to bind JS sessionStorage
    DATA mv_filter_value TYPE string.

    METHODS find_changed_by
      IMPORTING
        !it_local            TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      RETURNING
        VALUE(rt_changed_by) TYPE ty_changed_by_tt .
    METHODS find_transports
      IMPORTING
        it_local             TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      RETURNING
        VALUE(rt_transports) TYPE ty_transport_tt.
    METHODS render_list
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_file
      IMPORTING
        !iv_context    TYPE string
        !is_file       TYPE zif_abapgit_definitions=&gt;ty_file
        !is_item       TYPE zif_abapgit_definitions=&gt;ty_item OPTIONAL
        !iv_changed_by TYPE xubname OPTIONAL
        !iv_transport  TYPE trkorr OPTIONAL
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS render_actions
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS process_stage_list
      IMPORTING
        !it_postdata TYPE cnht_post_data_tab
        !io_stage    TYPE REF TO zcl_abapgit_stage
      RAISING
        zcx_abapgit_exception .
    METHODS build_menu
      RETURNING
        VALUE(ro_menu) TYPE REF TO zcl_abapgit_html_toolbar .
    METHODS get_page_patch
      IMPORTING iv_getdata     TYPE clike
                iv_prev_page   TYPE clike
      RETURNING VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING   zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_gui_page_syntax DEFINITION FINAL CREATE PUBLIC
    INHERITING FROM zcl_abapgit_gui_page_codi_base.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    METHODS:
      constructor
        IMPORTING io_repo TYPE REF TO zcl_abapgit_repo.

  PROTECTED SECTION.

    METHODS:
      render_content REDEFINITION.

ENDCLASS.
CLASS zcl_abapgit_gui_page_tag DEFINITION FINAL
    CREATE PUBLIC INHERITING FROM zcl_abapgit_gui_page.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_gui_page_hotkey.

    CONSTANTS: BEGIN OF c_action,
                 commit_post     TYPE string VALUE &apos;commit_post&apos;,
                 commit_cancel   TYPE string VALUE &apos;commit_cancel&apos;,
                 change_tag_type TYPE string VALUE &apos;change_tag_type&apos;,
               END OF c_action.

    METHODS:
      constructor
        IMPORTING io_repo TYPE REF TO zcl_abapgit_repo
        RAISING   zcx_abapgit_exception,

      zif_abapgit_gui_page~on_event REDEFINITION.

  PROTECTED SECTION.
    METHODS:
      render_content REDEFINITION,
      scripts        REDEFINITION.

  PRIVATE SECTION.
    CONSTANTS: BEGIN OF c_tag_type,
                 lightweight TYPE string VALUE &apos;lightweight&apos;,
                 annotated   TYPE string VALUE &apos;annotated&apos;,
               END OF c_tag_type.

    DATA: mo_repo_online   TYPE REF TO zcl_abapgit_repo_online,
          mv_selected_type TYPE string.

    METHODS:
      render_menu
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,

      render_form
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,

      render_text_input
        IMPORTING iv_name        TYPE string
                  iv_label       TYPE string
                  iv_value       TYPE string OPTIONAL
                  iv_max_length  TYPE string OPTIONAL
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,

      create_tag
        IMPORTING it_postdata TYPE cnht_post_data_tab
        RAISING   zcx_abapgit_exception,

      parse_tag_request
        IMPORTING it_postdata TYPE cnht_post_data_tab
        EXPORTING eg_fields   TYPE any,
      parse_change_tag_type_request
        IMPORTING
          it_postdata TYPE cnht_post_data_tab.

ENDCLASS.
CLASS zcl_abapgit_gui_router DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_gui_router.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES: BEGIN OF ty_event_data,
             action    TYPE string,
             prev_page TYPE string,
             getdata   TYPE string,
             postdata  TYPE cnht_post_data_tab,
           END OF ty_event_data.

    METHODS general_page_routing
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS abapgit_services_actions
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS db_actions
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS git_services
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS remote_origin_manipulations
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS sap_gui_actions
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS zip_services
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS repository_services
      IMPORTING
        is_event_data TYPE ty_event_data
      EXPORTING
        !ei_page      TYPE REF TO zif_abapgit_gui_page
        !ev_state     TYPE i
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    METHODS get_page_diff
      IMPORTING
        !iv_getdata    TYPE clike
        !iv_prev_page  TYPE clike
      RETURNING
        VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING
        zcx_abapgit_exception .
    METHODS get_page_branch_overview
      IMPORTING
        !iv_getdata    TYPE clike
      RETURNING
        VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING
        zcx_abapgit_exception .
    METHODS get_page_stage
      IMPORTING
        !iv_getdata    TYPE clike
      RETURNING
        VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING
        zcx_abapgit_exception .
    METHODS get_page_background
      IMPORTING
        !iv_key        TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RETURNING
        VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING
        zcx_abapgit_exception .
    METHODS get_page_playground
      RETURNING
        VALUE(ri_page) TYPE REF TO zif_abapgit_gui_page
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS jump_display_transport
      IMPORTING
        !iv_getdata TYPE clike .
ENDCLASS.
CLASS zcl_abapgit_gui_view_repo DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_gui_page .
    INTERFACES zif_abapgit_gui_page_hotkey.

    ALIASES render
      FOR zif_abapgit_gui_page~render .

    CONSTANTS:
      BEGIN OF c_actions,
        change_dir        TYPE string VALUE &apos;change_dir&apos; ##NO_TEXT,
        toggle_hide_files TYPE string VALUE &apos;toggle_hide_files&apos; ##NO_TEXT,
        toggle_folders    TYPE string VALUE &apos;toggle_folders&apos; ##NO_TEXT,
        toggle_changes    TYPE string VALUE &apos;toggle_changes&apos; ##NO_TEXT,
        display_more      TYPE string VALUE &apos;display_more&apos; ##NO_TEXT,
      END OF c_actions .

    METHODS constructor
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception .

  PRIVATE SECTION.

    DATA: mo_repo         TYPE REF TO zcl_abapgit_repo,
          mv_cur_dir      TYPE string,
          mv_hide_files   TYPE abap_bool,
          mv_max_lines    TYPE i,
          mv_max_setting  TYPE i,
          mv_show_folders TYPE abap_bool,
          mv_changes_only TYPE abap_bool.

    METHODS:
      render_head_line
        IMPORTING iv_lstate      TYPE char1
                  iv_rstate      TYPE char1
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      build_head_menu
        IMPORTING iv_lstate         TYPE char1
                  iv_rstate         TYPE char1
        RETURNING VALUE(ro_toolbar) TYPE REF TO zcl_abapgit_html_toolbar
        RAISING   zcx_abapgit_exception,
      build_grid_menu
        RETURNING VALUE(ro_toolbar) TYPE REF TO zcl_abapgit_html_toolbar
        RAISING   zcx_abapgit_exception,
      render_item
        IMPORTING is_item              TYPE zif_abapgit_definitions=&gt;ty_repo_item
                  iv_render_transports TYPE abap_bool
        RETURNING VALUE(ro_html)       TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception,
      render_item_files
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,
      render_item_command
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html,
      get_item_class
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(rv_html) TYPE string,
      get_item_icon
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(rv_html) TYPE string,
      render_item_lock_column
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(rv_html) TYPE string,
      render_empty_package
        RETURNING VALUE(rv_html) TYPE string,
      render_parent_dir
        RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html
        RAISING   zcx_abapgit_exception.

    METHODS:
      build_obj_jump_link
        IMPORTING is_item        TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(rv_html) TYPE string,
      build_dir_jump_link
        IMPORTING iv_path        TYPE string
        RETURNING VALUE(rv_html) TYPE string,
      build_inactive_object_code
        IMPORTING is_item                      TYPE zif_abapgit_definitions=&gt;ty_repo_item
        RETURNING VALUE(rv_inactive_html_code) TYPE string,
      open_in_master_language
        RAISING zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_gui_view_tutorial DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_gui_page.
    INTERFACES zif_abapgit_gui_page_hotkey.
    ALIASES render FOR zif_abapgit_gui_page~render.

  PRIVATE SECTION.
    METHODS render_content
      RETURNING VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

ENDCLASS.
CLASS zcl_abapgit_hotkeys DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS:
      get_default_hotkeys_from_pages
        IMPORTING
          io_page TYPE REF TO zcl_abapgit_gui_page OPTIONAL
        RETURNING
          VALUE(rt_hotkey_actions) TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action
        RAISING
          zcx_abapgit_exception,

      get_relevant_hotkeys_for_page
        IMPORTING
          io_page           TYPE REF TO zcl_abapgit_gui_page
        RETURNING
          VALUE(rt_hotkeys) TYPE zif_abapgit_definitions=&gt;tty_hotkey
        RAISING
          zcx_abapgit_exception.

    CLASS-METHODS should_show_hint
      RETURNING
        VALUE(rv_yes) TYPE abap_bool.

  PRIVATE SECTION.
    CLASS-DATA gv_hint_was_shown TYPE abap_bool.

ENDCLASS.
CLASS zcl_abapgit_html DEFINITION
  CREATE PUBLIC.

  PUBLIC SECTION.

    CONSTANTS c_indent_size TYPE i VALUE 2 ##NO_TEXT.

    CLASS-METHODS class_constructor .
    METHODS add
      IMPORTING
        !ig_chunk TYPE any .
    METHODS render
      IMPORTING
        !iv_no_indent_jscss TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(rv_html)      TYPE string .
    METHODS is_empty
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS add_a
      IMPORTING
        !iv_txt   TYPE string
        !iv_act   TYPE string
        !iv_typ   TYPE char1 DEFAULT zif_abapgit_definitions=&gt;c_action_type-sapevent
        !iv_opt   TYPE clike OPTIONAL
        !iv_class TYPE string OPTIONAL
        !iv_id    TYPE string OPTIONAL
        !iv_style TYPE string OPTIONAL.
    METHODS add_icon
      IMPORTING
        !iv_name  TYPE string
        !iv_hint  TYPE string OPTIONAL
        !iv_class TYPE string OPTIONAL .
    CLASS-METHODS a
      IMPORTING
        !iv_txt       TYPE string
        !iv_act       TYPE string
        !iv_typ       TYPE char1 DEFAULT zif_abapgit_definitions=&gt;c_action_type-sapevent
        !iv_opt       TYPE clike OPTIONAL
        !iv_class     TYPE string OPTIONAL
        !iv_id        TYPE string OPTIONAL
        !iv_style     TYPE string OPTIONAL
      RETURNING
        VALUE(rv_str) TYPE string .
    CLASS-METHODS icon
      IMPORTING
        !iv_name      TYPE string
        !iv_hint      TYPE string OPTIONAL
        !iv_class     TYPE string OPTIONAL
      RETURNING
        VALUE(rv_str) TYPE string .
  PRIVATE SECTION.
    CLASS-DATA: go_single_tags_re TYPE REF TO cl_abap_regex.

    DATA: mt_buffer TYPE string_table.

    TYPES:
      BEGIN OF ty_indent_context,
        no_indent_jscss TYPE abap_bool,
        within_style    TYPE abap_bool,
        within_js       TYPE abap_bool,
        indent          TYPE i,
        indent_str      TYPE string,
      END OF ty_indent_context,

      BEGIN OF ty_study_result,
        style_open   TYPE abap_bool,
        style_close  TYPE abap_bool,
        script_open  TYPE abap_bool,
        script_close TYPE abap_bool,
        tag_close    TYPE abap_bool,
        curly_close  TYPE abap_bool,
        openings     TYPE i,
        closings     TYPE i,
        singles      TYPE i,
      END OF ty_study_result.

    METHODS indent_line
      CHANGING
        cs_context TYPE ty_indent_context
        cv_line    TYPE string.

    METHODS study_line
      IMPORTING iv_line          TYPE string
                is_context       TYPE ty_indent_context
      RETURNING VALUE(rs_result) TYPE ty_study_result.

ENDCLASS.
CLASS zcl_abapgit_html_action_utils DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS field_keys_to_upper
      CHANGING
        !ct_fields TYPE tihttpnvp .
    CLASS-METHODS parse_fields
      IMPORTING
        !iv_string       TYPE clike
      RETURNING
        VALUE(rt_fields) TYPE tihttpnvp .
    CLASS-METHODS parse_fields_upper_case_name
      IMPORTING
        !iv_string       TYPE clike
      RETURNING
        VALUE(rt_fields) TYPE tihttpnvp .
    CLASS-METHODS add_field
      IMPORTING
        !iv_name TYPE string
        !ig_field   TYPE any
      CHANGING
        !ct_field   TYPE tihttpnvp .
    CLASS-METHODS get_field
      IMPORTING
        !iv_name  TYPE string
        !it_field TYPE tihttpnvp
      CHANGING
        !cg_field TYPE any .
    CLASS-METHODS jump_encode
      IMPORTING
        !iv_obj_type     TYPE tadir-object
        !iv_obj_name     TYPE tadir-obj_name
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS jump_decode
      IMPORTING
        !iv_string   TYPE clike
      EXPORTING
        !ev_obj_type TYPE tadir-object
        !ev_obj_name TYPE tadir-obj_name
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS dir_encode
      IMPORTING
        !iv_path         TYPE string
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS dir_decode
      IMPORTING
        !iv_string     TYPE clike
      RETURNING
        VALUE(rv_path) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS file_encode
      IMPORTING
        !iv_key          TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !ig_file         TYPE any                                                 &quot;assuming ty_file
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS obj_encode
      IMPORTING
        !iv_key          TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !ig_object       TYPE any                                         &quot;assuming ty_item
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS file_obj_decode
      IMPORTING
        !iv_string TYPE clike
      EXPORTING
        !ev_key    TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !eg_file   TYPE any                        &quot;assuming ty_file
        !eg_object TYPE any                &quot;assuming ty_item
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS dbkey_encode
      IMPORTING
        !is_key          TYPE zif_abapgit_persistence=&gt;ty_content
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS dbkey_decode
      IMPORTING
        !iv_string    TYPE clike
      RETURNING
        VALUE(rs_key) TYPE zif_abapgit_persistence=&gt;ty_content .
    CLASS-METHODS stage_decode
      IMPORTING
        !iv_getdata TYPE clike
      EXPORTING
        !ev_key     TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !ev_seed    TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
    CLASS-METHODS unescape
      IMPORTING iv_string        TYPE string
      RETURNING VALUE(rv_string) TYPE string.

ENDCLASS.
CLASS zcl_abapgit_html_toolbar DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          iv_id TYPE string OPTIONAL,
      add
        IMPORTING
          iv_txt TYPE string
          io_sub TYPE REF TO zcl_abapgit_html_toolbar OPTIONAL
          iv_typ TYPE c         DEFAULT zif_abapgit_definitions=&gt;c_action_type-sapevent
          iv_act TYPE string    OPTIONAL
          iv_ico TYPE string    OPTIONAL
          iv_cur TYPE abap_bool OPTIONAL
          iv_opt TYPE c         OPTIONAL
          iv_chk TYPE abap_bool DEFAULT abap_undefined
          iv_aux TYPE string    OPTIONAL
          iv_id  TYPE string    OPTIONAL,
      count
        RETURNING VALUE(rv_count) TYPE i,
      render
        IMPORTING
          iv_right       TYPE abap_bool OPTIONAL
          iv_sort        TYPE abap_bool OPTIONAL
        RETURNING
          VALUE(ro_html) TYPE REF TO zcl_abapgit_html,
      render_as_droplist
        IMPORTING
          iv_label       TYPE string
          iv_right       TYPE abap_bool OPTIONAL
          iv_sort        TYPE abap_bool OPTIONAL
          iv_corner      TYPE abap_bool OPTIONAL
          iv_action      TYPE string OPTIONAL
        RETURNING
          VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_item,
        txt TYPE string,
        act TYPE string,
        ico TYPE string,
        sub TYPE REF TO zcl_abapgit_html_toolbar,
        opt TYPE char1,
        typ TYPE char1,
        cur TYPE abap_bool,
        chk TYPE abap_bool,
        aux TYPE string,
        id  TYPE string,
      END OF ty_item.

    TYPES tt_items TYPE STANDARD TABLE OF ty_item.

    DATA: mt_items TYPE tt_items,
          mv_id    TYPE string.

    METHODS:
      render_items
        IMPORTING
          iv_sort        TYPE abap_bool OPTIONAL
        RETURNING
          VALUE(ro_html) TYPE REF TO zcl_abapgit_html.

ENDCLASS.
CLASS zcl_abapgit_password_dialog DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS popup
      IMPORTING
        !iv_repo_url TYPE string
      CHANGING
        !cv_user     TYPE string
        !cv_pass     TYPE string .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_popups DEFINITION
  FINAL
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_ui_factory.

  PUBLIC SECTION.

    INTERFACES: zif_abapgit_popups.
    ALIASES:
      popup_package_export          FOR zif_abapgit_popups~popup_package_export,
      popup_folder_logic            FOR zif_abapgit_popups~popup_folder_logic,
      popup_object                  FOR zif_abapgit_popups~popup_object,
      create_branch_popup           FOR zif_abapgit_popups~create_branch_popup,
      run_page_class_popup          FOR zif_abapgit_popups~run_page_class_popup,
      repo_new_offline              FOR zif_abapgit_popups~repo_new_offline,
      branch_list_popup             FOR zif_abapgit_popups~branch_list_popup,
      repo_popup                    FOR zif_abapgit_popups~repo_popup,
      popup_to_confirm              FOR zif_abapgit_popups~popup_to_confirm,
      popup_to_inform               FOR zif_abapgit_popups~popup_to_inform,
      popup_to_create_package       FOR zif_abapgit_popups~popup_to_create_package,
      popup_to_create_transp_branch FOR zif_abapgit_popups~popup_to_create_transp_branch,
      popup_to_select_transports    FOR zif_abapgit_popups~popup_to_select_transports,
      popup_to_select_from_list     FOR zif_abapgit_popups~popup_to_select_from_list,
      branch_popup_callback         FOR zif_abapgit_popups~branch_popup_callback,
      package_popup_callback        FOR zif_abapgit_popups~package_popup_callback,
      popup_transport_request       FOR zif_abapgit_popups~popup_transport_request.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      ty_sval_tt TYPE STANDARD TABLE OF sval WITH DEFAULT KEY.

    CONSTANTS c_fieldname_selected TYPE lvc_fname VALUE `SELECTED` ##NO_TEXT.
    CONSTANTS c_answer_cancel      TYPE char1 VALUE &apos;A&apos; ##NO_TEXT.

    DATA mo_select_list_popup TYPE REF TO cl_salv_table .
    DATA mr_table TYPE REF TO data .
    DATA mv_cancel TYPE abap_bool .
    DATA mo_table_descr TYPE REF TO cl_abap_tabledescr .

    METHODS add_field
      IMPORTING
        !iv_tabname    TYPE sval-tabname
        !iv_fieldname  TYPE sval-fieldname
        !iv_fieldtext  TYPE sval-fieldtext
        !iv_value      TYPE clike DEFAULT &apos;&apos;
        !iv_field_attr TYPE sval-field_attr DEFAULT &apos;&apos;
        !iv_obligatory TYPE spo_obl OPTIONAL
      CHANGING
        !ct_fields     TYPE ty_sval_tt .
    METHODS create_new_table
      IMPORTING
        !it_list TYPE STANDARD TABLE .
    METHODS get_selected_rows
      EXPORTING
        !et_list TYPE INDEX TABLE .
    METHODS on_select_list_link_click
          FOR EVENT link_click OF cl_salv_events_table
      IMPORTING
          !row
          !column .
    METHODS on_select_list_function_click
          FOR EVENT added_function OF cl_salv_events_table
      IMPORTING
          !e_salv_function .
    METHODS extract_field_values
      IMPORTING
        it_fields  TYPE ty_sval_tt
      EXPORTING
        ev_url     TYPE abaptxt255-line
        ev_package TYPE tdevc-devclass
        ev_branch  TYPE textl-line .
    TYPES:
      ty_lt_fields TYPE STANDARD TABLE OF sval WITH DEFAULT KEY.
    METHODS _popup_2_get_values
      IMPORTING iv_popup_title    TYPE string
                iv_no_value_check TYPE abap_bool DEFAULT abap_false
      EXPORTING ev_value_1        TYPE spo_value
                ev_value_2        TYPE spo_value
      CHANGING  ct_fields         TYPE ty_lt_fields
      RAISING   zcx_abapgit_exception
                zcx_abapgit_cancel.

ENDCLASS.
CLASS zcl_abapgit_services_abapgit DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CONSTANTS c_abapgit_homepage TYPE string VALUE &apos;http://www.abapgit.org&apos; ##NO_TEXT.
    CONSTANTS c_abapgit_wikipage TYPE string VALUE &apos;http://docs.abapgit.org&apos; ##NO_TEXT.
    CONSTANTS c_package_abapgit TYPE devclass VALUE &apos;$ABAPGIT&apos; ##NO_TEXT.
    CONSTANTS c_abapgit_url TYPE string VALUE &apos;https://github.com/larshp/abapGit.git&apos; ##NO_TEXT.
    CONSTANTS c_abapgit_tcode TYPE tcode VALUE `ZABAPGIT` ##NO_TEXT.

    CLASS-METHODS open_abapgit_homepage
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS open_abapgit_wikipage
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS install_abapgit
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS is_installed
      RETURNING
        VALUE(rv_installed) TYPE abap_bool .
    CLASS-METHODS prepare_gui_startup
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.
    CLASS-METHODS do_install
      IMPORTING iv_title   TYPE c
                iv_text    TYPE c
                iv_url     TYPE string
                iv_package TYPE devclass
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS set_start_repo_from_package
      IMPORTING
        iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS get_package_from_adt
      RETURNING
        VALUE(rv_package) TYPE devclass.

ENDCLASS.
CLASS zcl_abapgit_services_git DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    TYPES:
      BEGIN OF ty_commit_fields,
        repo_key        TYPE zif_abapgit_persistence=&gt;ty_repo-key,
        committer_name  TYPE string,
        committer_email TYPE string,
        author_name     TYPE string,
        author_email    TYPE string,
        comment         TYPE string,
        body            TYPE string,
      END OF ty_commit_fields.

    CLASS-METHODS pull
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS reset
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS create_branch
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS switch_branch
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS delete_branch
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .

    CLASS-METHODS delete_tag
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS switch_tag
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS tag_overview
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS commit
      IMPORTING
        !io_repo   TYPE REF TO zcl_abapgit_repo_online
        !is_commit TYPE ty_commit_fields
        !io_stage  TYPE REF TO zcl_abapgit_stage
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel.

  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_services_repo DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS new_online
      IMPORTING
        !iv_url        TYPE string
      RETURNING
        VALUE(ro_repo) TYPE REF TO zcl_abapgit_repo_online
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS refresh
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS remove
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS purge
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS new_offline
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS remote_attach
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS remote_detach
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS remote_change
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS refresh_local_checksums
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS toggle_favorite
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS open_se80
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS transport_to_branch
      IMPORTING
        !iv_repository_key TYPE zif_abapgit_persistence=&gt;ty_value
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS gui_deserialize
      IMPORTING
        !io_repo TYPE REF TO zcl_abapgit_repo
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-METHODS popup_overwrite
      CHANGING
        !ct_overwrite TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS popup_package_overwrite
      CHANGING
        !ct_overwrite TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
ENDCLASS.
CLASS zcl_abapgit_tag_popups DEFINITION
  FINAL
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_ui_factory.

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_tag_popups.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_tag_out.
        INCLUDE TYPE zif_abapgit_definitions=&gt;ty_git_tag.
    TYPES: body_icon TYPE icon_d,
           END OF ty_tag_out,
           tty_tag_out TYPE STANDARD TABLE OF ty_tag_out
                       WITH NON-UNIQUE DEFAULT KEY.

    DATA:
      mt_tags              TYPE tty_tag_out,
      mo_docking_container TYPE REF TO cl_gui_docking_container,
      mo_text_control      TYPE REF TO cl_gui_textedit.

    METHODS:
      on_double_click FOR EVENT double_click OF cl_salv_events_table
        IMPORTING row column,

      prepare_tags_for_display
        IMPORTING
          it_tags            TYPE zif_abapgit_definitions=&gt;ty_git_tag_list_tt
        RETURNING
          VALUE(rt_tags_out) TYPE zcl_abapgit_tag_popups=&gt;tty_tag_out,

      clean_up,

      show_docking_container_with
        IMPORTING
          iv_text TYPE string.

ENDCLASS.
CLASS zcl_abapgit_ui_factory DEFINITION
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_ui_injector.

  PUBLIC SECTION.
    CLASS-METHODS:
      get_popups
        RETURNING
          VALUE(ri_popups) TYPE REF TO zif_abapgit_popups,

      get_tag_popups
        RETURNING
          VALUE(ri_tag_popups) TYPE REF TO zif_abapgit_tag_popups,

      get_gui_functions
        RETURNING
          VALUE(ri_gui_functions) TYPE REF TO zif_abapgit_gui_functions.

    CLASS-METHODS: get_gui
      RETURNING
        VALUE(ro_gui) TYPE REF TO zcl_abapgit_gui
      RAISING
        zcx_abapgit_exception.
  PRIVATE SECTION.
    CLASS-DATA:
      gi_popups        TYPE REF TO zif_abapgit_popups,
      gi_tag_popups    TYPE REF TO zif_abapgit_tag_popups,
      gi_gui_functions TYPE REF TO zif_abapgit_gui_functions,
      go_gui           TYPE REF TO zcl_abapgit_gui.

ENDCLASS.
CLASS zcl_abapgit_ui_injector DEFINITION
  CREATE PRIVATE.

  PUBLIC SECTION.
    CLASS-METHODS:
      set_popups
        IMPORTING
          ii_popups TYPE REF TO zif_abapgit_popups,

      set_tag_popups
        IMPORTING
          ii_tag_popups TYPE REF TO zif_abapgit_tag_popups,

      set_gui_functions
        IMPORTING
          ii_gui_functions TYPE REF TO zif_abapgit_gui_functions.

ENDCLASS.
CLASS zcl_abapgit_convert DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS bitbyte_to_int
      IMPORTING
        !iv_bits      TYPE clike
      RETURNING
        VALUE(rv_int) TYPE i .
    CLASS-METHODS x_to_bitbyte
      IMPORTING
        !iv_x             TYPE x
      RETURNING
        VALUE(rv_bitbyte) TYPE zif_abapgit_definitions=&gt;ty_bitbyte .
    CLASS-METHODS string_to_xstring_utf8
      IMPORTING
        !iv_string        TYPE string
      RETURNING
        VALUE(rv_xstring) TYPE xstring .
    CLASS-METHODS xstring_to_string_utf8
      IMPORTING
        !iv_data         TYPE xstring
      RETURNING
        VALUE(rv_string) TYPE string .
    CLASS-METHODS xstring_to_int
      IMPORTING
        !iv_xstring TYPE xstring
      RETURNING
        VALUE(rv_i) TYPE i
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS int_to_xstring4
      IMPORTING
        !iv_i             TYPE i
      RETURNING
        VALUE(rv_xstring) TYPE xstring .
    CLASS-METHODS split_string
      IMPORTING
        !iv_string      TYPE string
      RETURNING
        VALUE(rt_lines) TYPE string_table .
ENDCLASS.
CLASS zcl_abapgit_diff DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    DATA mt_beacons TYPE zif_abapgit_definitions=&gt;ty_string_tt READ-ONLY.

* assumes data is UTF8 based with newlines
* only works with lines up to 255 characters
    METHODS constructor
      IMPORTING iv_new TYPE xstring
                iv_old TYPE xstring.

    METHODS get
      RETURNING VALUE(rt_diff) TYPE zif_abapgit_definitions=&gt;ty_diffs_tt.

    METHODS stats
      RETURNING VALUE(rs_count) TYPE zif_abapgit_definitions=&gt;ty_count.

    METHODS set_patch_new
      IMPORTING
        iv_line_new   TYPE i
        iv_patch_flag TYPE abap_bool
      RAISING
        zcx_abapgit_exception.

    METHODS set_patch_old
      IMPORTING
        iv_line_old   TYPE i
        iv_patch_flag TYPE abap_bool
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA mt_diff     TYPE zif_abapgit_definitions=&gt;ty_diffs_tt.
    DATA ms_stats    TYPE zif_abapgit_definitions=&gt;ty_count.

    CLASS-METHODS:
      unpack
        IMPORTING iv_new TYPE xstring
                  iv_old TYPE xstring
        EXPORTING et_new TYPE abaptxt255_tab
                  et_old TYPE abaptxt255_tab,
      render
        IMPORTING it_new         TYPE abaptxt255_tab
                  it_old         TYPE abaptxt255_tab
                  it_delta       TYPE vxabapt255_tab
        RETURNING VALUE(rt_diff) TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
      compute
        IMPORTING it_new          TYPE abaptxt255_tab
                  it_old          TYPE abaptxt255_tab
        RETURNING VALUE(rt_delta) TYPE vxabapt255_tab.

    METHODS:
      calculate_line_num_and_stats,
      map_beacons,
      shortlist.
ENDCLASS.
CLASS zcl_abapgit_hash DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS adler32
      IMPORTING
        !iv_xstring        TYPE xstring
      RETURNING
        VALUE(rv_checksum) TYPE zif_abapgit_definitions=&gt;ty_adler32 .
    CLASS-METHODS sha1
      IMPORTING
        !iv_type       TYPE zif_abapgit_definitions=&gt;ty_type
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_definitions=&gt;ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_raw
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_definitions=&gt;ty_sha1
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
*----------------------------------------------------------------------*
* This helper class is used to set and restore the current language.
* As some of the SAP functions used rely on SY-LANGU containing the
* master language, this class is used to temporarily change and then
* restore the value of SY-LANGU.
*----------------------------------------------------------------------*
CLASS zcl_abapgit_language DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS class_constructor .
    CLASS-METHODS restore_login_language .
    CLASS-METHODS set_current_language
      IMPORTING
        !iv_language TYPE langu .
  PRIVATE SECTION.

    CLASS-DATA gv_login_language TYPE langu .
ENDCLASS.
CLASS zcl_abapgit_log DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS add
      IMPORTING
        !iv_msg  TYPE csequence
        !iv_type TYPE symsgty DEFAULT &apos;E&apos;
        !iv_rc   TYPE balsort OPTIONAL .
    METHODS add_error
      IMPORTING
        !iv_msg TYPE csequence .
    METHODS add_info
      IMPORTING
        !iv_msg TYPE csequence .
    METHODS add_warning
      IMPORTING
        !iv_msg TYPE csequence .
    METHODS clear .
    METHODS count
      RETURNING
        VALUE(rv_count) TYPE i .
    METHODS has_rc
      IMPORTING
        !iv_rc        TYPE balsort
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS show
      IMPORTING
        !iv_header_text TYPE csequence DEFAULT &apos;Log&apos; .
    METHODS to_html
      RETURNING
        VALUE(ro_html) TYPE REF TO zcl_abapgit_html .
    METHODS write .
  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_log,
        msg  TYPE string,
        type TYPE symsgty,
        rc   TYPE balsort,
      END OF ty_log .
    TYPES:
      BEGIN OF ty_log_out,
        type TYPE icon_d,
        msg  TYPE string,
      END OF ty_log_out .
    TYPES:
      tty_log_out TYPE STANDARD TABLE OF ty_log_out
                              WITH NON-UNIQUE DEFAULT KEY .

    DATA:
      mt_log TYPE STANDARD TABLE OF ty_log WITH DEFAULT KEY .

    METHODS prepare_log_for_display
      RETURNING
        VALUE(rt_log_out) TYPE zcl_abapgit_log=&gt;tty_log_out .
ENDCLASS.
CLASS zcl_abapgit_login_manager DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS load
      IMPORTING
        !iv_uri                 TYPE string
        !ii_client              TYPE REF TO if_http_client OPTIONAL
      RETURNING
        VALUE(rv_authorization) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS save
      IMPORTING
        !iv_uri    TYPE string
        !ii_client TYPE REF TO if_http_client
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS clear .
    CLASS-METHODS set
      IMPORTING
        !iv_uri        TYPE string
        !iv_username   TYPE string
        !iv_password   TYPE string
      RETURNING
        VALUE(rv_auth) TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_auth,
        uri           TYPE string,
        authorization TYPE string,
      END OF ty_auth .

    CLASS-DATA:
      gt_auth TYPE TABLE OF ty_auth WITH DEFAULT KEY.

    CLASS-METHODS:
      append
        IMPORTING
          !iv_uri  TYPE string
          !iv_auth TYPE string
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_path DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS split_file_location
      IMPORTING iv_fullpath TYPE string
      EXPORTING ev_path     TYPE string
                ev_filename TYPE string.

    CLASS-METHODS is_root
      IMPORTING iv_path       TYPE string
      RETURNING VALUE(rv_yes) TYPE abap_bool.

    CLASS-METHODS is_subdir
      IMPORTING iv_path       TYPE string
                iv_parent     TYPE string
      RETURNING VALUE(rv_yes) TYPE abap_bool.

    CLASS-METHODS change_dir
      IMPORTING iv_cur_dir     TYPE string
                iv_cd          TYPE string
      RETURNING VALUE(rv_path) TYPE string.

    CLASS-METHODS get_filename_from_syspath
      IMPORTING iv_path            TYPE string
      RETURNING VALUE(rv_filename) TYPE string.

ENDCLASS.
CLASS zcl_abapgit_progress DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS show
      IMPORTING
        VALUE(iv_current) TYPE i
        !iv_text          TYPE csequence .
    METHODS constructor
      IMPORTING
        !iv_total TYPE i .
  PROTECTED SECTION.

    DATA mv_total TYPE i .

    METHODS calc_pct
      IMPORTING
        !iv_current   TYPE i
      RETURNING
        VALUE(rv_pct) TYPE i .
  PRIVATE SECTION.

    DATA mv_cv_time_next TYPE sy-uzeit .
    DATA mv_cv_datum_next TYPE sy-datum .
ENDCLASS.
CLASS zcl_abapgit_requirement_helper DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_requirement_status,
        met               TYPE abap_bool,
        component         TYPE dlvunit,
        description       TYPE text80,
        installed_release TYPE saprelease,
        installed_patch   TYPE sappatchlv,
        required_release  TYPE saprelease,
        required_patch    TYPE sappatchlv,
      END OF ty_requirement_status .
    TYPES:
      ty_requirement_status_tt TYPE STANDARD TABLE OF ty_requirement_status WITH DEFAULT KEY .

    CLASS-METHODS requirements_popup
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_requirements_met
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt
      RETURNING
        VALUE(rv_status) TYPE zif_abapgit_definitions=&gt;ty_yes_no
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-METHODS show_requirement_popup
      IMPORTING
        !it_requirements TYPE ty_requirement_status_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_requirement_met_status
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt
      RETURNING
        VALUE(rt_status) TYPE ty_requirement_status_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS version_greater_or_equal
      IMPORTING
        !is_status     TYPE ty_requirement_status
      RETURNING
        VALUE(rv_true) TYPE abap_bool .
ENDCLASS.
CLASS zcl_abapgit_state DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS:
      reduce
        IMPORTING
          !iv_cur  TYPE char1
        CHANGING
          !cv_prev TYPE char1 .

ENDCLASS.
CLASS zcl_abapgit_time DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    TYPES: ty_unixtime TYPE c LENGTH 16.

    CLASS-METHODS get
      RETURNING VALUE(rv_time) TYPE ty_unixtime
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    CONSTANTS: c_epoch TYPE datum VALUE &apos;19700101&apos;.

ENDCLASS.
CLASS zcl_abapgit_url DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS validate
      IMPORTING
        !iv_url TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS host
      IMPORTING
        !iv_url        TYPE string
      RETURNING
        VALUE(rv_host) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS name
      IMPORTING
        !iv_url        TYPE string
      RETURNING
        VALUE(rv_name) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS path_name
      IMPORTING
        !iv_url             TYPE string
      RETURNING
        VALUE(rv_path_name) TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-METHODS regex
      IMPORTING
        !iv_url  TYPE string
      EXPORTING
        !ev_host TYPE string
        !ev_path TYPE string
        !ev_name TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_user_master_record DEFINITION
  FINAL
  CREATE PRIVATE .

  PUBLIC SECTION.

    CLASS-METHODS:
      get_instance
        IMPORTING
          !iv_user       TYPE uname
        RETURNING
          VALUE(ro_user) TYPE REF TO zcl_abapgit_user_master_record.

    METHODS:
      constructor
        IMPORTING
          !iv_user TYPE uname,

      get_name
        RETURNING
          VALUE(rv_name) TYPE zif_abapgit_definitions=&gt;ty_git_user-name,

      get_email
        RETURNING
          VALUE(rv_email) TYPE zif_abapgit_definitions=&gt;ty_git_user-email.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_user,
        user   TYPE uname,
        o_user TYPE REF TO zcl_abapgit_user_master_record,
      END OF ty_user.

    CLASS-DATA:
      gt_user TYPE HASHED TABLE OF ty_user
                   WITH UNIQUE KEY user.

    DATA:
      ms_user TYPE zif_abapgit_definitions=&gt;ty_git_user.
ENDCLASS.
CLASS zcl_abapgit_xml DEFINITION
  ABSTRACT
  CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS:
      constructor.

  PROTECTED SECTION.
    DATA: mi_ixml     TYPE REF TO if_ixml,
          mi_xml_doc  TYPE REF TO if_ixml_document,
          ms_metadata TYPE zif_abapgit_definitions=&gt;ty_metadata.

    CONSTANTS: c_abapgit_tag             TYPE string VALUE &apos;abapGit&apos; ##NO_TEXT,
               c_attr_version            TYPE string VALUE &apos;version&apos; ##NO_TEXT,
               c_attr_serializer         TYPE string VALUE &apos;serializer&apos; ##NO_TEXT,
               c_attr_serializer_version TYPE string VALUE &apos;serializer_version&apos; ##NO_TEXT.

    METHODS to_xml
      IMPORTING iv_normalize  TYPE sap_bool DEFAULT abap_true
      RETURNING VALUE(rv_xml) TYPE string.

    METHODS parse
      IMPORTING iv_normalize TYPE abap_bool DEFAULT abap_true
                iv_xml       TYPE string
      RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    METHODS error
      IMPORTING ii_parser TYPE REF TO if_ixml_parser
      RAISING   zcx_abapgit_exception.

    METHODS display_xml_error
      RAISING zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_xml_input DEFINITION
  INHERITING FROM zcl_abapgit_xml
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_xml TYPE clike
      RAISING
        zcx_abapgit_exception .
    METHODS read
      IMPORTING
        !iv_name TYPE clike
      CHANGING
        !cg_data TYPE any
      RAISING
        zcx_abapgit_exception .
    METHODS get_raw
      RETURNING
        VALUE(ri_raw) TYPE REF TO if_ixml_document .
* todo, add read_xml to match add_xml in lcl_xml_output
    METHODS get_metadata
      RETURNING
        VALUE(rs_metadata) TYPE zif_abapgit_definitions=&gt;ty_metadata .
  PRIVATE SECTION.
    METHODS: fix_xml.

ENDCLASS.
CLASS zcl_abapgit_xml_output DEFINITION
  INHERITING FROM zcl_abapgit_xml
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS add
      IMPORTING
        !iv_name TYPE clike
        !ig_data TYPE any
      RAISING
        zcx_abapgit_exception .
    METHODS set_raw
      IMPORTING
        !ii_raw TYPE REF TO if_ixml_element .
    METHODS add_xml
      IMPORTING
        !iv_name TYPE clike
        !ii_xml  TYPE REF TO if_ixml_element .
    METHODS build_asx_node
      RETURNING
        VALUE(ri_element) TYPE REF TO if_ixml_element .
    METHODS render
      IMPORTING
        !iv_normalize TYPE sap_bool DEFAULT abap_true
        !is_metadata  TYPE zif_abapgit_definitions=&gt;ty_metadata OPTIONAL
      RETURNING
        VALUE(rv_xml) TYPE string .
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: mi_raw  TYPE REF TO if_ixml_element.

ENDCLASS.
CLASS zcl_abapgit_xml_pretty DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS: print
      IMPORTING iv_xml           TYPE string
                iv_ignore_errors TYPE abap_bool DEFAULT abap_true
                iv_unpretty      TYPE abap_bool DEFAULT abap_false
      RETURNING VALUE(rv_xml)    TYPE string
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_abap_unit_tests DEFINITION
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_factory.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_code_inspector.

    METHODS:
      constructor
        IMPORTING
          iv_package TYPE devclass
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA:
      mo_adhoc_code_inspector TYPE REF TO zif_abapgit_code_inspector.

ENDCLASS.
CLASS zcl_abapgit_auth DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS:
      is_allowed
        IMPORTING iv_authorization  TYPE zif_abapgit_auth=&gt;ty_authorization
                  iv_param          TYPE string OPTIONAL
        RETURNING VALUE(rv_allowed) TYPE abap_bool.

ENDCLASS.
CLASS zcl_abapgit_branch_overview DEFINITION
  FINAL
  CREATE PRIVATE

  FRIENDS ZCL_ABAPGIT_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_branch_overview .
    TYPES: ty_commits TYPE STANDARD TABLE OF zif_abapgit_definitions=&gt;ty_commit WITH DEFAULT KEY .
    CONSTANTS c_deleted_branch_name_prefix TYPE string VALUE &apos;__DELETED_BRANCH_&apos; ##NO_TEXT.

    METHODS constructor
      IMPORTING
        io_repo TYPE REF TO zcl_abapgit_repo_online
      RAISING
        zcx_abapgit_exception .

  PRIVATE SECTION.

    TYPES:
      tyt_commit_sha1_range TYPE RANGE OF zif_abapgit_definitions=&gt;ty_sha1 .

    DATA mt_branches TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt .
    DATA mt_commits TYPE ty_commits .
    DATA mt_tags TYPE zif_abapgit_definitions=&gt;ty_git_tag_list_tt .

    CLASS-METHODS parse_commits
      IMPORTING
        !it_objects       TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RETURNING
        VALUE(rt_commits) TYPE ty_commits
      RAISING
        zcx_abapgit_exception .
    METHODS parse_annotated_tags
      IMPORTING
        !it_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    METHODS determine_branch
      RAISING
        zcx_abapgit_exception .
    METHODS determine_merges
      RAISING
        zcx_abapgit_exception .
    METHODS fixes
      RAISING
        zcx_abapgit_exception .
    METHODS get_git_objects
      IMPORTING
        !io_repo          TYPE REF TO zcl_abapgit_repo_online
      RETURNING
        VALUE(rt_objects) TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    METHODS determine_tags
      RAISING
        zcx_abapgit_exception .
    METHODS _sort_commits
      CHANGING
        !ct_commits TYPE ty_commits .
    METHODS _get_1st_child_commit
      IMPORTING
        !it_commit_sha1s TYPE tyt_commit_sha1_range
      EXPORTING
        !et_commit_sha1s TYPE tyt_commit_sha1_range
        !es_1st_commit   TYPE zif_abapgit_definitions=&gt;ty_commit
      CHANGING
        !ct_commits      TYPE ty_commits .
    METHODS _reverse_sort_order
      CHANGING
        !ct_commits TYPE ty_commits .
ENDCLASS.
CLASS zcl_abapgit_code_inspector DEFINITION
  CREATE PROTECTED
  FRIENDS ZCL_ABAPGIT_factory.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_code_inspector.

    METHODS:
      constructor
        IMPORTING
          iv_package            TYPE devclass
          iv_check_variant_name TYPE sci_chkv OPTIONAL
        RAISING
          zcx_abapgit_exception.

    CLASS-METHODS:
      validate_check_variant
        IMPORTING
          iv_check_variant_name TYPE sci_chkv
        RAISING
          zcx_abapgit_exception.

  PROTECTED SECTION.
    TYPES:
      ty_tdevc_tt TYPE STANDARD TABLE OF tdevc WITH DEFAULT KEY .

    DATA:
      mv_package            TYPE devclass,
      mv_check_variant_name TYPE sci_chkv.

    METHODS:
      create_variant
        RETURNING
          VALUE(ro_variant) TYPE REF TO cl_ci_checkvariant
        RAISING
          zcx_abapgit_exception,

      cleanup
        IMPORTING
          io_set TYPE REF TO cl_ci_objectset
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF co_run_mode,
        run_with_popup   TYPE sychar01 VALUE &apos;P&apos;,
        run_after_popup  TYPE sychar01 VALUE &apos;A&apos;,
        run_via_rfc      TYPE sychar01 VALUE &apos;R&apos;,
        run_in_batch     TYPE sychar01 VALUE &apos;B&apos;,
        run_loc_parallel TYPE sychar01 VALUE &apos;L&apos;,
        run_direct       TYPE sychar01 VALUE &apos;L&apos;,
      END OF co_run_mode.

    DATA:
      mo_inspection      TYPE REF TO cl_ci_inspection,
      mv_objectset_name  TYPE sci_objs,
      mv_inspection_name TYPE sci_insp,
      mv_run_mode        TYPE sychar01.

    METHODS:
      find_all_subpackages
        IMPORTING
          iv_package         TYPE devclass
        RETURNING
          VALUE(rt_packages) TYPE ty_tdevc_tt,

      create_objectset
        RETURNING
          VALUE(ro_set) TYPE REF TO cl_ci_objectset,

      run_inspection
        IMPORTING
          io_inspection  TYPE REF TO cl_ci_inspection
        RETURNING
          VALUE(rt_list) TYPE scit_alvlist
        RAISING
          zcx_abapgit_exception,

      create_inspection
        IMPORTING
          io_set               TYPE REF TO cl_ci_objectset
          io_variant           TYPE REF TO cl_ci_checkvariant
        RETURNING
          VALUE(ro_inspection) TYPE REF TO cl_ci_inspection
        RAISING
          zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_adhoc_code_insp DEFINITION
  CREATE PRIVATE
  INHERITING FROM zcl_abapgit_code_inspector
  FRIENDS ZCL_ABAPGIT_factory.

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          iv_package   TYPE devclass
          iv_test_name TYPE sci_tstval-testname
        RAISING
          zcx_abapgit_exception.

  PROTECTED SECTION.
    METHODS:
      create_variant REDEFINITION,

      cleanup REDEFINITION.

  PRIVATE SECTION.
    DATA:
      mo_variant   TYPE REF TO cl_ci_checkvariant,
      mv_test_name TYPE sci_tstval-testname.

ENDCLASS.
&quot;! Change transport system API
CLASS zcl_abapgit_cts_api DEFINITION
  FINAL
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_factory.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_cts_api.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_default_transport DEFINITION
  CREATE PRIVATE .

  PUBLIC SECTION.
    CLASS-METHODS:
      get_instance
        RETURNING
          VALUE(ro_instance) TYPE REF TO zcl_abapgit_default_transport
        RAISING
          zcx_abapgit_exception.

    METHODS:
      constructor
        RAISING
          zcx_abapgit_exception,

      set
        IMPORTING
          iv_transport TYPE trkorr
        RAISING
          zcx_abapgit_exception,

      reset
        RAISING
          zcx_abapgit_exception.
  PRIVATE SECTION.

    CLASS-DATA go_instance TYPE REF TO zcl_abapgit_default_transport .
    DATA mv_is_set_by_abapgit TYPE abap_bool .
    DATA ms_save TYPE e070use .

    METHODS store
      RAISING
        zcx_abapgit_exception .
    METHODS restore
      RAISING
        zcx_abapgit_exception .
    METHODS get
      RETURNING
        VALUE(rs_default_task) TYPE e070use
      RAISING
        zcx_abapgit_exception .
    METHODS set_internal
      IMPORTING
        !iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    METHODS clear
      IMPORTING
        !is_default_task TYPE e070use
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_dependencies DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS resolve
      CHANGING
        !ct_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_dependency,
        depname  TYPE dd02l-tabname,
        deptyp   TYPE c LENGTH 4,
        deplocal TYPE dd02l-as4local,
        refname  TYPE dd02l-tabname,
        reftyp   TYPE c LENGTH 4,
        kind     TYPE c LENGTH 1,
      END OF ty_dependency .
    TYPES:
      tty_dedenpency TYPE STANDARD TABLE OF ty_dependency
                                 WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      BEGIN OF ty_item,
        obj_type TYPE tadir-object,
        obj_name TYPE tadir-obj_name,
        devclass TYPE devclass,
      END OF ty_item .

    CLASS-METHODS resolve_ddic
      CHANGING
        !ct_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_ddls_dependencies
      IMPORTING
        iv_ddls_name         TYPE tadir-obj_name
      RETURNING
        VALUE(rt_dependency) TYPE tty_dedenpency .
    CLASS-METHODS resolve_packages
      CHANGING
        ct_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt.
ENDCLASS.
CLASS zcl_abapgit_dot_abapgit DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS build_default
      RETURNING
        VALUE(ro_dot_abapgit) TYPE REF TO zcl_abapgit_dot_abapgit .
    CLASS-METHODS deserialize
      IMPORTING
        !iv_xstr              TYPE xstring
      RETURNING
        VALUE(ro_dot_abapgit) TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapgit_exception .
    METHODS constructor
      IMPORTING
        !is_data TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit .
    METHODS serialize
      RETURNING
        VALUE(rv_xstr) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    METHODS get_data
      RETURNING
        VALUE(rs_data) TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit .
    METHODS add_ignore
      IMPORTING
        !iv_path     TYPE string
        !iv_filename TYPE string .
    METHODS is_ignored
      IMPORTING
        !iv_path          TYPE string
        !iv_filename      TYPE string
      RETURNING
        VALUE(rv_ignored) TYPE abap_bool .
    METHODS remove_ignore
      IMPORTING
        !iv_path     TYPE string
        !iv_filename TYPE string .
    METHODS get_starting_folder
      RETURNING
        VALUE(rv_path) TYPE string .

    METHODS get_folder_logic
      RETURNING
        VALUE(rv_logic) TYPE string .

    METHODS set_folder_logic
      IMPORTING
        !iv_logic TYPE string .

    METHODS set_starting_folder
      IMPORTING
        !iv_path TYPE string .

    METHODS get_master_language
      RETURNING
        VALUE(rv_language) TYPE spras .
*      set_master_language
*        IMPORTING iv_language TYPE spras,
    METHODS get_signature
      RETURNING
        VALUE(rs_signature) TYPE zif_abapgit_definitions=&gt;ty_file_signature
      RAISING
        zcx_abapgit_exception .
    METHODS get_requirements
      RETURNING
        VALUE(rt_requirements) TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt.
    METHODS set_requirements
      IMPORTING
        it_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt.
  PRIVATE SECTION.
    DATA: ms_data TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit.

    CLASS-METHODS:
      to_xml
        IMPORTING is_data       TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit
        RETURNING VALUE(rv_xml) TYPE string
        RAISING   zcx_abapgit_exception,
      from_xml
        IMPORTING iv_xml         TYPE string
        RETURNING VALUE(rs_data) TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit.

ENDCLASS.
CLASS zcl_abapgit_exit DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS: get_instance RETURNING VALUE(ri_exit) TYPE REF TO zif_abapgit_exit.

    INTERFACES: zif_abapgit_exit.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gi_exit TYPE REF TO zif_abapgit_exit .
ENDCLASS.
CLASS zcl_abapgit_factory DEFINITION
  CREATE PRIVATE

  FRIENDS ZCL_ABAPGIT_injector .

  PUBLIC SECTION.

    CLASS-METHODS get_tadir
      RETURNING
        VALUE(ri_tadir) TYPE REF TO zif_abapgit_tadir .
    CLASS-METHODS get_sap_package
      IMPORTING
        !iv_package           TYPE devclass
      RETURNING
        VALUE(ri_sap_package) TYPE REF TO zif_abapgit_sap_package .
    CLASS-METHODS get_code_inspector
      IMPORTING
        !iv_package              TYPE devclass
        !iv_check_variant_name   TYPE sci_chkv
      RETURNING
        VALUE(ri_code_inspector) TYPE REF TO zif_abapgit_code_inspector
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_syntax_check
      IMPORTING
        !iv_package            TYPE devclass
      RETURNING
        VALUE(ri_syntax_check) TYPE REF TO zif_abapgit_code_inspector
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_adhoc_code_inspector
      IMPORTING
        !iv_package                    TYPE devclass
        iv_test_name                   TYPE sci_tstval-testname
      RETURNING
        VALUE(ri_adhoc_code_inspector) TYPE REF TO zif_abapgit_code_inspector
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_abap_unit_tests
      IMPORTING
        !iv_package               TYPE devclass
      RETURNING
        VALUE(ri_abap_unit_tests) TYPE REF TO zif_abapgit_code_inspector
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_branch_overview
      IMPORTING
        !io_repo                  TYPE REF TO zcl_abapgit_repo_online
      RETURNING
        VALUE(ri_branch_overview) TYPE REF TO zif_abapgit_branch_overview
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_stage_logic
      RETURNING
        VALUE(ri_logic) TYPE REF TO zif_abapgit_stage_logic .
    CLASS-METHODS get_cts_api
      RETURNING
        VALUE(ri_cts_api) TYPE REF TO zif_abapgit_cts_api.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_sap_package,
        package  TYPE devclass,
        instance TYPE REF TO zif_abapgit_sap_package,
      END OF ty_sap_package .
    TYPES:
      tty_sap_package TYPE HASHED TABLE OF ty_sap_package
                        WITH UNIQUE KEY package .
    TYPES:
      BEGIN OF ty_code_inspector,
        package            TYPE devclass,
        check_variant_name TYPE sci_chkv,
        instance           TYPE REF TO zif_abapgit_code_inspector,
      END OF ty_code_inspector .
    TYPES:
      tty_code_inspector TYPE HASHED TABLE OF ty_code_inspector
                           WITH UNIQUE KEY package check_variant_name .
    TYPES:
      BEGIN OF ty_syntax_check,
        package  TYPE devclass,
        instance TYPE REF TO zif_abapgit_code_inspector,
      END OF ty_syntax_check .
    TYPES:
      tty_syntax_check TYPE HASHED TABLE OF ty_syntax_check
                         WITH UNIQUE KEY package .

    CLASS-DATA gi_tadir TYPE REF TO zif_abapgit_tadir .
    CLASS-DATA gt_sap_package TYPE tty_sap_package .
    CLASS-DATA gt_code_inspector TYPE tty_code_inspector .
    CLASS-DATA gt_syntax_check TYPE tty_syntax_check .
    CLASS-DATA gi_stage_logic TYPE REF TO zif_abapgit_stage_logic .
    CLASS-DATA gi_cts_api TYPE REF TO zif_abapgit_cts_api.
    CLASS-DATA gi_adhoc_code_inspector TYPE REF TO zif_abapgit_code_inspector.
ENDCLASS.
CLASS zcl_abapgit_file_status DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS status
      IMPORTING io_repo           TYPE REF TO zcl_abapgit_repo
                io_log            TYPE REF TO zcl_abapgit_log OPTIONAL
      RETURNING VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.

    CLASS-METHODS:
      calculate_status
        IMPORTING iv_devclass       TYPE devclass
                  io_dot            TYPE REF TO zcl_abapgit_dot_abapgit
                  it_local          TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
                  it_remote         TYPE zif_abapgit_definitions=&gt;ty_files_tt
                  it_cur_state      TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt
        RETURNING VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt
        RAISING   zcx_abapgit_exception,
      run_checks
        IMPORTING io_log     TYPE REF TO zcl_abapgit_log
                  it_results TYPE zif_abapgit_definitions=&gt;ty_results_tt
                  io_dot     TYPE REF TO zcl_abapgit_dot_abapgit
                  iv_top     TYPE devclass
        RAISING   zcx_abapgit_exception,
      build_existing
        IMPORTING is_local         TYPE zif_abapgit_definitions=&gt;ty_file_item
                  is_remote        TYPE zif_abapgit_definitions=&gt;ty_file
                  it_state         TYPE zif_abapgit_definitions=&gt;ty_file_signatures_ts
        RETURNING VALUE(rs_result) TYPE zif_abapgit_definitions=&gt;ty_result,
      build_new_local
        IMPORTING is_local         TYPE zif_abapgit_definitions=&gt;ty_file_item
        RETURNING VALUE(rs_result) TYPE zif_abapgit_definitions=&gt;ty_result,
      build_new_remote
        IMPORTING iv_devclass      TYPE devclass
                  io_dot           TYPE REF TO zcl_abapgit_dot_abapgit
                  is_remote        TYPE zif_abapgit_definitions=&gt;ty_file
                  it_items         TYPE zif_abapgit_definitions=&gt;ty_items_ts
                  it_state         TYPE zif_abapgit_definitions=&gt;ty_file_signatures_ts
        RETURNING VALUE(rs_result) TYPE zif_abapgit_definitions=&gt;ty_result
        RAISING   zcx_abapgit_exception,
      identify_object
        IMPORTING iv_filename TYPE string
                  iv_path     TYPE string
                  iv_devclass TYPE devclass
                  io_dot      TYPE REF TO zcl_abapgit_dot_abapgit
        EXPORTING es_item     TYPE zif_abapgit_definitions=&gt;ty_item
                  ev_is_xml   TYPE abap_bool
        RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_folder_logic DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS package_to_path
      IMPORTING
        !iv_top        TYPE devclass
        !io_dot        TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_package    TYPE devclass
      RETURNING
        VALUE(rv_path) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS path_to_package
      IMPORTING
        !iv_top                  TYPE devclass
        !io_dot                  TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_path                 TYPE string
        !iv_create_if_not_exists TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rv_package)        TYPE devclass
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_folder_logic .
  PROTECTED SECTION.
    METHODS get_parent
      IMPORTING
        !iv_package      TYPE devclass
      RETURNING
        VALUE(rv_parent) TYPE devclass.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_devclass_info,
        devclass  TYPE devclass,
        namespace TYPE namespace,
        parentcl  TYPE parentcl,
      END OF ty_devclass_info .
    TYPES:
      ty_devclass_info_tt TYPE SORTED TABLE OF ty_devclass_info
        WITH UNIQUE KEY devclass .
    DATA mt_parent TYPE ty_devclass_info_tt .
ENDCLASS.
CLASS zcl_abapgit_http_client DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS:
      constructor
        IMPORTING ii_client TYPE REF TO if_http_client,
      close,
      set_digest
        IMPORTING io_digest TYPE REF TO zcl_abapgit_http_digest,
      send_receive_close
        IMPORTING iv_data        TYPE xstring
        RETURNING VALUE(rv_data) TYPE xstring
        RAISING   zcx_abapgit_exception,
      get_cdata
        RETURNING VALUE(rv_value) TYPE string,
      check_http_200
        RAISING zcx_abapgit_exception,
      check_smart_response
        IMPORTING iv_expected_content_type TYPE string
                  iv_content_regex         TYPE string
        RAISING   zcx_abapgit_exception,
      send_receive
        RAISING zcx_abapgit_exception,
      set_headers
        IMPORTING iv_url     TYPE string
                  iv_service TYPE string
        RAISING   zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA: mi_client TYPE REF TO if_http_client,
          mo_digest TYPE REF TO zcl_abapgit_http_digest.

ENDCLASS.
CLASS zcl_abapgit_injector DEFINITION
  CREATE PRIVATE
  FOR TESTING .

  PUBLIC SECTION.

    CLASS-METHODS set_tadir
      IMPORTING
        !ii_tadir TYPE REF TO zif_abapgit_tadir .
    CLASS-METHODS set_sap_package
      IMPORTING
        !iv_package     TYPE devclass
        !ii_sap_package TYPE REF TO zif_abapgit_sap_package .
    CLASS-METHODS set_code_inspector
      IMPORTING
        !iv_package            TYPE devclass
        !iv_check_variant_name TYPE sci_chkv OPTIONAL
        !ii_code_inspector     TYPE REF TO zif_abapgit_code_inspector .
    CLASS-METHODS set_syntax_check
      IMPORTING
        !iv_package      TYPE devclass
        !ii_syntax_check TYPE REF TO zif_abapgit_code_inspector .
    CLASS-METHODS set_stage_logic
      IMPORTING
        !ii_logic TYPE REF TO zif_abapgit_stage_logic .
    CLASS-METHODS set_cts_api
      IMPORTING
        ii_cts_api TYPE REF TO zif_abapgit_cts_api.
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_longtexts DEFINITION
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS:
      serialize
        IMPORTING
          iv_object_name TYPE sobj_name
          iv_longtext_id TYPE dokil-id
          it_dokil       TYPE zif_abapgit_definitions=&gt;tty_dokil
          io_xml         TYPE REF TO zcl_abapgit_xml_output
        RAISING
          zcx_abapgit_exception,

      deserialize
        IMPORTING
          io_xml             TYPE REF TO zcl_abapgit_xml_input
          iv_master_language TYPE langu
        RAISING
          zcx_abapgit_exception,

      delete
        IMPORTING
          iv_object_name TYPE sobj_name
          iv_longtext_id TYPE dokil-id
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_longtext,
        dokil TYPE dokil,
        head  TYPE thead,
        lines TYPE tline_tab,
      END OF ty_longtext,
      tty_longtexts TYPE STANDARD TABLE OF ty_longtext
                         WITH NON-UNIQUE DEFAULT KEY.
    CONSTANTS:
      c_longtexts_name    TYPE string   VALUE &apos;LONGTEXTS&apos; ##NO_TEXT,
      c_docu_state_active TYPE dokstate VALUE &apos;A&apos; ##NO_TEXT.

ENDCLASS.
CLASS zcl_abapgit_merge DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !io_repo          TYPE REF TO zcl_abapgit_repo_online
        !iv_source_branch TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS get_conflicts
      RETURNING
        VALUE(rt_conflicts) TYPE zif_abapgit_definitions=&gt;tt_merge_conflict .
    METHODS get_result
      RETURNING
        VALUE(rs_merge) TYPE zif_abapgit_definitions=&gt;ty_merge .
    METHODS get_source_branch
      RETURNING
        VALUE(rv_source_branch) TYPE string .
    METHODS has_conflicts
      RETURNING
        VALUE(rv_conflicts_exists) TYPE boolean .
    METHODS resolve_conflict
      IMPORTING
        !is_conflict TYPE zif_abapgit_definitions=&gt;ty_merge_conflict
      RAISING
        zcx_abapgit_exception .
    METHODS run
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    TYPES:
      ty_ancestor_tt TYPE STANDARD TABLE OF zif_abapgit_definitions=&gt;ty_ancestor WITH DEFAULT KEY .

    DATA mo_repo TYPE REF TO zcl_abapgit_repo_online .
    DATA ms_merge TYPE zif_abapgit_definitions=&gt;ty_merge .
    DATA mt_conflicts TYPE zif_abapgit_definitions=&gt;tt_merge_conflict .
    DATA mt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt .
    DATA mv_source_branch TYPE string .

    METHODS all_files
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_expanded_tt .
    METHODS calculate_result
      RAISING
        zcx_abapgit_exception .
    METHODS fetch_git
      RETURNING
        VALUE(rt_objects) TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    METHODS find_ancestors
      IMPORTING
        !iv_commit          TYPE zif_abapgit_definitions=&gt;ty_sha1
      RETURNING
        VALUE(rt_ancestors) TYPE ty_ancestor_tt
      RAISING
        zcx_abapgit_exception .
    METHODS find_first_common
      IMPORTING
        !it_list1        TYPE ty_ancestor_tt
        !it_list2        TYPE ty_ancestor_tt
      RETURNING
        VALUE(rs_common) TYPE zif_abapgit_definitions=&gt;ty_ancestor
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_migrations DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS run
      RAISING zcx_abapgit_exception.

  PRIVATE SECTION.

    CLASS-METHODS rebuild_local_checksums_161112
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS local_dot_abapgit
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_news DEFINITION
  FINAL
  CREATE PRIVATE .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_log,
        version      TYPE string,
        pos_to_cur   TYPE i,
        is_header    TYPE abap_bool,
        is_important TYPE abap_bool,
        text         TYPE string,
      END OF ty_log .
    TYPES:
      tt_log TYPE STANDARD TABLE OF ty_log WITH DEFAULT KEY .

    CONSTANTS c_tail_length TYPE i VALUE 5 ##NO_TEXT.   &quot; Number of versions to display if no updates

    CLASS-METHODS create   &quot; TODO REFACTOR
      IMPORTING
        !io_repo           TYPE REF TO zcl_abapgit_repo
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_news
      RAISING
        zcx_abapgit_exception .
    METHODS get_log
      RETURNING
        VALUE(rt_log) TYPE tt_log .
    METHODS has_news
      RETURNING
        VALUE(rv_boolean) TYPE abap_bool .
    METHODS has_important
      RETURNING
        VALUE(rv_boolean) TYPE abap_bool .
    METHODS has_updates
      RETURNING
        VALUE(rv_boolean) TYPE abap_bool .
    METHODS has_unseen
      RETURNING
        VALUE(rv_boolean) TYPE abap_bool .
  PRIVATE SECTION.

    DATA mt_log TYPE tt_log .
    DATA mv_current_version TYPE string .
    DATA mv_lastseen_version TYPE string .
    DATA mv_latest_version TYPE string .

    CLASS-METHODS is_relevant
      IMPORTING
        !iv_url            TYPE string
      RETURNING
        VALUE(rv_relevant) TYPE abap_bool .
    METHODS latest_version
      RETURNING
        VALUE(rv_version) TYPE string .
    METHODS constructor
      IMPORTING
        !iv_rawdata          TYPE xstring
        !iv_lastseen_version TYPE string
        !iv_current_version  TYPE string .
    CLASS-METHODS version_to_numeric
      IMPORTING
        !iv_version       TYPE string
      RETURNING
        VALUE(rv_version) TYPE i .
    CLASS-METHODS normalize_version
      IMPORTING
        !iv_version       TYPE string
      RETURNING
        VALUE(rv_version) TYPE string .
    CLASS-METHODS compare_versions
      IMPORTING
        !iv_a            TYPE string
        !iv_b            TYPE string
      RETURNING
        VALUE(rv_result) TYPE i .
    CLASS-METHODS parse_line
      IMPORTING
        !iv_line            TYPE string
        !iv_current_version TYPE string
      RETURNING
        VALUE(rs_log)       TYPE ty_log .
    CLASS-METHODS parse
      IMPORTING
        !it_lines           TYPE string_table
        !iv_current_version TYPE string
      RETURNING
        VALUE(rt_log)       TYPE tt_log .
ENDCLASS.
CLASS zcl_abapgit_object_enhc DEFINITION
  INHERITING FROM zcl_abapgit_objects_super.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

    METHODS:
      constructor
        IMPORTING
          is_item     TYPE zif_abapgit_definitions=&gt;ty_item
          iv_language TYPE spras.

  PRIVATE SECTION.
    DATA:
      mv_composite_id TYPE enhcompositename.

ENDCLASS.
CLASS zcl_abapgit_objects DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      ty_types_tt TYPE STANDARD TABLE OF tadir-object WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_deserialization,
        obj     TYPE REF TO zif_abapgit_object,
        xml     TYPE REF TO zcl_abapgit_xml_input,
        package TYPE devclass,
        item    TYPE zif_abapgit_definitions=&gt;ty_item,
      END OF ty_deserialization .
    TYPES:
      ty_deserialization_tt TYPE STANDARD TABLE OF ty_deserialization WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_serialization,
        files TYPE zif_abapgit_definitions=&gt;ty_files_tt,
        item  TYPE zif_abapgit_definitions=&gt;ty_item,
      END OF ty_serialization .

    CLASS-METHODS serialize
      IMPORTING
        !is_item                 TYPE zif_abapgit_definitions=&gt;ty_item
        !iv_language             TYPE spras
      RETURNING
        VALUE(rs_files_and_item) TYPE zcl_abapgit_objects=&gt;ty_serialization
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS deserialize
      IMPORTING
        !io_repo                 TYPE REF TO zcl_abapgit_repo
        !is_checks               TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks
      RETURNING
        VALUE(rt_accessed_files) TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS deserialize_checks
      IMPORTING
        !io_repo         TYPE REF TO zcl_abapgit_repo
      RETURNING
        VALUE(rs_checks) TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delete
      IMPORTING
        !it_tadir  TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
        !is_checks TYPE zif_abapgit_definitions=&gt;ty_delete_checks OPTIONAL
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS jump
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=&gt;ty_item
        !iv_line_number TYPE i OPTIONAL
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS changed_by
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=&gt;ty_item
      RETURNING
        VALUE(rv_user) TYPE xubname
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS has_changed_since
      IMPORTING
        !is_item          TYPE zif_abapgit_definitions=&gt;ty_item
        !iv_timestamp     TYPE timestamp
      RETURNING
        VALUE(rv_changed) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_supported
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=&gt;ty_item
        !iv_native_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_bool)  TYPE abap_bool .
    CLASS-METHODS exists
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=&gt;ty_item
      RETURNING
        VALUE(rv_bool) TYPE abap_bool .
    CLASS-METHODS supported_list
      RETURNING
        VALUE(rt_types) TYPE ty_types_tt .
    CLASS-METHODS is_active
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=&gt;ty_item
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_obj_serializer_map,
             item     TYPE zif_abapgit_definitions=&gt;ty_item,
             metadata TYPE zif_abapgit_definitions=&gt;ty_metadata,
           END OF ty_obj_serializer_map,
           tty_obj_serializer_map
        TYPE SORTED TABLE OF ty_obj_serializer_map WITH UNIQUE KEY item.
    CLASS-DATA gt_obj_serializer_map TYPE tty_obj_serializer_map.

    CLASS-METHODS files_to_deserialize
      IMPORTING
        !io_repo          TYPE REF TO zcl_abapgit_repo
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS check_duplicates
      IMPORTING
        !it_files TYPE zif_abapgit_definitions=&gt;ty_files_tt
      RAISING
        zcx_abapgit_exception .

    CLASS-METHODS prioritize_deser
      IMPORTING
        !it_results       TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt .
    CLASS-METHODS class_name
      IMPORTING
        !is_item             TYPE zif_abapgit_definitions=&gt;ty_item
      RETURNING
        VALUE(rv_class_name) TYPE string .
    CLASS-METHODS warning_overwrite_adjust
      IMPORTING
        !it_overwrite TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      CHANGING
        !ct_results   TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS checks_adjust
      IMPORTING
        !io_repo    TYPE REF TO zcl_abapgit_repo
        !is_checks  TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks
      CHANGING
        !ct_results TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS warning_overwrite_find
      IMPORTING
        !it_results         TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RETURNING
        VALUE(rt_overwrite) TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS warning_package_adjust
      IMPORTING
        !io_repo      TYPE REF TO zcl_abapgit_repo
        !it_overwrite TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      CHANGING
        !ct_results   TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS warning_package_find
      IMPORTING
        !it_results         TYPE zif_abapgit_definitions=&gt;ty_results_tt
        !io_repo            TYPE REF TO zcl_abapgit_repo
      RETURNING
        VALUE(rt_overwrite) TYPE zif_abapgit_definitions=&gt;ty_overwrite_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_package_tree
      IMPORTING
        !iv_package TYPE devclass .
    CLASS-METHODS delete_obj
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS compare_remote_to_local
      IMPORTING
        !ii_object TYPE REF TO zif_abapgit_object
        !it_remote TYPE zif_abapgit_definitions=&gt;ty_files_tt
        !is_result TYPE zif_abapgit_definitions=&gt;ty_result
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS deserialize_objects
      IMPORTING
        it_objects TYPE ty_deserialization_tt
        iv_ddic    TYPE abap_bool DEFAULT abap_false
        iv_descr   TYPE string
      CHANGING
        ct_files   TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS check_objects_locked
      IMPORTING
        iv_language TYPE spras
        it_items    TYPE zif_abapgit_definitions=&gt;ty_items_tt
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS create_object
      IMPORTING
        is_item        TYPE zif_abapgit_definitions=&gt;ty_item
        iv_language    TYPE spras
        is_metadata    TYPE zif_abapgit_definitions=&gt;ty_metadata OPTIONAL
        iv_native_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ri_obj)  TYPE REF TO zif_abapgit_object
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS map_tadir_to_items
      IMPORTING
        it_tadir        TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RETURNING
        VALUE(rt_items) TYPE zif_abapgit_definitions=&gt;ty_items_tt.
    CLASS-METHODS map_results_to_items
      IMPORTING
        it_results      TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RETURNING
        VALUE(rt_items) TYPE zif_abapgit_definitions=&gt;ty_items_tt.
    CLASS-METHODS filter_files_to_deserialize
      IMPORTING
        it_results        TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt.
    CLASS-METHODS adjust_namespaces
      IMPORTING
        it_results        TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt.
ENDCLASS.
CLASS zcl_abapgit_objects_bridge DEFINITION FINAL CREATE PUBLIC INHERITING FROM zcl_abapgit_objects_super.

  PUBLIC SECTION.

    CLASS-METHODS class_constructor.

    METHODS constructor
      IMPORTING is_item TYPE zif_abapgit_definitions=&gt;ty_item
      RAISING   cx_sy_create_object_error.

    INTERFACES zif_abapgit_object.
    ALIASES mo_files FOR zif_abapgit_object~mo_files.

  PRIVATE SECTION.
    DATA: mo_plugin TYPE REF TO object.

    TYPES: BEGIN OF ty_s_objtype_map,
             obj_typ      TYPE trobjtype,
             plugin_class TYPE seoclsname,
           END OF ty_s_objtype_map,
           ty_t_objtype_map TYPE SORTED TABLE OF ty_s_objtype_map WITH UNIQUE KEY obj_typ.

    CLASS-DATA gt_objtype_map TYPE ty_t_objtype_map.

ENDCLASS.
CLASS zcl_abapgit_repo DEFINITION
  ABSTRACT
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS bind_listener
      IMPORTING
        ii_listener TYPE REF TO zif_abapgit_repo_listener.
    METHODS deserialize_checks
      RETURNING
        VALUE(rs_checks) TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks
      RAISING
        zcx_abapgit_exception .
    METHODS delete_checks
      RETURNING
        VALUE(rs_checks) TYPE zif_abapgit_definitions=&gt;ty_delete_checks
      RAISING
        zcx_abapgit_exception .
    METHODS constructor
      IMPORTING
        !is_data TYPE zif_abapgit_persistence=&gt;ty_repo .
    METHODS get_key
      RETURNING
        VALUE(rv_key) TYPE zif_abapgit_persistence=&gt;ty_value .
    METHODS get_name
          ABSTRACT
      RETURNING
        VALUE(rv_name) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS get_files_local
      IMPORTING
        !io_log         TYPE REF TO zcl_abapgit_log OPTIONAL
        !it_filter      TYPE zif_abapgit_definitions=&gt;ty_tadir_tt OPTIONAL
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      RAISING
        zcx_abapgit_exception .
    METHODS get_local_checksums
      RETURNING
        VALUE(rt_checksums) TYPE zif_abapgit_persistence=&gt;ty_local_checksum_tt .
    METHODS get_local_checksums_per_file
      RETURNING
        VALUE(rt_checksums) TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt .
    METHODS get_files_remote
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_files_tt
      RAISING
        zcx_abapgit_exception .
    METHODS get_package
      RETURNING
        VALUE(rv_package) TYPE zif_abapgit_persistence=&gt;ty_repo-package .
    METHODS get_dot_abapgit
      RETURNING
        VALUE(ro_dot_abapgit) TYPE REF TO zcl_abapgit_dot_abapgit .
    METHODS set_dot_abapgit
      IMPORTING
        !io_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize
      IMPORTING
        !is_checks TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks
      RAISING
        zcx_abapgit_exception .
    METHODS refresh
      IMPORTING
        !iv_drop_cache TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    METHODS update_local_checksums
      IMPORTING
        !it_files TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    METHODS rebuild_local_checksums
      RAISING
        zcx_abapgit_exception .
    METHODS find_remote_dot_abapgit
      RETURNING
        VALUE(ro_dot) TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapgit_exception .
    METHODS is_offline
      RETURNING
        VALUE(rv_offline) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS set_files_remote
      IMPORTING
        !it_files TYPE zif_abapgit_definitions=&gt;ty_files_tt .
    METHODS get_local_settings
      RETURNING
        VALUE(rs_settings) TYPE zif_abapgit_persistence=&gt;ty_repo-local_settings .
    METHODS set_local_settings
      IMPORTING
        !is_settings TYPE zif_abapgit_persistence=&gt;ty_repo-local_settings
      RAISING
        zcx_abapgit_exception .
    METHODS run_code_inspector
      RETURNING
        VALUE(rt_list) TYPE scit_alvlist
      RAISING
        zcx_abapgit_exception .
    METHODS has_remote_source
          ABSTRACT
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS status
      IMPORTING
        !io_log           TYPE REF TO zcl_abapgit_log OPTIONAL
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
    METHODS get_unnecessary_local_objs
      RETURNING
        VALUE(rt_unnecessary_local_objects) TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS switch_repo_type
      IMPORTING
        iv_offline TYPE abap_bool
      RAISING
        zcx_abapgit_exception .

  PROTECTED SECTION.

    DATA mt_local TYPE zif_abapgit_definitions=&gt;ty_files_item_tt .
    DATA mt_remote TYPE zif_abapgit_definitions=&gt;ty_files_tt .
    DATA mv_request_local_refresh TYPE abap_bool .
    DATA mv_last_serialization TYPE timestamp .
    DATA ms_data TYPE zif_abapgit_persistence=&gt;ty_repo .
    DATA mv_code_inspector_successful TYPE abap_bool .
    DATA mv_request_remote_refresh TYPE abap_bool .
    DATA mt_status TYPE zif_abapgit_definitions=&gt;ty_results_tt .

    METHODS set
      IMPORTING it_checksums       TYPE zif_abapgit_persistence=&gt;ty_local_checksum_tt OPTIONAL
                iv_url             TYPE zif_abapgit_persistence=&gt;ty_repo-url OPTIONAL
                iv_branch_name     TYPE zif_abapgit_persistence=&gt;ty_repo-branch_name OPTIONAL
                iv_head_branch     TYPE zif_abapgit_persistence=&gt;ty_repo-head_branch OPTIONAL
                iv_offline         TYPE zif_abapgit_persistence=&gt;ty_repo-offline OPTIONAL
                is_dot_abapgit     TYPE zif_abapgit_persistence=&gt;ty_repo-dot_abapgit OPTIONAL
                is_local_settings  TYPE zif_abapgit_persistence=&gt;ty_repo-local_settings OPTIONAL
                iv_deserialized_at TYPE zif_abapgit_persistence=&gt;ty_repo-deserialized_at OPTIONAL
                iv_deserialized_by TYPE zif_abapgit_persistence=&gt;ty_repo-deserialized_by OPTIONAL
      RAISING
                zcx_abapgit_exception .
    METHODS reset_status .
    METHODS reset_remote .
  PRIVATE SECTION.

    DATA mi_listener TYPE REF TO zif_abapgit_repo_listener .

    TYPES:
      ty_cache_tt TYPE SORTED TABLE OF zif_abapgit_definitions=&gt;ty_file_item
                             WITH NON-UNIQUE KEY item .
    METHODS notify_listener
      IMPORTING
        is_change_mask TYPE zif_abapgit_persistence=&gt;ty_repo_meta_mask
      RAISING
        zcx_abapgit_exception .
    METHODS apply_filter
      IMPORTING
        !it_filter TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      CHANGING
        !ct_tadir  TYPE zif_abapgit_definitions=&gt;ty_tadir_tt .
    METHODS build_dotabapgit_file
      RETURNING
        VALUE(rs_file) TYPE zif_abapgit_definitions=&gt;ty_file
      RAISING
        zcx_abapgit_exception .
    METHODS lookup_cache
      IMPORTING
        !it_cache TYPE ty_cache_tt
      EXPORTING
        !et_found TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      CHANGING
        !ct_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS update_last_deserialize
      RAISING
        zcx_abapgit_exception .
    METHODS conversion_exit_isola_output
      IMPORTING
        iv_spras        TYPE spras
      RETURNING
        VALUE(rv_spras) TYPE laiso.
ENDCLASS.
CLASS zcl_abapgit_repo_content_list DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING io_repo TYPE REF TO zcl_abapgit_repo.

    METHODS list
      IMPORTING iv_path              TYPE string
                iv_by_folders        TYPE abap_bool
                iv_changes_only      TYPE abap_bool
      RETURNING VALUE(rt_repo_items) TYPE zif_abapgit_definitions=&gt;tt_repo_items
      RAISING   zcx_abapgit_exception.

    METHODS get_log
      RETURNING VALUE(ro_log) TYPE REF TO zcl_abapgit_log.
  PRIVATE SECTION.
    CONSTANTS: BEGIN OF c_sortkey,
                 default    TYPE i VALUE 9999,
                 parent_dir TYPE i VALUE 0,
                 dir        TYPE i VALUE 1,
                 orphan     TYPE i VALUE 2,
                 changed    TYPE i VALUE 3,
                 inactive   TYPE i VALUE 4,
               END OF c_sortkey.

    DATA: mo_repo TYPE REF TO zcl_abapgit_repo,
          mo_log  TYPE REF TO zcl_abapgit_log.

    METHODS build_repo_items_local_only
      RETURNING VALUE(rt_repo_items) TYPE zif_abapgit_definitions=&gt;tt_repo_items
      RAISING   zcx_abapgit_exception.

    METHODS build_repo_items_with_remote
      RETURNING VALUE(rt_repo_items) TYPE zif_abapgit_definitions=&gt;tt_repo_items
      RAISING   zcx_abapgit_exception.

    METHODS build_folders
      IMPORTING iv_cur_dir    TYPE string
      CHANGING  ct_repo_items TYPE zif_abapgit_definitions=&gt;tt_repo_items
      RAISING   zcx_abapgit_exception.

    METHODS filter_changes
      CHANGING ct_repo_items TYPE zif_abapgit_definitions=&gt;tt_repo_items.
ENDCLASS.
CLASS zcl_abapgit_repo_offline DEFINITION
  INHERITING FROM zcl_abapgit_repo
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS get_name
      REDEFINITION .
    METHODS has_remote_source
      REDEFINITION .
  PROTECTED SECTION.

    METHODS reset_remote
      REDEFINITION .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_repo_online DEFINITION
  INHERITING FROM zcl_abapgit_repo
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_git_operations .

    ALIASES create_branch
      FOR zif_abapgit_git_operations~create_branch .
    ALIASES push
      FOR zif_abapgit_git_operations~push .

    METHODS get_url
      RETURNING
        VALUE(rv_url) TYPE zif_abapgit_persistence=&gt;ty_repo-url .
    METHODS get_branch_name
      RETURNING
        VALUE(rv_name) TYPE zif_abapgit_persistence=&gt;ty_repo-branch_name .
    METHODS set_url
      IMPORTING
        !iv_url TYPE zif_abapgit_persistence=&gt;ty_repo-url
      RAISING
        zcx_abapgit_exception .
    METHODS set_branch_name
      IMPORTING
        !iv_branch_name TYPE zif_abapgit_persistence=&gt;ty_repo-branch_name
      RAISING
        zcx_abapgit_exception .
    METHODS get_sha1_remote
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_definitions=&gt;ty_sha1
      RAISING
        zcx_abapgit_exception .
    METHODS get_objects
      RETURNING
        VALUE(rt_objects) TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    METHODS get_files_remote
      REDEFINITION .
    METHODS get_name
      REDEFINITION .
    METHODS rebuild_local_checksums
      REDEFINITION .
    METHODS has_remote_source
      REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt .
    DATA mv_branch TYPE zif_abapgit_definitions=&gt;ty_sha1 .

    METHODS handle_stage_ignore
      IMPORTING
        !io_stage TYPE REF TO zcl_abapgit_stage
      RAISING
        zcx_abapgit_exception .
    METHODS set_objects
      IMPORTING
        !it_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt
      RAISING
        zcx_abapgit_exception .
    METHODS fetch_remote
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_repo_srv DEFINITION
  FINAL
  CREATE PRIVATE .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_repo_srv .
    INTERFACES zif_abapgit_repo_listener .

    CLASS-METHODS get_instance
      RETURNING
        VALUE(ri_srv) TYPE REF TO zif_abapgit_repo_srv .

  PRIVATE SECTION.

    ALIASES delete
      FOR zif_abapgit_repo_srv~delete .
    ALIASES get
      FOR zif_abapgit_repo_srv~get .
    ALIASES list
      FOR zif_abapgit_repo_srv~list .
    ALIASES validate_package
      FOR zif_abapgit_repo_srv~validate_package .

    CLASS-DATA gi_ref TYPE REF TO zif_abapgit_repo_srv .
    DATA mv_init TYPE abap_bool VALUE abap_false ##NO_TEXT.
    DATA mt_list TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt .

    METHODS refresh
      RAISING
        zcx_abapgit_exception .
    METHODS is_sap_object_allowed
      RETURNING
        VALUE(rv_allowed) TYPE abap_bool .
    METHODS instantiate_and_add
      IMPORTING
        !is_repo_meta TYPE zif_abapgit_persistence=&gt;ty_repo
      RETURNING
        VALUE(ro_repo) TYPE REF TO zcl_abapgit_repo
      RAISING
        zcx_abapgit_exception .
    METHODS add
      IMPORTING
        !io_repo TYPE REF TO zcl_abapgit_repo
      RAISING
        zcx_abapgit_exception .
    METHODS reinstantiate_repo
      IMPORTING
        !iv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key
        !is_meta TYPE zif_abapgit_persistence=&gt;ty_repo_xml
      RAISING
        zcx_abapgit_exception .
    METHODS validate_sub_super_packages
      IMPORTING
        !iv_package TYPE devclass
        !it_repos   TYPE zif_abapgit_persistence=&gt;tt_repo
      RAISING
        zcx_abapgit_exception .

ENDCLASS.
CLASS zcl_abapgit_sap_package DEFINITION CREATE PRIVATE
    FRIENDS ZCL_ABAPGIT_factory.

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING iv_package TYPE devclass.

    INTERFACES: zif_abapgit_sap_package.

  PRIVATE SECTION.
    DATA: mv_package TYPE devclass.

    ALIASES:
      create FOR zif_abapgit_sap_package~create,
      create_local FOR zif_abapgit_sap_package~create_local.

ENDCLASS.
CLASS zcl_abapgit_serialize DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS on_end_of_task
      IMPORTING
        !p_task TYPE clike .
    METHODS serialize
      IMPORTING
        !it_tadir            TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
        !iv_language         TYPE langu DEFAULT sy-langu
        !io_log              TYPE REF TO zcl_abapgit_log OPTIONAL
        !iv_force_sequential TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rt_files)      TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

    CLASS-DATA gv_max TYPE i .
    DATA mt_files TYPE zif_abapgit_definitions=&gt;ty_files_item_tt .
    DATA mv_free TYPE i .
    DATA mo_log TYPE REF TO zcl_abapgit_log .

    METHODS add_to_return
      IMPORTING
        !iv_path      TYPE string
        !is_fils_item TYPE zcl_abapgit_objects=&gt;ty_serialization .
    METHODS run_parallel
      IMPORTING
        !iv_group    TYPE rzlli_apcl
        !is_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir
        !iv_language TYPE langu
        !iv_task     TYPE sychar32
      RAISING
        zcx_abapgit_exception .
    METHODS run_sequential
      IMPORTING
        !is_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir
        !iv_language TYPE langu
      RAISING
        zcx_abapgit_exception .
    METHODS determine_max_threads
      IMPORTING
        !iv_force_sequential TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_threads)    TYPE i
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_settings DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    CONSTANTS: c_commitmsg_comment_length_dft TYPE i VALUE 50.
    CONSTANTS: c_commitmsg_body_size_dft      TYPE i VALUE 72.

    METHODS:
      set_proxy_url
        IMPORTING
          iv_url TYPE string,
      set_proxy_port
        IMPORTING
          iv_port TYPE string,
      set_proxy_authentication
        IMPORTING
          iv_auth TYPE abap_bool,
      get_proxy_url
        RETURNING
          VALUE(rv_proxy_url) TYPE string,
      get_proxy_port
        RETURNING
          VALUE(rv_port) TYPE string,
      get_proxy_authentication
        RETURNING
          VALUE(rv_auth) TYPE abap_bool,
      set_run_critical_tests
        IMPORTING
          iv_run TYPE abap_bool,
      get_run_critical_tests
        RETURNING
          VALUE(rv_run) TYPE abap_bool,
      set_experimental_features
        IMPORTING
          iv_run TYPE abap_bool,
      get_experimental_features
        RETURNING
          VALUE(rv_run) TYPE abap_bool,
      set_max_lines
        IMPORTING iv_lines TYPE i,
      get_max_lines
        RETURNING
          VALUE(rv_lines) TYPE i,
      set_adt_jump_enanbled
        IMPORTING
          iv_adt_jump_enabled TYPE abap_bool,
      get_adt_jump_enabled
        RETURNING
          VALUE(rv_adt_jump_enabled) TYPE abap_bool,
      set_commitmsg_comment_length
        IMPORTING
          iv_length TYPE i,
      get_commitmsg_comment_length
        RETURNING
          VALUE(rv_length) TYPE i,
      set_commitmsg_body_size
        IMPORTING
          iv_length TYPE i,
      get_commitmsg_body_size
        RETURNING
          VALUE(rv_length) TYPE i,
      get_settings_xml
        RETURNING
          VALUE(rv_settings_xml) TYPE string
        RAISING
          zcx_abapgit_exception,
      get_user_settings
        RETURNING
          VALUE(rs_settings) TYPE zif_abapgit_definitions=&gt;ty_s_user_settings
        RAISING
          zcx_abapgit_exception,
      set_xml_settings
        IMPORTING
          iv_settings_xml TYPE string
        RAISING
          zcx_abapgit_exception,
      set_defaults,
      set_user_settings
        IMPORTING
          is_user_settings TYPE zif_abapgit_definitions=&gt;ty_s_user_settings,
      get_show_default_repo
        RETURNING
          VALUE(rv_show_default_repo) TYPE abap_bool,
      set_show_default_repo
        IMPORTING
          iv_show_default_repo TYPE abap_bool,
      set_link_hints_enabled
        IMPORTING
          iv_link_hints_enabled TYPE abap_bool,
      get_link_hints_enabled
        RETURNING
          VALUE(rv_link_hints_enabled) TYPE abap_bool
        RAISING
          zcx_abapgit_exception,
      set_link_hint_key
        IMPORTING
          iv_link_hint_key TYPE char01,
      get_link_hint_key
        RETURNING
          VALUE(rv_link_hint_key) TYPE char01,
      get_link_hint_background_color
        RETURNING
          VALUE(rv_background_color) TYPE string,
      set_link_hint_background_color
        IMPORTING
          iv_background_color TYPE string,
      set_hotkeys
        IMPORTING
          it_hotkeys TYPE zif_abapgit_definitions=&gt;tty_hotkey,
      get_hotkeys
        RETURNING
          VALUE(rt_hotkeys) TYPE zif_abapgit_definitions=&gt;tty_hotkey
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_s_settings,
             proxy_url                TYPE string,
             proxy_port               TYPE string,
             proxy_auth               TYPE string,
             run_critical_tests       TYPE abap_bool,
             experimental_features    TYPE abap_bool,
             commitmsg_comment_length TYPE i,
             commitmsg_body_size      TYPE i,
           END OF ty_s_settings.

    DATA: ms_settings      TYPE ty_s_settings,
          ms_user_settings TYPE zif_abapgit_definitions=&gt;ty_s_user_settings.

    METHODS:
      set_default_link_hint_key,
      set_default_link_hint_bg_color.

ENDCLASS.
CLASS zcl_abapgit_skip_objects DEFINITION FINAL CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS:
      skip_sadl_generated_objects
        IMPORTING
          it_tadir        TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
          io_log          TYPE REF TO zcl_abapgit_log OPTIONAL
        RETURNING
          VALUE(rt_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir_tt.
  PRIVATE SECTION.
    METHODS:
      has_sadl_superclass
        IMPORTING
          is_class         TYPE zif_abapgit_definitions=&gt;ty_tadir
        RETURNING
          VALUE(rv_return) TYPE abap_bool.

ENDCLASS.
CLASS zcl_abapgit_stage DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      ty_method TYPE c LENGTH 1 .
    TYPES:
      BEGIN OF ty_stage,
        file   TYPE zif_abapgit_definitions=&gt;ty_file,
        method TYPE ty_method,
      END OF ty_stage .
    TYPES:
      ty_stage_tt TYPE SORTED TABLE OF ty_stage
            WITH UNIQUE KEY file-path file-filename .

    CONSTANTS:
      BEGIN OF c_method,
        add    TYPE ty_method VALUE &apos;A&apos;,
        rm     TYPE ty_method VALUE &apos;R&apos;,
        ignore TYPE ty_method VALUE &apos;I&apos;,
        skip   TYPE ty_method VALUE &apos;?&apos;,
      END OF c_method .

    CLASS-METHODS method_description
      IMPORTING
        !iv_method            TYPE ty_method
      RETURNING
        VALUE(rv_description) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS constructor
      IMPORTING
        !iv_merge_source TYPE zif_abapgit_definitions=&gt;ty_sha1 OPTIONAL .
    METHODS add
      IMPORTING
        !iv_path     TYPE zif_abapgit_definitions=&gt;ty_file-path
        !iv_filename TYPE zif_abapgit_definitions=&gt;ty_file-filename
        !iv_data     TYPE xstring
      RAISING
        zcx_abapgit_exception .
    METHODS reset
      IMPORTING
        !iv_path     TYPE zif_abapgit_definitions=&gt;ty_file-path
        !iv_filename TYPE zif_abapgit_definitions=&gt;ty_file-filename
      RAISING
        zcx_abapgit_exception .
    METHODS rm
      IMPORTING
        !iv_path     TYPE zif_abapgit_definitions=&gt;ty_file-path
        !iv_filename TYPE zif_abapgit_definitions=&gt;ty_file-filename
      RAISING
        zcx_abapgit_exception .
    METHODS ignore
      IMPORTING
        !iv_path     TYPE zif_abapgit_definitions=&gt;ty_file-path
        !iv_filename TYPE zif_abapgit_definitions=&gt;ty_file-filename
      RAISING
        zcx_abapgit_exception .
    METHODS get_merge_source
      RETURNING
        VALUE(rv_source) TYPE zif_abapgit_definitions=&gt;ty_sha1 .
    METHODS count
      RETURNING
        VALUE(rv_count) TYPE i .
    METHODS get_all
      RETURNING
        VALUE(rt_stage) TYPE ty_stage_tt .
  PRIVATE SECTION.

    DATA mt_stage TYPE ty_stage_tt .
    DATA mv_merge_source TYPE zif_abapgit_definitions=&gt;ty_sha1 .

    METHODS append
      IMPORTING
        !iv_path     TYPE zif_abapgit_definitions=&gt;ty_file-path
        !iv_filename TYPE zif_abapgit_definitions=&gt;ty_file-filename
        !iv_method   TYPE ty_method
        !iv_data     TYPE xstring OPTIONAL
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_stage_logic DEFINITION
  CREATE PRIVATE

  FRIENDS ZCL_ABAPGIT_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_stage_logic .
  PRIVATE SECTION.
    CLASS-METHODS:
      remove_ignored
        IMPORTING io_repo  TYPE REF TO zcl_abapgit_repo_online
        CHANGING  cs_files TYPE zif_abapgit_definitions=&gt;ty_stage_files,
      remove_identical
        CHANGING cs_files TYPE zif_abapgit_definitions=&gt;ty_stage_files.

ENDCLASS.
CLASS zcl_abapgit_syntax_check DEFINITION
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_factory.
  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_code_inspector.

    METHODS:
      constructor
        IMPORTING
          iv_package TYPE devclass
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.
    DATA:
      mo_adhoc_code_inspector TYPE REF TO zif_abapgit_code_inspector.

ENDCLASS.
CLASS zcl_abapgit_tadir DEFINITION
  FINAL
  CREATE PRIVATE
  FRIENDS ZCL_ABAPGIT_factory .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_tadir .

  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS exists
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=&gt;ty_item
      RETURNING
        VALUE(rv_exists) TYPE abap_bool .
    METHODS check_exists
      IMPORTING
        !it_tadir       TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RETURNING
        VALUE(rt_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS build
      IMPORTING
        !iv_package            TYPE tadir-devclass
        !iv_top                TYPE tadir-devclass
        !io_dot                TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
        !iv_only_local_objects TYPE abap_bool
        !io_log                TYPE REF TO zcl_abapgit_log OPTIONAL
        !io_folder_logic       TYPE REF TO zcl_abapgit_folder_logic OPTIONAL
      RETURNING
        VALUE(rt_tadir)        TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception.
ENDCLASS.
CLASS zcl_abapgit_transport DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS zip
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS to_tadir
      IMPORTING
        !it_transport_headers TYPE trwbo_request_headers
      RETURNING
        VALUE(rt_tadir)       TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CLASS-METHODS read_requests
      IMPORTING
        !it_trkorr         TYPE trwbo_request_headers
      RETURNING
        VALUE(rt_requests) TYPE trwbo_requests
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS find_top_package
      IMPORTING
        !it_tadir         TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RETURNING
        VALUE(rv_package) TYPE devclass .
    CLASS-METHODS resolve
      IMPORTING
        !it_requests    TYPE trwbo_requests
      RETURNING
        VALUE(rt_tadir) TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
ENDCLASS.
CLASS zcl_abapgit_transport_2_branch DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS create
      IMPORTING
        !io_repository          TYPE REF TO zcl_abapgit_repo_online
        !is_transport_to_branch TYPE zif_abapgit_definitions=&gt;ty_transport_to_branch
        !it_transport_objects   TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

    METHODS generate_commit_message
      IMPORTING
        !is_transport_to_branch TYPE zif_abapgit_definitions=&gt;ty_transport_to_branch
      RETURNING
        VALUE(rs_comment)       TYPE zif_abapgit_definitions=&gt;ty_comment .
    METHODS stage_transport_objects
      IMPORTING
        !it_transport_objects TYPE zif_abapgit_definitions=&gt;ty_tadir_tt
        !io_stage             TYPE REF TO zcl_abapgit_stage
        !is_stage_objects     TYPE zif_abapgit_definitions=&gt;ty_stage_files
        !it_object_statuses   TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.
CLASS zcl_abapgit_transport_objects DEFINITION
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !it_transport_objects TYPE zif_abapgit_definitions=&gt;ty_tadir_tt .
    METHODS to_stage
      IMPORTING
        !io_stage           TYPE REF TO zcl_abapgit_stage
        !is_stage_objects   TYPE zif_abapgit_definitions=&gt;ty_stage_files
        !it_object_statuses TYPE zif_abapgit_definitions=&gt;ty_results_tt
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    DATA mt_transport_objects TYPE zif_abapgit_definitions=&gt;ty_tadir_tt .
ENDCLASS.
CLASS zcl_abapgit_zip DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS import
      IMPORTING
        !iv_key TYPE zif_abapgit_persistence=&gt;ty_value
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS export
      IMPORTING
        !io_repo   TYPE REF TO zcl_abapgit_repo
        !it_filter TYPE zif_abapgit_definitions=&gt;ty_tadir_tt OPTIONAL
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS export_package
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
    CLASS-METHODS export_object
      RAISING
        zcx_abapgit_exception
        zcx_abapgit_cancel .
  PRIVATE SECTION.
    CLASS-METHODS file_upload
      RETURNING VALUE(rv_xstr) TYPE xstring
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS unzip_file
      IMPORTING iv_xstr         TYPE xstring
      RETURNING VALUE(rt_files) TYPE zif_abapgit_definitions=&gt;ty_files_tt
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS normalize_path
      CHANGING ct_files TYPE zif_abapgit_definitions=&gt;ty_files_tt
      RAISING  zcx_abapgit_exception.

    CLASS-METHODS filename
      IMPORTING iv_str      TYPE string
      EXPORTING ev_path     TYPE string
                ev_filename TYPE string
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS file_download
      IMPORTING iv_package TYPE devclass
                iv_xstr    TYPE xstring
      RAISING   zcx_abapgit_exception.

    CLASS-METHODS encode_files
      IMPORTING it_files       TYPE zif_abapgit_definitions=&gt;ty_files_item_tt
      RETURNING VALUE(rv_xstr) TYPE xstring
      RAISING   zcx_abapgit_exception.

ENDCLASS.
CLASS zcl_abapgit_zlib DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_decompress,
        raw            TYPE xstring,
        compressed_len TYPE i,
      END OF ty_decompress .

    CLASS-METHODS decompress
      IMPORTING
        !iv_compressed TYPE xsequence
      RETURNING
        VALUE(rs_data) TYPE ty_decompress .

  PRIVATE SECTION.
    CONSTANTS: c_maxdcodes TYPE i VALUE 30.

    CLASS-DATA: gv_out      TYPE xstring,
                go_lencode  TYPE REF TO zcl_abapgit_zlib_huffman,
                go_distcode TYPE REF TO zcl_abapgit_zlib_huffman,
                go_stream   TYPE REF TO zcl_abapgit_zlib_stream.

    TYPES: BEGIN OF ty_pair,
             length   TYPE i,
             distance TYPE i,
           END OF ty_pair.

    CLASS-METHODS:
      decode
        IMPORTING io_huffman       TYPE REF TO zcl_abapgit_zlib_huffman
        RETURNING VALUE(rv_symbol) TYPE i,
      map_length
        IMPORTING iv_code          TYPE i
        RETURNING VALUE(rv_length) TYPE i,
      map_distance
        IMPORTING iv_code            TYPE i
        RETURNING VALUE(rv_distance) TYPE i,
      dynamic,
      fixed,
      read_pair
        IMPORTING iv_length      TYPE i
        RETURNING VALUE(rs_pair) TYPE ty_pair,
      copy_out
        IMPORTING is_pair TYPE ty_pair.

ENDCLASS.
CLASS zcl_abapgit_zlib_convert DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS hex_to_bits
      IMPORTING
        !iv_hex        TYPE xsequence
      RETURNING
        VALUE(rv_bits) TYPE string .
    CLASS-METHODS bits_to_int
      IMPORTING
        !iv_bits      TYPE clike
      RETURNING
        VALUE(rv_int) TYPE i .
    CLASS-METHODS int_to_hex
      IMPORTING
        !iv_int       TYPE i
      RETURNING
        VALUE(rv_hex) TYPE xstring .
ENDCLASS.
CLASS zcl_abapgit_zlib_huffman DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.
    TYPES: ty_lengths TYPE STANDARD TABLE OF i WITH DEFAULT KEY.

    CONSTANTS: c_maxbits TYPE i VALUE 15.

    METHODS:
      constructor
        IMPORTING it_lengths TYPE ty_lengths,
      get_count
        IMPORTING iv_index        TYPE i
        RETURNING VALUE(rv_value) TYPE i,
      get_symbol
        IMPORTING iv_index        TYPE i
        RETURNING VALUE(rv_value) TYPE i.

  PRIVATE SECTION.

    DATA: mt_count  TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
          mt_symbol TYPE STANDARD TABLE OF i WITH DEFAULT KEY.

ENDCLASS.
CLASS zcl_abapgit_zlib_stream DEFINITION
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_data TYPE xstring .
    METHODS take_bits
      IMPORTING
        !iv_length     TYPE i
      RETURNING
        VALUE(rv_bits) TYPE string .
    METHODS take_int
      IMPORTING
        !iv_length    TYPE i
      RETURNING
        VALUE(rv_int) TYPE i .
    METHODS remaining
      RETURNING
        VALUE(rv_length) TYPE i .
  PRIVATE SECTION.
    DATA: mv_compressed TYPE xstring,
          mv_bits       TYPE string.

ENDCLASS.
CLASS ZCL_ABAPGIT_ZLIB_STREAM IMPLEMENTATION.
  METHOD constructor.

    mv_compressed = iv_data.

  ENDMETHOD.
  METHOD remaining.

    rv_length = xstrlen( mv_compressed ) + 1.

  ENDMETHOD.
  METHOD take_bits.

    DATA: lv_left  TYPE i,
          lv_index TYPE i,
          lv_x     TYPE x LENGTH 1.
    WHILE strlen( rv_bits ) &lt; iv_length.
      IF mv_bits IS INITIAL.
        lv_x = mv_compressed(1).
        mv_bits = zcl_abapgit_zlib_convert=&gt;hex_to_bits( lv_x ).
        mv_compressed = mv_compressed+1.
      ENDIF.
      lv_left = iv_length - strlen( rv_bits ).
      IF lv_left &gt;= strlen( mv_bits ).
        CONCATENATE mv_bits rv_bits INTO rv_bits.
        CLEAR mv_bits.
      ELSE.
        lv_index = strlen( mv_bits ) - lv_left.
        CONCATENATE mv_bits+lv_index(lv_left) rv_bits INTO rv_bits.
        mv_bits = mv_bits(lv_index).
      ENDIF.

    ENDWHILE.

  ENDMETHOD.
  METHOD take_int.

    rv_int = zcl_abapgit_zlib_convert=&gt;bits_to_int( take_bits( iv_length ) ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ZLIB_HUFFMAN IMPLEMENTATION.
  METHOD constructor.

    DATA: lv_index  TYPE i,
          lt_offset TYPE TABLE OF i,
          lv_length LIKE LINE OF it_lengths,
          lv_prev   TYPE i,
          lv_count  LIKE LINE OF mt_count.

    FIELD-SYMBOLS: &lt;lv_offset&gt; LIKE LINE OF lt_offset,
                   &lt;lv_symbol&gt; LIKE LINE OF mt_symbol,
                   &lt;lv_i&gt;      LIKE LINE OF it_lengths.
    DO c_maxbits TIMES.
      APPEND 0 TO mt_count.
    ENDDO.
    LOOP AT it_lengths INTO lv_index.
      IF lv_index = 0.
        CONTINUE.
      ENDIF.
      READ TABLE mt_count INDEX lv_index ASSIGNING &lt;lv_i&gt;.
      ASSERT sy-subrc = 0.
      &lt;lv_i&gt; = &lt;lv_i&gt; + 1.
    ENDLOOP.

************

    APPEND 0 TO lt_offset.
    DO c_maxbits - 1 TIMES.
      READ TABLE mt_count INDEX sy-index INTO lv_count.
      ASSERT sy-subrc = 0.
      lv_prev = lv_prev + lv_count.
      APPEND lv_prev TO lt_offset.
    ENDDO.

    DO lines( it_lengths ) TIMES.
      APPEND 0 TO mt_symbol.
    ENDDO.
    DO lines( it_lengths ) TIMES.
      lv_index = sy-index.
      READ TABLE it_lengths INDEX lv_index INTO lv_length.
      ASSERT sy-subrc = 0.
      IF lv_length = 0.
        CONTINUE.
      ENDIF.
      READ TABLE lt_offset INDEX lv_length ASSIGNING &lt;lv_offset&gt;.
      ASSERT sy-subrc = 0.
      READ TABLE mt_symbol INDEX &lt;lv_offset&gt; + 1 ASSIGNING &lt;lv_symbol&gt;.
      ASSERT sy-subrc = 0.
      &lt;lv_symbol&gt; = lv_index - 1.
      &lt;lv_offset&gt; = &lt;lv_offset&gt; + 1.
    ENDDO.

  ENDMETHOD.
  METHOD get_count.
    READ TABLE mt_count INDEX iv_index INTO rv_value.     &quot;#EC CI_SUBRC
  ENDMETHOD.
  METHOD get_symbol.
    READ TABLE mt_symbol INDEX iv_index INTO rv_value.    &quot;#EC CI_SUBRC
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ZLIB_CONVERT IMPLEMENTATION.
  METHOD bits_to_int.

    DATA: lv_c    TYPE c LENGTH 1,
          lv_bits TYPE string.

    lv_bits = iv_bits.

    WHILE NOT lv_bits IS INITIAL.
      lv_c = lv_bits.
      rv_int = rv_int * 2.
      rv_int = rv_int + lv_c.
      lv_bits = lv_bits+1.
    ENDWHILE.

  ENDMETHOD.
  METHOD hex_to_bits.

    DATA: lv_x   TYPE x LENGTH 1,
          lv_c   TYPE c LENGTH 1,
          lv_bit TYPE i,
          lv_hex TYPE xstring.
    lv_hex = iv_hex.
    WHILE NOT lv_hex IS INITIAL.
      lv_x = lv_hex.
      DO 8 TIMES.
        lv_bit = sy-index.
        GET BIT lv_bit OF lv_x INTO lv_c.
        CONCATENATE rv_bits lv_c INTO rv_bits.
      ENDDO.
      lv_hex = lv_hex+1.
    ENDWHILE.

  ENDMETHOD.
  METHOD int_to_hex.

    DATA: lv_x TYPE x.
    lv_x = iv_int.
    rv_hex = lv_x.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ZLIB IMPLEMENTATION.
  METHOD copy_out.

* copy one byte at a time, it is not possible to copy using
* string offsets, as it might copy data that does not exist
* in mv_out yet

    DATA: lv_distance TYPE i,
          lv_index    TYPE i,
          lv_x        TYPE x LENGTH 1.
    lv_distance = xstrlen( gv_out ) - is_pair-distance.
    DO is_pair-length TIMES.
      lv_index = sy-index - 1 + lv_distance.
      lv_x = gv_out+lv_index(1).
      CONCATENATE gv_out lv_x INTO gv_out IN BYTE MODE.
    ENDDO.

  ENDMETHOD.
  METHOD decode.

    DATA: lv_bit   TYPE c LENGTH 1,
          lv_len   TYPE i,
          lv_count TYPE i,
          lv_code  TYPE i,
          lv_index TYPE i,
          lv_first TYPE i,
          lv_bits  TYPE string.
    DO zcl_abapgit_zlib_huffman=&gt;c_maxbits TIMES.
      lv_len = sy-index.

      lv_bit = go_stream-&gt;take_bits( 1 ).
      CONCATENATE lv_bits lv_bit INTO lv_bits.
      lv_code = zcl_abapgit_zlib_convert=&gt;bits_to_int( lv_bits ).
      lv_count = io_huffman-&gt;get_count( lv_len ).

      IF lv_code - lv_count &lt; lv_first.
        rv_symbol = io_huffman-&gt;get_symbol( lv_index + lv_code - lv_first + 1 ).
        RETURN.
      ENDIF.
      lv_index = lv_index + lv_count.
      lv_first = lv_first + lv_count.
      lv_first = lv_first * 2.
    ENDDO.

  ENDMETHOD.
  METHOD decompress.

    DATA: lv_x      TYPE x LENGTH 1,
          lv_symbol TYPE i,
          lv_bfinal TYPE c LENGTH 1,
          lv_btype  TYPE c LENGTH 2.
    IF iv_compressed IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR gv_out.
    CREATE OBJECT go_stream
      EXPORTING
        iv_data = iv_compressed.

    DO.
      lv_bfinal = go_stream-&gt;take_bits( 1 ).

      lv_btype = go_stream-&gt;take_bits( 2 ).
      CASE lv_btype.
        WHEN &apos;01&apos;.
          fixed( ).
        WHEN &apos;10&apos;.
          dynamic( ).
        WHEN OTHERS.
          ASSERT 1 = 0.
      ENDCASE.

      DO.
        lv_symbol = decode( go_lencode ).

        IF lv_symbol &lt; 256.
          lv_x = zcl_abapgit_zlib_convert=&gt;int_to_hex( lv_symbol ).
          CONCATENATE gv_out lv_x INTO gv_out IN BYTE MODE.
        ELSEIF lv_symbol = 256.
          EXIT.
        ELSE.
          copy_out( read_pair( lv_symbol ) ).
        ENDIF.

      ENDDO.

      IF lv_bfinal = &apos;1&apos;.
        EXIT.
      ENDIF.

    ENDDO.

    rs_data-raw = gv_out.
    rs_data-compressed_len = xstrlen( iv_compressed ) - go_stream-&gt;remaining( ).

  ENDMETHOD.
  METHOD dynamic.

    DATA: lv_nlen    TYPE i,
          lv_ndist   TYPE i,
          lv_ncode   TYPE i,
          lv_index   TYPE i,
          lv_length  TYPE i,
          lv_symbol  TYPE i,
          lt_order   TYPE TABLE OF i,
          lt_lengths TYPE zcl_abapgit_zlib_huffman=&gt;ty_lengths,
          lt_dists   TYPE zcl_abapgit_zlib_huffman=&gt;ty_lengths.

    FIELD-SYMBOLS: &lt;lv_length&gt; LIKE LINE OF lt_lengths.
    APPEND 16 TO lt_order.
    APPEND 17 TO lt_order.
    APPEND 18 TO lt_order.
    APPEND 0 TO lt_order.
    APPEND 8 TO lt_order.
    APPEND 7 TO lt_order.
    APPEND 9 TO lt_order.
    APPEND 6 TO lt_order.
    APPEND 10 TO lt_order.
    APPEND 5 TO lt_order.
    APPEND 11 TO lt_order.
    APPEND 4 TO lt_order.
    APPEND 12 TO lt_order.
    APPEND 3 TO lt_order.
    APPEND 13 TO lt_order.
    APPEND 2 TO lt_order.
    APPEND 14 TO lt_order.
    APPEND 1 TO lt_order.
    APPEND 15 TO lt_order.

    lv_nlen = go_stream-&gt;take_int( 5 ) + 257.
    lv_ndist = go_stream-&gt;take_int( 5 ) + 1.
    lv_ncode = go_stream-&gt;take_int( 4 ) + 4.

    DO 19 TIMES.
      APPEND 0 TO lt_lengths.
    ENDDO.

    DO lv_ncode TIMES.
      READ TABLE lt_order INDEX sy-index INTO lv_index.
      ASSERT sy-subrc = 0.
      lv_index = lv_index + 1.
      READ TABLE lt_lengths INDEX lv_index ASSIGNING &lt;lv_length&gt;.
      ASSERT sy-subrc = 0.
      &lt;lv_length&gt; = go_stream-&gt;take_int( 3 ).
    ENDDO.

    CREATE OBJECT go_lencode
      EXPORTING
        it_lengths = lt_lengths.

    CLEAR lt_lengths.
    WHILE lines( lt_lengths ) &lt; lv_nlen + lv_ndist.
      lv_symbol = decode( go_lencode ).

      IF lv_symbol &lt; 16.
        APPEND lv_symbol TO lt_lengths.
      ELSE.
        lv_length = 0.
        IF lv_symbol = 16.
          READ TABLE lt_lengths INDEX lines( lt_lengths ) INTO lv_length.
          ASSERT sy-subrc = 0.
          lv_symbol = go_stream-&gt;take_int( 2 ) + 3.
        ELSEIF lv_symbol = 17.
          lv_symbol = go_stream-&gt;take_int( 3 ) + 3.
        ELSE.
          lv_symbol = go_stream-&gt;take_int( 7 ) + 11.
        ENDIF.
        DO lv_symbol TIMES.
          APPEND lv_length TO lt_lengths.
        ENDDO.
      ENDIF.
    ENDWHILE.

    lt_dists = lt_lengths.
    DELETE lt_lengths FROM lv_nlen + 1.
    DELETE lt_dists TO lv_nlen.

    CREATE OBJECT go_lencode
      EXPORTING
        it_lengths = lt_lengths.

    CREATE OBJECT go_distcode
      EXPORTING
        it_lengths = lt_dists.

  ENDMETHOD.
  METHOD fixed.

    DATA: lt_lengths TYPE zcl_abapgit_zlib_huffman=&gt;ty_lengths.
    DO 144 TIMES.
      APPEND 8 TO lt_lengths.
    ENDDO.
    DO 112 TIMES.
      APPEND 9 TO lt_lengths.
    ENDDO.
    DO 24 TIMES.
      APPEND 7 TO lt_lengths.
    ENDDO.
    DO 8 TIMES.
      APPEND 8 TO lt_lengths.
    ENDDO.

    CREATE OBJECT go_lencode
      EXPORTING
        it_lengths = lt_lengths.

    CLEAR lt_lengths.
    DO c_maxdcodes TIMES.
      APPEND 5 TO lt_lengths.
    ENDDO.

    CREATE OBJECT go_distcode
      EXPORTING
        it_lengths = lt_lengths.

  ENDMETHOD.
  METHOD map_distance.

    DEFINE _distance.
      rv_distance = go_stream-&gt;take_int( &amp;1 ).
      rv_distance = rv_distance + &amp;2.
    END-OF-DEFINITION.

    CASE iv_code.
      WHEN 0.
        _distance 0 1.
      WHEN 1.
        _distance 0 2.
      WHEN 2.
        _distance 0 3.
      WHEN 3.
        _distance 0 4.
      WHEN 4.
        _distance 1 5.
      WHEN 5.
        _distance 1 7.
      WHEN 6.
        _distance 2 9.
      WHEN 7.
        _distance 2 13.
      WHEN 8.
        _distance 3 17.
      WHEN 9.
        _distance 3 25.
      WHEN 10.
        _distance 4 33.
      WHEN 11.
        _distance 4 49.
      WHEN 12.
        _distance 5 65.
      WHEN 13.
        _distance 5 97.
      WHEN 14.
        _distance 6 129.
      WHEN 15.
        _distance 6 193.
      WHEN 16.
        _distance 7 257.
      WHEN 17.
        _distance 7 385.
      WHEN 18.
        _distance 8 513.
      WHEN 19.
        _distance 8 769.
      WHEN 20.
        _distance 9 1025.
      WHEN 21.
        _distance 9 1537.
      WHEN 22.
        _distance 10 2049.
      WHEN 23.
        _distance 10 3073.
      WHEN 24.
        _distance 11 4097.
      WHEN 25.
        _distance 11 6145.
      WHEN 26.
        _distance 12 8193.
      WHEN 27.
        _distance 12 12289.
      WHEN 28.
        _distance 13 16385.
      WHEN 29.
        _distance 13 24577.
      WHEN OTHERS.
        ASSERT 1 = 0.
    ENDCASE.

  ENDMETHOD.
  METHOD map_length.

    DEFINE _length.
      rv_length = go_stream-&gt;take_int( &amp;1 ).
      rv_length = rv_length + &amp;2.
    END-OF-DEFINITION.

    CASE iv_code.
      WHEN 257.
        _length 0 3.
      WHEN 258.
        _length 0 4.
      WHEN 259.
        _length 0 5.
      WHEN 260.
        _length 0 6.
      WHEN 261.
        _length 0 7.
      WHEN 262.
        _length 0 8.
      WHEN 263.
        _length 0 9.
      WHEN 264.
        _length 0 10.
      WHEN 265.
        _length 1 11.
      WHEN 266.
        _length 1 13.
      WHEN 267.
        _length 1 15.
      WHEN 268.
        _length 1 17.
      WHEN 269.
        _length 2 19.
      WHEN 270.
        _length 2 23.
      WHEN 271.
        _length 2 27.
      WHEN 272.
        _length 2 31.
      WHEN 273.
        _length 3 35.
      WHEN 274.
        _length 3 43.
      WHEN 275.
        _length 3 51.
      WHEN 276.
        _length 3 59.
      WHEN 277.
        _length 4 67.
      WHEN 278.
        _length 4 83.
      WHEN 279.
        _length 4 99.
      WHEN 280.
        _length 4 115.
      WHEN 281.
        _length 5 131.
      WHEN 282.
        _length 5 163.
      WHEN 283.
        _length 5 195.
      WHEN 284.
        _length 5 227.
      WHEN 285.
        _length 0 258.
      WHEN OTHERS.
        ASSERT 1 = 0.
    ENDCASE.

  ENDMETHOD.
  METHOD read_pair.

    DATA: lv_symbol TYPE i.
    rs_pair-length = map_length( iv_length ).

    lv_symbol = decode( go_distcode ).
    rs_pair-distance = map_distance( lv_symbol ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ZIP IMPLEMENTATION.
  METHOD encode_files.

    DATA: lo_zip      TYPE REF TO cl_abap_zip,
          lv_filename TYPE string.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF it_files.
    CREATE OBJECT lo_zip.

    LOOP AT it_files ASSIGNING &lt;ls_file&gt;.
      CONCATENATE &lt;ls_file&gt;-file-path+1 &lt;ls_file&gt;-file-filename INTO lv_filename.
      lo_zip-&gt;add( name    = lv_filename
                   content = &lt;ls_file&gt;-file-data ).
    ENDLOOP.

    rv_xstr = lo_zip-&gt;save( ).

  ENDMETHOD.
  METHOD export.

    DATA: lo_log     TYPE REF TO zcl_abapgit_log,
          lt_zip     TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
          lv_package TYPE devclass.
    CREATE OBJECT lo_log.

    lv_package = io_repo-&gt;get_package( ).

    IF zcl_abapgit_factory=&gt;get_sap_package( lv_package )-&gt;exists( ) = abap_false.
      zcx_abapgit_exception=&gt;raise( |Package { lv_package } doesn&apos;t exist| ).
    ENDIF.

    lt_zip = io_repo-&gt;get_files_local( io_log    = lo_log
                                       it_filter = it_filter ).

    IF lo_log-&gt;count( ) &gt; 0.
      lo_log-&gt;show( ).
    ENDIF.

    file_download( iv_package = io_repo-&gt;get_package( )
                   iv_xstr    = encode_files( lt_zip ) ).

  ENDMETHOD.
  METHOD export_object.

    DATA: ls_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir,
          lv_folder   TYPE string,
          lv_fullpath TYPE string,
          lt_rawdata  TYPE solix_tab,
          lv_sep      TYPE c LENGTH 1,
          ls_files_item TYPE zcl_abapgit_objects=&gt;ty_serialization.

    STATICS: sv_prev TYPE string.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF ls_files_item-files.
    ls_tadir = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_object( ).
    IF ls_tadir IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    ls_files_item-item-obj_type = ls_tadir-object.
    ls_files_item-item-obj_name = ls_tadir-obj_name.

    ls_files_item = zcl_abapgit_objects=&gt;serialize( is_item = ls_files_item-item
                                                    iv_language = sy-langu ).

    IF lines( ls_files_item-files ) = 0.
      MESSAGE &apos;Empty&apos; TYPE &apos;S&apos;.
      RETURN.
    ENDIF.

    cl_gui_frontend_services=&gt;directory_browse(
      EXPORTING
        initial_folder  = sv_prev
      CHANGING
        selected_folder = lv_folder ).
    IF lv_folder IS INITIAL.
      RETURN.
    ENDIF.

    sv_prev = lv_folder.

    cl_gui_frontend_services=&gt;get_file_separator(
      CHANGING
        file_separator = lv_sep ).

    LOOP AT ls_files_item-files ASSIGNING &lt;ls_file&gt;.
      CONCATENATE lv_folder lv_sep &lt;ls_file&gt;-filename INTO lv_fullpath.

      lt_rawdata = cl_bcs_convert=&gt;xstring_to_solix( &lt;ls_file&gt;-data ).

      cl_gui_frontend_services=&gt;gui_download(
        EXPORTING
          bin_filesize              = xstrlen( &lt;ls_file&gt;-data )
          filename                  = lv_fullpath
          filetype                  = &apos;BIN&apos;
        CHANGING
          data_tab                  = lt_rawdata
        EXCEPTIONS
          file_write_error          = 1
          no_batch                  = 2
          gui_refuse_filetransfer   = 3
          invalid_type              = 4
          no_authority              = 5
          unknown_error             = 6
          header_not_allowed        = 7
          separator_not_allowed     = 8
          filesize_not_allowed      = 9
          header_too_long           = 10
          dp_error_create           = 11
          dp_error_send             = 12
          dp_error_write            = 13
          unknown_dp_error          = 14
          access_denied             = 15
          dp_out_of_memory          = 16
          disk_full                 = 17
          dp_timeout                = 18
          file_not_found            = 19
          dataprovider_exception    = 20
          control_flush_error       = 21
          not_supported_by_gui      = 22
          error_no_gui              = 23
          OTHERS                    = 24 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from gui_download&apos; ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD export_package.

    DATA: lo_repo   TYPE REF TO zcl_abapgit_repo_offline,
          ls_data   TYPE zif_abapgit_persistence=&gt;ty_repo,
          li_popups TYPE REF TO zif_abapgit_popups.
    ls_data-key = &apos;DUMMY&apos;.
    ls_data-dot_abapgit = zcl_abapgit_dot_abapgit=&gt;build_default( )-&gt;get_data( ).

    li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
    li_popups-&gt;popup_package_export(
      IMPORTING
        ev_package      = ls_data-package
        ev_folder_logic = ls_data-dot_abapgit-folder_logic ).
    IF ls_data-package IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    CREATE OBJECT lo_repo
      EXPORTING
        is_data = ls_data.

    export( lo_repo ).

  ENDMETHOD.
  METHOD filename.

    IF iv_str CA &apos;/&apos;.
      FIND REGEX &apos;(.*/)(.*)&apos; IN iv_str
        SUBMATCHES ev_path ev_filename.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Malformed path&apos; ).
      ENDIF.
      IF ev_path &lt;&gt; &apos;/&apos;.
        CONCATENATE &apos;/&apos; ev_path INTO ev_path.
      ENDIF.
    ELSE.
      ev_path = &apos;/&apos;.
      ev_filename = iv_str.
    ENDIF.
    TRANSLATE ev_filename TO LOWER CASE.

  ENDMETHOD.
  METHOD file_download.

    DATA: lt_rawdata  TYPE solix_tab,
          lv_action   TYPE i,
          lv_filename TYPE string,
          lv_default  TYPE string,
          lv_path     TYPE string,
          lv_fullpath TYPE string,
          lv_package  TYPE devclass.
    lv_package = iv_package.
    TRANSLATE lv_package USING &apos;/#&apos;.
    CONCATENATE lv_package &apos;_&apos; sy-datlo &apos;_&apos; sy-timlo INTO lv_default.

    cl_gui_frontend_services=&gt;file_save_dialog(
      EXPORTING
        window_title         = &apos;Export ZIP&apos;
        default_extension    = &apos;zip&apos;
        default_file_name    = lv_default
      CHANGING
        filename             = lv_filename
        path                 = lv_path
        fullpath             = lv_fullpath
        user_action          = lv_action
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4 ).                         &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from file_save_dialog&apos; ).
    ENDIF.
    IF lv_action = cl_gui_frontend_services=&gt;action_cancel.
      zcx_abapgit_exception=&gt;raise( &apos;cancelled&apos; ).
    ENDIF.

    lt_rawdata = cl_bcs_convert=&gt;xstring_to_solix( iv_xstr ).

    cl_gui_frontend_services=&gt;gui_download(
      EXPORTING
        bin_filesize              = xstrlen( iv_xstr )
        filename                  = lv_fullpath
        filetype                  = &apos;BIN&apos;
      CHANGING
        data_tab                  = lt_rawdata
      EXCEPTIONS
        file_write_error          = 1
        no_batch                  = 2
        gui_refuse_filetransfer   = 3
        invalid_type              = 4
        no_authority              = 5
        unknown_error             = 6
        header_not_allowed        = 7
        separator_not_allowed     = 8
        filesize_not_allowed      = 9
        header_too_long           = 10
        dp_error_create           = 11
        dp_error_send             = 12
        dp_error_write            = 13
        unknown_dp_error          = 14
        access_denied             = 15
        dp_out_of_memory          = 16
        disk_full                 = 17
        dp_timeout                = 18
        file_not_found            = 19
        dataprovider_exception    = 20
        control_flush_error       = 21
        not_supported_by_gui      = 22
        error_no_gui              = 23
        OTHERS                    = 24 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from gui_download&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD file_upload.

    DATA: lt_data       TYPE TABLE OF x255,
          lt_file_table TYPE filetable,
          ls_file_table LIKE LINE OF lt_file_table,
          lv_action     TYPE i,
          lv_string     TYPE string,
          lv_rc         TYPE i,
          lv_length     TYPE i.
    cl_gui_frontend_services=&gt;file_open_dialog(
      EXPORTING
        window_title            = &apos;Import ZIP&apos;
        default_filename        = &apos;*.zip&apos;
      CHANGING
        file_table              = lt_file_table
        rc                      = lv_rc
        user_action             = lv_action
      EXCEPTIONS
        file_open_dialog_failed = 1
        cntl_error              = 2
        error_no_gui            = 3
        not_supported_by_gui    = 4
        OTHERS                  = 5 ).                      &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from file_open_dialog&apos; ).
    ENDIF.
    IF lv_action = cl_gui_frontend_services=&gt;action_cancel.
      zcx_abapgit_exception=&gt;raise( &apos;cancelled&apos; ).
    ENDIF.

    READ TABLE lt_file_table INDEX 1 INTO ls_file_table.
    ASSERT sy-subrc = 0.
    lv_string = ls_file_table-filename.

    cl_gui_frontend_services=&gt;gui_upload(
      EXPORTING
        filename                = lv_string
        filetype                = &apos;BIN&apos;
      IMPORTING
        filelength              = lv_length
      CHANGING
        data_tab                = lt_data
      EXCEPTIONS
        file_open_error         = 1
        file_read_error         = 2
        no_batch                = 3
        gui_refuse_filetransfer = 4
        invalid_type            = 5
        no_authority            = 6
        unknown_error           = 7
        bad_data_format         = 8
        header_not_allowed      = 9
        separator_not_allowed   = 10
        header_too_long         = 11
        unknown_dp_error        = 12
        access_denied           = 13
        dp_out_of_memory        = 14
        disk_full               = 15
        dp_timeout              = 16
        not_supported_by_gui    = 17
        error_no_gui            = 18
        OTHERS                  = 19 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from gui_upload&apos; ).
    ENDIF.

    CONCATENATE LINES OF lt_data INTO rv_xstr IN BYTE MODE.
    rv_xstr = rv_xstr(lv_length).

  ENDMETHOD.
  METHOD import.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_offline.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    lo_repo-&gt;set_files_remote( unzip_file( file_upload( ) ) ).

  ENDMETHOD.
  METHOD normalize_path.
* removes first folder from path if needed

    DATA: lt_split  TYPE TABLE OF string,
          lv_needed TYPE abap_bool,
          lv_length TYPE i,
          lv_split  LIKE LINE OF lt_split.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF ct_files.
    READ TABLE ct_files INDEX 1 ASSIGNING &lt;ls_file&gt;.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    SPLIT &lt;ls_file&gt;-path AT &apos;/&apos; INTO TABLE lt_split.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.
    READ TABLE lt_split INDEX 2 INTO lv_split.
    IF sy-subrc &lt;&gt; 0 OR strlen( lv_split ) = 0.
      RETURN.
    ENDIF.

    CONCATENATE &apos;/&apos; lv_split &apos;/*&apos; INTO lv_split.

    lv_needed = abap_true.
    LOOP AT ct_files ASSIGNING &lt;ls_file&gt;.
      IF NOT &lt;ls_file&gt;-path CP lv_split.
        lv_needed = abap_false.
        EXIT. &quot; current loop
      ENDIF.
    ENDLOOP.

    IF lv_needed = abap_true.
      lv_length = strlen( lv_split ) - 2.
      LOOP AT ct_files ASSIGNING &lt;ls_file&gt;.
        &lt;ls_file&gt;-path = &lt;ls_file&gt;-path+lv_length.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD unzip_file.

    DATA: lo_zip  TYPE REF TO cl_abap_zip,
          lv_data TYPE xstring.

    FIELD-SYMBOLS: &lt;ls_zipfile&gt; TYPE cl_abap_zip=&gt;t_file,
                   &lt;ls_file&gt;    LIKE LINE OF rt_files.
    CREATE OBJECT lo_zip.
    lo_zip-&gt;load( EXPORTING
                    zip             = iv_xstr
                  EXCEPTIONS
                    zip_parse_error = 1
                    OTHERS          = 2 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from zip&apos; ).
    ENDIF.

    LOOP AT lo_zip-&gt;files ASSIGNING &lt;ls_zipfile&gt;.

      lo_zip-&gt;get(
        EXPORTING
          name                    = &lt;ls_zipfile&gt;-name
        IMPORTING
          content                 = lv_data
        EXCEPTIONS
          zip_index_error         = 1
          zip_decompression_error = 2
          OTHERS                  = 3 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from zip get&apos; ).
      ENDIF.

      APPEND INITIAL LINE TO rt_files ASSIGNING &lt;ls_file&gt;.

      filename(
        EXPORTING
          iv_str      = &lt;ls_zipfile&gt;-name
        IMPORTING
          ev_path     = &lt;ls_file&gt;-path
          ev_filename = &lt;ls_file&gt;-filename ).

      &lt;ls_file&gt;-data = lv_data.

      &lt;ls_file&gt;-sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-blob
                                               iv_data = &lt;ls_file&gt;-data ).

    ENDLOOP.

    DELETE rt_files WHERE filename IS INITIAL.

    normalize_path( CHANGING ct_files = rt_files ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TRANSPORT_OBJECTS IMPLEMENTATION.
  METHOD constructor.
    mt_transport_objects = it_transport_objects.
  ENDMETHOD.
  METHOD to_stage.
    DATA: ls_transport_object LIKE LINE OF mt_transport_objects,
          ls_local_file       TYPE zif_abapgit_definitions=&gt;ty_file_item,
          ls_object_status    TYPE zif_abapgit_definitions=&gt;ty_result.

    LOOP AT mt_transport_objects INTO ls_transport_object.
      LOOP AT it_object_statuses INTO ls_object_status
          WHERE obj_name = ls_transport_object-obj_name
          AND obj_type = ls_transport_object-object
          AND NOT lstate IS INITIAL.

        CASE ls_object_status-lstate.
          WHEN zif_abapgit_definitions=&gt;c_state-added OR zif_abapgit_definitions=&gt;c_state-modified.
            IF ls_transport_object-delflag = abap_true.
              zcx_abapgit_exception=&gt;raise( |Object { ls_transport_object-obj_name
              } should be added/modified, but has deletion flag in transport| ).
            ENDIF.

            READ TABLE is_stage_objects-local
                  INTO ls_local_file
              WITH KEY item-obj_name = ls_transport_object-obj_name
                       item-obj_type = ls_transport_object-object
                       file-filename = ls_object_status-filename.
            IF sy-subrc &lt;&gt; 0.
              zcx_abapgit_exception=&gt;raise( |Object { ls_transport_object-obj_name
              } not found in the local repository files| ).
            ENDIF.

            io_stage-&gt;add(
              iv_path     = ls_local_file-file-path
              iv_filename = ls_local_file-file-filename
              iv_data     = ls_local_file-file-data ).
          WHEN zif_abapgit_definitions=&gt;c_state-deleted.
            IF ls_transport_object-delflag = abap_false.
              zcx_abapgit_exception=&gt;raise( |Object { ls_transport_object-obj_name
              } should be removed, but has NO deletion flag in transport| ).
            ENDIF.
            io_stage-&gt;rm(
              iv_path     = ls_object_status-path
              iv_filename = ls_object_status-filename ).
          WHEN OTHERS.
            ASSERT 0 = 1. &quot;Unexpected state
        ENDCASE.
      ENDLOOP.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Object { ls_transport_object-obj_name
        } not found in the local repository files| ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TRANSPORT_2_BRANCH IMPLEMENTATION.
  METHOD create.
    DATA:
      lv_branch_name     TYPE string,
      ls_comment         TYPE zif_abapgit_definitions=&gt;ty_comment,
      lo_stage           TYPE REF TO zcl_abapgit_stage,
      ls_stage_objects   TYPE zif_abapgit_definitions=&gt;ty_stage_files,
      lt_object_statuses TYPE zif_abapgit_definitions=&gt;ty_results_tt.

    lv_branch_name = zcl_abapgit_git_branch_list=&gt;complete_heads_branch_name(
        zcl_abapgit_git_branch_list=&gt;normalize_branch_name( is_transport_to_branch-branch_name ) ).

    io_repository-&gt;create_branch( lv_branch_name ).

    CREATE OBJECT lo_stage.

    ls_stage_objects = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( io_repository ).

    lt_object_statuses = io_repository-&gt;status( ).

    stage_transport_objects(
       it_transport_objects = it_transport_objects
       io_stage             = lo_stage
       is_stage_objects     = ls_stage_objects
       it_object_statuses   = lt_object_statuses ).

    ls_comment = generate_commit_message( is_transport_to_branch ).

    io_repository-&gt;push( is_comment = ls_comment
                         io_stage   = lo_stage ).
  ENDMETHOD.
  METHOD generate_commit_message.
    rs_comment-committer-name  = sy-uname.
    rs_comment-committer-email = |{ rs_comment-committer-name }@localhost|.
    rs_comment-comment         = is_transport_to_branch-commit_text.
  ENDMETHOD.
  METHOD stage_transport_objects.
    DATA lo_transport_objects TYPE REF TO zcl_abapgit_transport_objects.
    CREATE OBJECT lo_transport_objects
      EXPORTING
        it_transport_objects = it_transport_objects.

    lo_transport_objects-&gt;to_stage(
      io_stage           = io_stage
      is_stage_objects   = is_stage_objects
      it_object_statuses = it_object_statuses ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TRANSPORT IMPLEMENTATION.
  METHOD find_top_package.
* assumption: all objects in transport share a common super package

    DATA: lt_obj   TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
          lt_super TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
          lv_super LIKE LINE OF lt_super,
          lv_index TYPE i.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF it_tadir.
    READ TABLE it_tadir INDEX 1 ASSIGNING &lt;ls_tadir&gt;.
    ASSERT sy-subrc = 0.
    lt_super = zcl_abapgit_factory=&gt;get_sap_package( &lt;ls_tadir&gt;-devclass )-&gt;list_superpackages( ).

    LOOP AT it_tadir ASSIGNING &lt;ls_tadir&gt;.
      lt_obj = zcl_abapgit_factory=&gt;get_sap_package( &lt;ls_tadir&gt;-devclass )-&gt;list_superpackages( ).

* filter out possibilities from lt_super
      LOOP AT lt_super INTO lv_super.
        lv_index = sy-tabix.
        READ TABLE lt_obj FROM lv_super TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          DELETE lt_super INDEX lv_index.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    SORT lt_super.
    READ TABLE lt_super INDEX 1 INTO rv_package.
  ENDMETHOD.
  METHOD read_requests.
    DATA lt_requests LIKE rt_requests.
    FIELD-SYMBOLS &lt;ls_trkorr&gt; LIKE LINE OF it_trkorr.

    LOOP AT it_trkorr ASSIGNING &lt;ls_trkorr&gt;.
      CALL FUNCTION &apos;TR_READ_REQUEST_WITH_TASKS&apos;
        EXPORTING
          iv_trkorr     = &lt;ls_trkorr&gt;-trkorr
        IMPORTING
          et_requests   = lt_requests
        EXCEPTIONS
          invalid_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from TR_READ_REQUEST_WITH_TASKS&apos; ).
      ENDIF.

      APPEND LINES OF lt_requests TO rt_requests.
    ENDLOOP.
  ENDMETHOD.
  METHOD resolve.
    DATA: lv_object     TYPE tadir-object,
          lv_obj_name   TYPE tadir-obj_name,
          lv_trobj_name TYPE trobj_name,
          ls_tadir      TYPE zif_abapgit_definitions=&gt;ty_tadir.

    FIELD-SYMBOLS: &lt;ls_request&gt; LIKE LINE OF it_requests,
                   &lt;ls_object&gt;  LIKE LINE OF &lt;ls_request&gt;-objects.
    LOOP AT it_requests ASSIGNING &lt;ls_request&gt;.
      LOOP AT &lt;ls_request&gt;-objects ASSIGNING &lt;ls_object&gt;.
        IF &lt;ls_object&gt;-pgmid = &apos;LIMU&apos;.
          CALL FUNCTION &apos;GET_R3TR_OBJECT_FROM_LIMU_OBJ&apos;
            EXPORTING
              p_limu_objtype = &lt;ls_object&gt;-object
              p_limu_objname = &lt;ls_object&gt;-obj_name
            IMPORTING
              p_r3tr_objtype = lv_object
              p_r3tr_objname = lv_trobj_name
            EXCEPTIONS
              no_mapping     = 1
              OTHERS         = 2.
          IF sy-subrc &lt;&gt; 0.
            zcx_abapgit_exception=&gt;raise( &apos;error from GET_R3TR_OBJECT_FROM_LIMU_OBJ&apos; ).
          ENDIF.
          lv_obj_name = lv_trobj_name.
        ELSE.
          lv_object   = &lt;ls_object&gt;-object.
          lv_obj_name = &lt;ls_object&gt;-obj_name.
        ENDIF.

        ls_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read_single(
          iv_object   = lv_object
          iv_obj_name = lv_obj_name ).

        APPEND ls_tadir TO rt_tadir.
      ENDLOOP.
    ENDLOOP.

    SORT rt_tadir BY object ASCENDING obj_name ASCENDING.
    DELETE ADJACENT DUPLICATES FROM rt_tadir COMPARING object obj_name.
    DELETE rt_tadir WHERE table_line IS INITIAL.
  ENDMETHOD.
  METHOD to_tadir.
    DATA: lt_requests TYPE trwbo_requests.
    IF lines( it_transport_headers ) = 0.
      RETURN.
    ENDIF.

    lt_requests = read_requests( it_transport_headers ).
    rt_tadir = resolve( lt_requests ).
  ENDMETHOD.
  METHOD zip.

    DATA: lt_requests TYPE trwbo_requests,
          lt_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lv_package  TYPE devclass,
          ls_data     TYPE zif_abapgit_persistence=&gt;ty_repo,
          lo_repo     TYPE REF TO zcl_abapgit_repo_offline,
          lt_trkorr   TYPE trwbo_request_headers.
    lt_trkorr = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_select_transports( ).
    IF lines( lt_trkorr ) = 0.
      RETURN.
    ENDIF.

    lt_requests = read_requests( lt_trkorr ).
    lt_tadir = resolve( lt_requests ).
    IF lines( lt_tadir ) = 0.
      zcx_abapgit_exception=&gt;raise( &apos;empty transport&apos; ).
    ENDIF.

    lv_package = find_top_package( lt_tadir ).
    IF lv_package IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;error finding super package&apos; ).
    ENDIF.

    ls_data-key         = &apos;TZIP&apos;.
    ls_data-package     = lv_package.
    ls_data-dot_abapgit = zcl_abapgit_dot_abapgit=&gt;build_default( )-&gt;get_data( ).

    ls_data-dot_abapgit-folder_logic = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_folder_logic( ).

    CREATE OBJECT lo_repo
      EXPORTING
        is_data = ls_data.

    zcl_abapgit_zip=&gt;export( io_repo   = lo_repo
                             it_filter = lt_tadir ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TADIR IMPLEMENTATION.
  METHOD build.

    DATA: lt_tdevc        TYPE STANDARD TABLE OF tdevc,
          lv_path         TYPE string,
          lo_skip_objects TYPE REF TO zcl_abapgit_skip_objects,
          lt_excludes     TYPE RANGE OF trobjtype,
          lt_srcsystem    TYPE RANGE OF tadir-srcsystem,
          ls_srcsystem    LIKE LINE OF lt_srcsystem,
          ls_exclude      LIKE LINE OF lt_excludes,
          lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic,
          lv_last_package TYPE devclass VALUE cl_abap_char_utilities=&gt;horizontal_tab,
          lt_packages     TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt.

    FIELD-SYMBOLS: &lt;ls_tadir&gt;   LIKE LINE OF rt_tadir,
                   &lt;lv_package&gt; TYPE devclass.

    &quot;Determine Packages to Read
    IF iv_ignore_subpackages = abap_false.
      lt_packages = zcl_abapgit_factory=&gt;get_sap_package( iv_package )-&gt;list_subpackages( ).
    ENDIF.
    INSERT iv_package INTO lt_packages INDEX 1.

    ls_exclude-sign = &apos;I&apos;.
    ls_exclude-option = &apos;EQ&apos;.

    ls_exclude-low = &apos;SOTR&apos;.
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low = &apos;SFB1&apos;.
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low = &apos;SFB2&apos;.
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low = &apos;STOB&apos;. &quot; auto generated by core data services
    APPEND ls_exclude TO lt_excludes.

    IF iv_only_local_objects = abap_true.
      ls_srcsystem-sign   = &apos;I&apos;.
      ls_srcsystem-option = &apos;EQ&apos;.
      ls_srcsystem-low    = sy-sysid.
      APPEND ls_srcsystem TO lt_srcsystem.
    ENDIF.

    IF lt_packages IS NOT INITIAL.
      SELECT * FROM tadir
        INTO CORRESPONDING FIELDS OF TABLE rt_tadir
        FOR ALL ENTRIES IN lt_packages
        WHERE devclass = lt_packages-table_line
        AND pgmid = &apos;R3TR&apos;
        AND object NOT IN lt_excludes
        AND delflag = abap_false
        AND srcsystem IN lt_srcsystem
        ORDER BY PRIMARY KEY.             &quot;#EC CI_GENBUFF &quot;#EC CI_SUBRC
    ENDIF.

    SORT rt_tadir BY devclass pgmid object obj_name.

    CREATE OBJECT lo_skip_objects.
    rt_tadir = lo_skip_objects-&gt;skip_sadl_generated_objects(
      it_tadir = rt_tadir
      io_log   = io_log ).

    LOOP AT lt_packages ASSIGNING &lt;lv_package&gt;.
      &quot; Local packages are not in TADIR, only in TDEVC, act as if they were
      IF &lt;lv_package&gt; CP &apos;$*&apos;. &quot; OR &lt;package&gt; CP &apos;T*&apos; ).
        APPEND INITIAL LINE TO rt_tadir ASSIGNING &lt;ls_tadir&gt;.
        &lt;ls_tadir&gt;-pgmid    = &apos;R3TR&apos;.
        &lt;ls_tadir&gt;-object   = &apos;DEVC&apos;.
        &lt;ls_tadir&gt;-obj_name = &lt;lv_package&gt;.
        &lt;ls_tadir&gt;-devclass = &lt;lv_package&gt;.
      ENDIF.
    ENDLOOP.

    LOOP AT rt_tadir ASSIGNING &lt;ls_tadir&gt;.

      IF lv_last_package &lt;&gt; &lt;ls_tadir&gt;-devclass.
        &quot;Change in Package
        lv_last_package = &lt;ls_tadir&gt;-devclass.

        IF NOT io_dot IS INITIAL.
          &quot;Reuse given Folder Logic Instance
          IF lo_folder_logic IS NOT BOUND.
            &quot;Get Folder Logic Instance
            lo_folder_logic = zcl_abapgit_folder_logic=&gt;get_instance( ).
          ENDIF.

          lv_path = lo_folder_logic-&gt;package_to_path(
            iv_top     = iv_top
            io_dot     = io_dot
            iv_package = &lt;ls_tadir&gt;-devclass ).
        ENDIF.
      ENDIF.

      &lt;ls_tadir&gt;-path = lv_path.

      CASE &lt;ls_tadir&gt;-object.
        WHEN &apos;SICF&apos;.
* replace the internal GUID with a hash of the path
          TRY.
              CALL METHOD (&apos;ZCL_ABAPGIT_OBJECT_SICF&apos;)=&gt;read_sicf_url
                EXPORTING
                  iv_obj_name = &lt;ls_tadir&gt;-obj_name
                RECEIVING
                  rv_hash     = &lt;ls_tadir&gt;-obj_name+15.
            CATCH cx_sy_dyn_call_illegal_method.
* SICF might not be supported in some systems, assume this code is not called
          ENDTRY.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
  METHOD check_exists.

    DATA: lo_progress TYPE REF TO zcl_abapgit_progress,
          ls_item     TYPE zif_abapgit_definitions=&gt;ty_item.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF it_tadir.
    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( it_tadir ).

* rows from database table TADIR are not removed for
* transportable objects until the transport is released
    LOOP AT it_tadir ASSIGNING &lt;ls_tadir&gt;.
      IF sy-tabix MOD 200 = 0.
        lo_progress-&gt;show(
          iv_current = sy-tabix
          iv_text    = |Check object exists { &lt;ls_tadir&gt;-object } { &lt;ls_tadir&gt;-obj_name }| ).
      ENDIF.

      ls_item-obj_type = &lt;ls_tadir&gt;-object.
      ls_item-obj_name = &lt;ls_tadir&gt;-obj_name.
      ls_item-devclass = &lt;ls_tadir&gt;-devclass.

      IF exists( ls_item ) = abap_true.
        APPEND &lt;ls_tadir&gt; TO rt_tadir.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD exists.

    IF is_item IS INITIAL.
      RETURN.
    ENDIF.

    IF zcl_abapgit_objects=&gt;is_supported( is_item ) = abap_false.
      rv_exists = abap_true.
      RETURN.
    ENDIF.

    rv_exists = zcl_abapgit_objects=&gt;exists( is_item ).

  ENDMETHOD.
  METHOD zif_abapgit_tadir~get_object_package.

    DATA: ls_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir,
          ls_item  TYPE zif_abapgit_definitions=&gt;ty_item.

    ls_tadir = zif_abapgit_tadir~read_single(
      iv_pgmid    = iv_pgmid
      iv_object   = iv_object
      iv_obj_name = iv_obj_name ).

    IF ls_tadir-delflag = &apos;X&apos;.
      RETURN. &quot;Mark for deletion -&gt; return nothing
    ENDIF.

    ls_item-obj_type = ls_tadir-object.
    ls_item-obj_name = ls_tadir-obj_name.
    ls_item-devclass = ls_tadir-devclass.
    IF exists( ls_item ) = abap_false.
      RETURN.
    ENDIF.

    rv_devclass = ls_tadir-devclass.

  ENDMETHOD.
  METHOD zif_abapgit_tadir~read.

    DATA: li_exit TYPE REF TO zif_abapgit_exit.

* start recursion
* hmm, some problems here, should TADIR also build path?
    rt_tadir = build( iv_package            = iv_package
                      iv_top                = iv_package
                      io_dot                = io_dot
                      iv_ignore_subpackages = iv_ignore_subpackages
                      iv_only_local_objects = iv_only_local_objects
                      io_log                = io_log ).

    li_exit = zcl_abapgit_exit=&gt;get_instance( ).
    li_exit-&gt;change_tadir(
      EXPORTING
        iv_package = iv_package
        io_log     = io_log
      CHANGING
        ct_tadir   = rt_tadir ).

    rt_tadir = check_exists( rt_tadir ).

  ENDMETHOD.
  METHOD zif_abapgit_tadir~read_single.

    IF iv_object = &apos;SICF&apos;.
      TRY.
          CALL METHOD (&apos;ZCL_ABAPGIT_OBJECT_SICF&apos;)=&gt;read_tadir
            EXPORTING
              iv_pgmid    = iv_pgmid
              iv_obj_name = iv_obj_name
            RECEIVING
              rs_tadir    = rs_tadir.
        CATCH cx_sy_dyn_call_illegal_method.
* SICF might not be supported in some systems, assume this code is not called
      ENDTRY.
    ELSE.
      SELECT SINGLE * FROM tadir INTO CORRESPONDING FIELDS OF rs_tadir
        WHERE pgmid = iv_pgmid
        AND object = iv_object
        AND obj_name = iv_obj_name.                       &quot;#EC CI_SUBRC
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_syntax_check IMPLEMENTATION.
  METHOD constructor.

    mo_adhoc_code_inspector = zcl_abapgit_factory=&gt;get_adhoc_code_inspector(
                                iv_package   = iv_package
                                iv_test_name = &apos;CL_CI_TEST_SYNTAX_CHECK&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~get_inspection.

    ro_inspection = mo_adhoc_code_inspector-&gt;get_inspection( ).

  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~run.

    rt_list = mo_adhoc_code_inspector-&gt;run( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_STAGE_LOGIC IMPLEMENTATION.
  METHOD remove_identical.

    DATA: lv_index  TYPE i,
          ls_remote LIKE LINE OF cs_files-remote.

    FIELD-SYMBOLS: &lt;ls_local&gt; LIKE LINE OF cs_files-local.

    SORT cs_files-remote BY path filename.

    LOOP AT cs_files-local ASSIGNING &lt;ls_local&gt;.
      lv_index = sy-tabix.

      READ TABLE cs_files-remote INTO ls_remote
        WITH KEY path = &lt;ls_local&gt;-file-path filename = &lt;ls_local&gt;-file-filename
        BINARY SEARCH.
      IF sy-subrc = 0.
        DELETE cs_files-remote INDEX sy-tabix.
        IF ls_remote-sha1 = &lt;ls_local&gt;-file-sha1.
          DELETE cs_files-local INDEX lv_index.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD remove_ignored.

    DATA: lv_index TYPE i.

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF cs_files-remote.
    LOOP AT cs_files-remote ASSIGNING &lt;ls_remote&gt;.
      lv_index = sy-tabix.

      IF io_repo-&gt;get_dot_abapgit( )-&gt;is_ignored(
          iv_path     = &lt;ls_remote&gt;-path
          iv_filename = &lt;ls_remote&gt;-filename ) = abap_true.
        DELETE cs_files-remote INDEX lv_index.
      ELSEIF &lt;ls_remote&gt;-path     = zif_abapgit_definitions=&gt;c_root_dir
         AND &lt;ls_remote&gt;-filename = zif_abapgit_definitions=&gt;c_dot_abapgit.
        &quot; Remove .abapgit from remotes - it cannot be removed or ignored
        DELETE cs_files-remote INDEX lv_index.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_stage_logic~get.

    rs_files-local  = io_repo-&gt;get_files_local( ).
    rs_files-remote = io_repo-&gt;get_files_remote( ).
    remove_identical( CHANGING cs_files = rs_files ).
    remove_ignored( EXPORTING io_repo  = io_repo
                    CHANGING  cs_files = rs_files ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_stage IMPLEMENTATION.
  METHOD add.

    append( iv_path     = iv_path
            iv_filename = iv_filename
            iv_method   = c_method-add
            iv_data     = iv_data ).

  ENDMETHOD.
  METHOD append.

    DATA: ls_stage LIKE LINE OF mt_stage.

    FIELD-SYMBOLS: &lt;ls_stage&gt; LIKE LINE OF mt_stage.
    READ TABLE mt_stage WITH KEY
      file-path     = iv_path
      file-filename = iv_filename
      ASSIGNING &lt;ls_stage&gt;.
    IF sy-subrc = 0.
      &lt;ls_stage&gt;-file-data = iv_data.
      &lt;ls_stage&gt;-method    = iv_method.
    ELSE.
      ls_stage-file-path     = iv_path.
      ls_stage-file-filename = iv_filename.
      ls_stage-file-data     = iv_data.
      ls_stage-method        = iv_method.
      INSERT ls_stage INTO TABLE mt_stage.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.
    mv_merge_source = iv_merge_source.
  ENDMETHOD.
  METHOD count.
    rv_count = lines( mt_stage ).
  ENDMETHOD.
  METHOD get_all.
    rt_stage = mt_stage.
  ENDMETHOD.
  METHOD get_merge_source.
    rv_source = mv_merge_source.
  ENDMETHOD.
  METHOD ignore.
    append( iv_path     = iv_path
            iv_filename = iv_filename
            iv_method   = c_method-ignore ).
  ENDMETHOD.
  METHOD method_description.

    CASE iv_method.
      WHEN c_method-add.
        rv_description = &apos;add&apos;.
      WHEN c_method-rm.
        rv_description = &apos;rm&apos;.
      WHEN c_method-ignore.
        rv_description = &apos;ignore&apos; ##NO_TEXT.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;unknown staging method type&apos; ).
    ENDCASE.

  ENDMETHOD.
  METHOD reset.
    DELETE mt_stage WHERE file-path     = iv_path
                    AND   file-filename = iv_filename.
    ASSERT sy-subrc = 0.
  ENDMETHOD.
  METHOD rm.
    append( iv_path     = iv_path
            iv_filename = iv_filename
            iv_method   = c_method-rm ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SKIP_OBJECTS IMPLEMENTATION.
  METHOD has_sadl_superclass.

    DATA: li_oo_functions TYPE REF TO zif_abapgit_oo_object_fnc,
          lv_class_name   TYPE seoclsname,
          lv_superclass   TYPE seoclsname.
    li_oo_functions = zcl_abapgit_oo_factory=&gt;make( is_class-object ).
    lv_class_name = is_class-obj_name.
    lv_superclass = li_oo_functions-&gt;read_superclass( lv_class_name ).
    IF lv_superclass = &apos;CL_SADL_GTK_EXPOSURE_MPC&apos;.
      rv_return = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD skip_sadl_generated_objects.
    DATA: ls_tadir_class     LIKE LINE OF rt_tadir,
          ls_tadir           LIKE LINE OF rt_tadir,
          lt_lines_to_delete TYPE zif_abapgit_definitions=&gt;ty_tadir_tt.

    rt_tadir = it_tadir.
    LOOP AT it_tadir INTO ls_tadir WHERE object = &apos;DDLS&apos;.
      LOOP AT rt_tadir INTO ls_tadir_class
       WHERE object = &apos;CLAS&apos; AND obj_name CS ls_tadir-obj_name.

        IF has_sadl_superclass( ls_tadir_class ) = abap_true.
          APPEND ls_tadir_class TO lt_lines_to_delete.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    DELETE ADJACENT DUPLICATES FROM lt_lines_to_delete.
    LOOP AT lt_lines_to_delete INTO ls_tadir_class.
      DELETE TABLE rt_tadir FROM ls_tadir_class.
      IF io_log IS BOUND.
        io_log-&gt;add(
          iv_msg = |{ ls_tadir_class-obj_name } skipped: generated by SADL|
          iv_type = &apos;W&apos; ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_settings IMPLEMENTATION.
  METHOD get_adt_jump_enabled.
    rv_adt_jump_enabled = ms_user_settings-adt_jump_enabled.
  ENDMETHOD.
  METHOD get_commitmsg_body_size.
    rv_length = ms_settings-commitmsg_body_size.
  ENDMETHOD.
  METHOD get_commitmsg_comment_length.
    rv_length = ms_settings-commitmsg_comment_length.
  ENDMETHOD.
  METHOD get_experimental_features.
    rv_run = ms_settings-experimental_features.
  ENDMETHOD.
  METHOD get_link_hints_enabled.
    rv_link_hints_enabled = ms_user_settings-link_hints_enabled.
  ENDMETHOD.
  METHOD get_link_hint_key.
    rv_link_hint_key = ms_user_settings-link_hint_key.
  ENDMETHOD.
  METHOD get_max_lines.
    rv_lines = ms_user_settings-max_lines.
  ENDMETHOD.
  METHOD get_proxy_authentication.
    rv_auth = ms_settings-proxy_auth.
  ENDMETHOD.
  METHOD get_proxy_port.
    rv_port = ms_settings-proxy_port.
  ENDMETHOD.
  METHOD get_proxy_url.
    rv_proxy_url = ms_settings-proxy_url.
  ENDMETHOD.
  METHOD get_run_critical_tests.
    rv_run = ms_settings-run_critical_tests.
  ENDMETHOD.
  METHOD get_settings_xml.

    DATA: lo_output TYPE REF TO zcl_abapgit_xml_output.
    CREATE OBJECT lo_output.

    lo_output-&gt;add( iv_name = zcl_abapgit_persistence_db=&gt;c_type_settings
                    ig_data = ms_settings ).

    rv_settings_xml = lo_output-&gt;render( ).

  ENDMETHOD.
  METHOD get_show_default_repo.
    rv_show_default_repo = ms_user_settings-show_default_repo.
  ENDMETHOD.
  METHOD get_user_settings.
    rs_settings = ms_user_settings.
  ENDMETHOD.
  METHOD set_adt_jump_enanbled.
    ms_user_settings-adt_jump_enabled = iv_adt_jump_enabled.
  ENDMETHOD.
  METHOD set_commitmsg_body_size.
    ms_settings-commitmsg_body_size = iv_length.
  ENDMETHOD.
  METHOD set_commitmsg_comment_length.
    ms_settings-commitmsg_comment_length = iv_length.
  ENDMETHOD.
  METHOD set_defaults.

    CLEAR ms_settings.

    set_proxy_authentication( abap_false ).
    set_run_critical_tests( abap_false ).
    set_experimental_features( abap_false ).
    set_max_lines( 500 ).
    set_adt_jump_enanbled( abap_true ).
    set_show_default_repo( abap_false ).
    set_commitmsg_comment_length( c_commitmsg_comment_length_dft ).
    set_commitmsg_body_size( c_commitmsg_body_size_dft ).
    set_default_link_hint_key( ).
    set_default_link_hint_bg_color( ).

  ENDMETHOD.
  METHOD set_default_link_hint_bg_color.
    set_link_hint_background_color( |lightgreen| ).
  ENDMETHOD.
  METHOD set_default_link_hint_key.
    set_link_hint_key( |f| ).
  ENDMETHOD.
  METHOD set_experimental_features.
    ms_settings-experimental_features = iv_run.
  ENDMETHOD.
  METHOD set_link_hints_enabled.
    ms_user_settings-link_hints_enabled = iv_link_hints_enabled.
  ENDMETHOD.
  METHOD set_link_hint_key.
    ms_user_settings-link_hint_key = iv_link_hint_key.
  ENDMETHOD.
  METHOD set_max_lines.
    ms_user_settings-max_lines = iv_lines.
  ENDMETHOD.
  METHOD set_proxy_authentication.
    ms_settings-proxy_auth = iv_auth.
  ENDMETHOD.
  METHOD set_proxy_port.
    ms_settings-proxy_port = iv_port.
  ENDMETHOD.
  METHOD set_proxy_url.
    ms_settings-proxy_url = iv_url.
  ENDMETHOD.
  METHOD set_run_critical_tests.
    ms_settings-run_critical_tests = iv_run.
  ENDMETHOD.
  METHOD set_show_default_repo.
    ms_user_settings-show_default_repo = iv_show_default_repo.
  ENDMETHOD.
  METHOD set_user_settings.
    ms_user_settings = is_user_settings.

    IF ms_user_settings-link_hint_key IS INITIAL.
      set_default_link_hint_key( ).
    ENDIF.

    IF ms_user_settings-link_hint_background_color IS INITIAL.
      set_default_link_hint_bg_color( ).
    ENDIF.
  ENDMETHOD.
  METHOD set_xml_settings.

    DATA: lo_input TYPE REF TO zcl_abapgit_xml_input.
    CREATE OBJECT lo_input EXPORTING iv_xml = iv_settings_xml.

    CLEAR ms_settings.

    lo_input-&gt;read(
      EXPORTING
        iv_name = zcl_abapgit_persistence_db=&gt;c_type_settings
      CHANGING
        cg_data = ms_settings ).

  ENDMETHOD.

  METHOD get_link_hint_background_color.
    rv_background_color = ms_user_settings-link_hint_background_color.
  ENDMETHOD.
  METHOD set_link_hint_background_color.
    ms_user_settings-link_hint_background_color = iv_background_color.
  ENDMETHOD.
  METHOD set_hotkeys.
    ms_user_settings-hotkeys = it_hotkeys.
  ENDMETHOD.

  METHOD get_hotkeys.

    DATA: lt_default_hotkeys TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action,
          ls_hotkey          LIKE LINE OF rt_hotkeys.

    FIELD-SYMBOLS: &lt;ls_default_hotkey&gt; LIKE LINE OF lt_default_hotkeys.

    IF lines( ms_user_settings-hotkeys ) &gt; 0.

      rt_hotkeys = ms_user_settings-hotkeys.

    ELSE.

      &quot; provide default hotkeys
      lt_default_hotkeys = zcl_abapgit_hotkeys=&gt;get_default_hotkeys_from_pages( ).

      LOOP AT lt_default_hotkeys ASSIGNING &lt;ls_default_hotkey&gt;.

        ls_hotkey-action   = &lt;ls_default_hotkey&gt;-action.
        ls_hotkey-sequence = &lt;ls_default_hotkey&gt;-default_hotkey.
        INSERT ls_hotkey INTO TABLE rt_hotkeys.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_SERIALIZE IMPLEMENTATION.
  METHOD add_to_return.

    FIELD-SYMBOLS: &lt;ls_file&gt;   LIKE LINE OF is_fils_item-files,
                   &lt;ls_return&gt; LIKE LINE OF mt_files.
    LOOP AT is_fils_item-files ASSIGNING &lt;ls_file&gt;.
      APPEND INITIAL LINE TO mt_files ASSIGNING &lt;ls_return&gt;.
      &lt;ls_return&gt;-file = &lt;ls_file&gt;.
      &lt;ls_return&gt;-file-path = iv_path.
      &lt;ls_return&gt;-item = is_fils_item-item.
    ENDLOOP.

  ENDMETHOD.
  METHOD determine_max_threads.

    IF iv_force_sequential = abap_true.
      rv_threads = 1.
      RETURN.
    ENDIF.

    IF gv_max &gt;= 1.
* SPBT_INITIALIZE gives error PBT_ENV_ALREADY_INITIALIZED if called
* multiple times in same session
      rv_threads = gv_max.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
      EXPORTING
        funcname           = &apos;Z_ABAPGIT_SERIALIZE_PARALLEL&apos;
      EXCEPTIONS
        function_not_exist = 1
        OTHERS             = 2.
    IF sy-subrc &lt;&gt; 0.
      gv_max = 1.
    ELSE.
* todo, add possibility to set group name in user exit
      CALL FUNCTION &apos;SPBT_INITIALIZE&apos;
        EXPORTING
          group_name                     = &apos;parallel_generators&apos;
        IMPORTING
          free_pbt_wps                   = gv_max
        EXCEPTIONS
          invalid_group_name             = 1
          internal_error                 = 2
          pbt_env_already_initialized    = 3
          currently_no_resources_avail   = 4
          no_pbt_resources_found         = 5
          cant_init_different_pbt_groups = 6
          OTHERS                         = 7.
      IF sy-subrc &lt;&gt; 0.
*   fallback to running sequentially. If SPBT_INITIALIZE fails, check transactions
*   RZ12, SM50, SM21, SARFC
        gv_max = 1.
      ENDIF.
    ENDIF.

    IF gv_max &gt; 1.
      gv_max = gv_max - 1.
    ENDIF.

    ASSERT gv_max &gt;= 1.

    rv_threads = gv_max.

  ENDMETHOD.
  METHOD on_end_of_task.

    DATA: lv_result    TYPE xstring,
          lv_path      TYPE string,
          ls_fils_item TYPE zcl_abapgit_objects=&gt;ty_serialization.
    RECEIVE RESULTS FROM FUNCTION &apos;Z_ABAPGIT_SERIALIZE_PARALLEL&apos;
      IMPORTING
        ev_result = lv_result
        ev_path   = lv_path
      EXCEPTIONS
        error     = 1
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
      IF NOT mo_log IS INITIAL.
        mo_log-&gt;add_error( |{ sy-msgv1 }{ sy-msgv2 }{ sy-msgv3 }{ sy-msgv3 }| ).
      ENDIF.
    ELSE.
      IMPORT data = ls_fils_item FROM DATA BUFFER lv_result. &quot;#EC CI_SUBRC
      ASSERT sy-subrc = 0.
      add_to_return( is_fils_item = ls_fils_item
                     iv_path      = lv_path ).
    ENDIF.

    mv_free = mv_free + 1.

  ENDMETHOD.
  METHOD run_parallel.

    DATA: lv_msg  TYPE c LENGTH 100,
          lv_free LIKE mv_free.
    ASSERT mv_free &gt; 0.

    DO.
      CALL FUNCTION &apos;Z_ABAPGIT_SERIALIZE_PARALLEL&apos;
        STARTING NEW TASK iv_task
        DESTINATION IN GROUP iv_group
        CALLING on_end_of_task ON END OF TASK
        EXPORTING
          iv_obj_type           = is_tadir-object
          iv_obj_name           = is_tadir-obj_name
          iv_devclass           = is_tadir-devclass
          iv_language           = iv_language
          iv_path               = is_tadir-path
        EXCEPTIONS
          system_failure        = 1 MESSAGE lv_msg
          communication_failure = 2 MESSAGE lv_msg
          resource_failure      = 3
          OTHERS                = 4.
      IF sy-subrc = 3.
        lv_free = mv_free.
        WAIT UNTIL mv_free &lt;&gt; lv_free UP TO 1 SECONDS.
        CONTINUE.
      ELSEIF sy-subrc &lt;&gt; 0.
        ASSERT lv_msg = &apos;&apos; AND 0 = 1.
      ENDIF.
      EXIT.
    ENDDO.

    mv_free = mv_free - 1.

  ENDMETHOD.
  METHOD run_sequential.

    DATA: lx_error     TYPE REF TO zcx_abapgit_exception,
          ls_fils_item TYPE zcl_abapgit_objects=&gt;ty_serialization.
    ls_fils_item-item-obj_type = is_tadir-object.
    ls_fils_item-item-obj_name = is_tadir-obj_name.
    ls_fils_item-item-devclass = is_tadir-devclass.

    TRY.
        ls_fils_item = zcl_abapgit_objects=&gt;serialize(
          is_item     = ls_fils_item-item
          iv_language = iv_language ).

        add_to_return( is_fils_item = ls_fils_item
                       iv_path      = is_tadir-path ).
      CATCH zcx_abapgit_exception INTO lx_error.
        IF NOT mo_log IS INITIAL.
          mo_log-&gt;add_error( lx_error-&gt;get_text( ) ).
        ENDIF.
    ENDTRY.

  ENDMETHOD.
  METHOD serialize.

    DATA: lv_max      TYPE i,
          lo_progress TYPE REF TO zcl_abapgit_progress.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF it_tadir.
    CLEAR mt_files.

    lv_max = determine_max_threads( iv_force_sequential ).
    mv_free = lv_max.
    mo_log = io_log.

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( it_tadir ).

    LOOP AT it_tadir ASSIGNING &lt;ls_tadir&gt;.

      lo_progress-&gt;show(
        iv_current = sy-tabix
        iv_text    = |Serialize { &lt;ls_tadir&gt;-obj_name }, { lv_max } threads| ) ##NO_TEXT.

      IF lv_max = 1.
        run_sequential(
          is_tadir    = &lt;ls_tadir&gt;
          iv_language = iv_language ).
      ELSE.
        run_parallel(
          iv_group    = &apos;parallel_generators&apos;    &quot; todo
          is_tadir    = &lt;ls_tadir&gt;
          iv_task     = |{ sy-tabix }|
          iv_language = iv_language ).
        WAIT UNTIL mv_free &gt; 0 UP TO 10 SECONDS.
      ENDIF.
    ENDLOOP.

    WAIT UNTIL mv_free = lv_max UP TO 10 SECONDS.
    rt_files = mt_files.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SAP_PACKAGE IMPLEMENTATION.
  METHOD constructor.
    mv_package = iv_package.
  ENDMETHOD.
  METHOD zif_abapgit_sap_package~are_changes_recorded_in_tr_req.

    DATA: li_package TYPE REF TO if_package.

    cl_package_factory=&gt;load_package(
      EXPORTING
        i_package_name             = mv_package
      IMPORTING
        e_package                  = li_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from CL_PACKAGE_FACTORY=&gt;LOAD_PACKAGE { sy-subrc }| ).
    ENDIF.

    rv_are_changes_rec_in_tr_req = li_package-&gt;wbo_korr_flag.

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~create.

    DATA: lv_err     TYPE string,
          li_package TYPE REF TO if_package,
          ls_package LIKE is_package.
    ASSERT NOT is_package-devclass IS INITIAL.

    cl_package_factory=&gt;load_package(
      EXPORTING
        i_package_name             = is_package-devclass
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    IF sy-subrc = 0.
      &quot; Package already exists. We assume this is fine. Its properties might be changed later at
      &quot; DEVC deserialization.
      RETURN.
    ENDIF.

    ls_package = is_package.

    &quot; Set software component to &apos;HOME&apos; if none is set at this point.
    &quot; Otherwise SOFTWARE_COMPONENT_INVALID will be raised.
    IF ls_package-dlvunit IS INITIAL.
      ls_package-dlvunit = &apos;HOME&apos;.
    ENDIF.

    cl_package_factory=&gt;create_new_package(
      EXPORTING
        i_reuse_deleted_object     = abap_true
*        i_suppress_dialog          = abap_true &quot; does not exist in 730
      IMPORTING
        e_package                  = li_package
      CHANGING
        c_package_data             = ls_package
      EXCEPTIONS
        object_already_existing    = 1
        object_just_created        = 2
        not_authorized             = 3
        wrong_name_prefix          = 4
        undefined_name             = 5
        reserved_local_name        = 6
        invalid_package_name       = 7
        short_text_missing         = 8
        software_component_invalid = 9
        layer_invalid              = 10
        author_not_existing        = 11
        component_not_existing     = 12
        component_missing          = 13
        prefix_in_use              = 14
        unexpected_error           = 15
        intern_err                 = 16
        no_access                  = 17
*        invalid_translation_depth  = 18
*        wrong_mainpack_value       = 19
*        superpackage_invalid       = 20
*        error_in_cts_checks        = 21
        OTHERS                     = 18 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Package { is_package-devclass } could not be created| ).
    ENDIF.

    li_package-&gt;save(
*      EXPORTING
*        i_suppress_dialog     = abap_true    &quot; Controls whether popups can be transmitted
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7 ).
    IF sy-subrc &lt;&gt; 0.

      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_err.

      &quot; Here we have to delete the package,
      &quot; otherwise it would remain in the memory
      &quot; and cannot created again in this session.
      li_package-&gt;delete(
        EXCEPTIONS
          object_not_empty      = 1
          object_not_changeable = 2
          object_invalid        = 3
          intern_err            = 4
          OTHERS                = 5 ).

      zcx_abapgit_exception=&gt;raise( lv_err ).

    ENDIF.

    li_package-&gt;set_changeable( abap_false ).

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~create_child.

    DATA: li_parent TYPE REF TO if_package,
          ls_child  TYPE scompkdtln.
    cl_package_factory=&gt;load_package(
      EXPORTING
        i_package_name             = mv_package
      IMPORTING
        e_package                  = li_parent
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error reading parent package&apos; ).
    ENDIF.

    ls_child-devclass  = iv_child.
    ls_child-dlvunit   = li_parent-&gt;software_component.
    ls_child-component = li_parent-&gt;application_component.
    ls_child-ctext     = iv_child.
    ls_child-parentcl  = mv_package.
    ls_child-pdevclass = li_parent-&gt;transport_layer.
    ls_child-as4user   = sy-uname.

    create( ls_child ).

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~create_local.

    DATA: ls_package TYPE scompkdtln.
    ls_package-devclass  = mv_package.
    ls_package-ctext     = mv_package.
    ls_package-parentcl  = &apos;$TMP&apos;.
    ls_package-dlvunit   = &apos;LOCAL&apos;.
    ls_package-as4user   = sy-uname.

    create( ls_package ).

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~exists.

    cl_package_factory=&gt;load_package(
      EXPORTING
        i_package_name             = mv_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    rv_bool = boolc( sy-subrc &lt;&gt; 1 ).

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~get_transport_type.
    DATA: lv_err_prefix TYPE string,
          lv_pkg_name   TYPE e071-obj_name.

    lv_err_prefix = |TRINT_GET_REQUEST_TYPE(R3TR, DEVC, { mv_package })|.
    lv_pkg_name = mv_package.

    CALL FUNCTION &apos;TRINT_GET_REQUEST_TYPE&apos;
      EXPORTING
        iv_pgmid                   = &apos;R3TR&apos;
        iv_object                  = &apos;DEVC&apos;
        iv_obj_name                = lv_pkg_name
      IMPORTING
        ev_request_type            = rv_transport_type-request
        ev_task_type               = rv_transport_type-task
      EXCEPTIONS
        no_request_needed          = 1
        internal_error             = 2
        cts_initialization_failure = 3.

    CASE sy-subrc.
      WHEN 0.
        &quot; OK!

      WHEN 1.
        zcx_abapgit_exception=&gt;raise( |{ lv_err_prefix }: transport is not needed| ).

      WHEN 2.
        zcx_abapgit_exception=&gt;raise( |{ lv_err_prefix }: internal error| ).

      WHEN 3.
        zcx_abapgit_exception=&gt;raise( |{ lv_err_prefix }: failed to initialized CTS| ).

      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |{ lv_err_prefix }: unrecognized return code| ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~list_subpackages.

    DATA: lt_list     LIKE rt_list.

    SELECT devclass FROM tdevc
      INTO TABLE lt_list
      WHERE parentcl = mv_package
      ORDER BY PRIMARY KEY.               &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    rt_list = lt_list.
    WHILE lines( lt_list ) &gt; 0.

      SELECT devclass FROM tdevc
        INTO TABLE lt_list
        FOR ALL ENTRIES IN lt_list
        WHERE parentcl = lt_list-table_line
        ORDER BY PRIMARY KEY.             &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF
      APPEND LINES OF lt_list TO rt_list.

    ENDWHILE.

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~list_superpackages.

    DATA: lt_list   LIKE rt_list,
          lv_parent TYPE tdevc-parentcl.
    APPEND mv_package TO rt_list.

    lv_parent = zif_abapgit_sap_package~read_parent( ).

    IF sy-subrc = 0 AND NOT lv_parent IS INITIAL.
      lt_list = zcl_abapgit_factory=&gt;get_sap_package( lv_parent )-&gt;list_superpackages( ).
      APPEND LINES OF lt_list TO rt_list.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_sap_package~read_parent.

    SELECT SINGLE parentcl FROM tdevc INTO rv_parentcl
      WHERE devclass = mv_package.        &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF
    ASSERT sy-subrc = 0.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REPO_SRV IMPLEMENTATION.
  METHOD add.

    DATA: lo_repo LIKE LINE OF mt_list.
    LOOP AT mt_list INTO lo_repo.
      IF lo_repo-&gt;get_key( ) = io_repo-&gt;get_key( ).
        IF lo_repo = io_repo.
          RETURN.
        ENDIF.
        zcx_abapgit_exception=&gt;raise( &apos;identical keys&apos; ).
      ENDIF.
    ENDLOOP.

    io_repo-&gt;bind_listener( me ).
    APPEND io_repo TO mt_list.

  ENDMETHOD.
  METHOD instantiate_and_add.

    IF is_repo_meta-offline = abap_false.
      CREATE OBJECT ro_repo TYPE zcl_abapgit_repo_online
        EXPORTING
          is_data = is_repo_meta.
    ELSE.
      CREATE OBJECT ro_repo TYPE zcl_abapgit_repo_offline
        EXPORTING
          is_data = is_repo_meta.
    ENDIF.
    add( ro_repo ).

  ENDMETHOD.
  METHOD get_instance.
    IF gi_ref IS INITIAL.
      CREATE OBJECT gi_ref TYPE zcl_abapgit_repo_srv.
    ENDIF.
    ri_srv = gi_ref.
  ENDMETHOD.
  METHOD is_sap_object_allowed.

    rv_allowed = cl_enh_badi_def_utility=&gt;is_sap_system( ).
    IF rv_allowed = abap_true.
      RETURN.
    ENDIF.

    rv_allowed = zcl_abapgit_exit=&gt;get_instance( )-&gt;allow_sap_objects( ).

  ENDMETHOD.
  METHOD refresh.

    DATA: lt_list    TYPE zif_abapgit_persistence=&gt;tt_repo,
          lo_online  TYPE REF TO zcl_abapgit_repo_online,
          lo_offline TYPE REF TO zcl_abapgit_repo_offline.

    FIELD-SYMBOLS: &lt;ls_list&gt; LIKE LINE OF lt_list.
    CLEAR mt_list.

    lt_list = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;list( ).
    LOOP AT lt_list ASSIGNING &lt;ls_list&gt;.
      instantiate_and_add( &lt;ls_list&gt; ).
    ENDLOOP.

    mv_init = abap_true.

  ENDMETHOD.
  METHOD validate_sub_super_packages.
    DATA:
      ls_repo     LIKE LINE OF it_repos,
      lo_package  TYPE REF TO zif_abapgit_sap_package,
      lt_packages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
      lo_repo     TYPE REF TO zcl_abapgit_repo.

    LOOP AT it_repos INTO ls_repo.
      lo_repo = get( ls_repo-key ).

      lo_package = zcl_abapgit_factory=&gt;get_sap_package( ls_repo-package ).
      IF lo_package-&gt;exists( ) EQ abap_false.
        &quot; Skip dangling repository
        CONTINUE.
      ENDIF.

      CLEAR lt_packages.
      IF lo_repo-&gt;get_local_settings( )-ignore_subpackages = abap_false.
        APPEND LINES OF lo_package-&gt;list_subpackages( ) TO lt_packages.
      ENDIF.
      APPEND LINES OF lo_package-&gt;list_superpackages( ) TO lt_packages.

      READ TABLE lt_packages TRANSPORTING NO FIELDS
        WITH KEY table_line = iv_package.
      IF sy-subrc = 0.
        zcx_abapgit_exception=&gt;raise( |Repository { lo_repo-&gt;get_name( ) } already contains { iv_package } | ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~delete.

    zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;delete( io_repo-&gt;get_key( ) ).

    DELETE TABLE mt_list FROM io_repo.
    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~get.

    FIELD-SYMBOLS: &lt;lo_list&gt; LIKE LINE OF mt_list.
    IF mv_init = abap_false.
      refresh( ).
    ENDIF.

    LOOP AT mt_list ASSIGNING &lt;lo_list&gt;.
      IF &lt;lo_list&gt;-&gt;get_key( ) = iv_key.
        ro_repo = &lt;lo_list&gt;.
        RETURN.
      ENDIF.
    ENDLOOP.

    zcx_abapgit_exception=&gt;raise( &apos;repo not found, get&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~is_repo_installed.

    DATA: lt_repo        TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt,
          lo_repo        TYPE REF TO zcl_abapgit_repo,
          lv_url         TYPE string,
          lv_package     TYPE devclass,
          lo_repo_online TYPE REF TO zcl_abapgit_repo_online,
          lv_err         TYPE string.

    lt_repo = list( ).

    LOOP AT lt_repo INTO lo_repo.
      CHECK lo_repo-&gt;is_offline( ) = abap_false.
      lo_repo_online ?= lo_repo.

      lv_url     = lo_repo_online-&gt;get_url( ).
      lv_package = lo_repo_online-&gt;get_package( ).
      CHECK to_upper( lv_url ) = to_upper( iv_url ).

      &quot; Validate bindings
      &quot;TODO refactor: move this message out of this method
      IF iv_target_package IS NOT INITIAL AND iv_target_package &lt;&gt; lv_package.
        lv_err = |Installation to package { lv_package } detected. |
              &amp;&amp; |Cancelling installation|.
        zcx_abapgit_exception=&gt;raise( lv_err ).
      ENDIF.

      rv_installed = abap_true.
      EXIT.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~list.

    IF mv_init = abap_false.
      refresh( ).
    ENDIF.

    rt_list = mt_list.

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~new_offline.

    DATA: ls_repo TYPE zif_abapgit_persistence=&gt;ty_repo,
          lv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    validate_package( iv_package ).

    lv_key = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;add(
      iv_url         = iv_url
      iv_branch_name = &apos;&apos;
      iv_package     = iv_package
      iv_offline     = abap_true
      is_dot_abapgit = zcl_abapgit_dot_abapgit=&gt;build_default( )-&gt;get_data( ) ).

    TRY.
        ls_repo = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;read( lv_key ).
      CATCH zcx_abapgit_not_found.
        zcx_abapgit_exception=&gt;raise( &apos;new_offline not found&apos; ).
    ENDTRY.

    ro_repo ?= instantiate_and_add( ls_repo ).

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~new_online.

    DATA: ls_repo TYPE zif_abapgit_persistence=&gt;ty_repo,
          lv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    ASSERT NOT iv_url IS INITIAL
      AND NOT iv_branch_name IS INITIAL
      AND NOT iv_package IS INITIAL.

    validate_package( iv_package ).
    zcl_abapgit_url=&gt;validate( |{ iv_url }| ).

    lv_key = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;add(
      iv_url         = iv_url
      iv_branch_name = iv_branch_name
      iv_package     = iv_package
      iv_offline     = abap_false
      is_dot_abapgit = zcl_abapgit_dot_abapgit=&gt;build_default( )-&gt;get_data( ) ).
    TRY.
        ls_repo = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;read( lv_key ).
      CATCH zcx_abapgit_not_found.
        zcx_abapgit_exception=&gt;raise( &apos;new_online not found&apos; ).
    ENDTRY.

    ro_repo ?= instantiate_and_add( ls_repo ).

    ro_repo-&gt;refresh( ).
    ro_repo-&gt;find_remote_dot_abapgit( ).

  ENDMETHOD.
  METHOD zif_abapgit_repo_listener~on_meta_change.

    DATA li_persistence TYPE REF TO zif_abapgit_persist_repo.

    li_persistence = zcl_abapgit_persist_factory=&gt;get_repo( ).
    li_persistence-&gt;update_metadata(
      iv_key         = iv_key
      is_meta        = is_meta
      is_change_mask = is_change_mask ).
    &quot; Recreate repo instance if type changed
    &quot; Instances in mt_list are of *_online and *_offline type
    &quot; If type is changed object should be recreated from the proper class
    &quot; TODO refactor, e.g. unify repo logic in one class
    IF is_change_mask-offline = abap_true.
      reinstantiate_repo(
        iv_key  = iv_key
        is_meta = is_meta ).

    ENDIF.

  ENDMETHOD.
  METHOD reinstantiate_repo.

      DATA lo_repo      TYPE REF TO zcl_abapgit_repo.
      DATA ls_full_meta TYPE zif_abapgit_persistence=&gt;ty_repo.

      lo_repo = get( iv_key ).
      DELETE TABLE mt_list FROM lo_repo.
      ASSERT sy-subrc IS INITIAL.

      MOVE-CORRESPONDING is_meta TO ls_full_meta.
      ls_full_meta-key = iv_key.

      instantiate_and_add( ls_full_meta ).

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~purge.

* todo, this should be a method on the repo instead

    DATA: lt_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt.
    IF io_repo-&gt;get_local_settings( )-write_protected = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot purge. Local code is write-protected by repo config&apos; ).
    ELSEIF zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-uninstall ) = abap_false.
      zcx_abapgit_exception=&gt;raise( &apos;Not authorized&apos; ).
    ENDIF.

    lt_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read( io_repo-&gt;get_package( ) ).

    zcl_abapgit_objects=&gt;delete( it_tadir  = lt_tadir
                                 is_checks = is_checks ).

    delete( io_repo ).

  ENDMETHOD.
  METHOD zif_abapgit_repo_srv~validate_package.

    DATA: lv_as4user TYPE tdevc-as4user,
          lt_repos   TYPE zif_abapgit_persistence=&gt;tt_repo.

    IF iv_package IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;add, package empty&apos; ).
    ENDIF.

    IF iv_package = &apos;$TMP&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;not possible to use $TMP, create new (local) package&apos; ).
    ENDIF.

    SELECT SINGLE as4user FROM tdevc
      INTO lv_as4user
      WHERE devclass = iv_package.                      &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Package { iv_package } not found| ).
    ENDIF.

    IF is_sap_object_allowed( ) = abap_false AND lv_as4user = &apos;SAP&apos;.
      zcx_abapgit_exception=&gt;raise( |Package { iv_package } not allowed| ).
    ENDIF.

    &quot; make sure its not already in use for a different repository
    lt_repos = zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;list( ).
    READ TABLE lt_repos WITH KEY package = iv_package TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      zcx_abapgit_exception=&gt;raise( |Package { iv_package } already in use| ).
    ENDIF.

    validate_sub_super_packages(
      iv_package = iv_package
      it_repos   = lt_repos ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REPO_ONLINE IMPLEMENTATION.
  METHOD fetch_remote.

    DATA: lo_progress TYPE REF TO zcl_abapgit_progress,
          ls_pull     TYPE zcl_abapgit_git_porcelain=&gt;ty_pull_result.

    IF mv_request_remote_refresh = abap_false.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = 1.
    lo_progress-&gt;show( iv_current = 1
                       iv_text    = &apos;Fetch remote files&apos; ) ##NO_TEXT.

    ls_pull = zcl_abapgit_git_porcelain=&gt;pull(
      iv_url         = get_url( )
      iv_branch_name = get_branch_name( ) ).

    set_files_remote( ls_pull-files ).
    set_objects( ls_pull-objects ).
    mv_branch = ls_pull-branch.

  ENDMETHOD.
  METHOD get_branch_name.
    rv_name = ms_data-branch_name.
  ENDMETHOD.
  METHOD get_files_remote.
    fetch_remote( ).
    rt_files = super-&gt;get_files_remote( ).
  ENDMETHOD.
  METHOD get_name.
    rv_name = zcl_abapgit_url=&gt;name( ms_data-url ).
    rv_name = cl_http_utility=&gt;if_http_utility~unescape_url( rv_name ).
  ENDMETHOD.
  METHOD get_objects.
    fetch_remote( ).
    rt_objects = mt_objects.
  ENDMETHOD.
  METHOD get_sha1_remote.
    fetch_remote( ).
    rv_sha1 = mv_branch.
  ENDMETHOD.
  METHOD get_url.
    rv_url = ms_data-url.
  ENDMETHOD.
  METHOD handle_stage_ignore.

    DATA: lv_add         TYPE abap_bool,
          lo_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit,
          lt_stage       TYPE zcl_abapgit_stage=&gt;ty_stage_tt.

    FIELD-SYMBOLS: &lt;ls_stage&gt; LIKE LINE OF lt_stage.
    lo_dot_abapgit = get_dot_abapgit( ).
    lt_stage = io_stage-&gt;get_all( ).
    LOOP AT lt_stage ASSIGNING &lt;ls_stage&gt; WHERE method = zcl_abapgit_stage=&gt;c_method-ignore.

      lo_dot_abapgit-&gt;add_ignore(
        iv_path     = &lt;ls_stage&gt;-file-path
        iv_filename = &lt;ls_stage&gt;-file-filename ).

      &quot; remove it from the staging object, as the action is handled here
      io_stage-&gt;reset( iv_path     = &lt;ls_stage&gt;-file-path
                       iv_filename = &lt;ls_stage&gt;-file-filename ).

      lv_add = abap_true.

    ENDLOOP.

    IF lv_add = abap_true.
      io_stage-&gt;add(
        iv_path     = zif_abapgit_definitions=&gt;c_root_dir
        iv_filename = zif_abapgit_definitions=&gt;c_dot_abapgit
        iv_data     = lo_dot_abapgit-&gt;serialize( ) ).

      set_dot_abapgit( lo_dot_abapgit ).
    ENDIF.

  ENDMETHOD.
  METHOD has_remote_source.
    rv_yes = abap_true.
  ENDMETHOD.
  METHOD rebuild_local_checksums.

    &quot; TODO: method unify to base class !

    DATA:
          lt_remote    TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lt_local     TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
          ls_last_item TYPE zif_abapgit_definitions=&gt;ty_item,
          lt_checksums TYPE zif_abapgit_persistence=&gt;ty_local_checksum_tt.

    FIELD-SYMBOLS:
                   &lt;ls_checksum&gt; LIKE LINE OF lt_checksums,
                   &lt;ls_file_sig&gt; LIKE LINE OF &lt;ls_checksum&gt;-files,
                   &lt;ls_remote&gt;   LIKE LINE OF lt_remote,
                   &lt;ls_local&gt;    LIKE LINE OF lt_local.

    lt_local  = get_files_local( ).

    DELETE lt_local &quot; Remove non-code related files except .abapgit
      WHERE item IS INITIAL
      AND NOT ( file-path     = zif_abapgit_definitions=&gt;c_root_dir
      AND       file-filename = zif_abapgit_definitions=&gt;c_dot_abapgit ).
    SORT lt_local BY item.

    lt_remote = get_files_remote( ).
    SORT lt_remote BY path filename.

    LOOP AT lt_local ASSIGNING &lt;ls_local&gt;.
      IF ls_last_item &lt;&gt; &lt;ls_local&gt;-item OR sy-tabix = 1. &quot; First or New item reached ?
        APPEND INITIAL LINE TO lt_checksums ASSIGNING &lt;ls_checksum&gt;.
        &lt;ls_checksum&gt;-item = &lt;ls_local&gt;-item.
        ls_last_item       = &lt;ls_local&gt;-item.
      ENDIF.

      READ TABLE lt_remote ASSIGNING &lt;ls_remote&gt;
        WITH KEY path = &lt;ls_local&gt;-file-path filename = &lt;ls_local&gt;-file-filename
        BINARY SEARCH.
      CHECK sy-subrc = 0.  &quot; Ignore new local ones

      APPEND INITIAL LINE TO &lt;ls_checksum&gt;-files ASSIGNING &lt;ls_file_sig&gt;.
      MOVE-CORRESPONDING &lt;ls_local&gt;-file TO &lt;ls_file_sig&gt;.

      &quot; If hashes are equal -&gt; local sha1 is OK
      &quot; Else if R-branch is ahead  -&gt; assume changes were remote, state - local sha1
      &quot;      Else (branches equal) -&gt; assume changes were local, state - remote sha1
      IF &lt;ls_local&gt;-file-sha1 &lt;&gt; &lt;ls_remote&gt;-sha1.
        &lt;ls_file_sig&gt;-sha1 = &lt;ls_remote&gt;-sha1.
      ENDIF.
    ENDLOOP.

    set( it_checksums = lt_checksums ).
    reset_status( ).

  ENDMETHOD.
  METHOD set_branch_name.

    IF ms_data-local_settings-write_protected = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot switch branch. Local code is write-protected by repo config&apos; ).
    ENDIF.

    reset_remote( ).
    set( iv_branch_name = iv_branch_name ).

  ENDMETHOD.
  METHOD set_objects.
    mt_objects = it_objects.
  ENDMETHOD.
  METHOD set_url.

    IF ms_data-local_settings-write_protected = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot change URL. Local code is write-protected by repo config&apos; ).
    ENDIF.

    reset_remote( ).
    set( iv_url = iv_url ).

  ENDMETHOD.
  METHOD zif_abapgit_git_operations~create_branch.

    DATA: lv_sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1.

    ASSERT iv_name CP &apos;refs/heads/+*&apos;.

    IF iv_from IS INITIAL.
      lv_sha1 = get_sha1_remote( ).
    ELSE.
      lv_sha1 = iv_from.
    ENDIF.

    zcl_abapgit_git_porcelain=&gt;create_branch(
      iv_url  = get_url( )
      iv_name = iv_name
      iv_from = lv_sha1 ).

    &quot; automatically switch to new branch
    set_branch_name( iv_name ).

  ENDMETHOD.
  METHOD zif_abapgit_git_operations~push.

* assumption: PUSH is done on top of the currently selected branch

    DATA: ls_push TYPE zcl_abapgit_git_porcelain=&gt;ty_push_result,
          lv_text TYPE string.
    IF ms_data-branch_name CP &apos;refs/tags*&apos;.
      lv_text = |You&apos;re working on a tag. Currently it&apos;s not |
             &amp;&amp; |possible to push on tags. Consider creating a branch instead|.
      zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDIF.

    IF ms_data-local_settings-block_commit = abap_true
        AND mv_code_inspector_successful = abap_false.
      zcx_abapgit_exception=&gt;raise( |A successful code inspection is required| ).
    ENDIF.

    handle_stage_ignore( io_stage ).

    ls_push = zcl_abapgit_git_porcelain=&gt;push(
      is_comment     = is_comment
      io_stage       = io_stage
      iv_branch_name = get_branch_name( )
      iv_url         = get_url( )
      iv_parent      = get_sha1_remote( )
      it_old_objects = get_objects( ) ).

    set_objects( ls_push-new_objects ).
    set_files_remote( ls_push-new_files ).

    mv_branch = ls_push-branch.

    update_local_checksums( ls_push-updated_files ).

    reset_status( ).
    CLEAR: mv_code_inspector_successful.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REPO_OFFLINE IMPLEMENTATION.
  METHOD get_name.
    rv_name = ms_data-url.
  ENDMETHOD.
  METHOD has_remote_source.
    rv_yes = boolc( lines( mt_remote ) &gt; 0 ).
  ENDMETHOD.
  METHOD reset_remote.

    DATA lt_backup LIKE mt_remote.

    &quot; online repo has online source to renew data from, offline does not
    &quot; so offline repo preserves the remote
    &quot; in case of partial pull failure the user will immediately see the new difference
    &quot; UI will detect &quot;pullable&quot; content based on mt_status
    &quot; in the uniform way both for online and offline repos
    &quot; for more details see discussion in 2096 and 1953

    lt_backup = mt_remote.
    super-&gt;reset_remote( ).
    set_files_remote( lt_backup ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REPO_CONTENT_LIST IMPLEMENTATION.
  METHOD build_folders.

    DATA: lv_index    TYPE i,
          lt_subitems LIKE ct_repo_items,
          ls_subitem  LIKE LINE OF ct_repo_items,
          ls_folder   LIKE LINE OF ct_repo_items.

    FIELD-SYMBOLS &lt;ls_item&gt; LIKE LINE OF ct_repo_items.
    LOOP AT ct_repo_items ASSIGNING &lt;ls_item&gt;.
      lv_index = sy-tabix.
      CHECK &lt;ls_item&gt;-path &lt;&gt; iv_cur_dir. &quot; files in target dir - just leave them be

      IF zcl_abapgit_path=&gt;is_subdir( iv_path = &lt;ls_item&gt;-path  iv_parent = iv_cur_dir ) = abap_true.
        ls_subitem-changes = &lt;ls_item&gt;-changes.
        ls_subitem-path    = &lt;ls_item&gt;-path.
        ls_subitem-lstate  = &lt;ls_item&gt;-lstate.
        ls_subitem-rstate  = &lt;ls_item&gt;-rstate.
        APPEND ls_subitem TO lt_subitems.
      ENDIF.

      DELETE ct_repo_items INDEX lv_index.
    ENDLOOP.

    SORT lt_subitems BY path ASCENDING.

    LOOP AT lt_subitems ASSIGNING &lt;ls_item&gt;.
      AT NEW path.
        CLEAR ls_folder.
        ls_folder-path    = &lt;ls_item&gt;-path.
        ls_folder-sortkey = c_sortkey-dir. &quot; Directory
        ls_folder-is_dir  = abap_true.
      ENDAT.

      ls_folder-changes = ls_folder-changes + &lt;ls_item&gt;-changes.

      zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = &lt;ls_item&gt;-lstate
                                 CHANGING cv_prev = ls_folder-lstate ).
      zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = &lt;ls_item&gt;-rstate
                                 CHANGING cv_prev = ls_folder-rstate ).

      AT END OF path.
        APPEND ls_folder TO ct_repo_items.
      ENDAT.
    ENDLOOP.

  ENDMETHOD.
  METHOD build_repo_items_local_only.

    DATA: lt_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          ls_item  TYPE zif_abapgit_definitions=&gt;ty_item.

    FIELD-SYMBOLS: &lt;ls_repo_item&gt; LIKE LINE OF rt_repo_items,
                   &lt;ls_tadir&gt;     LIKE LINE OF lt_tadir.
    lt_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read(
      iv_package = mo_repo-&gt;get_package( )
      io_dot     = mo_repo-&gt;get_dot_abapgit( ) ).

    LOOP AT lt_tadir ASSIGNING &lt;ls_tadir&gt;.
      APPEND INITIAL LINE TO rt_repo_items ASSIGNING &lt;ls_repo_item&gt;.
      &lt;ls_repo_item&gt;-obj_type = &lt;ls_tadir&gt;-object.
      &lt;ls_repo_item&gt;-obj_name = &lt;ls_tadir&gt;-obj_name.
      &lt;ls_repo_item&gt;-path     = &lt;ls_tadir&gt;-path.
      MOVE-CORRESPONDING &lt;ls_repo_item&gt; TO ls_item.
      &lt;ls_repo_item&gt;-inactive = boolc( zcl_abapgit_objects=&gt;is_active( ls_item ) = abap_false ).
      IF &lt;ls_repo_item&gt;-inactive = abap_true.
        &lt;ls_repo_item&gt;-sortkey = c_sortkey-inactive.
      ELSE.
        &lt;ls_repo_item&gt;-sortkey  = c_sortkey-default.      &quot; Default sort key
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD build_repo_items_with_remote.

    DATA:
          ls_file        TYPE zif_abapgit_definitions=&gt;ty_repo_file,
          lt_status      TYPE zif_abapgit_definitions=&gt;ty_results_tt.

    FIELD-SYMBOLS: &lt;ls_status&gt;    LIKE LINE OF lt_status,
                   &lt;ls_repo_item&gt; LIKE LINE OF rt_repo_items.
    lt_status       = mo_repo-&gt;status( mo_log ).

    LOOP AT lt_status ASSIGNING &lt;ls_status&gt;.
      AT NEW obj_name. &quot;obj_type + obj_name
        APPEND INITIAL LINE TO rt_repo_items ASSIGNING &lt;ls_repo_item&gt;.
        &lt;ls_repo_item&gt;-obj_type = &lt;ls_status&gt;-obj_type.
        &lt;ls_repo_item&gt;-obj_name = &lt;ls_status&gt;-obj_name.
        &lt;ls_repo_item&gt;-inactive = &lt;ls_status&gt;-inactive.
        &lt;ls_repo_item&gt;-sortkey  = c_sortkey-default. &quot; Default sort key
        &lt;ls_repo_item&gt;-changes  = 0.
        &lt;ls_repo_item&gt;-path     = &lt;ls_status&gt;-path.
      ENDAT.

      IF &lt;ls_status&gt;-filename IS NOT INITIAL.
        ls_file-path       = &lt;ls_status&gt;-path.
        ls_file-filename   = &lt;ls_status&gt;-filename.
        ls_file-is_changed = boolc( &lt;ls_status&gt;-match = abap_false ). &quot; TODO refactor
        ls_file-rstate     = &lt;ls_status&gt;-rstate.
        ls_file-lstate     = &lt;ls_status&gt;-lstate.
        APPEND ls_file TO &lt;ls_repo_item&gt;-files.

        IF &lt;ls_status&gt;-inactive = abap_true AND
           &lt;ls_repo_item&gt;-sortkey &gt; c_sortkey-changed.
          &lt;ls_repo_item&gt;-sortkey = c_sortkey-inactive.
        ENDIF.

        IF ls_file-is_changed = abap_true.
          &lt;ls_repo_item&gt;-sortkey = c_sortkey-changed. &quot; Changed files
          &lt;ls_repo_item&gt;-changes = &lt;ls_repo_item&gt;-changes + 1.

          zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = ls_file-lstate
                                     CHANGING cv_prev = &lt;ls_repo_item&gt;-lstate ).
          zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = ls_file-rstate
                                     CHANGING cv_prev = &lt;ls_repo_item&gt;-rstate ).
        ENDIF.
      ENDIF.

      AT END OF obj_name. &quot;obj_type + obj_name
        IF &lt;ls_repo_item&gt;-obj_type IS INITIAL.
          &lt;ls_repo_item&gt;-sortkey = c_sortkey-orphan. &quot;Virtual objects
        ENDIF.
      ENDAT.
    ENDLOOP.

  ENDMETHOD.
  METHOD constructor.
    mo_repo = io_repo.
    CREATE OBJECT mo_log.
  ENDMETHOD.
  METHOD filter_changes.

    DELETE ct_repo_items WHERE changes = 0.

  ENDMETHOD.
  METHOD get_log.
    ro_log = mo_log.
  ENDMETHOD.
  METHOD list.

    mo_log-&gt;clear( ).

    IF mo_repo-&gt;has_remote_source( ) = abap_true.
      rt_repo_items = build_repo_items_with_remote( ).
    ELSE.
      rt_repo_items = build_repo_items_local_only( ).
    ENDIF.

    IF iv_by_folders = abap_true.
      build_folders(
        EXPORTING iv_cur_dir    = iv_path
        CHANGING  ct_repo_items = rt_repo_items ).
    ENDIF.

    IF iv_changes_only = abap_true.
      &quot; There are never changes for offline repositories
      filter_changes( CHANGING ct_repo_items = rt_repo_items ).
    ENDIF.

    SORT rt_repo_items BY
      sortkey ASCENDING
      obj_type ASCENDING
      obj_name ASCENDING.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REPO IMPLEMENTATION.
  METHOD apply_filter.

    DATA: lt_filter TYPE SORTED TABLE OF zif_abapgit_definitions=&gt;ty_tadir
                      WITH NON-UNIQUE KEY object obj_name,
          lv_index  TYPE i.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF ct_tadir.
    IF lines( it_filter ) = 0.
      RETURN.
    ENDIF.

    lt_filter = it_filter.

* this is another loop at TADIR, but typically the filter is blank
    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;.
      lv_index = sy-tabix.
      READ TABLE lt_filter TRANSPORTING NO FIELDS WITH KEY object = &lt;ls_tadir&gt;-object
                                                           obj_name = &lt;ls_tadir&gt;-obj_name
                                                  BINARY SEARCH.
      IF sy-subrc &lt;&gt; 0.
        DELETE ct_tadir INDEX lv_index.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD build_dotabapgit_file.

    rs_file-path     = zif_abapgit_definitions=&gt;c_root_dir.
    rs_file-filename = zif_abapgit_definitions=&gt;c_dot_abapgit.
    rs_file-data     = get_dot_abapgit( )-&gt;serialize( ).
    rs_file-sha1     = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-blob
                                               iv_data = rs_file-data ).

  ENDMETHOD.
  METHOD constructor.

    ASSERT NOT is_data-key IS INITIAL.

    ms_data = is_data.
    mv_request_remote_refresh = abap_true.

  ENDMETHOD.
  METHOD conversion_exit_isola_output.

    CALL FUNCTION &apos;CONVERSION_EXIT_ISOLA_OUTPUT&apos;
      EXPORTING
        input  = iv_spras
      IMPORTING
        output = rv_spras.

  ENDMETHOD.
  METHOD delete_checks.

    DATA: li_package TYPE REF TO zif_abapgit_sap_package.

    li_package = zcl_abapgit_factory=&gt;get_sap_package( get_package( ) ).
    rs_checks-transport-required = li_package-&gt;are_changes_recorded_in_tr_req( ).

  ENDMETHOD.
  METHOD deserialize.

    DATA: lt_updated_files TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt,
          lx_error         TYPE REF TO zcx_abapgit_exception.
    deserialize_checks( ).

    IF is_checks-requirements-met = &apos;N&apos; AND is_checks-requirements-decision IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Requirements not met and undecided&apos; ).
    ENDIF.

    IF is_checks-transport-required = abap_true AND is_checks-transport-transport IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |No transport request was supplied| ).
    ENDIF.

    TRY.
        lt_updated_files = zcl_abapgit_objects=&gt;deserialize(
            io_repo   = me
            is_checks = is_checks ).
      CATCH zcx_abapgit_exception INTO lx_error.
* ensure to reset default transport request task
        zcl_abapgit_default_transport=&gt;get_instance( )-&gt;reset( ).
        RAISE EXCEPTION lx_error.
    ENDTRY.

    APPEND get_dot_abapgit( )-&gt;get_signature( ) TO lt_updated_files.

    CLEAR: mt_local, mv_last_serialization.

    update_local_checksums( lt_updated_files ).
    update_last_deserialize( ).
    reset_status( ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD deserialize_checks.

    DATA: lt_requirements    TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt,
          lv_master_language TYPE spras,
          lv_logon_language  TYPE spras.
    find_remote_dot_abapgit( ).

    lv_master_language = get_dot_abapgit( )-&gt;get_master_language( ).
    lv_logon_language  = sy-langu.

    IF get_local_settings( )-write_protected = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot deserialize. Local code is write-protected by repo config&apos; ).
    ELSEIF lv_master_language &lt;&gt; lv_logon_language.
      zcx_abapgit_exception=&gt;raise( |Current login language |
                                 &amp;&amp; |&apos;{ conversion_exit_isola_output( lv_logon_language ) }&apos;|
                                 &amp;&amp; | does not match master language |
                                 &amp;&amp; |&apos;{ conversion_exit_isola_output( lv_master_language ) }&apos;| ).
    ENDIF.

    rs_checks = zcl_abapgit_objects=&gt;deserialize_checks( me ).

    lt_requirements = get_dot_abapgit( )-&gt;get_data( )-requirements.
    rs_checks-requirements-met = zcl_abapgit_requirement_helper=&gt;is_requirements_met(
      lt_requirements ).

  ENDMETHOD.
  METHOD find_remote_dot_abapgit.

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF mt_remote.

    get_files_remote( ).

    READ TABLE mt_remote ASSIGNING &lt;ls_remote&gt;
      WITH KEY path = zif_abapgit_definitions=&gt;c_root_dir
      filename = zif_abapgit_definitions=&gt;c_dot_abapgit.
    IF sy-subrc = 0.
      ro_dot = zcl_abapgit_dot_abapgit=&gt;deserialize( &lt;ls_remote&gt;-data ).
      set_dot_abapgit( ro_dot ).
    ENDIF.

  ENDMETHOD.
  METHOD get_dot_abapgit.
    CREATE OBJECT ro_dot_abapgit
      EXPORTING
        is_data = ms_data-dot_abapgit.
  ENDMETHOD.
  METHOD get_files_local.

    DATA: lt_tadir     TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lo_serialize TYPE REF TO zcl_abapgit_serialize,
          lt_cache     TYPE ty_cache_tt,
          lt_found     LIKE rt_files.

    FIELD-SYMBOLS: &lt;ls_return&gt; LIKE LINE OF rt_files.
    &quot; Serialization happened before and no refresh request
    IF mv_last_serialization IS NOT INITIAL AND mv_request_local_refresh = abap_false.
      rt_files = mt_local.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO rt_files ASSIGNING &lt;ls_return&gt;.
    &lt;ls_return&gt;-file = build_dotabapgit_file( ).

    lt_cache = mt_local.

    lt_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read(
      iv_package            = get_package( )
      iv_ignore_subpackages = get_local_settings( )-ignore_subpackages
      iv_only_local_objects = get_local_settings( )-only_local_objects
      io_dot                = get_dot_abapgit( )
      io_log                = io_log ).

    apply_filter( EXPORTING it_filter = it_filter
                  CHANGING ct_tadir  = lt_tadir ).

    lookup_cache(
      EXPORTING it_cache = lt_cache
      IMPORTING et_found = lt_found
      CHANGING ct_tadir = lt_tadir ).
    APPEND LINES OF lt_found TO rt_files.

    CREATE OBJECT lo_serialize.

    lt_found = lo_serialize-&gt;serialize(
      it_tadir    = lt_tadir
      iv_language = get_dot_abapgit( )-&gt;get_master_language( )
      io_log      = io_log ).
    APPEND LINES OF lt_found TO rt_files.

    GET TIME STAMP FIELD mv_last_serialization.
    mt_local                 = rt_files.
    mv_request_local_refresh = abap_false. &quot; Fulfill refresh

  ENDMETHOD.
  METHOD get_files_remote.
    rt_files = mt_remote.
  ENDMETHOD.
  METHOD get_key.
    rv_key = ms_data-key.
  ENDMETHOD.
  METHOD get_local_checksums.
    rt_checksums = ms_data-local_checksums.
  ENDMETHOD.
  METHOD get_local_checksums_per_file.

    FIELD-SYMBOLS &lt;ls_object&gt; LIKE LINE OF ms_data-local_checksums.

    LOOP AT ms_data-local_checksums ASSIGNING &lt;ls_object&gt;.
      APPEND LINES OF &lt;ls_object&gt;-files TO rt_checksums.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_local_settings.

    rs_settings = ms_data-local_settings.

  ENDMETHOD.
  METHOD get_package.
    rv_package = ms_data-package.
  ENDMETHOD.
  METHOD get_unnecessary_local_objs.

    DATA: lt_tadir        TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lt_tadir_unique TYPE HASHED TABLE OF zif_abapgit_definitions=&gt;ty_tadir
                               WITH UNIQUE KEY pgmid object obj_name,
          lt_local        TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
          lt_remote       TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lt_status       TYPE zif_abapgit_definitions=&gt;ty_results_tt,
          lv_package      TYPE zif_abapgit_persistence=&gt;ty_repo-package.

    FIELD-SYMBOLS: &lt;ls_status&gt; TYPE zif_abapgit_definitions=&gt;ty_result,
                   &lt;ls_tadir&gt;  TYPE zif_abapgit_definitions=&gt;ty_tadir.
    &quot; delete objects which are added locally but are not in remote repo
    lt_local  = get_files_local( ).
    lt_remote = get_files_remote( ).
    lt_status = status( ).

    lv_package = get_package( ).
    lt_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read( lv_package ).
    SORT lt_tadir BY pgmid ASCENDING object ASCENDING obj_name ASCENDING devclass ASCENDING.

    LOOP AT lt_status ASSIGNING &lt;ls_status&gt;
                      WHERE lstate = zif_abapgit_definitions=&gt;c_state-added.

      READ TABLE lt_tadir ASSIGNING &lt;ls_tadir&gt;
                          WITH KEY pgmid    = &apos;R3TR&apos;
                                   object   = &lt;ls_status&gt;-obj_type
                                   obj_name = &lt;ls_status&gt;-obj_name
                                   devclass = &lt;ls_status&gt;-package
                          BINARY SEARCH.
      IF sy-subrc &lt;&gt; 0.
* skip objects that does not exist locally
        CONTINUE.
      ENDIF.

      INSERT &lt;ls_tadir&gt; INTO TABLE lt_tadir_unique.

    ENDLOOP.

    rt_unnecessary_local_objects = lt_tadir_unique.

  ENDMETHOD.
  METHOD is_offline.
    rv_offline = ms_data-offline.
  ENDMETHOD.
  METHOD lookup_cache.

    DATA: ls_item  TYPE zif_abapgit_definitions=&gt;ty_item,
          lv_index TYPE i.

    FIELD-SYMBOLS: &lt;ls_cache&gt; LIKE LINE OF it_cache,
                   &lt;ls_tadir&gt; LIKE LINE OF ct_tadir.

    CLEAR et_found.

    IF mv_last_serialization IS INITIAL.
      RETURN.
    ENDIF.

    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;.
      lv_index = sy-tabix.

      ls_item-obj_type = &lt;ls_tadir&gt;-object.
      ls_item-obj_name = &lt;ls_tadir&gt;-obj_name.
      ls_item-devclass = &lt;ls_tadir&gt;-devclass.
      READ TABLE it_cache TRANSPORTING NO FIELDS
        WITH KEY item = ls_item. &quot; type+name+package key
      &quot; There is something in cache and the object is unchanged
      IF sy-subrc = 0
          AND abap_false = zcl_abapgit_objects=&gt;has_changed_since(
          is_item      = ls_item
          iv_timestamp = mv_last_serialization ).
        LOOP AT it_cache ASSIGNING &lt;ls_cache&gt; WHERE item = ls_item.
          APPEND &lt;ls_cache&gt; TO et_found.
        ENDLOOP.
        DELETE ct_tadir INDEX lv_index.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD notify_listener.

    DATA ls_meta_slug TYPE zif_abapgit_persistence=&gt;ty_repo_xml.

    IF mi_listener IS BOUND.
      MOVE-CORRESPONDING ms_data TO ls_meta_slug.
      mi_listener-&gt;on_meta_change(
        iv_key         = ms_data-key
        is_meta        = ls_meta_slug
        is_change_mask = is_change_mask ).
    ENDIF.

  ENDMETHOD.
  METHOD rebuild_local_checksums.

    DATA:
      lt_local     TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
      ls_last_item TYPE zif_abapgit_definitions=&gt;ty_item,
      lt_checksums TYPE zif_abapgit_persistence=&gt;ty_local_checksum_tt.

    FIELD-SYMBOLS:
      &lt;ls_checksum&gt; LIKE LINE OF lt_checksums,
      &lt;ls_file_sig&gt; LIKE LINE OF &lt;ls_checksum&gt;-files,
      &lt;ls_local&gt;    LIKE LINE OF lt_local.

    lt_local = get_files_local( ).

    DELETE lt_local &quot; Remove non-code related files except .abapgit
      WHERE item IS INITIAL
      AND NOT ( file-path     = zif_abapgit_definitions=&gt;c_root_dir
      AND       file-filename = zif_abapgit_definitions=&gt;c_dot_abapgit ).
    SORT lt_local BY item.

    LOOP AT lt_local ASSIGNING &lt;ls_local&gt;.
      IF ls_last_item &lt;&gt; &lt;ls_local&gt;-item OR sy-tabix = 1. &quot; First or New item reached ?
        APPEND INITIAL LINE TO lt_checksums ASSIGNING &lt;ls_checksum&gt;.
        &lt;ls_checksum&gt;-item = &lt;ls_local&gt;-item.
        ls_last_item       = &lt;ls_local&gt;-item.
      ENDIF.

      APPEND INITIAL LINE TO &lt;ls_checksum&gt;-files ASSIGNING &lt;ls_file_sig&gt;.
      MOVE-CORRESPONDING &lt;ls_local&gt;-file TO &lt;ls_file_sig&gt;.

    ENDLOOP.

    set( it_checksums = lt_checksums ).
    reset_status( ).

  ENDMETHOD.
  METHOD refresh.

    mv_request_local_refresh = abap_true.
    reset_remote( ).

    IF iv_drop_cache = abap_true.
      CLEAR: mv_last_serialization, mt_local.
    ENDIF.

  ENDMETHOD.
  METHOD reset_remote.
    CLEAR mt_remote.
    mv_request_remote_refresh = abap_true.
    reset_status( ).
  ENDMETHOD.
  METHOD reset_status.
    CLEAR mt_status.
  ENDMETHOD.
  METHOD run_code_inspector.

    DATA: li_code_inspector TYPE REF TO zif_abapgit_code_inspector,
          lv_check_variant  TYPE string.

    lv_check_variant = get_local_settings( )-code_inspector_check_variant.

    IF lv_check_variant IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |No check variant maintained in repo settings.| ).
    ENDIF.

    li_code_inspector = zcl_abapgit_factory=&gt;get_code_inspector(
                                  iv_package            = get_package( )
                                  iv_check_variant_name = |{ lv_check_variant }| ).

    rt_list = li_code_inspector-&gt;run( ).

    DELETE rt_list WHERE kind = &apos;N&apos;.

    READ TABLE rt_list TRANSPORTING NO FIELDS
                       WITH KEY kind = &apos;E&apos;.

    mv_code_inspector_successful = boolc( sy-subrc &lt;&gt; 0 ).

  ENDMETHOD.
  METHOD set.

* TODO: refactor

    DATA:
          ls_mask        TYPE zif_abapgit_persistence=&gt;ty_repo_meta_mask.
    ASSERT it_checksums IS SUPPLIED
      OR iv_url IS SUPPLIED
      OR iv_branch_name IS SUPPLIED
      OR iv_head_branch IS SUPPLIED
      OR iv_offline IS SUPPLIED
      OR is_dot_abapgit IS SUPPLIED
      OR is_local_settings IS SUPPLIED
      OR iv_deserialized_by IS SUPPLIED
      OR iv_deserialized_at IS SUPPLIED.
    IF it_checksums IS SUPPLIED.
      ms_data-local_checksums = it_checksums.
      ls_mask-local_checksums = abap_true.
    ENDIF.

    IF iv_url IS SUPPLIED.
      ms_data-url = iv_url.
      ls_mask-url = abap_true.
    ENDIF.

    IF iv_branch_name IS SUPPLIED.
      ms_data-branch_name = iv_branch_name.
      ls_mask-branch_name = abap_true.
    ENDIF.

    IF iv_head_branch IS SUPPLIED.
      ms_data-head_branch = iv_head_branch.
      ls_mask-head_branch = abap_true.
    ENDIF.

    IF iv_offline IS SUPPLIED.
      ms_data-offline = iv_offline.
      ls_mask-offline = abap_true.
    ENDIF.

    IF is_dot_abapgit IS SUPPLIED.
      ms_data-dot_abapgit = is_dot_abapgit.
      ls_mask-dot_abapgit = abap_true.
    ENDIF.

    IF is_local_settings IS SUPPLIED.
      ms_data-local_settings = is_local_settings.
      ls_mask-local_settings = abap_true.
    ENDIF.

    IF iv_deserialized_at IS SUPPLIED OR iv_deserialized_by IS SUPPLIED.
      ms_data-deserialized_at = iv_deserialized_at.
      ms_data-deserialized_by = iv_deserialized_by.
      ls_mask-deserialized_at = abap_true.
      ls_mask-deserialized_by = abap_true.
    ENDIF.

    notify_listener( ls_mask ).

  ENDMETHOD.
  METHOD set_dot_abapgit.
    set( is_dot_abapgit = io_dot_abapgit-&gt;get_data( ) ).
  ENDMETHOD.
  METHOD set_files_remote.

    mt_remote = it_files.
    mv_request_remote_refresh = abap_false.

  ENDMETHOD.
  METHOD set_local_settings.

    set( is_local_settings = is_settings ).

  ENDMETHOD.
  METHOD status.

    IF lines( mt_status ) = 0.
      mt_status = zcl_abapgit_file_status=&gt;status(
        io_repo = me
        io_log  = io_log ).
    ENDIF.

    rt_results = mt_status.

  ENDMETHOD.
  METHOD bind_listener.
    mi_listener = ii_listener.
  ENDMETHOD.
  METHOD update_last_deserialize.

    DATA: lv_deserialized_at TYPE zif_abapgit_persistence=&gt;ty_repo-deserialized_at,
          lv_deserialized_by TYPE zif_abapgit_persistence=&gt;ty_repo-deserialized_by.

    GET TIME STAMP FIELD lv_deserialized_at.
    lv_deserialized_by = sy-uname.

    set( iv_deserialized_at = lv_deserialized_at
         iv_deserialized_by = lv_deserialized_by ).

  ENDMETHOD.
  METHOD update_local_checksums.

    &quot; ASSUMTION: SHA1 in param is actual and correct.
    &quot; Push fills it from local files before pushing, deserialize from remote
    &quot; If this is not true that there is an error somewhere but not here

    DATA: lt_checksums TYPE zif_abapgit_persistence=&gt;ty_local_checksum_tt,
          lt_files_idx TYPE zif_abapgit_definitions=&gt;ty_file_signatures_tt,
          lt_local     TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
          lv_chks_row  TYPE i,
          lv_file_row  TYPE i.

    FIELD-SYMBOLS: &lt;ls_checksum&gt;  LIKE LINE OF lt_checksums,
                   &lt;ls_file&gt;      LIKE LINE OF &lt;ls_checksum&gt;-files,
                   &lt;ls_local&gt;     LIKE LINE OF lt_local,
                   &lt;ls_new_state&gt; LIKE LINE OF it_files.

    lt_checksums = get_local_checksums( ).
    lt_files_idx = it_files.
    SORT lt_files_idx BY path filename. &quot; Sort for binary search

    &quot; Loop through current chacksum state, update sha1 for common files
    LOOP AT lt_checksums ASSIGNING &lt;ls_checksum&gt;.
      lv_chks_row = sy-tabix.

      LOOP AT &lt;ls_checksum&gt;-files ASSIGNING &lt;ls_file&gt;.
        lv_file_row = sy-tabix.

        READ TABLE lt_files_idx ASSIGNING &lt;ls_new_state&gt;
          WITH KEY path = &lt;ls_file&gt;-path filename = &lt;ls_file&gt;-filename
          BINARY SEARCH.
        CHECK sy-subrc = 0. &quot; Missing in param table, skip

        IF &lt;ls_new_state&gt;-sha1 IS INITIAL. &quot; Empty input sha1 is a deletion marker
          DELETE &lt;ls_checksum&gt;-files INDEX lv_file_row.
        ELSE.
          &lt;ls_file&gt;-sha1 = &lt;ls_new_state&gt;-sha1.  &quot; Update sha1
          CLEAR &lt;ls_new_state&gt;-sha1.             &quot; Mark as processed
        ENDIF.
      ENDLOOP.

      IF lines( &lt;ls_checksum&gt;-files ) = 0. &quot; Remove empty objects
        DELETE lt_checksums INDEX lv_chks_row.
      ENDIF.
    ENDLOOP.

    DELETE lt_files_idx WHERE sha1 IS INITIAL. &quot; Remove processed
    IF lines( lt_files_idx ) &gt; 0.
      lt_local = get_files_local( ).
      SORT lt_local BY file-path file-filename. &quot; Sort for binary search
    ENDIF.

    &quot; Add new files - not deleted and not marked as processed above
    LOOP AT lt_files_idx ASSIGNING &lt;ls_new_state&gt;.

      READ TABLE lt_local ASSIGNING &lt;ls_local&gt;
        WITH KEY file-path = &lt;ls_new_state&gt;-path file-filename = &lt;ls_new_state&gt;-filename
        BINARY SEARCH.
      IF sy-subrc &lt;&gt; 0.
* if the deserialization fails, the local file might not be there
        CONTINUE.
      ENDIF.

      READ TABLE lt_checksums ASSIGNING &lt;ls_checksum&gt; &quot; TODO Optimize
        WITH KEY item = &lt;ls_local&gt;-item.
      IF sy-subrc &gt; 0.
        APPEND INITIAL LINE TO lt_checksums ASSIGNING &lt;ls_checksum&gt;.
        &lt;ls_checksum&gt;-item = &lt;ls_local&gt;-item.
      ENDIF.

      APPEND &lt;ls_new_state&gt; TO &lt;ls_checksum&gt;-files.
    ENDLOOP.

    SORT lt_checksums BY item.
    set( it_checksums = lt_checksums ).

  ENDMETHOD.
  METHOD switch_repo_type.

    IF iv_offline = ms_data-offline.
      zcx_abapgit_exception=&gt;raise( |Cannot switch_repo_type, offline already = &quot;{ ms_data-offline }&quot;| ).
    ENDIF.

    IF iv_offline = abap_true. &quot; On-line -&gt; OFFline
      set(
        iv_url         = zcl_abapgit_url=&gt;name( ms_data-url )
        iv_branch_name = &apos;&apos;
        iv_head_branch = &apos;&apos;
        iv_offline     = abap_true ).
    ELSE. &quot; OFFline -&gt; On-line
      set( iv_offline = abap_false ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_objects_bridge IMPLEMENTATION.
  METHOD class_constructor.

    DATA lt_plugin_class    TYPE STANDARD TABLE OF seoclsname WITH DEFAULT KEY.
    DATA lv_plugin_class    LIKE LINE OF lt_plugin_class.
    DATA lo_plugin          TYPE REF TO object.
    DATA lt_plugin_obj_type TYPE objtyptable.
    DATA ls_objtype_map     LIKE LINE OF gt_objtype_map.
    SELECT ext~clsname
      FROM vseoextend AS ext
      INTO TABLE lt_plugin_class
      WHERE ext~refclsname LIKE &apos;ZCL_ABAPGITP_OBJECT%&apos;
      AND ext~version = &apos;1&apos;.                              &quot;#EC CI_SUBRC

    CLEAR gt_objtype_map.
    LOOP AT lt_plugin_class INTO lv_plugin_class
        WHERE table_line &lt;&gt; &apos;ZCL_ABAPGITP_OBJECT_BY_SOBJ&apos;.
* have the generic plugin only as fallback
      TRY.
          CREATE OBJECT lo_plugin TYPE (lv_plugin_class).
        CATCH cx_sy_create_object_error.
          CONTINUE. &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
      ENDTRY.

      CALL METHOD lo_plugin-&gt;(&apos;GET_SUPPORTED_OBJ_TYPES&apos;)
        IMPORTING
          rt_obj_type = lt_plugin_obj_type.

      ls_objtype_map-plugin_class = lv_plugin_class.
      LOOP AT lt_plugin_obj_type INTO ls_objtype_map-obj_typ.
        INSERT ls_objtype_map INTO TABLE gt_objtype_map.
        IF sy-subrc &lt;&gt; 0.
* No exception in class-contructor possible.
* Anyway, a shortdump is more appropriate in this case
          ASSERT &apos;There must not be&apos; =
            |multiple abapGit-Plugins for the same object type {
            ls_objtype_map-obj_typ }|.
        ENDIF.
      ENDLOOP.
    ENDLOOP. &quot;at plugins

* and the same for the generic plugin if exists
* have the generic plugin only as fallback
    LOOP AT lt_plugin_class INTO lv_plugin_class
        WHERE table_line = &apos;ZCL_ABAPGITP_OBJECT_BY_SOBJ&apos;.
      CREATE OBJECT lo_plugin TYPE (lv_plugin_class).

      CALL METHOD lo_plugin-&gt;(&apos;GET_SUPPORTED_OBJ_TYPES&apos;)
        RECEIVING
          rt_obj_type = lt_plugin_obj_type.

      ls_objtype_map-plugin_class = lv_plugin_class.
      LOOP AT lt_plugin_obj_type INTO ls_objtype_map-obj_typ.
        INSERT ls_objtype_map INTO TABLE gt_objtype_map. &quot;knowingly ignore the subrc
      ENDLOOP.
    ENDLOOP. &quot;at plugins

  ENDMETHOD.
  METHOD constructor.

    DATA ls_objtype_map LIKE LINE OF gt_objtype_map.

    super-&gt;constructor( is_item = is_item
                        iv_language = zif_abapgit_definitions=&gt;c_english ).

*    determine the responsible plugin
    READ TABLE gt_objtype_map INTO ls_objtype_map
      WITH TABLE KEY obj_typ = is_item-obj_type.
    IF sy-subrc = 0.
      CREATE OBJECT mo_plugin TYPE (ls_objtype_map-plugin_class).

      CALL METHOD mo_plugin-&gt;(&apos;SET_ITEM&apos;)
        EXPORTING
          iv_obj_type = is_item-obj_type
          iv_obj_name = is_item-obj_name.
    ELSE.
      RAISE EXCEPTION TYPE cx_sy_create_object_error
        EXPORTING
          classname = &apos;LCL_OBJECTS_BRIDGE&apos;.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    DATA lx_plugin TYPE REF TO cx_static_check.

    TRY.
        CALL METHOD mo_plugin-&gt;(&apos;ZIF_ABAPGITP_PLUGIN~DELETE&apos;).
      CATCH cx_static_check INTO lx_plugin.
        zcx_abapgit_exception=&gt;raise( lx_plugin-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lx_plugin        TYPE REF TO cx_static_check.

    TRY.
        CALL METHOD mo_plugin-&gt;(&apos;WRAP_DESERIALIZE&apos;)
          EXPORTING
            iv_package = iv_package
            io_xml     = io_xml.
      CATCH cx_static_check INTO lx_plugin.
        zcx_abapgit_exception=&gt;raise( lx_plugin-&gt;get_text( ) ).
    ENDTRY.
  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    CALL METHOD mo_plugin-&gt;(&apos;ZIF_ABAPGITP_PLUGIN~EXISTS&apos;)
      RECEIVING
        rv_bool = rv_bool.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    CALL METHOD mo_plugin-&gt;(&apos;ZIF_ABAPGITP_PLUGIN~GET_METADATA&apos;)
      RECEIVING
        rs_metadata = rs_metadata.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL METHOD mo_plugin-&gt;(&apos;ZIF_ABAPGITP_PLUGIN~JUMP&apos;).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    CALL METHOD mo_plugin-&gt;(&apos;WRAP_SERIALIZE&apos;)
      EXPORTING
        io_xml = io_xml.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = abap_true.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS IMPLEMENTATION.
  METHOD adjust_namespaces.

    FIELD-SYMBOLS: &lt;ls_result&gt; LIKE LINE OF rt_results.

    rt_results = it_results.

    LOOP AT rt_results ASSIGNING &lt;ls_result&gt;.
      REPLACE ALL OCCURRENCES OF &apos;#&apos; IN &lt;ls_result&gt;-obj_name WITH &apos;/&apos;.
    ENDLOOP.

  ENDMETHOD.
  METHOD changed_by.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    IF is_item IS NOT INITIAL.
      li_obj = create_object( is_item     = is_item
                              iv_language = zif_abapgit_definitions=&gt;c_english ).
      rv_user = li_obj-&gt;changed_by( ).
    ENDIF.

    IF rv_user IS INITIAL.
* eg. &quot;.abapgit.xml&quot; file
      rv_user = zcl_abapgit_objects_super=&gt;c_user_unknown.
    ENDIF.

* todo, fallback to looking at transports if rv_user = &apos;UNKNOWN&apos;?

  ENDMETHOD.
  METHOD checks_adjust.

    warning_overwrite_adjust(
      EXPORTING it_overwrite = is_checks-overwrite
      CHANGING ct_results = ct_results ).

    warning_package_adjust(
      EXPORTING
        io_repo = io_repo
        it_overwrite = is_checks-warning_package
      CHANGING
        ct_results = ct_results ).

  ENDMETHOD.
  METHOD check_duplicates.

    DATA: lt_files TYPE zif_abapgit_definitions=&gt;ty_files_tt.
    lt_files = it_files.
    SORT lt_files BY path ASCENDING filename ASCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_files COMPARING path filename.
    IF lines( lt_files ) &lt;&gt; lines( it_files ).
      zcx_abapgit_exception=&gt;raise( &apos;Duplicates&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD check_objects_locked.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    FIELD-SYMBOLS: &lt;ls_item&gt; LIKE LINE OF it_items.

    LOOP AT it_items ASSIGNING &lt;ls_item&gt;.

      li_obj = create_object( is_item     = &lt;ls_item&gt;
                              iv_language = iv_language ).

      IF li_obj-&gt;is_locked( ) = abap_true.
        zcx_abapgit_exception=&gt;raise( |Object { &lt;ls_item&gt;-obj_type } { &lt;ls_item&gt;-obj_name } |
                                   &amp;&amp; |is locked. Action not possible.| ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD class_name.

    CONCATENATE &apos;ZCL_ABAPGIT_OBJECT_&apos; is_item-obj_type INTO rv_class_name. &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD compare_remote_to_local.
* this method is used for comparing local with remote objects
* before pull, this is useful eg. when overwriting a TABL object.
* only the main XML file is used for comparison

    DATA: ls_remote_file       TYPE zif_abapgit_definitions=&gt;ty_file,
          lo_remote_version    TYPE REF TO zcl_abapgit_xml_input,
          lv_count             TYPE i,
          li_comparison_result TYPE REF TO zif_abapgit_comparison_result.
    FIND ALL OCCURRENCES OF &apos;.&apos; IN is_result-filename MATCH COUNT lv_count.

    IF is_result-filename CS &apos;.XML&apos; AND lv_count = 2.
      IF ii_object-&gt;exists( ) = abap_false.
        RETURN.
      ENDIF.

      READ TABLE it_remote WITH KEY filename = is_result-filename INTO ls_remote_file.

      &quot;if file does not exist in remote, we don&apos;t need to validate
      IF sy-subrc = 0.
        CREATE OBJECT lo_remote_version
          EXPORTING
            iv_xml = zcl_abapgit_convert=&gt;xstring_to_string_utf8( ls_remote_file-data ).
        li_comparison_result = ii_object-&gt;compare_to_remote_version( lo_remote_version ).
        li_comparison_result-&gt;show_confirmation_dialog( ).

        IF li_comparison_result-&gt;is_result_complete_halt( ) = abap_true.
          zcx_abapgit_exception=&gt;raise( &apos;Deserialization aborted by user&apos; ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD create_object.

    DATA: lv_message            TYPE string,
          lv_class_name         TYPE string,
          ls_obj_serializer_map LIKE LINE OF gt_obj_serializer_map.
    READ TABLE gt_obj_serializer_map
      INTO ls_obj_serializer_map WITH KEY item = is_item.
    IF sy-subrc = 0.
      lv_class_name = ls_obj_serializer_map-metadata-class.
    ELSEIF is_metadata IS NOT INITIAL.
*        Metadata is provided only on serialization
*        Once this has been triggered, the same serializer shall be used
*        for subsequent processes.
*        Thus, buffer the metadata afterwards
      ls_obj_serializer_map-item      = is_item.
      ls_obj_serializer_map-metadata  = is_metadata.
      INSERT ls_obj_serializer_map INTO TABLE gt_obj_serializer_map.

      lv_class_name = is_metadata-class.
    ELSE.
      lv_class_name = class_name( is_item ).
    ENDIF.

*    IF zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( )-&gt;get_experimental_features( ) = abap_true
*        AND is_item-obj_type = &apos;CLAS&apos;.
*      lv_class_name = &apos;LCL_OBJECT_CLAS_NEW&apos;.
*    ENDIF.

    REPLACE FIRST OCCURRENCE OF &apos;LCL&apos; IN lv_class_name WITH &apos;ZCL_ABAPGIT&apos;.

    TRY.
        CREATE OBJECT ri_obj TYPE (lv_class_name)
          EXPORTING
            is_item     = is_item
            iv_language = iv_language.
      CATCH cx_sy_create_object_error.
        lv_message = |Object type { is_item-obj_type } not supported, serialize|. &quot;#EC NOTEXT
        IF iv_native_only = abap_false.
          TRY. &quot; 2nd step, try looking for plugins
              CREATE OBJECT ri_obj TYPE zcl_abapgit_objects_bridge
                EXPORTING
                  is_item = is_item.
            CATCH cx_sy_create_object_error.
              zcx_abapgit_exception=&gt;raise( lv_message ).
          ENDTRY.
        ELSE. &quot; No native support? -&gt; fail
          zcx_abapgit_exception=&gt;raise( lv_message ).
        ENDIF.
    ENDTRY.

  ENDMETHOD.
  METHOD delete.

    DATA: ls_item     TYPE zif_abapgit_definitions=&gt;ty_item,
          lo_progress TYPE REF TO zcl_abapgit_progress,
          lt_tadir    LIKE it_tadir,
          lt_items    TYPE zif_abapgit_definitions=&gt;ty_items_tt,
          lx_error    TYPE REF TO zcx_abapgit_exception,
          lv_text     TYPE string.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF it_tadir.

    lt_tadir = it_tadir.

    IF is_checks-transport-required = abap_true.
      zcl_abapgit_default_transport=&gt;get_instance( )-&gt;set( is_checks-transport-transport ).
    ENDIF.

    TRY.
        zcl_abapgit_dependencies=&gt;resolve( CHANGING ct_tadir = lt_tadir ).

        CREATE OBJECT lo_progress
          EXPORTING
            iv_total = lines( lt_tadir ).

        lt_items = map_tadir_to_items( lt_tadir ).

        check_objects_locked( iv_language = zif_abapgit_definitions=&gt;c_english
                              it_items    = lt_items ).

        LOOP AT lt_tadir ASSIGNING &lt;ls_tadir&gt;.
          lo_progress-&gt;show( iv_current = sy-tabix
                             iv_text    = |Delete { &lt;ls_tadir&gt;-obj_name }| ) ##NO_TEXT.

          CLEAR ls_item.
          ls_item-obj_type = &lt;ls_tadir&gt;-object.
          ls_item-obj_name = &lt;ls_tadir&gt;-obj_name.
          delete_obj( ls_item ).

* make sure to save object deletions
          COMMIT WORK.
        ENDLOOP.

      CATCH zcx_abapgit_exception INTO lx_error.
        zcl_abapgit_default_transport=&gt;get_instance( )-&gt;reset( ).
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

    zcl_abapgit_default_transport=&gt;get_instance( )-&gt;reset( ).

  ENDMETHOD.
  METHOD delete_obj.

    DATA: li_obj TYPE REF TO zif_abapgit_object.
    IF is_supported( is_item ) = abap_true.
      li_obj = create_object( is_item     = is_item
                              iv_language = zif_abapgit_definitions=&gt;c_english ).

      li_obj-&gt;delete( ).

      IF li_obj-&gt;get_metadata( )-delete_tadir = abap_true.
        CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
          EXPORTING
            wi_delete_tadir_entry = abap_true
            wi_tadir_pgmid        = &apos;R3TR&apos;
            wi_tadir_object       = is_item-obj_type
            wi_tadir_obj_name     = is_item-obj_name
            wi_test_modus         = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD deserialize.

    DATA: ls_item     TYPE zif_abapgit_definitions=&gt;ty_item,
          li_obj      TYPE REF TO zif_abapgit_object,
          lt_remote   TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lv_package  TYPE devclass,
          lo_files    TYPE REF TO zcl_abapgit_objects_files,
          lo_xml      TYPE REF TO zcl_abapgit_xml_input,
          lt_results  TYPE zif_abapgit_definitions=&gt;ty_results_tt,
          lt_ddic     TYPE TABLE OF ty_deserialization,
          lt_rest     TYPE TABLE OF ty_deserialization,
          lt_late     TYPE TABLE OF ty_deserialization,
          lo_progress TYPE REF TO zcl_abapgit_progress,
          lv_path     TYPE string,
          lt_items    TYPE zif_abapgit_definitions=&gt;ty_items_tt.
    DATA: lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic.

    FIELD-SYMBOLS: &lt;ls_result&gt; TYPE zif_abapgit_definitions=&gt;ty_result,
                   &lt;ls_deser&gt;  LIKE LINE OF lt_late.
    lv_package = io_repo-&gt;get_package( ).

    IF is_checks-transport-required = abap_true.
      zcl_abapgit_default_transport=&gt;get_instance( )-&gt;set( is_checks-transport-transport ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;clear( ).

    lt_remote = io_repo-&gt;get_files_remote( ).

    lt_results = files_to_deserialize( io_repo ).

    checks_adjust(
      EXPORTING
        io_repo    = io_repo
        is_checks  = is_checks
      CHANGING
        ct_results = lt_results ).

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( lt_results ).

    lt_items = map_results_to_items( lt_results ).

    check_objects_locked( iv_language = io_repo-&gt;get_dot_abapgit( )-&gt;get_master_language( )
                          it_items    = lt_items ).

    lo_folder_logic = zcl_abapgit_folder_logic=&gt;get_instance( ).
    LOOP AT lt_results ASSIGNING &lt;ls_result&gt;.
      lo_progress-&gt;show( iv_current = sy-tabix
                         iv_text    = |Deserialize { &lt;ls_result&gt;-obj_name }| ) ##NO_TEXT.

      CLEAR ls_item.
      ls_item-obj_type = &lt;ls_result&gt;-obj_type.
      ls_item-obj_name = &lt;ls_result&gt;-obj_name.

      lv_package = lo_folder_logic-&gt;path_to_package(
        iv_top  = io_repo-&gt;get_package( )
        io_dot  = io_repo-&gt;get_dot_abapgit( )
        iv_path = &lt;ls_result&gt;-path ).

      IF ls_item-obj_type = &apos;DEVC&apos;.
        &quot; Packages have the same filename across different folders. The path needs to be supplied
        &quot; to find the correct file.
        lv_path = &lt;ls_result&gt;-path.
      ENDIF.

      CREATE OBJECT lo_files
        EXPORTING
          is_item = ls_item
          iv_path = lv_path.
      lo_files-&gt;set_files( lt_remote ).

* Analyze XML in order to instantiate the proper serializer
      lo_xml = lo_files-&gt;read_xml( ).

      li_obj = create_object( is_item     = ls_item
                              iv_language = io_repo-&gt;get_dot_abapgit( )-&gt;get_master_language( )
                              is_metadata = lo_xml-&gt;get_metadata( ) ).

      compare_remote_to_local(
        ii_object = li_obj
        it_remote = lt_remote
        is_result = &lt;ls_result&gt; ).

      li_obj-&gt;mo_files = lo_files.

      IF li_obj-&gt;get_metadata( )-late_deser = abap_true.
        APPEND INITIAL LINE TO lt_late ASSIGNING &lt;ls_deser&gt;.
      ELSEIF li_obj-&gt;get_metadata( )-ddic = abap_true.
        APPEND INITIAL LINE TO lt_ddic ASSIGNING &lt;ls_deser&gt;.
      ELSE.
        APPEND INITIAL LINE TO lt_rest ASSIGNING &lt;ls_deser&gt;.
      ENDIF.
      &lt;ls_deser&gt;-item    = ls_item.
      &lt;ls_deser&gt;-obj     = li_obj.
      &lt;ls_deser&gt;-xml     = lo_xml.
      &lt;ls_deser&gt;-package = lv_package.

      CLEAR: lv_path, lv_package.
    ENDLOOP.

    deserialize_objects( EXPORTING it_objects = lt_ddic
                                   iv_ddic    = abap_true
                                   iv_descr   = &apos;DDIC&apos;
                         CHANGING ct_files = rt_accessed_files ).

    deserialize_objects( EXPORTING it_objects = lt_rest
                                   iv_descr   = &apos;Objects&apos;
                         CHANGING ct_files = rt_accessed_files ).

    deserialize_objects( EXPORTING it_objects = lt_late
                                   iv_descr   = &apos;Late&apos;
                         CHANGING ct_files = rt_accessed_files ).

    update_package_tree( io_repo-&gt;get_package( ) ).

    SORT rt_accessed_files BY path ASCENDING filename ASCENDING.
    DELETE ADJACENT DUPLICATES FROM rt_accessed_files. &quot; Just in case

    zcl_abapgit_default_transport=&gt;get_instance( )-&gt;reset( ).

  ENDMETHOD.
  METHOD deserialize_checks.

    DATA: lt_results TYPE zif_abapgit_definitions=&gt;ty_results_tt,
          li_package TYPE REF TO zif_abapgit_sap_package.
    lt_results = files_to_deserialize( io_repo ).

    rs_checks-overwrite = warning_overwrite_find( lt_results ).

    rs_checks-warning_package = warning_package_find(
      io_repo    = io_repo
      it_results = lt_results ).

    IF lines( lt_results ) &gt; 0.
      li_package = zcl_abapgit_factory=&gt;get_sap_package( io_repo-&gt;get_package( ) ).
      rs_checks-transport-required = li_package-&gt;are_changes_recorded_in_tr_req( ).
      IF NOT rs_checks-transport-required IS INITIAL.
        rs_checks-transport-type = li_package-&gt;get_transport_type( ).
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD deserialize_objects.

    DATA: lo_progress TYPE REF TO zcl_abapgit_progress.

    FIELD-SYMBOLS: &lt;ls_obj&gt; LIKE LINE OF it_objects.
    zcl_abapgit_objects_activation=&gt;clear( ).

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( it_objects ).

    LOOP AT it_objects ASSIGNING &lt;ls_obj&gt;.
      lo_progress-&gt;show(
        iv_current = sy-tabix
        iv_text    = |Deserialize { iv_descr } - { &lt;ls_obj&gt;-item-obj_name }| ) ##NO_TEXT.

      &lt;ls_obj&gt;-obj-&gt;deserialize( iv_package = &lt;ls_obj&gt;-package
                                 io_xml     = &lt;ls_obj&gt;-xml ).
      APPEND LINES OF &lt;ls_obj&gt;-obj-&gt;mo_files-&gt;get_accessed_files( ) TO ct_files.
    ENDLOOP.

    zcl_abapgit_objects_activation=&gt;activate( iv_ddic ).

  ENDMETHOD.
  METHOD exists.

    DATA: li_obj TYPE REF TO zif_abapgit_object.
    TRY.
        li_obj = create_object( is_item = is_item
                                iv_language = zif_abapgit_definitions=&gt;c_english ).
        rv_bool = li_obj-&gt;exists( ).
      CATCH zcx_abapgit_exception.
* ignore all errors and assume the object exists
        rv_bool = abap_true.
    ENDTRY.

  ENDMETHOD.
  METHOD files_to_deserialize.

    rt_results = adjust_namespaces(
                   prioritize_deser(
                     filter_files_to_deserialize(
                       zcl_abapgit_file_status=&gt;status( io_repo ) ) ) ).

  ENDMETHOD.
  METHOD filter_files_to_deserialize.

    rt_results = it_results.

    DELETE rt_results WHERE match = abap_true.     &quot; Full match
    SORT rt_results
      BY obj_type ASCENDING
         obj_name ASCENDING
         rstate   DESCENDING. &quot; ensures that non-empty rstate is kept
    DELETE ADJACENT DUPLICATES FROM rt_results COMPARING obj_type obj_name.

    DELETE rt_results WHERE obj_type IS INITIAL.
    DELETE rt_results WHERE lstate = zif_abapgit_definitions=&gt;c_state-added AND rstate IS INITIAL.

  ENDMETHOD.
  METHOD has_changed_since.
    rv_changed = abap_true. &quot; Assume changed

    IF is_supported( is_item ) = abap_false.
      RETURN. &quot; Will requre serialize which will log the error
    ENDIF.

    rv_changed = create_object(
      is_item     = is_item
      iv_language = zif_abapgit_definitions=&gt;c_english )-&gt;has_changed_since( iv_timestamp ).

  ENDMETHOD.
  METHOD is_active.

    DATA: li_object TYPE REF TO zif_abapgit_object.

    TRY.
        li_object = create_object( is_item     = is_item
                                   iv_language = sy-langu ).

        rv_active = li_object-&gt;is_active( ).
      CATCH cx_sy_dyn_call_illegal_method
            cx_sy_ref_is_initial
            zcx_abapgit_exception.
        rv_active = abap_true.
    ENDTRY.
  ENDMETHOD.
  METHOD is_supported.

    TRY.
        create_object( is_item        = is_item
                       iv_language    = zif_abapgit_definitions=&gt;c_english
                       iv_native_only = iv_native_only ).
        rv_bool = abap_true.
      CATCH zcx_abapgit_exception.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD jump.

    DATA: li_obj              TYPE REF TO zif_abapgit_object,
          lv_adt_jump_enabled TYPE abap_bool.

    li_obj = create_object( is_item     = is_item
                            iv_language = zif_abapgit_definitions=&gt;c_english ).

    IF li_obj-&gt;exists( ) = abap_false.
      zcx_abapgit_exception=&gt;raise( |Object { is_item-obj_type } { is_item-obj_name } doesn&apos;t exist| ).
    ENDIF.

    lv_adt_jump_enabled = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( )-&gt;get_adt_jump_enabled( ).

    IF lv_adt_jump_enabled = abap_true.
      TRY.
          zcl_abapgit_objects_super=&gt;jump_adt(
            iv_obj_name    = is_item-obj_name
            iv_obj_type    = is_item-obj_type
            iv_line_number = iv_line_number ).
        CATCH zcx_abapgit_exception.
          li_obj-&gt;jump( ).
      ENDTRY.
    ELSE.
      li_obj-&gt;jump( ).
    ENDIF.

  ENDMETHOD.
  METHOD map_results_to_items.

    DATA: ls_item LIKE LINE OF rt_items.
    FIELD-SYMBOLS: &lt;ls_result&gt; TYPE zif_abapgit_definitions=&gt;ty_result.

    LOOP AT it_results ASSIGNING &lt;ls_result&gt;.

      ls_item-devclass = &lt;ls_result&gt;-package.
      ls_item-obj_type = &lt;ls_result&gt;-obj_type.
      ls_item-obj_name = &lt;ls_result&gt;-obj_name.
      INSERT ls_item INTO TABLE rt_items.

    ENDLOOP.

  ENDMETHOD.
  METHOD map_tadir_to_items.

    DATA: ls_item LIKE LINE OF rt_items.
    FIELD-SYMBOLS: &lt;ls_tadir&gt; TYPE zif_abapgit_definitions=&gt;ty_tadir.

    LOOP AT it_tadir ASSIGNING &lt;ls_tadir&gt;.

      ls_item-devclass = &lt;ls_tadir&gt;-devclass.
      ls_item-obj_type = &lt;ls_tadir&gt;-object.
      ls_item-obj_name = &lt;ls_tadir&gt;-obj_name.
      INSERT ls_item INTO TABLE rt_items.

    ENDLOOP.

  ENDMETHOD.
  METHOD prioritize_deser.

    FIELD-SYMBOLS: &lt;ls_result&gt; LIKE LINE OF it_results.

* XSLT has to be handled before CLAS/PROG
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;XSLT&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

* PROG before internet services, as the services might use the screens
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;PROG&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

* ISAP has to be handled before ISRP
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;IASP&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

* PINF has to be handled before DEVC for package interface usage
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;PINF&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

* ENHS has to be handled before ENHO
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;ENHS&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

* DDLS has to be handled before DCLS
    LOOP AT it_results ASSIGNING &lt;ls_result&gt; WHERE obj_type = &apos;DDLS&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

    LOOP AT it_results ASSIGNING &lt;ls_result&gt;
        WHERE obj_type &lt;&gt; &apos;IASP&apos;
        AND obj_type &lt;&gt; &apos;PROG&apos;
        AND obj_type &lt;&gt; &apos;XSLT&apos;
        AND obj_type &lt;&gt; &apos;PINF&apos;
        AND obj_type &lt;&gt; &apos;ENHS&apos;
        AND obj_type &lt;&gt; &apos;DDLS&apos;.
      APPEND &lt;ls_result&gt; TO rt_results.
    ENDLOOP.

  ENDMETHOD.
  METHOD serialize.

    DATA: li_obj   TYPE REF TO zif_abapgit_object,
          lo_xml   TYPE REF TO zcl_abapgit_xml_output,
          lo_files TYPE REF TO zcl_abapgit_objects_files.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF rs_files_and_item-files.

    rs_files_and_item-item = is_item.

    IF is_supported( rs_files_and_item-item ) = abap_false.
      zcx_abapgit_exception=&gt;raise( |Object type ignored, not supported: {
        rs_files_and_item-item-obj_type }-{
        rs_files_and_item-item-obj_name }| ).
    ENDIF.

    CREATE OBJECT lo_files
      EXPORTING
        is_item = rs_files_and_item-item.

    li_obj = create_object( is_item     = rs_files_and_item-item
                            iv_language = iv_language ).
    li_obj-&gt;mo_files = lo_files.
    CREATE OBJECT lo_xml.
    li_obj-&gt;serialize( lo_xml ).
    lo_files-&gt;add_xml( io_xml      = lo_xml
                       is_metadata = li_obj-&gt;get_metadata( ) ).

    rs_files_and_item-files = lo_files-&gt;get_files( ).

    check_duplicates( rs_files_and_item-files ).

    rs_files_and_item-item-inactive = boolc( li_obj-&gt;is_active( ) = abap_false ).

    LOOP AT rs_files_and_item-files ASSIGNING &lt;ls_file&gt;.
      &lt;ls_file&gt;-sha1 = zcl_abapgit_hash=&gt;sha1(
        iv_type = zif_abapgit_definitions=&gt;c_type-blob
        iv_data = &lt;ls_file&gt;-data ).
    ENDLOOP.

  ENDMETHOD.
  METHOD supported_list.

    DATA: lt_objects   TYPE STANDARD TABLE OF ko100,
          lv_supported TYPE abap_bool,
          ls_item      TYPE zif_abapgit_definitions=&gt;ty_item.

    FIELD-SYMBOLS &lt;ls_object&gt; LIKE LINE OF lt_objects.
    CALL FUNCTION &apos;TR_OBJECT_TABLE&apos;
      TABLES
        wt_object_text = lt_objects
      EXCEPTIONS
        OTHERS         = 1 ##FM_SUBRC_OK.

    LOOP AT lt_objects ASSIGNING &lt;ls_object&gt; WHERE pgmid = &apos;R3TR&apos;.
      ls_item-obj_type = &lt;ls_object&gt;-object.

      lv_supported = zcl_abapgit_objects=&gt;is_supported(
        is_item        = ls_item
        iv_native_only = abap_true ).

      IF lv_supported = abap_true.
        APPEND &lt;ls_object&gt;-object TO rt_types.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD update_package_tree.

    DATA: lt_packages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
          lv_package  LIKE LINE OF lt_packages,
          lv_tree     TYPE dirtree-tname.
    lt_packages = zcl_abapgit_factory=&gt;get_sap_package( iv_package )-&gt;list_subpackages( ).
    APPEND iv_package TO lt_packages.

    LOOP AT lt_packages INTO lv_package.
* update package tree for SE80
      lv_tree = &apos;EU_&apos; &amp;&amp; lv_package.
      CALL FUNCTION &apos;WB_TREE_ACTUALIZE&apos;
        EXPORTING
          tree_name              = lv_tree
          without_crossreference = abap_true
          with_tcode_index       = abap_true.
    ENDLOOP.

  ENDMETHOD.
  METHOD warning_overwrite_adjust.

    DATA: lt_overwrite LIKE it_overwrite,
          ls_overwrite LIKE LINE OF lt_overwrite.

    FIELD-SYMBOLS: &lt;ls_overwrite&gt; LIKE LINE OF lt_overwrite.
* make sure to get the current status, as something might have changed in the meanwhile
    lt_overwrite = warning_overwrite_find( ct_results ).

    LOOP AT lt_overwrite ASSIGNING &lt;ls_overwrite&gt;.
      READ TABLE it_overwrite INTO ls_overwrite WITH KEY
        obj_type = &lt;ls_overwrite&gt;-obj_type
        obj_name = &lt;ls_overwrite&gt;-obj_name.
      IF sy-subrc &lt;&gt; 0 OR ls_overwrite-decision IS INITIAL.
        zcx_abapgit_exception=&gt;raise( |Overwrite { &lt;ls_overwrite&gt;-obj_type } {
          &lt;ls_overwrite&gt;-obj_name } undecided| ).
      ENDIF.

      IF ls_overwrite-decision = &apos;N&apos;.
        DELETE ct_results WHERE
          obj_type = &lt;ls_overwrite&gt;-obj_type AND
          obj_name = &lt;ls_overwrite&gt;-obj_name.
        ASSERT sy-subrc = 0.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD warning_overwrite_find.

    DATA: ls_overwrite LIKE LINE OF rt_overwrite.

    FIELD-SYMBOLS: &lt;ls_result&gt; LIKE LINE OF it_results.

    LOOP AT it_results ASSIGNING &lt;ls_result&gt;
        WHERE NOT obj_type IS INITIAL.
      IF &lt;ls_result&gt;-lstate IS NOT INITIAL
          AND &lt;ls_result&gt;-lstate &lt;&gt; zif_abapgit_definitions=&gt;c_state-deleted
          AND NOT ( &lt;ls_result&gt;-lstate = zif_abapgit_definitions=&gt;c_state-added
          AND &lt;ls_result&gt;-rstate IS INITIAL ).
* current object has been modified locally, add to table
        CLEAR ls_overwrite.
        MOVE-CORRESPONDING &lt;ls_result&gt; TO ls_overwrite.
        APPEND ls_overwrite TO rt_overwrite.
      ENDIF.
    ENDLOOP.

    SORT rt_overwrite.
    DELETE ADJACENT DUPLICATES FROM rt_overwrite.

  ENDMETHOD.
  METHOD warning_package_adjust.

    DATA: lt_overwrite LIKE it_overwrite,
          ls_overwrite LIKE LINE OF lt_overwrite.

    FIELD-SYMBOLS: &lt;ls_overwrite&gt; LIKE LINE OF lt_overwrite.
* make sure to get the current status, as something might have changed in the meanwhile
    lt_overwrite = warning_package_find(
      it_results   = ct_results
      io_repo      = io_repo ).

    LOOP AT lt_overwrite ASSIGNING &lt;ls_overwrite&gt;.
      READ TABLE it_overwrite INTO ls_overwrite WITH KEY
        obj_type = &lt;ls_overwrite&gt;-obj_type
        obj_name = &lt;ls_overwrite&gt;-obj_name.
      IF sy-subrc &lt;&gt; 0 OR ls_overwrite-decision IS INITIAL.
        zcx_abapgit_exception=&gt;raise( |Overwrite odd package { &lt;ls_overwrite&gt;-obj_type } {
          &lt;ls_overwrite&gt;-obj_name } undecided| ).
      ENDIF.

      IF ls_overwrite-decision = &apos;N&apos;.
        DELETE ct_results WHERE
          obj_type = &lt;ls_overwrite&gt;-obj_type AND
          obj_name = &lt;ls_overwrite&gt;-obj_name.
        ASSERT sy-subrc = 0.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD warning_package_find.

    DATA: lv_package         TYPE devclass,
          lt_overwrite_uniqe TYPE HASHED TABLE OF zif_abapgit_definitions=&gt;ty_overwrite
                                  WITH UNIQUE KEY obj_type obj_name devclass,
          ls_overwrite       LIKE LINE OF rt_overwrite,
          ls_tadir           TYPE zif_abapgit_definitions=&gt;ty_tadir.

    DATA: lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic.

    FIELD-SYMBOLS: &lt;ls_result&gt; LIKE LINE OF it_results.

    lo_folder_logic = zcl_abapgit_folder_logic=&gt;get_instance( ).
    LOOP AT it_results ASSIGNING &lt;ls_result&gt;.

      lv_package = lo_folder_logic-&gt;path_to_package(
        iv_top  = io_repo-&gt;get_package( )
        io_dot  = io_repo-&gt;get_dot_abapgit( )
        iv_path = &lt;ls_result&gt;-path ).

      ls_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read_single(
        iv_object   = &lt;ls_result&gt;-obj_type
        iv_obj_name = &lt;ls_result&gt;-obj_name ).

      IF NOT ls_tadir IS INITIAL AND ls_tadir-devclass &lt;&gt; lv_package.
* overwriting object from different package than expected
        CLEAR ls_overwrite.
        ls_overwrite-obj_type = &lt;ls_result&gt;-obj_type.
        ls_overwrite-obj_name = &lt;ls_result&gt;-obj_name.
        ls_overwrite-devclass = ls_tadir-devclass.
        INSERT ls_overwrite INTO TABLE lt_overwrite_uniqe.
      ENDIF.

    ENDLOOP.

    rt_overwrite = lt_overwrite_uniqe.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_ENHC IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_composite_id = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lx_error      TYPE REF TO cx_enh_root,
          li_enh_object TYPE REF TO if_enh_object.

    TRY.
        li_enh_object = cl_enh_factory=&gt;load_enhancement_composite(
          name = mv_composite_id
          lock = abap_true ).

        li_enh_object-&gt;delete( ).
        li_enh_object-&gt;save( ).
        li_enh_object-&gt;unlock( ).

      CATCH cx_enh_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( lx_error-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lx_error            TYPE REF TO cx_enh_root,
          li_enh_composite    TYPE REF TO if_enh_composite,
          lv_package          TYPE devclass,
          lt_composite_childs TYPE enhcompositename_it,
          lt_enh_childs       TYPE enhname_it,
          lv_longtext_id      TYPE enhdocuobject,
          lv_shorttext        TYPE string.

    FIELD-SYMBOLS: &lt;ls_composite_child&gt; TYPE enhcompositename,
                   &lt;ls_enh_child&gt;       LIKE LINE OF lt_enh_childs.

    lv_package = iv_package.
    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING  cg_data = lv_shorttext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;COMPOSITE_CHILDS&apos;
                  CHANGING  cg_data = lt_composite_childs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ENH_CHILDS&apos;
                  CHANGING  cg_data = lt_enh_childs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;LONGTEXT_ID&apos;
                  CHANGING  cg_data = lv_longtext_id ).

    TRY.
        cl_enh_factory=&gt;create_enhancement_composite(
          EXPORTING
            name      = mv_composite_id
            run_dark  = abap_true
          IMPORTING
            composite = li_enh_composite
          CHANGING
            devclass  = lv_package ).

        li_enh_composite-&gt;if_enh_object_docu~set_shorttext( lv_shorttext ).

        LOOP AT lt_composite_childs ASSIGNING &lt;ls_composite_child&gt;.
          li_enh_composite-&gt;add_composite_child( &lt;ls_composite_child&gt; ).
        ENDLOOP.

        LOOP AT lt_enh_childs ASSIGNING &lt;ls_enh_child&gt;.
          li_enh_composite-&gt;add_enh_child( &lt;ls_enh_child&gt; ).
        ENDLOOP.

        li_enh_composite-&gt;set_longtext_id( lv_longtext_id ).

        li_enh_composite-&gt;if_enh_object~save( ).
        li_enh_composite-&gt;if_enh_object~activate( ).
        li_enh_composite-&gt;if_enh_object~unlock( ).

      CATCH cx_enh_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( lx_error-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    TRY.
        cl_enh_factory=&gt;load_enhancement_composite(
          name = mv_composite_id
          lock = abap_false ).
        rv_bool = abap_true.
      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = |{ mv_composite_id }|.
    OVERLAY lv_argument WITH &apos;                                  &apos;.
    lv_argument = |{ lv_argument }*|.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = |E_ENHANCE|
                                            iv_argument    = lv_argument ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = ms_item-obj_type
        in_new_window = abap_true
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lx_error            TYPE REF TO cx_enh_root,
          li_enh_composite    TYPE REF TO if_enh_composite,
          lt_composite_childs TYPE enhcompositename_it,
          lt_enh_childs       TYPE enhname_it,
          lv_longtext_id      TYPE enhdocuobject,
          lv_shorttext        TYPE string.

    TRY.
        li_enh_composite = cl_enh_factory=&gt;load_enhancement_composite(
          name = mv_composite_id
          lock = abap_false ).

        lv_shorttext = li_enh_composite-&gt;if_enh_object_docu~get_shorttext( ).

        lt_composite_childs = li_enh_composite-&gt;get_composite_childs( ).
        lt_enh_childs       = li_enh_composite-&gt;get_enh_childs( ).
        lv_longtext_id      = li_enh_composite-&gt;get_longtext_id( ).

        io_xml-&gt;add( iv_name = &apos;SHORTTEXT&apos;
                     ig_data = lv_shorttext ).
        io_xml-&gt;add( iv_name = &apos;COMPOSITE_CHILDS&apos;
                     ig_data = lt_composite_childs ).
        io_xml-&gt;add( iv_name = &apos;ENH_CHILDS&apos;
                     ig_data = lt_enh_childs ).
        io_xml-&gt;add( iv_name = &apos;LONGTEXT_ID&apos;
                     ig_data = lv_longtext_id ).

      CATCH cx_enh_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( lx_error-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_NEWS IMPLEMENTATION.
  METHOD compare_versions.

    DATA: lv_version_a TYPE i,
          lv_version_b TYPE i.

    &quot; Convert versions to numeric
    lv_version_a = version_to_numeric( iv_a ).
    lv_version_b = version_to_numeric( iv_b ).

    &quot; Compare versions
    IF lv_version_a &gt; lv_version_b.
      rv_result = 1.
    ELSEIF lv_version_a &lt; lv_version_b.
      rv_result = -1.
    ELSE.
      rv_result = 0.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    DATA: lt_lines    TYPE string_table,
          lv_string   TYPE string,
          ls_log_line LIKE LINE OF mt_log.

    &quot; Validate params
    mv_current_version  = normalize_version( iv_current_version ).
    mv_lastseen_version = normalize_version( iv_lastseen_version ).
    IF mv_current_version IS INITIAL.
      RETURN. &quot; Internal format of program version is not correct -&gt; abort parsing
    ENDIF.

    lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_rawdata ).
    lt_lines  = zcl_abapgit_convert=&gt;split_string( lv_string ).
    mt_log    = parse( it_lines = lt_lines iv_current_version = mv_current_version ).

    READ TABLE mt_log INTO ls_log_line INDEX 1.
    mv_latest_version = ls_log_line-version. &quot; Empty if not found

  ENDMETHOD.
  METHOD create.
    &quot; TODO REFACTOR !

    CONSTANTS: &quot; TODO refactor
      lc_log_path     TYPE string VALUE &apos;/&apos;,
      lc_log_filename TYPE string VALUE &apos;changelog.txt&apos;.

    DATA: lt_remote      TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lv_last_seen   TYPE string,
          lv_url         TYPE string,
          lo_repo_online TYPE REF TO zcl_abapgit_repo_online.

    FIELD-SYMBOLS &lt;ls_file&gt; LIKE LINE OF lt_remote.
    IF io_repo-&gt;is_offline( ) = abap_true.
      RETURN.
    ENDIF.

    lo_repo_online ?= io_repo.
    lv_url          = lo_repo_online-&gt;get_url( ).

    IF is_relevant( lv_url ) = abap_false.
      RETURN.
    ENDIF.

    lv_last_seen = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_repo_last_change_seen( lv_url ).

    TRY.
        &quot; Find changelog
        lt_remote = io_repo-&gt;get_files_remote( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    READ TABLE lt_remote ASSIGNING &lt;ls_file&gt;
      WITH KEY path = lc_log_path filename = lc_log_filename.
    IF sy-subrc = 0.
      CREATE OBJECT ro_instance
        EXPORTING
          iv_rawdata          = &lt;ls_file&gt;-data
          iv_current_version  = zif_abapgit_version=&gt;gc_abap_version &quot; TODO refactor
          iv_lastseen_version = normalize_version( lv_last_seen ).
    ENDIF.

    IF ro_instance IS BOUND AND lv_last_seen &lt;&gt; ro_instance-&gt;latest_version( ).
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_last_change_seen(
        iv_url     = lv_url
        iv_version = ro_instance-&gt;latest_version( ) ).
    ENDIF.

  ENDMETHOD.
  METHOD get_log.
    rt_log = me-&gt;mt_log.
  ENDMETHOD.
  METHOD has_important.
    READ TABLE mt_log WITH KEY is_important = abap_true TRANSPORTING NO FIELDS.
    rv_boolean = boolc( sy-subrc IS INITIAL ).
  ENDMETHOD.
  METHOD has_news.
    rv_boolean = boolc( lines( mt_log ) &gt; 0 ).
  ENDMETHOD.
  METHOD has_unseen.
    rv_boolean = boolc( compare_versions(
      iv_a = mv_latest_version
      iv_b = mv_lastseen_version ) &gt; 0 ).
  ENDMETHOD.
  METHOD has_updates.
    rv_boolean = boolc( compare_versions(
      iv_a = mv_latest_version
      iv_b = mv_current_version ) &gt; 0 ).
  ENDMETHOD.
  METHOD is_relevant.

    &quot; News announcement restricted to abapGit only
    IF iv_url CS &apos;/abapGit&apos; OR iv_url CS &apos;/abapGit.git&apos;.
      rv_relevant = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD latest_version.
    rv_version = me-&gt;mv_latest_version.
  ENDMETHOD.
  METHOD normalize_version.

    &quot; Internal program version should be in format &quot;XXX.XXX.XXX&quot; or &quot;vXXX.XXX.XXX&quot;
    CONSTANTS: lc_version_pattern TYPE string VALUE &apos;^v?(\d{1,3}\.\d{1,3}\.\d{1,3})\s*$&apos;.

    FIND FIRST OCCURRENCE OF REGEX lc_version_pattern
      IN iv_version SUBMATCHES rv_version.

  ENDMETHOD.
  METHOD parse.

    DATA: lv_tail                TYPE i,
          lv_first_version_found TYPE abap_bool,
          lv_version             TYPE string,
          ls_log                 LIKE LINE OF rt_log.

    FIELD-SYMBOLS: &lt;lv_line&gt; LIKE LINE OF it_lines.
    LOOP AT it_lines ASSIGNING &lt;lv_line&gt;.
      ls_log = parse_line( iv_line = &lt;lv_line&gt; iv_current_version = iv_current_version ).

      &quot; Skip until first version head and Skip empty lines
      CHECK ls_log IS NOT INITIAL AND
            ( lv_first_version_found = abap_true OR ls_log-version IS NOT INITIAL ).

      IF lv_first_version_found = abap_false.
        lv_first_version_found = abap_true.
        IF compare_versions( iv_a = ls_log-version iv_b = iv_current_version ) &lt;= 0.
          lv_tail = c_tail_length. &quot; Display some last versions if no updates
        ENDIF.
      ENDIF.

      IF ls_log-is_header = abap_true.
        &quot;Skip everything below current version or show tail news
        IF compare_versions( iv_a = ls_log-version iv_b = iv_current_version ) &lt;= 0.
          IF lv_tail &gt; 0.
            lv_tail = lv_tail - 1.
          ELSE.
            EXIT.
          ENDIF.
        ENDIF.
        lv_version = ls_log-version. &quot; Save to fill news lines
      ELSE.
        ls_log-version = lv_version.
      ENDIF.

      APPEND ls_log TO rt_log.
    ENDLOOP.

  ENDMETHOD.
  METHOD parse_line.

    CONSTANTS: lc_header_pattern TYPE string
        VALUE &apos;^\d{4}-\d{2}-\d{2}\s+v(\d{1,3}\.\d{1,3}\.\d{1,3})\s*$&apos;.

    DATA: lv_version TYPE string.

    IF iv_line IS INITIAL OR iv_line CO &apos; -=&apos;.
      RETURN. &quot; Skip empty and markup lines
    ENDIF.

    &quot; Check if line is a header line
    FIND FIRST OCCURRENCE OF REGEX lc_header_pattern IN iv_line SUBMATCHES lv_version.
    IF sy-subrc IS INITIAL.
      lv_version        = normalize_version( lv_version ).
      rs_log-version    = lv_version.
      rs_log-is_header  = abap_true.
      rs_log-pos_to_cur = compare_versions( iv_a = lv_version iv_b = iv_current_version ).
    ELSE.
      FIND FIRST OCCURRENCE OF REGEX &apos;^\s*!&apos; IN iv_line.
      rs_log-is_important = boolc( sy-subrc IS INITIAL ). &quot; Change is important
    ENDIF.

    rs_log-text = iv_line.

  ENDMETHOD.
  METHOD version_to_numeric.

    DATA: lv_major   TYPE numc4,
          lv_minor   TYPE numc4,
          lv_release TYPE numc4.

    SPLIT iv_version AT &apos;.&apos; INTO lv_major lv_minor lv_release.

    &quot; Calculated value of version number, empty version will become 0 which is OK
    rv_version = lv_major * 1000000 + lv_minor * 1000 + lv_release.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_MIGRATIONS IMPLEMENTATION.
  METHOD local_dot_abapgit.

    DATA: lt_repos       TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt,
          lo_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit.

    FIELD-SYMBOLS: &lt;lo_repo&gt; LIKE LINE OF lt_repos.
    lt_repos = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;list( ).

    LOOP AT lt_repos ASSIGNING &lt;lo_repo&gt;.
      lo_dot_abapgit = &lt;lo_repo&gt;-&gt;get_dot_abapgit( ).
      IF lo_dot_abapgit-&gt;get_data( ) IS INITIAL.
        CALL FUNCTION &apos;POPUP_TO_INFORM&apos;
          EXPORTING
            titel = &apos;Migration&apos;
            txt1  = &apos;Automatic migration of .abapgit.xml removed&apos;
            txt2  = &apos;Remove all repos and install latest abapGit version&apos;.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD rebuild_local_checksums_161112.

    DATA: lt_repos     TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt,
          lv_repo_list TYPE string,
          lv_index     TYPE i.

    FIELD-SYMBOLS: &lt;lo_repo&gt; LIKE LINE OF lt_repos.
    lt_repos = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;list( ).

    LOOP AT lt_repos ASSIGNING &lt;lo_repo&gt;.
      lv_index = sy-tabix.

      IF &lt;lo_repo&gt;-&gt;is_offline( ) = abap_true. &quot; Skip local repos
        DELETE lt_repos INDEX lv_index.
        CONTINUE.
      ENDIF.

      &quot; Ignore empty repos or repos with file checksums
      IF lines( &lt;lo_repo&gt;-&gt;get_local_checksums( ) ) = 0
          OR lines( &lt;lo_repo&gt;-&gt;get_local_checksums_per_file( ) ) &gt; 0.
        DELETE lt_repos INDEX lv_index.
        CONTINUE.
      ENDIF.

      lv_repo_list = lv_repo_list &amp;&amp; `, ` &amp;&amp; &lt;lo_repo&gt;-&gt;get_name( ).
    ENDLOOP.

    IF lines( lt_repos ) = 0.
      RETURN. &quot; All OK
    ENDIF.

    CALL FUNCTION &apos;POPUP_TO_INFORM&apos;
      EXPORTING
        titel = &apos;Migration&apos;
        txt1  = &apos;Automatic migration of local checksums removed&apos;
        txt2  = &apos;Remove all repos and install latest abapGit version&apos;.

  ENDMETHOD.
  METHOD run.

    &quot; Migrate STDTEXT to TABLE
    zcl_abapgit_persist_migrate=&gt;run( ).

    &quot; Rebuild local file checksums
    rebuild_local_checksums_161112( ).

    &quot; local .abapgit.xml state, issue #630
    local_dot_abapgit( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_MERGE IMPLEMENTATION.
  METHOD all_files.

    APPEND LINES OF ms_merge-stree TO rt_files.
    APPEND LINES OF ms_merge-ttree TO rt_files.
    APPEND LINES OF ms_merge-ctree TO rt_files.
    SORT rt_files BY path DESCENDING name ASCENDING.
    DELETE ADJACENT DUPLICATES FROM rt_files COMPARING path name.

  ENDMETHOD.
  METHOD calculate_result.

    DEFINE _from_source.
      READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
        WITH KEY type COMPONENTS
          type = zif_abapgit_definitions=&gt;c_type-blob
          sha1 = &lt;ls_source&gt;-sha1.
      ASSERT sy-subrc = 0.

      ms_merge-stage-&gt;add( iv_path     = &lt;ls_file&gt;-path
                           iv_filename = &lt;ls_file&gt;-name
                           iv_data     = &lt;ls_object&gt;-data ).
    END-OF-DEFINITION.

    DATA: lt_files        TYPE zif_abapgit_definitions=&gt;ty_expanded_tt,
          lv_found_source TYPE abap_bool,
          lv_found_target TYPE abap_bool,
          lv_found_common TYPE abap_bool.

    FIELD-SYMBOLS: &lt;ls_source&gt;   LIKE LINE OF lt_files,
                   &lt;ls_target&gt;   LIKE LINE OF lt_files,
                   &lt;ls_common&gt;   LIKE LINE OF lt_files,
                   &lt;ls_file&gt;     LIKE LINE OF lt_files,
                   &lt;ls_result&gt;   LIKE LINE OF ms_merge-result,
                   &lt;ls_object&gt;   LIKE LINE OF mt_objects,
                   &lt;ls_conflict&gt; LIKE LINE OF mt_conflicts.

    lt_files = all_files( ).

    CREATE OBJECT ms_merge-stage
      EXPORTING
        iv_merge_source = ms_merge-source-sha1.

    LOOP AT lt_files ASSIGNING &lt;ls_file&gt;.

      UNASSIGN &lt;ls_source&gt;.
      UNASSIGN &lt;ls_target&gt;.
      UNASSIGN &lt;ls_common&gt;.

      READ TABLE ms_merge-stree ASSIGNING &lt;ls_source&gt;
        WITH KEY path = &lt;ls_file&gt;-path name = &lt;ls_file&gt;-name. &quot;#EC CI_SUBRC
      READ TABLE ms_merge-ttree ASSIGNING &lt;ls_target&gt;
        WITH KEY path = &lt;ls_file&gt;-path name = &lt;ls_file&gt;-name. &quot;#EC CI_SUBRC
      READ TABLE ms_merge-ctree ASSIGNING &lt;ls_common&gt;
        WITH KEY path = &lt;ls_file&gt;-path name = &lt;ls_file&gt;-name. &quot;#EC CI_SUBRC

      lv_found_source = boolc( &lt;ls_source&gt; IS ASSIGNED ).
      lv_found_target = boolc( &lt;ls_target&gt; IS ASSIGNED ).
      lv_found_common = boolc( &lt;ls_common&gt; IS ASSIGNED ).

      IF lv_found_source = abap_false
          AND lv_found_target = abap_false.
* deleted in source and target, skip
        CONTINUE.
      ELSEIF lv_found_source = abap_false
          AND lv_found_common = abap_true
          AND &lt;ls_target&gt;-sha1 = &lt;ls_common&gt;-sha1.
* deleted in source, skip
        ms_merge-stage-&gt;rm( iv_path     = &lt;ls_file&gt;-path
                            iv_filename = &lt;ls_file&gt;-name ).
        CONTINUE.
      ELSEIF lv_found_target = abap_false
          AND lv_found_common = abap_true
          AND &lt;ls_source&gt;-sha1 = &lt;ls_common&gt;-sha1.
* deleted in target, skip
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO ms_merge-result ASSIGNING &lt;ls_result&gt;.
      &lt;ls_result&gt;-path = &lt;ls_file&gt;-path.
      &lt;ls_result&gt;-name = &lt;ls_file&gt;-name.

      IF lv_found_target = abap_false.
* added in source
        _from_source.
        &lt;ls_result&gt;-sha1 = &lt;ls_source&gt;-sha1.
        CONTINUE.
      ELSEIF lv_found_source = abap_false.
* added in target
        &lt;ls_result&gt;-sha1 = &lt;ls_target&gt;-sha1.
      ELSEIF lv_found_common = abap_false
          AND &lt;ls_target&gt;-sha1 = &lt;ls_source&gt;-sha1.
* added in source and target
        &lt;ls_result&gt;-sha1 = &lt;ls_source&gt;-sha1.
      ELSEIF lv_found_common = abap_false
         AND &lt;ls_target&gt;-sha1 &lt;&gt; &lt;ls_source&gt;-sha1.

        INSERT INITIAL LINE INTO TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt;.
        &lt;ls_conflict&gt;-path = &lt;ls_file&gt;-path.
        &lt;ls_conflict&gt;-filename = &lt;ls_file&gt;-name.
        &lt;ls_conflict&gt;-source_sha1 = &lt;ls_source&gt;-sha1.
        READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
          WITH KEY type COMPONENTS
            type = zif_abapgit_definitions=&gt;c_type-blob
            sha1 = &lt;ls_source&gt;-sha1.
        &lt;ls_conflict&gt;-source_data = &lt;ls_object&gt;-data.

        &lt;ls_conflict&gt;-target_sha1 = &lt;ls_target&gt;-sha1.
        READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
          WITH KEY type COMPONENTS
            type = zif_abapgit_definitions=&gt;c_type-blob
            sha1 = &lt;ls_target&gt;-sha1.
        &lt;ls_conflict&gt;-target_data = &lt;ls_object&gt;-data.

* added in source and target, but different, merge conflict must be resolved
        ms_merge-conflict = |{ &lt;ls_file&gt;-name } merge conflict|.
        CONTINUE.
      ENDIF.

      IF lv_found_source = abap_false
      OR lv_found_target = abap_false
      OR lv_found_common = abap_false.
        ms_merge-conflict = |{ &lt;ls_file&gt;-name } merge conflict, not found anywhere|.
        CONTINUE.
      ENDIF.

      IF &lt;ls_target&gt;-sha1 = &lt;ls_source&gt;-sha1.
* target and source match
        &lt;ls_result&gt;-sha1 = &lt;ls_source&gt;-sha1.
      ELSEIF &lt;ls_target&gt;-sha1 = &lt;ls_common&gt;-sha1.
* changed in source
        _from_source.
        &lt;ls_result&gt;-sha1 = &lt;ls_source&gt;-sha1.
      ELSEIF &lt;ls_source&gt;-sha1 = &lt;ls_common&gt;-sha1.
* changed in target
        &lt;ls_result&gt;-sha1 = &lt;ls_target&gt;-sha1.
      ELSE.
* changed in source and target, conflict
* conflict must be resolved before merge
        INSERT INITIAL LINE INTO TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt;.
        &lt;ls_conflict&gt;-path = &lt;ls_file&gt;-path.
        &lt;ls_conflict&gt;-filename = &lt;ls_file&gt;-name.
        &lt;ls_conflict&gt;-source_sha1 = &lt;ls_source&gt;-sha1.
        READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
          WITH KEY type COMPONENTS
            type = zif_abapgit_definitions=&gt;c_type-blob
            sha1 = &lt;ls_source&gt;-sha1.
        &lt;ls_conflict&gt;-source_data = &lt;ls_object&gt;-data.

        &lt;ls_conflict&gt;-target_sha1 = &lt;ls_target&gt;-sha1.
        READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
          WITH KEY type COMPONENTS
            type = zif_abapgit_definitions=&gt;c_type-blob
            sha1 = &lt;ls_target&gt;-sha1.
        &lt;ls_conflict&gt;-target_data = &lt;ls_object&gt;-data.

        ms_merge-conflict = |{ &lt;ls_file&gt;-name } merge conflict, changed in source and target branch|.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD constructor.

    IF iv_source_branch EQ io_repo-&gt;get_branch_name( ).
      zcx_abapgit_exception=&gt;raise( &apos;source = target&apos; ).
    ENDIF.

    mo_repo = io_repo.
    mv_source_branch = iv_source_branch.

  ENDMETHOD.
  METHOD fetch_git.

    DATA: lo_branch_list TYPE REF TO zcl_abapgit_git_branch_list,
          lt_upload      TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt.

    lo_branch_list = zcl_abapgit_git_transport=&gt;branches( ms_merge-repo-&gt;get_url( ) ).

    ms_merge-source = lo_branch_list-&gt;find_by_name(
      zcl_abapgit_git_branch_list=&gt;complete_heads_branch_name( mv_source_branch ) ).

    ms_merge-target = lo_branch_list-&gt;find_by_name(
      zcl_abapgit_git_branch_list=&gt;complete_heads_branch_name( mo_repo-&gt;get_branch_name( ) ) ).

    APPEND ms_merge-source TO lt_upload.
    APPEND ms_merge-target TO lt_upload.

    zcl_abapgit_git_transport=&gt;upload_pack(
      EXPORTING
        iv_url         = ms_merge-repo-&gt;get_url( )
        iv_branch_name = ms_merge-repo-&gt;get_branch_name( )
        iv_deepen      = abap_false
        it_branches    = lt_upload
      IMPORTING
        et_objects     = rt_objects ).

  ENDMETHOD.
  METHOD find_ancestors.

    DEFINE _visit.
      IF NOT &amp;1 IS INITIAL.
        READ TABLE lt_visit FROM &amp;1 TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          APPEND &amp;1 TO lt_visit.
        ENDIF.
      ENDIF.
    END-OF-DEFINITION.

    DATA: ls_commit TYPE zcl_abapgit_git_pack=&gt;ty_commit,
          lt_visit  TYPE STANDARD TABLE OF zif_abapgit_definitions=&gt;ty_sha1,
          lv_commit LIKE LINE OF lt_visit.

    FIELD-SYMBOLS: &lt;ls_ancestor&gt; LIKE LINE OF rt_ancestors,
                   &lt;ls_object&gt;   LIKE LINE OF mt_objects.
    APPEND iv_commit TO lt_visit.

    LOOP AT lt_visit INTO lv_commit.
      READ TABLE mt_objects ASSIGNING &lt;ls_object&gt;
        WITH KEY type COMPONENTS
          type = zif_abapgit_definitions=&gt;c_type-commit
          sha1 = lv_commit.
      ASSERT sy-subrc = 0.

      ls_commit = zcl_abapgit_git_pack=&gt;decode_commit( &lt;ls_object&gt;-data ).

      _visit ls_commit-parent.
      _visit ls_commit-parent2.

      APPEND INITIAL LINE TO rt_ancestors ASSIGNING &lt;ls_ancestor&gt;.
      &lt;ls_ancestor&gt;-commit = lv_commit.
      &lt;ls_ancestor&gt;-tree = ls_commit-tree.
      &lt;ls_ancestor&gt;-body = ls_commit-body.
      &lt;ls_ancestor&gt;-time = ls_commit-author.

      &quot;Strip Author entry of all but the time component
      REPLACE ALL OCCURRENCES OF REGEX &apos;[a-zA-Z&lt;&gt;@.-]*&apos; IN &lt;ls_ancestor&gt;-time WITH &apos;&apos;.
      CONDENSE &lt;ls_ancestor&gt;-time.
    ENDLOOP.

    SORT rt_ancestors BY time DESCENDING.

  ENDMETHOD.
  METHOD find_first_common.

    FIELD-SYMBOLS: &lt;ls_list1&gt; LIKE LINE OF it_list1,
                   &lt;ls_list2&gt; LIKE LINE OF it_list2.

    LOOP AT it_list1 ASSIGNING &lt;ls_list1&gt;.
      LOOP AT it_list2 ASSIGNING &lt;ls_list2&gt;.
        IF &lt;ls_list1&gt;-tree = &lt;ls_list2&gt;-tree.
          rs_common = &lt;ls_list1&gt;.
          RETURN.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    zcx_abapgit_exception=&gt;raise( &apos;error finding common ancestor&apos; ).

  ENDMETHOD.
  METHOD get_conflicts.

    rt_conflicts = mt_conflicts.

  ENDMETHOD.
  METHOD get_result.

    rs_merge = ms_merge.

  ENDMETHOD.
  METHOD get_source_branch.

    rv_source_branch = mv_source_branch.

  ENDMETHOD.
  METHOD has_conflicts.

    IF lines( mt_conflicts ) &gt; 0.
      rv_conflicts_exists = abap_true.
    ELSE.
      rv_conflicts_exists = abap_false.
    ENDIF.

  ENDMETHOD.
  METHOD resolve_conflict.

    FIELD-SYMBOLS: &lt;ls_conflict&gt; TYPE zif_abapgit_definitions=&gt;ty_merge_conflict,
                   &lt;ls_result&gt;   LIKE LINE OF ms_merge-result.

    IF is_conflict-result_sha1 IS NOT INITIAL
        AND is_conflict-result_data IS NOT INITIAL.
      READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; WITH KEY path = is_conflict-path
                                                               filename = is_conflict-filename.
      IF sy-subrc EQ 0.
        READ TABLE ms_merge-result ASSIGNING &lt;ls_result&gt; WITH KEY path = is_conflict-path
                                                                  name = is_conflict-filename.
        IF sy-subrc EQ 0.
          &lt;ls_result&gt;-sha1 = is_conflict-result_sha1.

          ms_merge-stage-&gt;add( iv_path     = &lt;ls_conflict&gt;-path
                               iv_filename = &lt;ls_conflict&gt;-filename
                               iv_data     = is_conflict-result_data ).

          DELETE mt_conflicts WHERE path     EQ is_conflict-path
                                AND filename EQ is_conflict-filename.
        ENDIF.

        READ TABLE ms_merge-result ASSIGNING &lt;ls_result&gt; WITH KEY sha1 = space.
        IF sy-subrc EQ 0.
          ms_merge-conflict = |{ &lt;ls_result&gt;-name } merge conflict, changed in source and target branch|.
        ELSE.
          CLEAR ms_merge-conflict.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD run.

    DATA: lt_asource TYPE ty_ancestor_tt,
          lt_atarget TYPE ty_ancestor_tt.

    CLEAR: ms_merge, mt_objects, mt_conflicts.

    ms_merge-repo = mo_repo.
    mt_objects = fetch_git( ).

    lt_asource = find_ancestors( ms_merge-source-sha1 ).
    lt_atarget = find_ancestors( ms_merge-target-sha1 ).

    ms_merge-common = find_first_common( it_list1 = lt_asource
                                         it_list2 = lt_atarget ).

    ms_merge-stree = zcl_abapgit_git_porcelain=&gt;full_tree(
      it_objects = mt_objects
      iv_branch  = ms_merge-source-sha1 ).
    ms_merge-ttree = zcl_abapgit_git_porcelain=&gt;full_tree(
      it_objects = mt_objects
      iv_branch  = ms_merge-target-sha1 ).
    ms_merge-ctree = zcl_abapgit_git_porcelain=&gt;full_tree(
      it_objects = mt_objects
      iv_branch  = ms_merge-common-commit ).

    calculate_result( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_LONGTEXTS IMPLEMENTATION.
  METHOD delete.

    DATA: lt_dokil TYPE zif_abapgit_definitions=&gt;tty_dokil.
    FIELD-SYMBOLS: &lt;ls_dokil&gt; TYPE dokil.

    SELECT * FROM dokil
             INTO TABLE lt_dokil
             WHERE id     = iv_longtext_id
             AND   object = iv_longtext_id.

    LOOP AT lt_dokil ASSIGNING &lt;ls_dokil&gt;.

      CALL FUNCTION &apos;DOCU_DEL&apos;
        EXPORTING
          id       = &lt;ls_dokil&gt;-id
          langu    = &lt;ls_dokil&gt;-langu
          object   = &lt;ls_dokil&gt;-object
          typ      = &lt;ls_dokil&gt;-typ
        EXCEPTIONS
          ret_code = 1
          OTHERS   = 2.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize.

    DATA: lt_longtexts     TYPE tty_longtexts,
          lv_no_masterlang TYPE dokil-masterlang.
    FIELD-SYMBOLS: &lt;ls_longtext&gt; TYPE ty_longtext.

    io_xml-&gt;read(
      EXPORTING
        iv_name = c_longtexts_name
      CHANGING
        cg_data = lt_longtexts ).

    LOOP AT lt_longtexts ASSIGNING &lt;ls_longtext&gt;.

      lv_no_masterlang = boolc( iv_master_language &lt;&gt; &lt;ls_longtext&gt;-dokil-langu ).

      CALL FUNCTION &apos;DOCU_UPDATE&apos;
        EXPORTING
          head          = &lt;ls_longtext&gt;-head
          state         = c_docu_state_active
          typ           = &lt;ls_longtext&gt;-dokil-typ
          version       = &lt;ls_longtext&gt;-dokil-version
          no_masterlang = lv_no_masterlang
        TABLES
          line          = &lt;ls_longtext&gt;-lines.

    ENDLOOP.

  ENDMETHOD.
  METHOD serialize.

    DATA: ls_longtext  TYPE ty_longtext,
          lt_longtexts TYPE tty_longtexts,
          lt_dokil     TYPE zif_abapgit_definitions=&gt;tty_dokil.

    FIELD-SYMBOLS: &lt;ls_dokil&gt; LIKE LINE OF lt_dokil.
    IF lines( it_dokil ) &gt; 0.

      lt_dokil = it_dokil.

    ELSEIF iv_longtext_id IS NOT INITIAL.

      SELECT * FROM dokil
              INTO TABLE lt_dokil
              WHERE id     = iv_longtext_id
              AND   object = iv_object_name.

    ELSE.

      zcx_abapgit_exception=&gt;raise( |serialize_longtexts parameter error| ).

    ENDIF.

    LOOP AT lt_dokil ASSIGNING &lt;ls_dokil&gt;
                     WHERE txtlines &gt; 0.

      CLEAR: ls_longtext.

      ls_longtext-dokil = &lt;ls_dokil&gt;.

      CALL FUNCTION &apos;DOCU_READ&apos;
        EXPORTING
          id      = &lt;ls_dokil&gt;-id
          langu   = &lt;ls_dokil&gt;-langu
          object  = &lt;ls_dokil&gt;-object
          typ     = &lt;ls_dokil&gt;-typ
          version = &lt;ls_dokil&gt;-version
        IMPORTING
          head    = ls_longtext-head
        TABLES
          line    = ls_longtext-lines.

      CLEAR: ls_longtext-head-tdfuser,
             ls_longtext-head-tdfreles,
             ls_longtext-head-tdfdate,
             ls_longtext-head-tdftime,
             ls_longtext-head-tdluser,
             ls_longtext-head-tdlreles,
             ls_longtext-head-tdldate,
             ls_longtext-head-tdltime.

      INSERT ls_longtext INTO TABLE lt_longtexts.

    ENDLOOP.

    io_xml-&gt;add( iv_name = c_longtexts_name
                 ig_data = lt_longtexts ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_injector IMPLEMENTATION.
  METHOD set_code_inspector.

    DATA: ls_code_inspector LIKE LINE OF zcl_abapgit_factory=&gt;gt_code_inspector.
    FIELD-SYMBOLS: &lt;ls_code_inspector&gt; LIKE LINE OF zcl_abapgit_factory=&gt;gt_code_inspector.

    READ TABLE zcl_abapgit_factory=&gt;gt_code_inspector
         ASSIGNING &lt;ls_code_inspector&gt;
         WITH TABLE KEY package            = iv_package
                        check_variant_name = iv_check_variant_name.
    IF sy-subrc &lt;&gt; 0.

      ls_code_inspector-package = iv_package.
      ls_code_inspector-check_variant_name = iv_check_variant_name.

      INSERT ls_code_inspector
             INTO TABLE zcl_abapgit_factory=&gt;gt_code_inspector
             ASSIGNING &lt;ls_code_inspector&gt;.

    ENDIF.

    &lt;ls_code_inspector&gt;-instance = ii_code_inspector.

  ENDMETHOD.
  METHOD set_sap_package.

    DATA: ls_sap_package TYPE zcl_abapgit_factory=&gt;ty_sap_package.
    FIELD-SYMBOLS: &lt;ls_sap_package&gt; TYPE zcl_abapgit_factory=&gt;ty_sap_package.

    READ TABLE zcl_abapgit_factory=&gt;gt_sap_package
         ASSIGNING &lt;ls_sap_package&gt;
         WITH TABLE KEY package = iv_package.

    IF sy-subrc &lt;&gt; 0.

      ls_sap_package-package = iv_package.
      INSERT ls_sap_package
             INTO TABLE zcl_abapgit_factory=&gt;gt_sap_package
             ASSIGNING &lt;ls_sap_package&gt;.

    ENDIF.

    &lt;ls_sap_package&gt;-instance = ii_sap_package.

  ENDMETHOD.
  METHOD set_stage_logic.

    zcl_abapgit_factory=&gt;gi_stage_logic = ii_logic.

  ENDMETHOD.
  METHOD set_syntax_check.

    DATA: ls_syntax_check LIKE LINE OF zcl_abapgit_factory=&gt;gt_syntax_check.
    FIELD-SYMBOLS: &lt;ls_syntax_check&gt; LIKE LINE OF zcl_abapgit_factory=&gt;gt_syntax_check.

    READ TABLE zcl_abapgit_factory=&gt;gt_syntax_check
         ASSIGNING &lt;ls_syntax_check&gt;
         WITH TABLE KEY package = iv_package.
    IF sy-subrc &lt;&gt; 0.

      ls_syntax_check-package = iv_package.

      INSERT ls_syntax_check
             INTO TABLE zcl_abapgit_factory=&gt;gt_syntax_check
             ASSIGNING &lt;ls_syntax_check&gt;.

    ENDIF.

    &lt;ls_syntax_check&gt;-instance = ii_syntax_check.

  ENDMETHOD.
  METHOD set_tadir.

    zcl_abapgit_factory=&gt;gi_tadir = ii_tadir.

  ENDMETHOD.

  METHOD set_cts_api.
    zcl_abapgit_factory=&gt;gi_cts_api = ii_cts_api.
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_http_client IMPLEMENTATION.
  METHOD check_http_200.

    DATA: lv_code TYPE i,
          lv_text TYPE string.

    mi_client-&gt;response-&gt;get_status(
      IMPORTING
        code   = lv_code ).
    CASE lv_code.
      WHEN 200.
        RETURN.
      WHEN 302.
        zcx_abapgit_exception=&gt;raise( &apos;HTTP redirect, check URL&apos; ).
      WHEN 401.
        zcx_abapgit_exception=&gt;raise( &apos;HTTP 401, unauthorized&apos; ).
      WHEN 403.
        zcx_abapgit_exception=&gt;raise( &apos;HTTP 403, forbidden&apos; ).
      WHEN 404.
        zcx_abapgit_exception=&gt;raise( &apos;HTTP 404, not found&apos; ).
      WHEN 415.
        zcx_abapgit_exception=&gt;raise( &apos;HTTP 415, unsupported media type&apos; ).
      WHEN OTHERS.
        lv_text = mi_client-&gt;response-&gt;get_cdata( ).
        zcx_abapgit_exception=&gt;raise( |HTTP error code: { lv_code }, { lv_text }| ).
    ENDCASE.

  ENDMETHOD.
  METHOD check_smart_response.

    DATA: lv_content_type TYPE string.
    DATA: lv_data         TYPE string.

    IF iv_expected_content_type IS NOT INITIAL.
      lv_content_type = mi_client-&gt;response-&gt;get_content_type( ).
      IF lv_content_type &lt;&gt; iv_expected_content_type.
        zcx_abapgit_exception=&gt;raise( &apos;Wrong Content-Type sent by server - no fallback to the dumb protocol!&apos; ).
      ENDIF.
    ENDIF.

    IF iv_content_regex IS NOT INITIAL.
      lv_data = mi_client-&gt;response-&gt;get_cdata( ).
      FIND REGEX iv_content_regex IN lv_data.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Wrong Content sent by server&apos; ).
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD close.
    mi_client-&gt;close( ).
  ENDMETHOD.
  METHOD constructor.
    mi_client = ii_client.
  ENDMETHOD.
  METHOD get_cdata.
    rv_value = mi_client-&gt;response-&gt;get_cdata( ).
  ENDMETHOD.
  METHOD send_receive.

    DATA: lv_text    TYPE string,
          lv_code    TYPE i,
          lv_message TYPE string.

    mi_client-&gt;send( ).
    mi_client-&gt;receive(
      EXCEPTIONS
        http_communication_failure = 1
        http_invalid_state         = 2
        http_processing_failed     = 3
        OTHERS                     = 4 ).

    IF sy-subrc &lt;&gt; 0.
      &quot; in case of HTTP_COMMUNICATION_FAILURE
      &quot; make sure:
      &quot; a) SSL is setup properly in STRUST
      &quot; b) no firewalls
      &quot; check trace file in transaction SMICM

      mi_client-&gt;get_last_error(
        IMPORTING
          code    = lv_code
          message = lv_message ).

      lv_text = |HTTP error { lv_code } occured: { lv_message }|.

      zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDIF.

  ENDMETHOD.
  METHOD send_receive_close.

* do not use set_cdata as it modifies the Content-Type header field
    mi_client-&gt;request-&gt;set_data( iv_data ).
    send_receive( ).
    check_http_200( ).
    rv_data = mi_client-&gt;response-&gt;get_data( ).
    mi_client-&gt;close( ).

  ENDMETHOD.
  METHOD set_digest.
    mo_digest = io_digest.
  ENDMETHOD.
  METHOD set_headers.

    DATA: lv_value TYPE string.
    mi_client-&gt;request-&gt;set_header_field(
        name  = &apos;~request_method&apos;
        value = &apos;POST&apos; ).

    lv_value = zcl_abapgit_url=&gt;path_name( iv_url ) &amp;&amp;
      &apos;/git-&apos; &amp;&amp;
      iv_service &amp;&amp;
      &apos;-pack&apos;.
    mi_client-&gt;request-&gt;set_header_field(
        name  = &apos;~request_uri&apos;
        value = lv_value ).

    lv_value = &apos;application/x-git-&apos;
                  &amp;&amp; iv_service &amp;&amp; &apos;-pack-request&apos;.         &quot;#EC NOTEXT
    mi_client-&gt;request-&gt;set_header_field(
        name  = &apos;Content-Type&apos;
        value = lv_value ).                                 &quot;#EC NOTEXT

    lv_value = &apos;application/x-git-&apos;
                  &amp;&amp; iv_service &amp;&amp; &apos;-pack-result&apos;.          &quot;#EC NOTEXT
    mi_client-&gt;request-&gt;set_header_field(
        name  = &apos;Accept&apos;
        value = lv_value ).                                 &quot;#EC NOTEXT

    IF mo_digest IS BOUND.
      mo_digest-&gt;run( mi_client ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_FOLDER_LOGIC IMPLEMENTATION.
  METHOD get_instance.
    CREATE OBJECT ro_instance.
  ENDMETHOD.
  METHOD get_parent.
    DATA: ls_parent LIKE LINE OF mt_parent.

    &quot;Determine Parent Package
    READ TABLE mt_parent INTO ls_parent
      WITH TABLE KEY devclass = iv_package.
    IF sy-subrc &lt;&gt; 0.
      rv_parent = zcl_abapgit_factory=&gt;get_sap_package( iv_package )-&gt;read_parent( ).
      ls_parent-devclass = iv_package.
      ls_parent-parentcl = rv_parent.
      INSERT ls_parent INTO TABLE mt_parent.
    ELSE.
      rv_parent = ls_parent-parentcl.
    ENDIF.
  ENDMETHOD.
  METHOD package_to_path.

    DATA: lv_len          TYPE i,
          lv_path         TYPE string,
          lv_message      TYPE string,
          lv_parentcl     TYPE tdevc-parentcl,
          lv_folder_logic TYPE string.

    IF iv_top = iv_package.
      rv_path = io_dot-&gt;get_starting_folder( ).
    ELSE.
      lv_parentcl = get_parent( iv_package ).

      IF lv_parentcl IS INITIAL.
        zcx_abapgit_exception=&gt;raise( |error, expected parent package, { iv_package }| ).
      ELSE.
        lv_folder_logic = io_dot-&gt;get_folder_logic( ).
        CASE lv_folder_logic.
          WHEN zif_abapgit_dot_abapgit=&gt;c_folder_logic-full.
            lv_len = 0.
            IF iv_package(1) = &apos;$&apos;.
              lv_len = 1.
            ENDIF.
          WHEN zif_abapgit_dot_abapgit=&gt;c_folder_logic-prefix.
            lv_len = strlen( lv_parentcl ).

            IF iv_package(lv_len) &lt;&gt; lv_parentcl.
* if abapGit project is installed in package ZZZ, all subpackages should be named
* ZZZ_something. This will define the folder name in the zip file to be &quot;something&quot;,
* similarily with online projects. Alternatively change to FULL folder logic
              lv_message = &apos;PREFIX: Unexpected package naming (&apos; &amp;&amp; iv_package &amp;&amp; &apos;)&apos;
                           &amp;&amp; &apos;you might switch to FULL folder logic&apos; ##no_text.
              zcx_abapgit_exception=&gt;raise( lv_message ).
            ENDIF.
          WHEN OTHERS.
            zcx_abapgit_exception=&gt;raise( |Invalid folder logic: { lv_folder_logic }| ).
        ENDCASE.

        lv_path = iv_package+lv_len.
        IF strlen( lv_path ) = 0.
          zcx_abapgit_exception=&gt;raise( |Folder logic: length = 0, parent: {
            lv_parentcl }, child: { iv_package }| ).
        ENDIF.

        IF lv_path(1) = &apos;_&apos;.
          lv_path = lv_path+1.
        ENDIF.
        IF strlen( lv_path ) = 0.
          zcx_abapgit_exception=&gt;raise( |Folder logic: length = 0, parent: {
            lv_parentcl }, child: { iv_package }| ).
        ENDIF.

        TRANSLATE lv_path USING &apos;/#&apos;.
        TRANSLATE lv_path TO LOWER CASE.
        CONCATENATE lv_path &apos;/&apos; INTO lv_path.

        rv_path = package_to_path( iv_top     = iv_top
                                   io_dot     = io_dot
                                   iv_package = lv_parentcl ).

        CONCATENATE rv_path lv_path INTO rv_path.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD path_to_package.

    DATA: lv_length               TYPE i,
          lv_parent               TYPE devclass,
          lv_new                  TYPE string,
          lv_path                 TYPE string,
          lv_absolute_name        TYPE string,
          lv_top                  TYPE devclass,
          lt_unique_package_names TYPE HASHED TABLE OF devclass WITH UNIQUE KEY table_line.

    lv_top = iv_top.

    lv_length  = strlen( io_dot-&gt;get_starting_folder( ) ).
    IF lv_length &gt; strlen( iv_path ).
* treat as not existing locally
      RETURN.
    ENDIF.
    lv_path    = iv_path+lv_length.
    lv_parent  = lv_top.
    rv_package = lv_top.

    INSERT iv_top INTO TABLE lt_unique_package_names.

    WHILE lv_path CA &apos;/&apos;.
      SPLIT lv_path AT &apos;/&apos; INTO lv_new lv_path.

      CASE io_dot-&gt;get_folder_logic( ).
        WHEN zif_abapgit_dot_abapgit=&gt;c_folder_logic-full.
          lv_absolute_name = lv_new.
          TRANSLATE lv_absolute_name USING &apos;#/&apos;.
          IF iv_top(1) = &apos;$&apos;.
            CONCATENATE &apos;$&apos; lv_absolute_name INTO lv_absolute_name.
          ENDIF.
        WHEN zif_abapgit_dot_abapgit=&gt;c_folder_logic-prefix.
          CONCATENATE rv_package &apos;_&apos; lv_new INTO lv_absolute_name.
        WHEN OTHERS.
          ASSERT 0 = 1.
      ENDCASE.

      TRANSLATE lv_absolute_name TO UPPER CASE.

      IF strlen( lv_absolute_name ) &gt; 30.
        zcx_abapgit_exception=&gt;raise( |Package { lv_absolute_name } exceeds ABAP 30-characters-name limit| ).
      ENDIF.

      rv_package = lv_absolute_name.
      READ TABLE lt_unique_package_names TRANSPORTING NO FIELDS
        WITH TABLE KEY table_line = rv_package.
      IF sy-subrc = 0.
        zcx_abapgit_exception=&gt;raise( |Package { rv_package } has a subpackage with the same name| ).
      ELSE.
        INSERT rv_package INTO TABLE lt_unique_package_names.
      ENDIF.

      IF zcl_abapgit_factory=&gt;get_sap_package( rv_package )-&gt;exists( ) = abap_false AND
          iv_create_if_not_exists = abap_true.

        zcl_abapgit_factory=&gt;get_sap_package( lv_parent )-&gt;create_child( rv_package ).
      ENDIF.

      lv_parent = rv_package.
    ENDWHILE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_FILE_STATUS IMPLEMENTATION.
  METHOD build_existing.

    DATA: ls_file_sig LIKE LINE OF it_state.

    &quot; Item
    rs_result-obj_type = is_local-item-obj_type.
    rs_result-obj_name = is_local-item-obj_name.
    rs_result-package  = is_local-item-devclass.

    &quot; File
    rs_result-path     = is_local-file-path.
    rs_result-filename = is_local-file-filename.

    IF is_local-file-sha1 = is_remote-sha1.
      rs_result-match = abap_true.
      RETURN.
    ENDIF.

    &quot; Match against current state
    READ TABLE it_state INTO ls_file_sig
      WITH KEY path = is_local-file-path
      filename = is_local-file-filename
      BINARY SEARCH.

    IF sy-subrc = 0.
      IF ls_file_sig-sha1 &lt;&gt; is_local-file-sha1.
        rs_result-lstate = zif_abapgit_definitions=&gt;c_state-modified.
      ENDIF.
      IF ls_file_sig-sha1 &lt;&gt; is_remote-sha1.
        rs_result-rstate = zif_abapgit_definitions=&gt;c_state-modified.
      ENDIF.
      rs_result-match = boolc( rs_result-lstate IS INITIAL
        AND rs_result-rstate IS INITIAL ).
    ELSE.
      &quot; This is a strange situation. As both local and remote exist
      &quot; the state should also be present. Maybe this is a first run of the code.
      &quot; In this case just compare hashes directly and mark both changed
      &quot; the user will presumably decide what to do after checking the actual diff
      rs_result-match = boolc( is_local-file-sha1 = is_remote-sha1 ).
      IF rs_result-match = abap_false.
        rs_result-lstate = zif_abapgit_definitions=&gt;c_state-modified.
        rs_result-rstate = zif_abapgit_definitions=&gt;c_state-modified.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD build_new_local.

    &quot; Item
    rs_result-obj_type = is_local-item-obj_type.
    rs_result-obj_name = is_local-item-obj_name.
    rs_result-package  = is_local-item-devclass.

    &quot; File
    rs_result-path     = is_local-file-path.
    rs_result-filename = is_local-file-filename.

    &quot; Match
    rs_result-match    = abap_false.
    rs_result-lstate   = zif_abapgit_definitions=&gt;c_state-added.

  ENDMETHOD.
  METHOD build_new_remote.

    DATA: ls_item     LIKE LINE OF it_items,
          ls_file_sig LIKE LINE OF it_state.

    &quot; Common and default part
    rs_result-path     = is_remote-path.
    rs_result-filename = is_remote-filename.
    rs_result-match    = abap_false.
    rs_result-rstate   = zif_abapgit_definitions=&gt;c_state-added.

    identify_object( EXPORTING iv_filename = is_remote-filename
                               iv_path     = is_remote-path
                               iv_devclass = iv_devclass
                               io_dot      = io_dot
                     IMPORTING es_item     = ls_item ).

    &quot; Check if in item index + get package
    READ TABLE it_items INTO ls_item
      WITH KEY obj_type = ls_item-obj_type obj_name = ls_item-obj_name
      BINARY SEARCH.

    IF sy-subrc = 0.

      &quot; Completely new (xml, abap) and new file in an existing object
      rs_result-obj_type = ls_item-obj_type.
      rs_result-obj_name = ls_item-obj_name.
      rs_result-package  = ls_item-devclass.

      READ TABLE it_state INTO ls_file_sig
        WITH KEY path = is_remote-path filename = is_remote-filename
        BINARY SEARCH.

      &quot; Existing file but from another package
      &quot; was not added during local file proc as was not in tadir for repo package
      IF sy-subrc = 0.
        IF ls_file_sig-sha1 = is_remote-sha1.
          rs_result-match = abap_true.
          CLEAR rs_result-rstate.
        ELSE.
          rs_result-rstate = zif_abapgit_definitions=&gt;c_state-modified.
        ENDIF.

        &quot; Item is in state and in cache but with no package - it was deleted
        &quot; OR devclass is the same as repo package (see #532)
        IF ls_item-devclass IS INITIAL OR ls_item-devclass = iv_devclass.
          rs_result-match  = abap_false.
          rs_result-lstate = zif_abapgit_definitions=&gt;c_state-deleted.
        ENDIF.
      ENDIF.

    ELSE. &quot; Completely unknown file, probably non-abapgit
      ASSERT 1 = 1. &quot; No action, just follow defaults
    ENDIF.

  ENDMETHOD.
  METHOD calculate_status.

    DATA: lt_remote       LIKE it_remote,
          lt_items        TYPE zif_abapgit_definitions=&gt;ty_items_tt,
          ls_item         LIKE LINE OF lt_items,
          lv_is_xml       TYPE abap_bool,
          lv_sub_fetched  TYPE abap_bool,
          lt_sub_packages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
          lt_items_idx    TYPE zif_abapgit_definitions=&gt;ty_items_ts,
          lt_state_idx    TYPE zif_abapgit_definitions=&gt;ty_file_signatures_ts. &quot; Sorted by path+filename

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF it_remote,
                   &lt;ls_result&gt; LIKE LINE OF rt_results,
                   &lt;ls_local&gt;  LIKE LINE OF it_local.
    lt_state_idx = it_cur_state. &quot; Force sort it
    lt_remote    = it_remote.
    SORT lt_remote BY path filename.

    &quot; Process local files and new local files
    LOOP AT it_local ASSIGNING &lt;ls_local&gt;.
      APPEND INITIAL LINE TO rt_results ASSIGNING &lt;ls_result&gt;.
      IF &lt;ls_local&gt;-item IS NOT INITIAL.
        APPEND &lt;ls_local&gt;-item TO lt_items. &quot; Collect for item index
      ENDIF.

      READ TABLE lt_remote ASSIGNING &lt;ls_remote&gt;
        WITH KEY path = &lt;ls_local&gt;-file-path filename = &lt;ls_local&gt;-file-filename
        BINARY SEARCH.
      IF sy-subrc = 0.  &quot; Exist local and remote
        &lt;ls_result&gt; = build_existing(
          is_local  = &lt;ls_local&gt;
          is_remote = &lt;ls_remote&gt;
          it_state  = lt_state_idx ).
        ASSERT &lt;ls_remote&gt;-sha1 IS NOT INITIAL.
        CLEAR &lt;ls_remote&gt;-sha1. &quot; Mark as processed
      ELSE.             &quot; Only L exists
        &lt;ls_result&gt; = build_new_local( &lt;ls_local&gt; ).
      ENDIF.
      &lt;ls_result&gt;-inactive = &lt;ls_local&gt;-item-inactive.
    ENDLOOP.

    &quot; Complete item index for unmarked remote files
    LOOP AT lt_remote ASSIGNING &lt;ls_remote&gt; WHERE sha1 IS NOT INITIAL.
      identify_object( EXPORTING iv_filename = &lt;ls_remote&gt;-filename
                                 iv_path     = &lt;ls_remote&gt;-path
                                 io_dot      = io_dot
                                 iv_devclass = iv_devclass
                       IMPORTING es_item     = ls_item
                                 ev_is_xml   = lv_is_xml ).

      CHECK lv_is_xml = abap_true. &quot; Skip all but obj definitions

      ls_item-devclass = zcl_abapgit_factory=&gt;get_tadir( )-&gt;get_object_package(
        iv_object   = ls_item-obj_type
        iv_obj_name = ls_item-obj_name ).

      IF NOT ls_item-devclass IS INITIAL AND iv_devclass &lt;&gt; ls_item-devclass.
        IF lv_sub_fetched = abap_false.
          lt_sub_packages = zcl_abapgit_factory=&gt;get_sap_package( iv_devclass )-&gt;list_subpackages( ).
          lv_sub_fetched = abap_true.
          SORT lt_sub_packages BY table_line. &quot;Optimize Read Access
        ENDIF.
* make sure the package is under the repo main package
        READ TABLE lt_sub_packages TRANSPORTING NO FIELDS
          WITH KEY table_line = ls_item-devclass
          BINARY SEARCH.
        IF sy-subrc &lt;&gt; 0.
          CLEAR ls_item-devclass.
        ENDIF.
      ENDIF.

      APPEND ls_item TO lt_items.
    ENDLOOP.

    SORT lt_items DESCENDING. &quot; Default key - type, name, pkg, inactive
    DELETE ADJACENT DUPLICATES FROM lt_items COMPARING obj_type obj_name devclass.
    lt_items_idx = lt_items. &quot; Self protection + UNIQUE records assertion

    &quot; Process new remote files (marked above with empty SHA1)
    LOOP AT lt_remote ASSIGNING &lt;ls_remote&gt; WHERE sha1 IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_results ASSIGNING &lt;ls_result&gt;.
      &lt;ls_result&gt; = build_new_remote( iv_devclass = iv_devclass
                                      io_dot      = io_dot
                                      is_remote   = &lt;ls_remote&gt;
                                      it_items    = lt_items_idx
                                      it_state    = lt_state_idx ).
    ENDLOOP.

    SORT rt_results BY
      obj_type ASCENDING
      obj_name ASCENDING
      filename ASCENDING.

  ENDMETHOD.
  METHOD identify_object.

    DATA: lv_name TYPE tadir-obj_name,
          lv_type TYPE string,
          lv_ext  TYPE string.

    &quot; Guess object type and name
    SPLIT to_upper( iv_filename ) AT &apos;.&apos; INTO lv_name lv_type lv_ext.

    &quot; Handle namespaces
    REPLACE ALL OCCURRENCES OF &apos;#&apos; IN lv_name WITH &apos;/&apos;.
    REPLACE ALL OCCURRENCES OF &apos;#&apos; IN lv_type WITH &apos;/&apos;.
    REPLACE ALL OCCURRENCES OF &apos;#&apos; IN lv_ext WITH &apos;/&apos;.

    &quot; Try to get a unique package name for DEVC by using the path
    IF lv_type = &apos;DEVC&apos;.
      ASSERT lv_name = &apos;PACKAGE&apos;.
      lv_name = zcl_abapgit_folder_logic=&gt;get_instance( )-&gt;path_to_package(
        iv_top                  = iv_devclass
        io_dot                  = io_dot
        iv_create_if_not_exists = abap_false
        iv_path                 = iv_path ).
    ENDIF.

    CLEAR es_item.
    es_item-obj_type = lv_type.
    es_item-obj_name = lv_name.
    ev_is_xml        = boolc( lv_ext = &apos;XML&apos; AND strlen( lv_type ) = 4 ).

  ENDMETHOD.
  METHOD run_checks.

    DATA: lv_path     TYPE string,
          ls_item     TYPE zif_abapgit_definitions=&gt;ty_item,
          ls_file     TYPE zif_abapgit_definitions=&gt;ty_file_signature,
          lt_res_sort LIKE it_results,
          lt_item_idx LIKE it_results.
    DATA: lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic.

    FIELD-SYMBOLS: &lt;ls_res1&gt; LIKE LINE OF it_results,
                   &lt;ls_res2&gt; LIKE LINE OF it_results.
    IF io_log IS INITIAL.
      RETURN.
    ENDIF.

    &quot; Collect object indexe
    lt_res_sort = it_results.
    SORT lt_res_sort BY obj_type ASCENDING obj_name ASCENDING.

    LOOP AT it_results ASSIGNING &lt;ls_res1&gt; WHERE NOT obj_type IS INITIAL.
      IF NOT ( &lt;ls_res1&gt;-obj_type = ls_item-obj_type
          AND &lt;ls_res1&gt;-obj_name = ls_item-obj_name ).
        APPEND INITIAL LINE TO lt_item_idx ASSIGNING &lt;ls_res2&gt;.
        &lt;ls_res2&gt;-obj_type = &lt;ls_res1&gt;-obj_type.
        &lt;ls_res2&gt;-obj_name = &lt;ls_res1&gt;-obj_name.
        &lt;ls_res2&gt;-path     = &lt;ls_res1&gt;-path.
        MOVE-CORRESPONDING &lt;ls_res1&gt; TO ls_item.
      ENDIF.
    ENDLOOP.

    &quot; Check files for one object is in the same folder

    LOOP AT it_results ASSIGNING &lt;ls_res1&gt; WHERE NOT obj_type IS INITIAL AND obj_type &lt;&gt; &apos;DEVC&apos;.
      READ TABLE lt_item_idx ASSIGNING &lt;ls_res2&gt;
        WITH KEY obj_type = &lt;ls_res1&gt;-obj_type obj_name = &lt;ls_res1&gt;-obj_name
        BINARY SEARCH. &quot; Sorted above

      IF sy-subrc &lt;&gt; 0 OR &lt;ls_res1&gt;-path &lt;&gt; &lt;ls_res2&gt;-path. &quot; All paths are same
        io_log-&gt;add( iv_msg = |Files for object { &lt;ls_res1&gt;-obj_type } {
                       &lt;ls_res1&gt;-obj_name } are not placed in the same folder|
                     iv_type = &apos;W&apos;
                     iv_rc    = &apos;1&apos; ) ##no_text.
      ENDIF.
    ENDLOOP.

    &quot; Check that objects are created in package corresponding to folder
    lo_folder_logic = zcl_abapgit_folder_logic=&gt;get_instance( ).
    LOOP AT it_results ASSIGNING &lt;ls_res1&gt;
        WHERE NOT package IS INITIAL AND NOT path IS INITIAL.
      lv_path = lo_folder_logic-&gt;package_to_path(
        iv_top     = iv_top
        io_dot     = io_dot
        iv_package = &lt;ls_res1&gt;-package ).
      IF lv_path &lt;&gt; &lt;ls_res1&gt;-path.
        io_log-&gt;add( iv_msg = |Package and path does not match for object, {
                       &lt;ls_res1&gt;-obj_type } { &lt;ls_res1&gt;-obj_name }|
                     iv_type = &apos;W&apos;
                     iv_rc    = &apos;2&apos; ) ##no_text.
      ENDIF.
    ENDLOOP.

    &quot; Check for multiple files with same filename
    SORT lt_res_sort BY filename ASCENDING.

    LOOP AT lt_res_sort ASSIGNING &lt;ls_res1&gt; WHERE obj_type &lt;&gt; &apos;DEVC&apos;.
      IF &lt;ls_res1&gt;-filename IS NOT INITIAL AND &lt;ls_res1&gt;-filename = ls_file-filename.
        io_log-&gt;add( iv_msg  = |Multiple files with same filename, { &lt;ls_res1&gt;-filename }|
                     iv_type = &apos;W&apos;
                     iv_rc   = &apos;3&apos; ) ##no_text.
      ENDIF.

      IF &lt;ls_res1&gt;-filename IS INITIAL.
        io_log-&gt;add( iv_msg  = |Filename is empty for object { &lt;ls_res1&gt;-obj_type } { &lt;ls_res1&gt;-obj_name }|
                     iv_type = &apos;W&apos;
                     iv_rc   = &apos;4&apos; ) ##no_text.
      ENDIF.

      MOVE-CORRESPONDING &lt;ls_res1&gt; TO ls_file.
    ENDLOOP.

  ENDMETHOD.
  METHOD status.

    DATA: lv_index       LIKE sy-tabix,
          lo_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit.

    FIELD-SYMBOLS &lt;ls_result&gt; LIKE LINE OF rt_results.
    rt_results = calculate_status(
      iv_devclass  = io_repo-&gt;get_package( )
      io_dot       = io_repo-&gt;get_dot_abapgit( )
      it_local     = io_repo-&gt;get_files_local( io_log = io_log )
      it_remote    = io_repo-&gt;get_files_remote( )
      it_cur_state = io_repo-&gt;get_local_checksums_per_file( ) ).

    lo_dot_abapgit = io_repo-&gt;get_dot_abapgit( ).

    &quot; Remove ignored files, fix .abapgit
    LOOP AT rt_results ASSIGNING &lt;ls_result&gt;.
      lv_index = sy-tabix.

      IF lo_dot_abapgit-&gt;is_ignored(
          iv_path     = &lt;ls_result&gt;-path
          iv_filename = &lt;ls_result&gt;-filename ) = abap_true.
        DELETE rt_results INDEX lv_index.
        CONTINUE.
      ENDIF.
    ENDLOOP.

    run_checks(
      io_log     = io_log
      it_results = rt_results
      io_dot     = lo_dot_abapgit
      iv_top     = io_repo-&gt;get_package( ) ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_factory IMPLEMENTATION.
  METHOD get_branch_overview.

    CREATE OBJECT ri_branch_overview
      TYPE zcl_abapgit_branch_overview
      EXPORTING
        io_repo = io_repo.

  ENDMETHOD.
  METHOD get_code_inspector.

    DATA: ls_code_inspector LIKE LINE OF gt_code_inspector.
    FIELD-SYMBOLS: &lt;ls_code_inspector&gt; TYPE zcl_abapgit_factory=&gt;ty_code_inspector.

    READ TABLE gt_code_inspector ASSIGNING &lt;ls_code_inspector&gt;
                                 WITH TABLE KEY package            = iv_package
                                                check_variant_name = iv_check_variant_name.
    IF sy-subrc &lt;&gt; 0.
      ls_code_inspector-package = iv_package.
      ls_code_inspector-check_variant_name = iv_check_variant_name.

      CREATE OBJECT ls_code_inspector-instance TYPE zcl_abapgit_code_inspector
        EXPORTING
          iv_package            = iv_package
          iv_check_variant_name = iv_check_variant_name.

      INSERT ls_code_inspector
             INTO TABLE gt_code_inspector
             ASSIGNING &lt;ls_code_inspector&gt;.

    ENDIF.

    ri_code_inspector = &lt;ls_code_inspector&gt;-instance.

  ENDMETHOD.
  METHOD get_sap_package.

    DATA: ls_sap_package TYPE ty_sap_package.
    FIELD-SYMBOLS: &lt;ls_sap_package&gt; TYPE ty_sap_package.

    READ TABLE gt_sap_package ASSIGNING &lt;ls_sap_package&gt;
                              WITH TABLE KEY package = iv_package.
    IF sy-subrc &lt;&gt; 0.

      ls_sap_package-package = iv_package.
      CREATE OBJECT ls_sap_package-instance TYPE zcl_abapgit_sap_package
        EXPORTING
          iv_package = iv_package.

      INSERT ls_sap_package
             INTO TABLE gt_sap_package
             ASSIGNING &lt;ls_sap_package&gt;.

    ENDIF.

    ri_sap_package = &lt;ls_sap_package&gt;-instance.

  ENDMETHOD.
  METHOD get_stage_logic.

    IF gi_stage_logic IS INITIAL.
      CREATE OBJECT gi_stage_logic
        TYPE zcl_abapgit_stage_logic.
    ENDIF.

    ri_logic = gi_stage_logic.

  ENDMETHOD.
  METHOD get_syntax_check.

    DATA: ls_syntax_check LIKE LINE OF gt_syntax_check.
    FIELD-SYMBOLS: &lt;ls_syntax_check&gt; TYPE zcl_abapgit_factory=&gt;ty_syntax_check.

    READ TABLE gt_syntax_check ASSIGNING &lt;ls_syntax_check&gt;
                               WITH TABLE KEY package = iv_package.
    IF sy-subrc &lt;&gt; 0.
      ls_syntax_check-package =  iv_package.

      CREATE OBJECT ls_syntax_check-instance TYPE zcl_abapgit_syntax_check
        EXPORTING
          iv_package = iv_package.

      INSERT ls_syntax_check
             INTO TABLE gt_syntax_check
             ASSIGNING &lt;ls_syntax_check&gt;.

    ENDIF.

    ri_syntax_check = &lt;ls_syntax_check&gt;-instance.

  ENDMETHOD.
  METHOD get_tadir.

    IF gi_tadir IS INITIAL.
      CREATE OBJECT gi_tadir TYPE zcl_abapgit_tadir.
    ENDIF.

    ri_tadir = gi_tadir.

  ENDMETHOD.

  METHOD get_cts_api.
    IF gi_cts_api IS NOT BOUND.
      CREATE OBJECT gi_cts_api TYPE zcl_abapgit_cts_api.
    ENDIF.

    ri_cts_api = gi_cts_api.
  ENDMETHOD.

  METHOD get_adhoc_code_inspector.

    IF gi_adhoc_code_inspector IS BOUND.
      ri_adhoc_code_inspector = gi_adhoc_code_inspector.
    ELSE.
      CREATE OBJECT ri_adhoc_code_inspector
        TYPE zcl_abapgit_adhoc_code_insp
        EXPORTING
          iv_package   = iv_package
          iv_test_name = iv_test_name.
    ENDIF.

  ENDMETHOD.
  METHOD get_abap_unit_tests.

    IF gi_adhoc_code_inspector IS BOUND.
      ri_abap_unit_tests = gi_adhoc_code_inspector.
    ELSE.
      CREATE OBJECT ri_abap_unit_tests
        TYPE zcl_abapgit_abap_unit_tests
        EXPORTING
          iv_package = iv_package.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_EXIT IMPLEMENTATION.
  METHOD get_instance.

    IF gi_exit IS INITIAL.
      TRY.
          CREATE OBJECT gi_exit TYPE (&apos;ZCL_ABAPGIT_USER_EXIT&apos;).
        CATCH cx_sy_create_object_error.
      ENDTRY.
    ENDIF.

    CREATE OBJECT ri_exit TYPE zcl_abapgit_exit.

  ENDMETHOD.
  METHOD zif_abapgit_exit~allow_sap_objects.

    TRY.
        rv_allowed = gi_exit-&gt;allow_sap_objects( ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~change_local_host.

    TRY.
        gi_exit-&gt;change_local_host( CHANGING ct_hosts = ct_hosts ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~change_proxy_authentication.

    TRY.
        gi_exit-&gt;change_proxy_authentication(
          EXPORTING
            iv_repo_url            = iv_repo_url
          CHANGING
            cv_proxy_authentication = cv_proxy_authentication ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~change_proxy_port.

    TRY.
        gi_exit-&gt;change_proxy_port(
          EXPORTING
            iv_repo_url  = iv_repo_url
          CHANGING
            cv_proxy_port = cv_proxy_port ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~change_proxy_url.

    TRY.
        gi_exit-&gt;change_proxy_url(
          EXPORTING
            iv_repo_url = iv_repo_url
          CHANGING
            cv_proxy_url = cv_proxy_url ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~change_tadir.

    TRY.
        gi_exit-&gt;change_tadir(
          EXPORTING
            iv_package = iv_package
            io_log     = io_log
          CHANGING
            ct_tadir   = ct_tadir ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~create_http_client.

    TRY.
        ri_client = gi_exit-&gt;create_http_client( iv_url ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~get_ssl_id.

    TRY.
        rv_ssl_id = gi_exit-&gt;get_ssl_id( ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
        rv_ssl_id = &apos;ANONYM&apos;.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_exit~http_client.

    TRY.
        gi_exit-&gt;http_client( ii_client ).
      CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_dot_abapgit IMPLEMENTATION.
  METHOD add_ignore.

    DATA: lv_name TYPE string.

    FIELD-SYMBOLS: &lt;lv_ignore&gt; LIKE LINE OF ms_data-ignore.
    lv_name = iv_path &amp;&amp; iv_filename.

    READ TABLE ms_data-ignore FROM lv_name TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO ms_data-ignore ASSIGNING &lt;lv_ignore&gt;.
    &lt;lv_ignore&gt; = lv_name.

  ENDMETHOD.
  METHOD build_default.

    DATA: ls_data TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit.
    ls_data-master_language = sy-langu.
    ls_data-starting_folder = &apos;/src/&apos;.
    ls_data-folder_logic    = zif_abapgit_dot_abapgit=&gt;c_folder_logic-prefix.

    APPEND &apos;/.gitignore&apos; TO ls_data-ignore.
    APPEND &apos;/LICENSE&apos; TO ls_data-ignore.
    APPEND &apos;/README.md&apos; TO ls_data-ignore.
    APPEND &apos;/package.json&apos; TO ls_data-ignore.
    APPEND &apos;/.travis.yml&apos; TO ls_data-ignore.

    CREATE OBJECT ro_dot_abapgit
      EXPORTING
        is_data = ls_data.

  ENDMETHOD.
  METHOD constructor.
    ms_data = is_data.
  ENDMETHOD.
  METHOD deserialize.

    DATA: lv_xml  TYPE string,
          ls_data TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit.
    lv_xml = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_xstr ).

    ls_data = from_xml( lv_xml ).

    CREATE OBJECT ro_dot_abapgit
      EXPORTING
        is_data = ls_data.

  ENDMETHOD.
  METHOD from_xml.

    DATA: lv_xml TYPE string.

    lv_xml = iv_xml.

* fix downward compatibility
    REPLACE ALL OCCURRENCES OF &apos;&lt;_--28C_DATA_--29&gt;&apos; IN lv_xml WITH &apos;&lt;DATA&gt;&apos;.
    REPLACE ALL OCCURRENCES OF &apos;&lt;/_--28C_DATA_--29&gt;&apos; IN lv_xml WITH &apos;&lt;/DATA&gt;&apos;.

    CALL TRANSFORMATION id
      OPTIONS value_handling = &apos;accept_data_loss&apos;
      SOURCE XML lv_xml
      RESULT data = rs_data ##NO_TEXT.

* downward compatibility
    IF rs_data-folder_logic IS INITIAL.
      rs_data-folder_logic = zif_abapgit_dot_abapgit=&gt;c_folder_logic-prefix.
    ENDIF.

  ENDMETHOD.
  METHOD get_data.
    rs_data = ms_data.
  ENDMETHOD.
  METHOD get_folder_logic.
    rv_logic = ms_data-folder_logic.
  ENDMETHOD.
  METHOD get_master_language.
    rv_language = ms_data-master_language.
  ENDMETHOD.
  METHOD get_signature.

    rs_signature-path     = zif_abapgit_definitions=&gt;c_root_dir.
    rs_signature-filename = zif_abapgit_definitions=&gt;c_dot_abapgit.
    rs_signature-sha1     = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-blob
                                                    iv_data = serialize( ) ).

  ENDMETHOD.
  METHOD get_starting_folder.
    rv_path = ms_data-starting_folder.
  ENDMETHOD.
  METHOD is_ignored.

    DATA: lv_name     TYPE string,
          lv_starting TYPE string,
          lv_dot      TYPE string,
          lv_count    TYPE i,
          lv_ignore   TYPE string.
    lv_name = iv_path &amp;&amp; iv_filename.

    CONCATENATE ms_data-starting_folder &apos;*&apos; INTO lv_starting.
    CONCATENATE &apos;/&apos; zif_abapgit_definitions=&gt;c_dot_abapgit INTO lv_dot.

    LOOP AT ms_data-ignore INTO lv_ignore.
      FIND ALL OCCURRENCES OF &apos;/&apos; IN lv_name MATCH COUNT lv_count.

      IF lv_name CP lv_ignore
          OR ( ms_data-starting_folder &lt;&gt; &apos;/&apos;
          AND lv_count &gt; 1
          AND NOT lv_name CP lv_starting
          AND NOT lv_name = lv_dot ).
        rv_ignored = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD remove_ignore.

    DATA: lv_name TYPE string.
    lv_name = iv_path &amp;&amp; iv_filename.

    DELETE TABLE ms_data-ignore FROM lv_name.

  ENDMETHOD.
  METHOD serialize.

    DATA: lv_xml TYPE string.

    lv_xml = to_xml( ms_data ).

    rv_xstr = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_xml ).

  ENDMETHOD.
  METHOD set_folder_logic.
    ms_data-folder_logic = iv_logic.
  ENDMETHOD.
  METHOD set_starting_folder.
    ms_data-starting_folder = iv_path.
  ENDMETHOD.
  METHOD to_xml.

    CALL TRANSFORMATION id
      OPTIONS initial_components = &apos;suppress&apos;
      SOURCE data = is_data
      RESULT XML rv_xml.

    rv_xml = zcl_abapgit_xml_pretty=&gt;print( rv_xml ).

    REPLACE FIRST OCCURRENCE
      OF REGEX &apos;&lt;\?xml version=&quot;1\.0&quot; encoding=&quot;[\w-]+&quot;\?&gt;&apos;
      IN rv_xml
      WITH &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&apos;.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD get_requirements.
    rt_requirements = ms_data-requirements.
  ENDMETHOD.

  METHOD set_requirements.
    ms_data-requirements = it_requirements.
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_dependencies IMPLEMENTATION.
  METHOD get_ddls_dependencies.

    TYPES: BEGIN OF ty_ddls_name.
        INCLUDE TYPE ddsymtab.
    TYPES: END OF ty_ddls_name.

    TYPES: tty_ddls_names TYPE STANDARD TABLE OF ty_ddls_name
                               WITH NON-UNIQUE DEFAULT KEY.

    DATA: lt_ddls_name TYPE tty_ddls_names,
          ls_ddls_name LIKE LINE OF lt_ddls_name.

    ls_ddls_name-name = iv_ddls_name.
    INSERT ls_ddls_name INTO TABLE lt_ddls_name.

    PERFORM (&apos;DDLS_GET_DEP&apos;) IN PROGRAM (&apos;RADMASDL&apos;)
                             TABLES lt_ddls_name rt_dependency.

  ENDMETHOD.
  METHOD resolve.

    DATA: lv_tabclass    TYPE dd02l-tabclass.

    FIELD-SYMBOLS: &lt;ls_tadir&gt;            LIKE LINE OF ct_tadir.

* misuse field KORRNUM to fix deletion sequence

    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;.
      CASE &lt;ls_tadir&gt;-object.
        WHEN &apos;DEVC&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;9990&apos;.
        WHEN &apos;IATU&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;5500&apos;.
        WHEN &apos;IARP&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;5510&apos;.
        WHEN &apos;IASP&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;5520&apos;.
        WHEN &apos;SUSC&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;5000&apos;.
        WHEN &apos;TTYP&apos; OR &apos;TABL&apos; OR &apos;VIEW&apos;.
          SELECT SINGLE tabclass FROM dd02l
            INTO lv_tabclass
            WHERE tabname = &lt;ls_tadir&gt;-obj_name
            AND as4local = &apos;A&apos;
            AND as4vers = &apos;0000&apos;.
          IF sy-subrc = 0 AND lv_tabclass = &apos;APPEND&apos;.
* delete append structures before database tables
            &lt;ls_tadir&gt;-korrnum = &apos;6500&apos;.
          ELSE.
            &lt;ls_tadir&gt;-korrnum = &apos;7000&apos;.
          ENDIF.
        WHEN &apos;DTEL&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;8000&apos;.
        WHEN &apos;PARA&apos;.
* PARA after DTEL
          &lt;ls_tadir&gt;-korrnum = &apos;8100&apos;.
        WHEN &apos;DOMA&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;9000&apos;.
* AUTH after DCLS
        WHEN &apos;DCLS&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;7100&apos;.
        WHEN &apos;AUTH&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;7000&apos;.
        WHEN &apos;PROG&apos;.
* delete includes after main programs
          SELECT COUNT(*) FROM reposrc
            WHERE progname = &lt;ls_tadir&gt;-obj_name
            AND r3state = &apos;A&apos;
            AND subc = &apos;I&apos;.
          IF sy-subrc = 0.
            &lt;ls_tadir&gt;-korrnum = &apos;2000&apos;.
          ELSE.
            &lt;ls_tadir&gt;-korrnum = &apos;1000&apos;.
          ENDIF.
        WHEN &apos;IDOC&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;2000&apos;.
        WHEN &apos;IEXT&apos;.
          &lt;ls_tadir&gt;-korrnum = &apos;1500&apos;.
        WHEN OTHERS.
          &lt;ls_tadir&gt;-korrnum = &apos;1000&apos;.
      ENDCASE.
    ENDLOOP.

    resolve_ddic( CHANGING ct_tadir = ct_tadir ).
    resolve_packages( CHANGING ct_tadir = ct_tadir ).

    SORT ct_tadir BY korrnum ASCENDING.

  ENDMETHOD.
  METHOD resolve_ddic.
* this will make sure the deletion sequence of structures/tables work
* in case they have dependencies with .INCLUDE

    TYPES: BEGIN OF ty_edge,
             from TYPE ty_item,
             to   TYPE ty_item,
           END OF ty_edge.

    DATA: lt_nodes        TYPE TABLE OF ty_item,
          lt_edges        TYPE TABLE OF ty_edge,
          lt_findstrings  TYPE TABLE OF rsfind,
          lv_plus         TYPE i VALUE 1,
          lv_find_obj_cls TYPE euobj-id,
          lv_index        TYPE i,
          lv_before       TYPE i,
          lt_founds       TYPE TABLE OF rsfindlst,
          lt_scope        TYPE STANDARD TABLE OF seu_obj,
          lt_dependency   TYPE tty_dedenpency.

    FIELD-SYMBOLS: &lt;ls_tadir_ddls&gt;      TYPE zif_abapgit_definitions=&gt;ty_tadir,
                   &lt;ls_dependency&gt;      TYPE ty_dependency,
                   &lt;ls_tadir_dependent&gt; TYPE zif_abapgit_definitions=&gt;ty_tadir,
                   &lt;ls_tadir&gt;           LIKE LINE OF ct_tadir,
                   &lt;ls_edge&gt;            LIKE LINE OF lt_edges,
                   &lt;ls_found&gt;           LIKE LINE OF lt_founds,
                   &lt;ls_node&gt;            LIKE LINE OF lt_nodes.
* build nodes
    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;
        WHERE object = &apos;TABL&apos;
        OR object = &apos;TTYP&apos;.
      APPEND INITIAL LINE TO lt_nodes ASSIGNING &lt;ls_node&gt;.
      &lt;ls_node&gt;-obj_name = &lt;ls_tadir&gt;-obj_name.
      &lt;ls_node&gt;-obj_type = &lt;ls_tadir&gt;-object.
    ENDLOOP.

    APPEND &apos;TABL&apos; TO lt_scope.
    APPEND &apos;STRU&apos; TO lt_scope.
    APPEND &apos;TTYP&apos; TO lt_scope.

* build edges
    LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt;.

      CLEAR lt_findstrings.
      APPEND &lt;ls_node&gt;-obj_name TO lt_findstrings.
      lv_find_obj_cls = &lt;ls_node&gt;-obj_type.

      CALL FUNCTION &apos;RS_EU_CROSSREF&apos;
        EXPORTING
          i_find_obj_cls           = lv_find_obj_cls
        TABLES
          i_findstrings            = lt_findstrings
          o_founds                 = lt_founds
          i_scope_object_cls       = lt_scope
        EXCEPTIONS
          not_executed             = 1
          not_found                = 2
          illegal_object           = 3
          no_cross_for_this_object = 4
          batch                    = 5
          batchjob_error           = 6
          wrong_type               = 7
          object_not_exist         = 8
          OTHERS                   = 9.
      IF sy-subrc &lt;&gt; 0.
        CONTINUE.
      ENDIF.

      LOOP AT lt_founds ASSIGNING &lt;ls_found&gt;.
        APPEND INITIAL LINE TO lt_edges ASSIGNING &lt;ls_edge&gt;.
        &lt;ls_edge&gt;-from = &lt;ls_node&gt;.

        &lt;ls_edge&gt;-to-obj_name   = &lt;ls_found&gt;-object.
        CASE &lt;ls_found&gt;-object_cls.
          WHEN &apos;DS&apos;
              OR &apos;DT&apos;.
            &lt;ls_edge&gt;-to-obj_type = &apos;TABL&apos;.
          WHEN &apos;DA&apos;.
            &lt;ls_edge&gt;-to-obj_type = &apos;TTYP&apos;.
          WHEN OTHERS.
            zcx_abapgit_exception=&gt;raise( &apos;resolve_ddic, unknown object_cls&apos; ).
        ENDCASE.
      ENDLOOP.

    ENDLOOP.

* build DDLS edges
    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir_ddls&gt;
                     WHERE object = &apos;DDLS&apos;.

      CLEAR: lt_dependency.

      APPEND INITIAL LINE TO lt_nodes ASSIGNING &lt;ls_node&gt;.
      &lt;ls_node&gt;-obj_name = &lt;ls_tadir_ddls&gt;-obj_name.
      &lt;ls_node&gt;-obj_type = &lt;ls_tadir_ddls&gt;-object.

      lt_dependency = get_ddls_dependencies( &lt;ls_tadir_ddls&gt;-obj_name ).

      LOOP AT lt_dependency ASSIGNING &lt;ls_dependency&gt;
                            WHERE deptyp = &apos;DDLS&apos;
                            AND   refname = &lt;ls_tadir_ddls&gt;-obj_name.

        READ TABLE ct_tadir ASSIGNING &lt;ls_tadir_dependent&gt;
                            WITH KEY pgmid    = &apos;R3TR&apos;
                                     object   = &apos;DDLS&apos;
                                     obj_name = &lt;ls_dependency&gt;-depname
                            BINARY SEARCH.
        CHECK sy-subrc = 0.

        APPEND INITIAL LINE TO lt_edges ASSIGNING &lt;ls_edge&gt;.
        &lt;ls_edge&gt;-from = &lt;ls_node&gt;.
        &lt;ls_edge&gt;-to-obj_name = &lt;ls_dependency&gt;-depname.
        &lt;ls_edge&gt;-to-obj_type = &apos;DDLS&apos;.

      ENDLOOP.

    ENDLOOP.

    DO.
      lv_before = lines( lt_nodes ).
      LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt;.
        lv_index = sy-tabix.
        READ TABLE lt_edges WITH KEY
          from-obj_name = &lt;ls_node&gt;-obj_name
          from-obj_type = &lt;ls_node&gt;-obj_type
          TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;
              WHERE obj_name = &lt;ls_node&gt;-obj_name
              AND object = &lt;ls_node&gt;-obj_type.
            &lt;ls_tadir&gt;-korrnum = &lt;ls_tadir&gt;-korrnum + lv_plus.
            CONDENSE &lt;ls_tadir&gt;-korrnum.
          ENDLOOP.
          DELETE lt_edges
            WHERE to-obj_name = &lt;ls_node&gt;-obj_name
            AND to-obj_type = &lt;ls_node&gt;-obj_type.
          DELETE lt_nodes INDEX lv_index.
          EXIT. &quot; make sure the sequence is fixed
        ENDIF.
      ENDLOOP.
      IF lv_before = lines( lt_nodes ).
        EXIT.
      ENDIF.
      lv_plus = lv_plus + 1.
    ENDDO.

  ENDMETHOD.
  METHOD resolve_packages.

    DATA: lt_subpackages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt.

    FIELD-SYMBOLS: &lt;ls_tadir&gt;            LIKE LINE OF ct_tadir,
                   &lt;lv_subpackage&gt;       LIKE LINE OF lt_subpackages,
                   &lt;ls_tadir_subpackage&gt; LIKE LINE OF ct_tadir.

    &quot; List subpackage before corresponding superpackage

    LOOP AT ct_tadir ASSIGNING &lt;ls_tadir&gt;
                     WHERE object = &apos;DEVC&apos;.

      lt_subpackages = zcl_abapgit_factory=&gt;get_sap_package( |{ &lt;ls_tadir&gt;-obj_name }| )-&gt;list_subpackages( ).

      LOOP AT lt_subpackages ASSIGNING &lt;lv_subpackage&gt;.

        READ TABLE ct_tadir ASSIGNING &lt;ls_tadir_subpackage&gt;
                            WITH KEY object   = &apos;DEVC&apos;
                                     obj_name = &lt;lv_subpackage&gt;.
        IF sy-subrc = 0.
          &lt;ls_tadir_subpackage&gt;-korrnum = condense( |{ &lt;ls_tadir_subpackage&gt;-korrnum - 1 }| ).
        ENDIF.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_DEFAULT_TRANSPORT IMPLEMENTATION.
  METHOD clear.

    CALL FUNCTION &apos;TR_TASK_RESET&apos;
      EXPORTING
        iv_username      = is_default_task-username
        iv_order         = is_default_task-ordernum
        iv_task          = is_default_task-tasknum
        iv_dialog        = abap_false
      EXCEPTIONS
        invalid_username = 1
        invalid_order    = 2
        invalid_task     = 3
        OTHERS           = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from TR_TASK_RESET { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    store( ).

  ENDMETHOD.
  METHOD get.

    DATA: lt_e070use TYPE STANDARD TABLE OF e070use.

    CALL FUNCTION &apos;TR_TASK_GET&apos;
      TABLES
        tt_e070use       = lt_e070use
      EXCEPTIONS
        invalid_username = 1
        invalid_category = 2
        invalid_client   = 3
        OTHERS           = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from TR_TASK_GET { sy-subrc }| ).
    ENDIF.

    READ TABLE lt_e070use INTO rs_default_task
                          INDEX 1.

  ENDMETHOD.
  METHOD get_instance.

    IF go_instance IS NOT BOUND.
      CREATE OBJECT go_instance.
    ENDIF.

    ro_instance = go_instance.

  ENDMETHOD.
  METHOD reset.

    DATA: ls_default_task TYPE e070use.

    IF mv_is_set_by_abapgit = abap_false.
      &quot; if the default transport request task isn&apos;t set
      &quot; by us there is nothing to do.
      RETURN.
    ENDIF.

    CLEAR mv_is_set_by_abapgit.

    ls_default_task = get( ).

    IF ls_default_task IS NOT INITIAL.

      clear( ls_default_task ).

    ENDIF.

    restore( ).

  ENDMETHOD.
  METHOD restore.

    IF ms_save IS INITIAL.
      &quot; There wasn&apos;t a default transport request before
      &quot; so we needn&apos;t restore anything.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;TR_TASK_SET&apos;
      EXPORTING
        iv_order          = ms_save-ordernum
        iv_task           = ms_save-tasknum
      EXCEPTIONS
        invalid_username  = 1
        invalid_category  = 2
        invalid_client    = 3
        invalid_validdays = 4
        invalid_order     = 5
        invalid_task      = 6
        OTHERS            = 7.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from TR_TASK_SET { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD set.

    &quot; checks whether object changes of the package are rerorded in transport
    &quot; requests. If true then we set the default task, so that no annoying
    &quot; transport request popups are shown while deserializing.

    IF mv_is_set_by_abapgit = abap_true.
      &quot; the default transport request task is already set by us
      &quot; -&gt; no reason to do it again.
      RETURN.
    ENDIF.

    IF iv_transport IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |No transport request was supplied| ).
    ENDIF.

    set_internal( iv_transport ).

    mv_is_set_by_abapgit = abap_true.

  ENDMETHOD.
  METHOD set_internal.

    CALL FUNCTION &apos;TR_TASK_SET&apos;
      EXPORTING
        iv_order          = iv_transport
*       iv_task           = iv_task
      EXCEPTIONS
        invalid_username  = 1
        invalid_category  = 2
        invalid_client    = 3
        invalid_validdays = 4
        invalid_order     = 5
        invalid_task      = 6
        OTHERS            = 7.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from TR_TASK_SET { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD store.

    ms_save = get( ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_cts_api IMPLEMENTATION.
  METHOD zif_abapgit_cts_api~get_current_transport_for_obj.
    DATA: lv_object_lockable   TYPE abap_bool,
          lv_locked            TYPE abap_bool,
          lv_transport_request TYPE trkorr,
          lv_task              TYPE trkorr,
          lv_tr_object_name    TYPE trobj_name.

    lv_tr_object_name = iv_object_name.

    CALL FUNCTION &apos;TR_CHECK_OBJECT_LOCK&apos;
      EXPORTING
        wi_pgmid             = iv_program_id
        wi_object            = iv_object_type
        wi_objname           = lv_tr_object_name
      IMPORTING
        we_lockable_object   = lv_object_lockable
        we_locked            = lv_locked
        we_lock_order        = lv_transport_request
        we_lock_task         = lv_task
      EXCEPTIONS
        empty_key            = 1
        no_systemname        = 2
        no_systemtype        = 3
        unallowed_lock_order = 4
        OTHERS               = 5.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    IF lv_locked = abap_false.
      zcx_abapgit_exception=&gt;raise( |Object { iv_program_id }-{ iv_object_type }-{ iv_object_name } is not locked| ).
    ENDIF.

    IF lv_object_lockable = abap_false.
      zcx_abapgit_exception=&gt;raise( |Object type { iv_program_id }-{ iv_object_type } not lockable| ).
    ENDIF.

    IF lv_task IS NOT INITIAL AND lv_task &lt;&gt; lv_transport_request AND iv_resolve_task_to_request = abap_false.
      rv_transport = lv_task.
    ELSE.
      rv_transport = lv_transport_request.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~is_object_locked_in_transport.
    DATA: ls_object_key        TYPE e071,
          lv_type_check_result TYPE c LENGTH 1,
          ls_lock_key          TYPE tlock_int,
          lv_lock_flag         TYPE c LENGTH 1.

    ls_object_key-pgmid = iv_program_id.
    ls_object_key-object = iv_object_type.
    ls_object_key-obj_name = iv_object_name.

    CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
      EXPORTING
        wi_e071     = ls_object_key
      IMPORTING
        pe_result   = lv_type_check_result
        we_lock_key = ls_lock_key.

    IF lv_type_check_result &lt;&gt; &apos;L&apos;.
      zcx_abapgit_exception=&gt;raise( |Object type { iv_program_id }-{ iv_object_type } not lockable| ).
    ENDIF.

    CALL FUNCTION &apos;TRINT_CHECK_LOCKS&apos;
      EXPORTING
        wi_lock_key = ls_lock_key
      IMPORTING
        we_lockflag = lv_lock_flag
      EXCEPTIONS
        empty_key   = 1
        OTHERS      = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |TRINT_CHECK_LOCKS: { sy-subrc }| ).
    ENDIF.

    rv_locked = boolc( lv_lock_flag &lt;&gt; space ).
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~is_object_type_lockable.
    DATA: ls_object_key        TYPE e071,
          lv_type_check_result TYPE c LENGTH 1.

    ls_object_key-pgmid = iv_program_id.
    ls_object_key-object = iv_object_type.
    ls_object_key-obj_name = &apos;_&apos;. &quot; Dummy value #2071

    CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
      EXPORTING
        wi_e071   = ls_object_key
      IMPORTING
        pe_result = lv_type_check_result.

    rv_lockable = boolc( lv_type_check_result = &apos;L&apos; ).
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~is_chrec_possible_for_package.
    rv_possible = zcl_abapgit_factory=&gt;get_sap_package( iv_package )-&gt;are_changes_recorded_in_tr_req( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_code_inspector IMPLEMENTATION.
  METHOD cleanup.

    IF mo_inspection IS BOUND.

      mo_inspection-&gt;delete(
        EXCEPTIONS
          locked              = 1
          error_in_enqueue    = 2
          not_authorized      = 3
          exceptn_appl_exists = 4
          OTHERS              = 5 ).

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Couldn&apos;t delete inspection. Subrc = { sy-subrc }| ).
      ENDIF.

    ENDIF.

    io_set-&gt;delete(
      EXCEPTIONS
        exists_in_insp   = 1
        locked           = 2
        error_in_enqueue = 3
        not_authorized   = 4
        exists_in_objs   = 5
        OTHERS           = 6 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Couldn&apos;t delete objectset. Subrc = { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    mv_package = iv_package.
    mv_check_variant_name = iv_check_variant_name.

    &quot; We create the inspection and objectset with dummy names.
    &quot; Because we want to persist them so we can run it in parallel.
    &quot; Both are deleted afterwards.
    mv_inspection_name = mv_objectset_name = |{ sy-uname }_{ sy-datum }_{ sy-uzeit }|.

    &quot; We have to disable parallelization in batch because of lock errors.
    IF sy-batch = abap_true.
      mv_run_mode = co_run_mode-run_via_rfc.
    ELSE.
      mv_run_mode = co_run_mode-run_loc_parallel.
    ENDIF.

  ENDMETHOD.
  METHOD create_inspection.

    cl_ci_inspection=&gt;create(
      EXPORTING
        p_user           = sy-uname
        p_name           = mv_inspection_name
      RECEIVING
        p_ref            = ro_inspection
      EXCEPTIONS
        locked           = 1
        error_in_enqueue = 2
        not_authorized   = 3
        OTHERS           = 4 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Failed to create inspection. Subrc = { sy-subrc }| ).
    ENDIF.

    ro_inspection-&gt;set(
      p_chkv = io_variant
      p_objs = io_set ).

    ro_inspection-&gt;save(
      EXCEPTIONS
        missing_information = 1
        insp_no_name        = 2
        not_enqueued        = 3
        OTHERS              = 4 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Failed to save inspection. Subrc = { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD create_objectset.

    DATA: lt_objs     TYPE scit_objs,
          lt_packages TYPE ty_tdevc_tt.
    lt_packages = find_all_subpackages( mv_package ).
    IF lines( lt_packages ) = 0.
      RETURN.
    ENDIF.

    SELECT object AS objtype obj_name AS objname
      FROM tadir
      INTO CORRESPONDING FIELDS OF TABLE lt_objs
      FOR ALL ENTRIES IN lt_packages
      WHERE devclass = lt_packages-devclass
      AND delflag = abap_false
      AND pgmid = &apos;R3TR&apos;.                               &quot;#EC CI_GENBUFF

    ro_set = cl_ci_objectset=&gt;save_from_list( p_name    = mv_objectset_name
                                              p_objects = lt_objs ).

  ENDMETHOD.
  METHOD create_variant.

    IF mv_check_variant_name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |No check variant supplied.| ).
    ENDIF.

    cl_ci_checkvariant=&gt;get_ref(
      EXPORTING
        p_user                   = &apos;&apos;
        p_name                   = mv_check_variant_name
      RECEIVING
        p_ref                    = ro_variant
      EXCEPTIONS
        chkv_not_exists          = 1
        missing_parameter        = 2
        OTHERS                   = 3 ).

    CASE sy-subrc.
      WHEN 1.
        zcx_abapgit_exception=&gt;raise( |Check variant { mv_check_variant_name } doesn&apos;t exist| ).
      WHEN 2.
        zcx_abapgit_exception=&gt;raise( |Parameter missing for check variant { mv_check_variant_name }| ).
    ENDCASE.

  ENDMETHOD.
  METHOD find_all_subpackages.

* TODO, in the future, move this method to the ABAPGIT global package class

    DATA: ls_package LIKE LINE OF rt_packages,
          lt_found   LIKE rt_packages,
          lt_sub     LIKE rt_packages.
    SELECT SINGLE * FROM tdevc INTO ls_package WHERE devclass = iv_package.
    ASSERT sy-subrc = 0.
    APPEND ls_package TO rt_packages.

    SELECT * FROM tdevc APPENDING TABLE lt_sub
      WHERE parentcl = ls_package-devclass.

    LOOP AT lt_sub INTO ls_package.
      lt_found = find_all_subpackages( ls_package-devclass ).
      APPEND LINES OF lt_found TO rt_packages.
    ENDLOOP.

  ENDMETHOD.
  METHOD run_inspection.

    io_inspection-&gt;run(
      EXPORTING
        p_howtorun            = mv_run_mode
      EXCEPTIONS
        invalid_check_version = 1
        OTHERS                = 2 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Code inspector run failed. Subrc = { sy-subrc }| ).
    ENDIF.

    io_inspection-&gt;plain_list(
      IMPORTING
        p_list = rt_list ).

  ENDMETHOD.
  METHOD validate_check_variant.

    cl_ci_checkvariant=&gt;get_ref(
      EXPORTING
        p_user                   = &apos;&apos;
        p_name                   = iv_check_variant_name
      EXCEPTIONS
        chkv_not_exists          = 1
        missing_parameter        = 2
        OTHERS                   = 3 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |No valid check variant { iv_check_variant_name  }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~get_inspection.
    ro_inspection = mo_inspection.
  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~run.

    DATA: lo_set     TYPE REF TO cl_ci_objectset,
          lo_variant TYPE REF TO cl_ci_checkvariant,
          lx_error   TYPE REF TO zcx_abapgit_exception.

    TRY.
        lo_set = create_objectset( ).

        IF lines( lo_set-&gt;iobjlst-objects ) = 0.
          &quot; no objects, nothing to check
          RETURN.
        ENDIF.

        lo_variant = create_variant( ).

        mo_inspection = create_inspection(
          io_set     = lo_set
          io_variant = lo_variant ).

        rt_list = run_inspection( mo_inspection ).

        cleanup( lo_set ).

      CATCH zcx_abapgit_exception INTO lx_error.

        &quot; ensure cleanup
        cleanup( lo_set ).
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).

    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_BRANCH_OVERVIEW IMPLEMENTATION.
  METHOD constructor.

    DATA: lt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt.

    lt_objects = get_git_objects( io_repo ).

    mt_commits = parse_commits( lt_objects ).
    _sort_commits( CHANGING ct_commits = mt_commits ).

    parse_annotated_tags( lt_objects ).

    CLEAR lt_objects.

    determine_branch( ).
    determine_merges( ).
    determine_tags( ).
    fixes( ).

  ENDMETHOD.
  METHOD determine_branch.

    CONSTANTS: lc_head TYPE string VALUE &apos;HEAD&apos;.

    DATA: lv_name TYPE string.

    FIELD-SYMBOLS: &lt;ls_branch&gt; LIKE LINE OF mt_branches,
                   &lt;ls_head&gt;   LIKE LINE OF mt_branches,
                   &lt;ls_commit&gt; LIKE LINE OF mt_commits,
                   &lt;ls_create&gt; LIKE LINE OF &lt;ls_commit&gt;-create.
* exchange HEAD, and make sure the branch determination starts with the HEAD branch
    READ TABLE mt_branches ASSIGNING &lt;ls_head&gt; WITH KEY name = lc_head.
    ASSERT sy-subrc = 0.
    LOOP AT mt_branches ASSIGNING &lt;ls_branch&gt;
        WHERE sha1 = &lt;ls_head&gt;-sha1 AND name &lt;&gt; lc_head.
      &lt;ls_head&gt;-name = &lt;ls_branch&gt;-name.
      DELETE mt_branches INDEX sy-tabix.
      EXIT.
    ENDLOOP.

    LOOP AT mt_branches ASSIGNING &lt;ls_branch&gt;.
      lv_name = &lt;ls_branch&gt;-name+11.
      READ TABLE mt_commits ASSIGNING &lt;ls_commit&gt; WITH KEY sha1 = &lt;ls_branch&gt;-sha1.
      ASSERT sy-subrc = 0.

      DO.
        IF &lt;ls_commit&gt;-branch IS INITIAL.
          &lt;ls_commit&gt;-branch = lv_name.
        ELSE.
          APPEND INITIAL LINE TO &lt;ls_commit&gt;-create ASSIGNING &lt;ls_create&gt;.
          &lt;ls_create&gt;-name = lv_name.
          &lt;ls_create&gt;-parent = &lt;ls_commit&gt;-branch.
          EXIT.
        ENDIF.

        IF &lt;ls_commit&gt;-parent1 IS INITIAL.
          EXIT.
        ELSE.
          READ TABLE mt_commits ASSIGNING &lt;ls_commit&gt;
              WITH KEY sha1 = &lt;ls_commit&gt;-parent1.
          ASSERT sy-subrc = 0.
        ENDIF.
      ENDDO.

    ENDLOOP.

  ENDMETHOD.
  METHOD determine_merges.

    DATA: BEGIN OF ls_deleted_branch_info,
            created TYPE flag,
            index   TYPE string,
            name    TYPE string,
          END OF ls_deleted_branch_info.

    FIELD-SYMBOLS: &lt;ls_merged_branch_commit&gt; TYPE zif_abapgit_definitions=&gt;ty_commit,
                   &lt;ls_merged_branch_parent&gt; TYPE zif_abapgit_definitions=&gt;ty_commit,
                   &lt;ls_commit&gt;               TYPE zif_abapgit_definitions=&gt;ty_commit,
                   &lt;ls_create&gt;               TYPE zif_abapgit_definitions=&gt;ty_create.

* we need latest first here: latest -&gt; initial
    _reverse_sort_order( CHANGING ct_commits = mt_commits ).

    LOOP AT mt_commits ASSIGNING &lt;ls_commit&gt; WHERE NOT parent2 IS INITIAL.
      ASSERT NOT &lt;ls_commit&gt;-branch IS INITIAL.

      READ TABLE mt_commits ASSIGNING &lt;ls_merged_branch_commit&gt; WITH KEY sha1 = &lt;ls_commit&gt;-parent2.
      IF sy-subrc = 0.
        &lt;ls_commit&gt;-merge = &lt;ls_merged_branch_commit&gt;-branch.

* orphaned, branch has been deleted after merge
        ls_deleted_branch_info-created = abap_false.

        WHILE &lt;ls_merged_branch_commit&gt;-branch IS INITIAL.
          IF ls_deleted_branch_info-created = abap_false.

            ls_deleted_branch_info-created = abap_true.
            ls_deleted_branch_info-index = ls_deleted_branch_info-index + 1.
            ls_deleted_branch_info-name = c_deleted_branch_name_prefix &amp;&amp; ls_deleted_branch_info-index &amp;&amp; &apos;__&apos;.
            CONDENSE ls_deleted_branch_info-name NO-GAPS.

            &lt;ls_commit&gt;-merge = ls_deleted_branch_info-name.

          ENDIF.
          &lt;ls_merged_branch_commit&gt;-branch = ls_deleted_branch_info-name.

          READ TABLE mt_commits ASSIGNING &lt;ls_merged_branch_parent&gt;
                                WITH KEY sha1 = &lt;ls_merged_branch_commit&gt;-parent1.
          IF sy-subrc &lt;&gt; 0.
            EXIT.
          ELSE.
            ASSIGN &lt;ls_merged_branch_parent&gt; TO &lt;ls_merged_branch_commit&gt;.
          ENDIF.
        ENDWHILE.

        IF &lt;ls_merged_branch_parent&gt; IS ASSIGNED.
          APPEND INITIAL LINE TO &lt;ls_merged_branch_parent&gt;-create ASSIGNING &lt;ls_create&gt;.
          &lt;ls_create&gt;-name = ls_deleted_branch_info-name.
          &lt;ls_create&gt;-parent = &lt;ls_commit&gt;-branch.
        ENDIF.

      ENDIF.
    ENDLOOP.

    &quot; switch back to initial -&gt; latest
    _reverse_sort_order( CHANGING ct_commits = mt_commits ).

  ENDMETHOD.
  METHOD determine_tags.

    DATA: lv_tag TYPE LINE OF zif_abapgit_definitions=&gt;ty_commit-tags.

    FIELD-SYMBOLS: &lt;ls_tag&gt;    LIKE LINE OF mt_tags,
                   &lt;ls_commit&gt; LIKE LINE OF mt_commits.

    LOOP AT mt_tags ASSIGNING &lt;ls_tag&gt;.

      IF &lt;ls_tag&gt;-type = zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag.
        READ TABLE mt_commits WITH KEY sha1 = &lt;ls_tag&gt;-sha1
                              ASSIGNING &lt;ls_commit&gt;.      &quot;#EC CI_SUBRC
      ELSEIF &lt;ls_tag&gt;-type = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.
        READ TABLE mt_commits WITH KEY sha1 = &lt;ls_tag&gt;-object
                              ASSIGNING &lt;ls_commit&gt;.
      ENDIF.

      CHECK sy-subrc = 0.

      lv_tag = zcl_abapgit_tag=&gt;remove_tag_prefix( &lt;ls_tag&gt;-name ).
      INSERT lv_tag INTO TABLE &lt;ls_commit&gt;-tags.

    ENDLOOP.

  ENDMETHOD.
  METHOD fixes.

    FIELD-SYMBOLS: &lt;ls_commit&gt; LIKE LINE OF mt_commits.
    LOOP AT mt_commits ASSIGNING &lt;ls_commit&gt; WHERE NOT merge IS INITIAL.
* commits from old branches
      IF &lt;ls_commit&gt;-branch = &lt;ls_commit&gt;-merge.
        CLEAR &lt;ls_commit&gt;-merge.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_git_objects.

    DATA: lo_branch_list       TYPE REF TO zcl_abapgit_git_branch_list,
          lo_progress          TYPE REF TO zcl_abapgit_progress,
          lt_branches_and_tags TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt,
          lt_tags              TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt,
          ls_tag               LIKE LINE OF mt_tags.

    FIELD-SYMBOLS: &lt;ls_branch&gt; LIKE LINE OF lt_tags.
    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = 1.

    lo_progress-&gt;show(
      iv_current = 1
      iv_text    = |Get git objects { io_repo-&gt;get_name( ) }| ) ##NO_TEXT.

* get objects directly from git, mo_repo only contains a shallow clone of only
* the selected branch

    &quot;TODO refactor

    lo_branch_list = zcl_abapgit_git_transport=&gt;branches( io_repo-&gt;get_url( ) ).

    mt_branches = lo_branch_list-&gt;get_branches_only( ).
    INSERT LINES OF mt_branches INTO TABLE lt_branches_and_tags.

    lt_tags = lo_branch_list-&gt;get_tags_only( ).
    INSERT LINES OF lt_tags INTO TABLE lt_branches_and_tags.

    LOOP AT lt_tags ASSIGNING &lt;ls_branch&gt;.

      IF &lt;ls_branch&gt;-name CP &apos;*^{}&apos;.
        CONTINUE.
      ENDIF.

      MOVE-CORRESPONDING &lt;ls_branch&gt; TO ls_tag.
      INSERT ls_tag INTO TABLE mt_tags.
    ENDLOOP.

    zcl_abapgit_git_transport=&gt;upload_pack(
      EXPORTING
        iv_url         = io_repo-&gt;get_url( )
        iv_branch_name = io_repo-&gt;get_branch_name( )
        iv_deepen      = abap_false
        it_branches    = lt_branches_and_tags
      IMPORTING
        et_objects     = rt_objects ).

    DELETE rt_objects WHERE type = zif_abapgit_definitions=&gt;c_type-blob.
  ENDMETHOD.
  METHOD parse_annotated_tags.

    DATA: ls_raw TYPE zcl_abapgit_git_pack=&gt;ty_tag.

    FIELD-SYMBOLS: &lt;ls_object&gt; LIKE LINE OF it_objects,
                   &lt;ls_tag&gt;    LIKE LINE OF mt_tags.

    LOOP AT it_objects ASSIGNING &lt;ls_object&gt; USING KEY type
        WHERE type = zif_abapgit_definitions=&gt;c_type-tag.

      ls_raw = zcl_abapgit_git_pack=&gt;decode_tag( &lt;ls_object&gt;-data ).

      READ TABLE mt_tags ASSIGNING &lt;ls_tag&gt;
                         WITH KEY sha1 = &lt;ls_object&gt;-sha1.
      ASSERT sy-subrc = 0.

      &lt;ls_tag&gt;-name         = |refs/tags/{ ls_raw-tag }|.
      &lt;ls_tag&gt;-sha1         = &lt;ls_object&gt;-sha1.
      &lt;ls_tag&gt;-object       = ls_raw-object.
      &lt;ls_tag&gt;-type         = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.
      &lt;ls_tag&gt;-display_name = ls_raw-tag.
      &lt;ls_tag&gt;-tagger_name  = ls_raw-tagger_name.
      &lt;ls_tag&gt;-tagger_email = ls_raw-tagger_email.
      &lt;ls_tag&gt;-message      = ls_raw-message.
      &lt;ls_tag&gt;-body         = ls_raw-body.

    ENDLOOP.

  ENDMETHOD.
  METHOD parse_commits.

    DATA: ls_commit LIKE LINE OF mt_commits,
          lt_body   TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
          ls_raw    TYPE zcl_abapgit_git_pack=&gt;ty_commit.

    FIELD-SYMBOLS: &lt;ls_object&gt; LIKE LINE OF it_objects.
    LOOP AT it_objects ASSIGNING &lt;ls_object&gt; USING KEY type
        WHERE type = zif_abapgit_definitions=&gt;c_type-commit.
      ls_raw = zcl_abapgit_git_pack=&gt;decode_commit( &lt;ls_object&gt;-data ).

      CLEAR ls_commit.
      ls_commit-sha1 = &lt;ls_object&gt;-sha1.
      ls_commit-parent1 = ls_raw-parent.
      ls_commit-parent2 = ls_raw-parent2.

      SPLIT ls_raw-body AT zif_abapgit_definitions=&gt;c_newline INTO TABLE lt_body.

      READ TABLE lt_body WITH KEY table_line = &apos; -----END PGP SIGNATURE-----&apos; TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        DELETE lt_body TO sy-tabix.
        DELETE lt_body TO 2.
      ENDIF.

      READ TABLE lt_body INDEX 1 INTO ls_commit-message.  &quot;#EC CI_SUBRC

* unix time stamps are in same time zone, so ignore the zone,
      FIND REGEX zif_abapgit_definitions=&gt;c_author_regex IN ls_raw-author
        SUBMATCHES
        ls_commit-author
        ls_commit-email
        ls_commit-time ##NO_TEXT.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Error author regex&apos; ).
      ENDIF.
      APPEND ls_commit TO rt_commits.

    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_branch_overview~compress.

    DEFINE _compress.
      IF lines( lt_temp ) &gt;= 10.
        READ TABLE lt_temp ASSIGNING &lt;ls_temp&gt; INDEX 1.
        ASSERT sy-subrc = 0.
        READ TABLE lt_temp ASSIGNING &lt;ls_temp_end&gt; INDEX lines( lt_temp ).
        ASSERT sy-subrc = 0.
        APPEND INITIAL LINE TO rt_commits ASSIGNING &lt;ls_new&gt;.
        &lt;ls_new&gt;-sha1       = &lt;ls_temp_end&gt;-sha1.
        &lt;ls_new&gt;-parent1    = &lt;ls_temp&gt;-parent1.
        &lt;ls_new&gt;-time       = &lt;ls_temp&gt;-time.
        &lt;ls_new&gt;-message    = |Compressed, { lines( lt_temp ) } commits|.
        &lt;ls_new&gt;-branch     = lv_name.
        &lt;ls_new&gt;-compressed = abap_true.
      ELSE.
        APPEND LINES OF lt_temp TO rt_commits.
      ENDIF.
      CLEAR lt_temp.
    END-OF-DEFINITION.

    DATA: lv_previous TYPE i,
          lv_index    TYPE i,
          lv_name     TYPE string,
          lt_temp     LIKE it_commits.

    FIELD-SYMBOLS: &lt;ls_branch&gt;   LIKE LINE OF mt_branches,
                   &lt;ls_new&gt;      LIKE LINE OF rt_commits,
                   &lt;ls_temp&gt;     LIKE LINE OF lt_temp,
                   &lt;ls_temp_end&gt; LIKE LINE OF lt_temp,
                   &lt;ls_commit&gt;   LIKE LINE OF it_commits.
    LOOP AT mt_branches ASSIGNING &lt;ls_branch&gt;.

      CLEAR lt_temp.
      lv_name = &lt;ls_branch&gt;-name+11.

      LOOP AT it_commits ASSIGNING &lt;ls_commit&gt;
          WHERE branch = lv_name.
        lv_index = sy-tabix.

        IF NOT &lt;ls_commit&gt;-merge IS INITIAL
            OR NOT &lt;ls_commit&gt;-create IS INITIAL.
* always show these vertices
          lv_previous = -1.
        ENDIF.

        IF lv_previous + 1 &lt;&gt; sy-tabix.
          _compress.
        ENDIF.

        lv_previous = lv_index.

        APPEND &lt;ls_commit&gt; TO lt_temp.

      ENDLOOP.

      _compress.

    ENDLOOP.

    _sort_commits( CHANGING ct_commits = rt_commits ).

  ENDMETHOD.
  METHOD zif_abapgit_branch_overview~get_branches.
    rt_branches = mt_branches.
  ENDMETHOD.
  METHOD zif_abapgit_branch_overview~get_commits.
    rt_commits = mt_commits.
  ENDMETHOD.
  METHOD zif_abapgit_branch_overview~get_tags.

    rt_tags = mt_tags.

  ENDMETHOD.
  METHOD _get_1st_child_commit.

    DATA: lt_1stchild_commits TYPE ty_commits,
          ls_parent           LIKE LINE OF it_commit_sha1s,
          lt_commit_sha1s     LIKE it_commit_sha1s.

    FIELD-SYMBOLS: &lt;ls_child_commit&gt; TYPE zif_abapgit_definitions=&gt;ty_commit.

    CLEAR: es_1st_commit.

* get all reachable next commits
    lt_commit_sha1s = it_commit_sha1s.
    LOOP AT ct_commits ASSIGNING &lt;ls_child_commit&gt; WHERE parent1 IN lt_commit_sha1s
                                                      OR parent2 IN lt_commit_sha1s.
      INSERT &lt;ls_child_commit&gt; INTO TABLE lt_1stchild_commits.
    ENDLOOP.

* return oldest one
    SORT lt_1stchild_commits BY time ASCENDING.
    READ TABLE lt_1stchild_commits INTO es_1st_commit INDEX 1.

* remove from available commits
    DELETE ct_commits WHERE sha1 = es_1st_commit-sha1.

* set relevant parent commit sha1s
    IF lines( lt_1stchild_commits ) = 1.
      CLEAR et_commit_sha1s.
    ELSE.
      et_commit_sha1s = it_commit_sha1s.
    ENDIF.

    ls_parent-sign   = &apos;I&apos;.
    ls_parent-option = &apos;EQ&apos;.
    ls_parent-low    = es_1st_commit-sha1.
    INSERT ls_parent INTO TABLE et_commit_sha1s.

  ENDMETHOD.
  METHOD _reverse_sort_order.
    DATA: lt_commits           TYPE ty_commits.
    FIELD-SYMBOLS: &lt;ls_commit&gt; TYPE zif_abapgit_definitions=&gt;ty_commit.

    LOOP AT ct_commits ASSIGNING &lt;ls_commit&gt;.
      INSERT &lt;ls_commit&gt; INTO lt_commits INDEX 1.
    ENDLOOP.
    ct_commits = lt_commits.
    FREE lt_commits.

  ENDMETHOD.
  METHOD _sort_commits.

    DATA: lt_sorted_commits TYPE ty_commits,
          lv_next_commit    TYPE zif_abapgit_definitions=&gt;ty_commit,
          lt_parents        TYPE tyt_commit_sha1_range,
          ls_parent         LIKE LINE OF lt_parents.

    FIELD-SYMBOLS: &lt;ls_initial_commit&gt; TYPE zif_abapgit_definitions=&gt;ty_commit.

* find initial commit
    READ TABLE ct_commits ASSIGNING &lt;ls_initial_commit&gt; WITH KEY parent1 = space.
    IF sy-subrc = 0.

      ls_parent-sign   = &apos;I&apos;.
      ls_parent-option = &apos;EQ&apos;.
      ls_parent-low    = &lt;ls_initial_commit&gt;-sha1.
      INSERT ls_parent INTO TABLE lt_parents.

* first commit
      INSERT &lt;ls_initial_commit&gt; INTO TABLE lt_sorted_commits.

* remove from available commits
      DELETE ct_commits WHERE sha1 = &lt;ls_initial_commit&gt;-sha1.

      DO.
        _get_1st_child_commit( EXPORTING it_commit_sha1s = lt_parents
                               IMPORTING et_commit_sha1s = lt_parents
                                         es_1st_commit   = lv_next_commit
                               CHANGING  ct_commits      = ct_commits ).
        IF lv_next_commit IS INITIAL.
          EXIT. &quot;DO
        ENDIF.
        INSERT lv_next_commit INTO TABLE lt_sorted_commits.
      ENDDO.
    ENDIF.

    ct_commits = lt_sorted_commits.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_AUTH IMPLEMENTATION.
  METHOD is_allowed.

    DATA: li_auth TYPE REF TO zif_abapgit_auth.

    TRY.
        CREATE OBJECT li_auth TYPE (&apos;ZCL_ABAPGIT_AUTH_EXIT&apos;).
        rv_allowed = li_auth-&gt;is_allowed( iv_authorization = iv_authorization
                                          iv_param         = iv_param ).
      CATCH cx_sy_create_object_error.
        rv_allowed = abap_true.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_adhoc_code_insp IMPLEMENTATION.
  METHOD cleanup.

    super-&gt;cleanup( io_set ).

    IF mo_variant IS BOUND.

      mo_variant-&gt;delete(
        EXCEPTIONS
          exists_in_insp   = 1
          locked           = 2
          error_in_enqueue = 3
          not_authorized   = 4
          transport_error  = 5
          OTHERS           = 6 ).

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Couldn&apos;t delete variant. Subrc = { sy-subrc }| ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    DATA: lv_check_variant_name TYPE sci_chkv.

    IF iv_test_name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |Please supply a test name| ).
    ENDIF.

    &quot; we supply a dummy name for the check variant,
    &quot; because we have to persists it to be able to run in parallel.
    &quot; Afterwards it&apos;s deleted.

    lv_check_variant_name = |{ sy-uname }_{ sy-datum }_{ sy-uzeit }|.

    super-&gt;constructor( iv_package            = iv_package
                        iv_check_variant_name = lv_check_variant_name ).

    mv_test_name = iv_test_name.

  ENDMETHOD.
  METHOD create_variant.

    DATA: lt_variant TYPE sci_tstvar,
          ls_variant LIKE LINE OF lt_variant.

    cl_ci_checkvariant=&gt;create(
      EXPORTING
        p_user              = sy-uname
        p_name              = mv_check_variant_name
      RECEIVING
        p_ref               = mo_variant
      EXCEPTIONS
        chkv_already_exists = 1
        locked              = 2
        error_in_enqueue    = 3
        not_authorized      = 4
        OTHERS              = 5 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Couldn&apos;t create variant. Subrc = { sy-subrc }| ).
    ENDIF.

    ls_variant-testname = mv_test_name.
    INSERT ls_variant INTO TABLE lt_variant.

    mo_variant-&gt;set_variant(
      EXPORTING
        p_variant    = lt_variant
      EXCEPTIONS
        not_enqueued = 1
        OTHERS       = 2 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Couldn&apos;t set variant. Subrc = { sy-subrc }| ).
    ENDIF.

    mo_variant-&gt;save(
      EXPORTING
        p_variant         = mo_variant-&gt;variant
      EXCEPTIONS
        empty_variant     = 1
        transport_error   = 2
        not_authorized    = 3
        OTHERS            = 4 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Couldn&apos;t save variant. Subrc = { sy-subrc }| ).
    ENDIF.

    ro_variant = mo_variant.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_abap_unit_tests IMPLEMENTATION.
  METHOD constructor.

    mo_adhoc_code_inspector = zcl_abapgit_factory=&gt;get_adhoc_code_inspector(
                                iv_package   = iv_package
                                iv_test_name = &apos;CL_SAUNIT_LEGACY_CI_CHECK&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~get_inspection.

    ro_inspection = mo_adhoc_code_inspector-&gt;get_inspection( ).

  ENDMETHOD.
  METHOD zif_abapgit_code_inspector~run.

    rt_list = mo_adhoc_code_inspector-&gt;run( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_XML_PRETTY IMPLEMENTATION.
  METHOD print.

    DATA: li_ixml           TYPE REF TO if_ixml,
          li_xml_doc        TYPE REF TO if_ixml_document,
          li_stream_factory TYPE REF TO if_ixml_stream_factory,
          li_istream        TYPE REF TO if_ixml_istream,
          li_parser         TYPE REF TO if_ixml_parser,
          li_ostream        TYPE REF TO if_ixml_ostream,
          li_renderer       TYPE REF TO if_ixml_renderer.
    ASSERT NOT iv_xml IS INITIAL.

    li_ixml    = cl_ixml=&gt;create( ).
    li_xml_doc = li_ixml-&gt;create_document( ).

    li_stream_factory = li_ixml-&gt;create_stream_factory( ).
    li_istream        = li_stream_factory-&gt;create_istream_string( iv_xml ).
    li_parser         = li_ixml-&gt;create_parser( stream_factory = li_stream_factory
                                                istream        = li_istream
                                                document       = li_xml_doc ).
    li_parser-&gt;set_normalizing( abap_true ).
    IF li_parser-&gt;parse( ) &lt;&gt; 0.
      IF iv_ignore_errors = abap_true.
        rv_xml = iv_xml.
        RETURN.
      ELSE.
        zcx_abapgit_exception=&gt;raise( &apos;error parsing xml&apos; ).
      ENDIF.
    ENDIF.
    li_istream-&gt;close( ).
    li_ostream  = li_stream_factory-&gt;create_ostream_cstring( rv_xml ).

    li_renderer = li_ixml-&gt;create_renderer( ostream  = li_ostream
                                            document = li_xml_doc ).

    li_renderer-&gt;set_normalizing( boolc( iv_unpretty = abap_false ) ).

    li_renderer-&gt;render( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_XML_OUTPUT IMPLEMENTATION.
  METHOD add.

    DATA: li_node TYPE REF TO if_ixml_node,
          li_doc  TYPE REF TO if_ixml_document,
          lt_stab TYPE abap_trans_srcbind_tab.

    FIELD-SYMBOLS: &lt;ls_stab&gt; LIKE LINE OF lt_stab.
    ASSERT NOT iv_name IS INITIAL.

    IF ig_data IS INITIAL.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO lt_stab ASSIGNING &lt;ls_stab&gt;.
    &lt;ls_stab&gt;-name = iv_name.
    GET REFERENCE OF ig_data INTO &lt;ls_stab&gt;-value.

    li_doc = cl_ixml=&gt;create( )-&gt;create_document( ).

    CALL TRANSFORMATION id
      OPTIONS initial_components = &apos;suppress&apos;
      SOURCE (lt_stab)
      RESULT XML li_doc.

    li_node = mi_xml_doc-&gt;get_root( )-&gt;get_first_child( ).
    IF li_node IS BOUND.
      mi_xml_doc-&gt;get_root( )-&gt;get_first_child( )-&gt;get_first_child( )-&gt;append_child(
        li_doc-&gt;get_root( )-&gt;get_first_child( )-&gt;get_first_child( )-&gt;get_first_child( ) ).
    ELSE.
      mi_xml_doc-&gt;get_root( )-&gt;append_child( li_doc-&gt;get_root( )-&gt;get_first_child( ) ).
    ENDIF.

  ENDMETHOD.
  METHOD add_xml.

    DATA: li_element TYPE REF TO if_ixml_element.

    li_element = mi_xml_doc-&gt;create_element( iv_name ).
    li_element-&gt;append_child( ii_xml ).

    mi_xml_doc-&gt;get_root( )-&gt;get_first_child( )-&gt;get_first_child( )-&gt;append_child( li_element ).

  ENDMETHOD.
  METHOD build_asx_node.

    DATA: li_attr TYPE REF TO if_ixml_attribute.
    ri_element = mi_xml_doc-&gt;create_element_ns(
      name   = &apos;abap&apos;
      prefix = &apos;asx&apos; ).

    li_attr = mi_xml_doc-&gt;create_attribute_ns( &apos;version&apos; ).
    li_attr-&gt;if_ixml_node~set_value( &apos;1.0&apos; ).
    ri_element-&gt;set_attribute_node_ns( li_attr ).

    li_attr = mi_xml_doc-&gt;create_attribute_ns(
      name   = &apos;asx&apos;
      prefix = &apos;xmlns&apos; ).
    li_attr-&gt;if_ixml_node~set_value( &apos;http://www.sap.com/abapxml&apos; ).
    ri_element-&gt;set_attribute_node_ns( li_attr ).

  ENDMETHOD.
  METHOD render.

    DATA: li_git  TYPE REF TO if_ixml_element,
          li_abap TYPE REF TO if_ixml_element.
    IF mi_raw IS INITIAL.
      li_abap ?= mi_xml_doc-&gt;get_root( )-&gt;get_first_child( ).
      mi_xml_doc-&gt;get_root( )-&gt;remove_child( li_abap ).
      IF li_abap IS INITIAL.
        li_abap = build_asx_node( ).
      ENDIF.
    ELSE.
      li_abap = mi_raw.
    ENDIF.

    li_git = mi_xml_doc-&gt;create_element( c_abapgit_tag ).
    li_git-&gt;set_attribute( name = c_attr_version value = zif_abapgit_version=&gt;gc_xml_version ).
    IF NOT is_metadata IS INITIAL.
      li_git-&gt;set_attribute( name  = c_attr_serializer
                             value = is_metadata-class ).
      li_git-&gt;set_attribute( name  = c_attr_serializer_version
                             value = is_metadata-version ).
    ENDIF.
    li_git-&gt;append_child( li_abap ).
    mi_xml_doc-&gt;get_root( )-&gt;append_child( li_git ).

    rv_xml = to_xml( iv_normalize ).

  ENDMETHOD.
  METHOD set_raw.
    mi_raw = ii_raw.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_XML_INPUT IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( ).
    parse( iv_xml ).
    fix_xml( ).

  ENDMETHOD.
  METHOD fix_xml.

    DATA: li_git  TYPE REF TO if_ixml_element,
          li_abap TYPE REF TO if_ixml_node.
    li_git ?= mi_xml_doc-&gt;find_from_name_ns( depth = 0 name = c_abapgit_tag ).
    li_abap = li_git-&gt;get_first_child( ).

    mi_xml_doc-&gt;get_root( )-&gt;remove_child( li_git ).
    mi_xml_doc-&gt;get_root( )-&gt;append_child( li_abap ).

  ENDMETHOD.
  METHOD get_metadata.
    rs_metadata = ms_metadata.
  ENDMETHOD.
  METHOD get_raw.
    ri_raw = mi_xml_doc.
  ENDMETHOD.
  METHOD read.

    DATA: lx_error TYPE REF TO cx_transformation_error,
          lt_rtab  TYPE abap_trans_resbind_tab.

    FIELD-SYMBOLS: &lt;ls_rtab&gt; LIKE LINE OF lt_rtab.

    ASSERT NOT iv_name IS INITIAL.

    CLEAR cg_data. &quot;Initialize result to avoid problems with empty values

    APPEND INITIAL LINE TO lt_rtab ASSIGNING &lt;ls_rtab&gt;.
    &lt;ls_rtab&gt;-name = iv_name.
    GET REFERENCE OF cg_data INTO &lt;ls_rtab&gt;-value.

    TRY.
        CALL TRANSFORMATION id
          OPTIONS value_handling = &apos;accept_data_loss&apos;
          SOURCE XML mi_xml_doc
          RESULT (lt_rtab) ##no_text.
      CATCH cx_transformation_error INTO lx_error.
        zcx_abapgit_exception=&gt;raise( lx_error-&gt;if_message~get_text( ) ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_XML IMPLEMENTATION.
  METHOD constructor.
    mi_ixml = cl_ixml=&gt;create( ).
    mi_xml_doc = mi_ixml-&gt;create_document( ).
  ENDMETHOD.
  METHOD display_xml_error.

    DATA: lv_version TYPE string.
    lv_version = |abapGit version: { zif_abapgit_version=&gt;gc_abap_version }|.

    CALL FUNCTION &apos;POPUP_TO_INFORM&apos;
      EXPORTING
        titel = &apos;abapGit XML version mismatch&apos;
        txt1  = &apos;abapGit XML version mismatch&apos;
        txt2  = &apos;See http://larshp.github.io/abapGit/other-xml-mismatch.html&apos;
        txt3  = lv_version.                                 &quot;#EC NOTEXT

    zcx_abapgit_exception=&gt;raise( &apos;XML error&apos; ).

  ENDMETHOD.
  METHOD error.

    DATA: lv_error TYPE i,
          lv_txt1  TYPE string,
          lv_txt2  TYPE string,
          lv_txt3  TYPE string,
          lv_times TYPE i,
          li_error TYPE REF TO if_ixml_parse_error.
    IF ii_parser-&gt;num_errors( ) &lt;&gt; 0.
      lv_times = ii_parser-&gt;num_errors( ).
      DO lv_times TIMES.
        lv_error = sy-index - 1.
        li_error = ii_parser-&gt;get_error( lv_error ).

        lv_txt1 = li_error-&gt;get_column( ).
        CONCATENATE &apos;Column:&apos; lv_txt1 INTO lv_txt1.         &quot;#EC NOTEXT
        lv_txt2 = li_error-&gt;get_line( ).
        CONCATENATE &apos;Line:&apos; lv_txt2 INTO lv_txt2.           &quot;#EC NOTEXT
        lv_txt3 = li_error-&gt;get_reason( ).

        CALL FUNCTION &apos;POPUP_TO_INFORM&apos;
          EXPORTING
            titel = &apos;Error from XML parser&apos;                 &quot;#EC NOTEXT
            txt1  = lv_txt1
            txt2  = lv_txt2
            txt3  = lv_txt3.
      ENDDO.
    ENDIF.

    zcx_abapgit_exception=&gt;raise( &apos;Error while parsing XML&apos; ).
  ENDMETHOD.
  METHOD parse.

    DATA: li_stream_factory TYPE REF TO if_ixml_stream_factory,
          li_istream        TYPE REF TO if_ixml_istream,
          li_element        TYPE REF TO if_ixml_element,
          li_version        TYPE REF TO if_ixml_node,
          li_parser         TYPE REF TO if_ixml_parser.
    ASSERT NOT iv_xml IS INITIAL.

    li_stream_factory = mi_ixml-&gt;create_stream_factory( ).
    li_istream = li_stream_factory-&gt;create_istream_string( iv_xml ).
    li_parser = mi_ixml-&gt;create_parser( stream_factory = li_stream_factory
                                        istream        = li_istream
                                        document       = mi_xml_doc ).
    li_parser-&gt;set_normalizing( iv_normalize ).
    IF li_parser-&gt;parse( ) &lt;&gt; 0.
      error( li_parser ).
    ENDIF.

    li_istream-&gt;close( ).
    li_element = mi_xml_doc-&gt;find_from_name_ns( depth = 0 name = c_abapgit_tag ).
    li_version = li_element-&gt;if_ixml_node~get_attributes(
      )-&gt;get_named_item_ns( c_attr_version ) ##no_text.
    IF li_version-&gt;get_value( ) &lt;&gt; zif_abapgit_version=&gt;gc_xml_version.
      display_xml_error( ).
    ENDIF.

* buffer serializer metadata. Git node will be removed lateron
    ms_metadata-class   = li_element-&gt;get_attribute_ns( c_attr_serializer ).
    ms_metadata-version = li_element-&gt;get_attribute_ns( c_attr_serializer_version ).

  ENDMETHOD.
  METHOD to_xml.
* will render to codepage UTF-16

    DATA: li_ostream       TYPE REF TO if_ixml_ostream,
          li_renderer      TYPE REF TO if_ixml_renderer,
          li_streamfactory TYPE REF TO if_ixml_stream_factory.
    li_streamfactory = mi_ixml-&gt;create_stream_factory( ).

    li_ostream = li_streamfactory-&gt;create_ostream_cstring( rv_xml ).

    li_renderer = mi_ixml-&gt;create_renderer( ostream  = li_ostream
                                            document = mi_xml_doc ).
    li_renderer-&gt;set_normalizing( iv_normalize ).

    li_renderer-&gt;render( ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_USER_MASTER_RECORD IMPLEMENTATION.
  METHOD constructor.

    DATA: lt_return  TYPE TABLE OF bapiret2,
          ls_address TYPE bapiaddr3,
          lt_smtp    TYPE TABLE OF bapiadsmtp,
          ls_smtp    TYPE bapiadsmtp.

    CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
      EXPORTING
        username = iv_user
      IMPORTING
        address  = ls_address
      TABLES
        return   = lt_return
        addsmtp  = lt_smtp.

*     Choose the first email from SU01
    SORT lt_smtp BY consnumber ASCENDING.

    LOOP AT lt_smtp INTO ls_smtp.
      ms_user-email = ls_smtp-e_mail.
      EXIT.
    ENDLOOP.

*     Attempt to use the full name from SU01
    ms_user-name = ls_address-fullname.

  ENDMETHOD.
  METHOD get_email.

    rv_email = ms_user-email.

  ENDMETHOD.
  METHOD get_instance.

    DATA: ls_user TYPE ty_user.
    FIELD-SYMBOLS: &lt;ls_user&gt; TYPE ty_user.

    READ TABLE gt_user ASSIGNING &lt;ls_user&gt;
                       WITH KEY user = iv_user.
    IF sy-subrc &lt;&gt; 0.

      ls_user-user = iv_user.
      CREATE OBJECT ls_user-o_user
        EXPORTING
          iv_user = iv_user.

      INSERT ls_user
             INTO TABLE gt_user
             ASSIGNING &lt;ls_user&gt;.

    ENDIF.

    ro_user = &lt;ls_user&gt;-o_user.

  ENDMETHOD.
  METHOD get_name.

    rv_name = ms_user-name.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_URL IMPLEMENTATION.
  METHOD host.

    regex( EXPORTING iv_url = iv_url
           IMPORTING ev_host = rv_host ).

  ENDMETHOD.
  METHOD name.

    regex( EXPORTING iv_url = iv_url
           IMPORTING ev_name = rv_name ).

  ENDMETHOD.
  METHOD path_name.

    DATA: lv_host TYPE string ##NEEDED.

    FIND REGEX &apos;(.*://[^/]*)(.*)&apos; IN iv_url
      SUBMATCHES lv_host rv_path_name.

  ENDMETHOD.
  METHOD regex.

    FIND REGEX &apos;(.*://[^/]*)(.*/)([^\.]*)[\.git]?&apos; IN iv_url
      SUBMATCHES ev_host ev_path ev_name.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Malformed URL&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD validate.

    regex( iv_url ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TIME IMPLEMENTATION.
  METHOD get.

    DATA: lv_i       TYPE i,
          lv_tz      TYPE tznzone,
          lv_utcdiff TYPE tznutcdiff,
          lv_utcsign TYPE tznutcsign.
    lv_i = sy-datum - c_epoch.
    lv_i = lv_i * 86400.
    lv_i = lv_i + sy-uzeit.

    CALL FUNCTION &apos;TZON_GET_OS_TIMEZONE&apos;
      IMPORTING
        ef_timezone = lv_tz.

    CALL FUNCTION &apos;TZON_GET_OFFSET&apos;
      EXPORTING
        if_timezone      = lv_tz
        if_local_date    = sy-datum
        if_local_time    = sy-uzeit
      IMPORTING
        ef_utcdiff       = lv_utcdiff
        ef_utcsign       = lv_utcsign
      EXCEPTIONS
        conversion_error = 1
        OTHERS           = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Timezone error&apos; ).
    ENDIF.

    CASE lv_utcsign.
      WHEN &apos;+&apos;.
        lv_i = lv_i - lv_utcdiff.
      WHEN &apos;-&apos;.
        lv_i = lv_i + lv_utcdiff.
    ENDCASE.

    rv_time = lv_i.
    CONDENSE rv_time.
    rv_time+11 = lv_utcsign.
    rv_time+12 = lv_utcdiff.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_STATE IMPLEMENTATION.
  METHOD reduce.

    IF cv_prev = iv_cur OR iv_cur IS INITIAL.
      RETURN. &quot; No change
    ELSEIF cv_prev IS INITIAL.
      cv_prev = iv_cur.
    ELSE.
      cv_prev = zif_abapgit_definitions=&gt;c_state-mixed.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_REQUIREMENT_HELPER IMPLEMENTATION.
  METHOD get_requirement_met_status.

    DATA: lt_installed TYPE STANDARD TABLE OF cvers_sdu.

    FIELD-SYMBOLS: &lt;ls_requirement&gt;    TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement,
                   &lt;ls_status&gt;         TYPE ty_requirement_status,
                   &lt;ls_installed_comp&gt; TYPE cvers_sdu.
    CALL FUNCTION &apos;DELIVERY_GET_INSTALLED_COMPS&apos;
      TABLES
        tt_comptab       = lt_installed
      EXCEPTIONS
        no_release_found = 1
        OTHERS           = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from DELIVERY_GET_INSTALLED_COMPS { sy-subrc }| ) ##no_text.
    ENDIF.

    LOOP AT it_requirements ASSIGNING &lt;ls_requirement&gt;.
      APPEND INITIAL LINE TO rt_status ASSIGNING &lt;ls_status&gt;.
      &lt;ls_status&gt;-component = &lt;ls_requirement&gt;-component.
      &lt;ls_status&gt;-required_release = &lt;ls_requirement&gt;-min_release.
      &lt;ls_status&gt;-required_patch = &lt;ls_requirement&gt;-min_patch.

      READ TABLE lt_installed WITH KEY component = &lt;ls_requirement&gt;-component
                              ASSIGNING &lt;ls_installed_comp&gt;.
      IF sy-subrc = 0.
        &quot; Component is installed, requirement is met if the installed version is greater or equal
        &quot; to the required one.
        &lt;ls_status&gt;-installed_release = &lt;ls_installed_comp&gt;-release.
        &lt;ls_status&gt;-installed_patch = &lt;ls_installed_comp&gt;-extrelease.
        &lt;ls_status&gt;-description = &lt;ls_installed_comp&gt;-desc_text.
        &lt;ls_status&gt;-met = version_greater_or_equal( &lt;ls_status&gt; ).
      ELSE.
        &quot; Component is not installed at all
        &lt;ls_status&gt;-met = abap_false.
      ENDIF.

      UNASSIGN &lt;ls_installed_comp&gt;.
    ENDLOOP.

  ENDMETHOD.
  METHOD is_requirements_met.

    DATA: lt_met_status TYPE ty_requirement_status_tt.
    lt_met_status = get_requirement_met_status( it_requirements ).

    READ TABLE lt_met_status TRANSPORTING NO FIELDS WITH KEY met = abap_false.
    IF sy-subrc = 0.
      rv_status = &apos;N&apos;.
    ELSE.
      rv_status = &apos;Y&apos;.
    ENDIF.

  ENDMETHOD.
  METHOD requirements_popup.

    DATA: lt_met_status TYPE ty_requirement_status_tt,
          lv_answer     TYPE c LENGTH 1.
    lt_met_status = get_requirement_met_status( it_requirements ).

    show_requirement_popup( lt_met_status ).

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question = &apos;The project has unmet requirements. Do you want to continue?&apos;
      IMPORTING
        answer        = lv_answer.
    IF lv_answer &lt;&gt; &apos;1&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;Cancelling because of unmet requirements.&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD show_requirement_popup.
    TYPES: BEGIN OF lty_color_line,
             color TYPE lvc_t_scol.
        INCLUDE TYPE ty_requirement_status.
    TYPES: END OF lty_color_line,
    lty_color_tab TYPE STANDARD TABLE OF lty_color_line WITH DEFAULT KEY.

    DATA: lo_alv            TYPE REF TO cl_salv_table,
          lo_column         TYPE REF TO cl_salv_column,
          lo_columns        TYPE REF TO cl_salv_columns_table,
          lt_color_table    TYPE lty_color_tab,
          lt_color_negative TYPE lvc_t_scol,
          lt_color_positive TYPE lvc_t_scol,
          ls_color          TYPE lvc_s_scol,
          lx_ex             TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;ls_line&gt;        TYPE lty_color_line,
                   &lt;ls_requirement&gt; LIKE LINE OF it_requirements.
    ls_color-color-col = col_negative.
    APPEND ls_color TO lt_color_negative.

    ls_color-color-col = col_positive.
    APPEND ls_color TO lt_color_positive.

    CLEAR ls_color.

    LOOP AT it_requirements ASSIGNING &lt;ls_requirement&gt;.
      APPEND INITIAL LINE TO lt_color_table ASSIGNING &lt;ls_line&gt;.
      MOVE-CORRESPONDING &lt;ls_requirement&gt; TO &lt;ls_line&gt;.
    ENDLOOP.

    LOOP AT lt_color_table ASSIGNING &lt;ls_line&gt;.
      IF &lt;ls_line&gt;-met = abap_false.
        &lt;ls_line&gt;-color = lt_color_negative.
      ELSE.
        &lt;ls_line&gt;-color = lt_color_positive.
      ENDIF.
    ENDLOOP.
    UNASSIGN &lt;ls_line&gt;.

    TRY.
        cl_salv_table=&gt;factory( IMPORTING r_salv_table = lo_alv
                                CHANGING t_table       = lt_color_table ).

        lo_columns = lo_alv-&gt;get_columns( ).
        lo_columns-&gt;get_column( &apos;MET&apos; )-&gt;set_short_text( &apos;Met&apos; ).
        lo_columns-&gt;set_color_column( &apos;COLOR&apos; ).
        lo_columns-&gt;set_optimize( ).

        lo_column = lo_columns-&gt;get_column( &apos;REQUIRED_RELEASE&apos; ).
*        lo_column-&gt;set_fixed_header_text( &apos;S&apos; ).
        lo_column-&gt;set_short_text( &apos;Req. Rel.&apos; ).

        lo_column = lo_columns-&gt;get_column( &apos;REQUIRED_PATCH&apos; ).
*        lo_column-&gt;set_fixed_header_text( &apos;S&apos; ).
        lo_column-&gt;set_short_text( &apos;Req. SP L.&apos; ).

        lo_alv-&gt;set_screen_popup( start_column = 30
                                  end_column   = 100
                                  start_line   = 10
                                  end_line     = 20 ).
        lo_alv-&gt;get_display_settings( )-&gt;set_list_header( &apos;Requirements&apos; ).
        lo_alv-&gt;display( ).

      CATCH cx_salv_msg cx_salv_not_found cx_salv_data_error INTO lx_ex.
        zcx_abapgit_exception=&gt;raise( lx_ex-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.
  METHOD version_greater_or_equal.

    DATA: lv_number TYPE numc4 ##NEEDED.

    TRY.
        MOVE EXACT: is_status-installed_release TO lv_number,
                    is_status-installed_patch   TO lv_number,
                    is_status-required_release  TO lv_number,
                    is_status-required_patch    TO lv_number.
      CATCH cx_sy_conversion_error.
        &quot; Cannot compare by number, assume requirement not fullfilled (user can force install
        &quot; anyways if this was an error)
        rv_true = abap_false.
        RETURN.
    ENDTRY.

    &quot; Versions are comparable by number, compare release and if necessary patch level
    IF is_status-installed_release &gt; is_status-required_release
        OR ( is_status-installed_release = is_status-required_release
        AND ( is_status-required_patch IS INITIAL OR
        is_status-installed_patch &gt;= is_status-required_patch ) ).

      rv_true = abap_true.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PROGRESS IMPLEMENTATION.
  METHOD calc_pct.

    DATA: lv_f TYPE f.

    lv_f = ( iv_current / mv_total ) * 100.
    rv_pct = lv_f.

    IF rv_pct = 100.
      rv_pct = 99.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    mv_total = iv_total.

  ENDMETHOD.
  METHOD show.

    DATA: lv_pct  TYPE i.
    DATA: lv_time TYPE t.

    CONSTANTS: lc_wait_secs TYPE i VALUE 2.

    GET TIME.
    lv_time = sy-uzeit.
    IF mv_cv_time_next IS INITIAL AND mv_cv_datum_next IS INITIAL.
      mv_cv_time_next  = lv_time.
      mv_cv_datum_next = sy-datum.
    ENDIF.

    &quot;We only do a progress indication if enough time has passed
    IF lv_time  &gt;= mv_cv_time_next  AND sy-datum = mv_cv_datum_next  OR
       sy-datum &gt;  mv_cv_datum_next.

      lv_pct = calc_pct( iv_current ).

      CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
        EXPORTING
          percentage = lv_pct
          text       = iv_text.
      mv_cv_time_next = lv_time + lc_wait_secs.

    ENDIF.
    IF sy-datum &gt; mv_cv_datum_next.
      mv_cv_datum_next = sy-datum.
    ENDIF.
    IF mv_cv_time_next &lt; lv_time.
      mv_cv_datum_next = sy-datum + 1.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PATH IMPLEMENTATION.
  METHOD change_dir.

    DATA: lv_last TYPE i,
          lv_temp TYPE string.

    lv_last = strlen( iv_cur_dir ) - 1.

    IF iv_cd = &apos;&apos; OR iv_cd = &apos;.&apos;. &quot; No change
      rv_path = iv_cur_dir.
    ELSEIF iv_cd+0(1) = &apos;/&apos;.      &quot; Absolute path
      rv_path = iv_cd.
    ELSEIF iv_cd = &apos;..&apos;.          &quot; CD back
      IF iv_cur_dir = &apos;/&apos; OR iv_cur_dir = &apos;&apos;. &quot; Back from root = root
        rv_path = iv_cur_dir.
      ELSE.
        lv_temp = reverse( iv_cur_dir ).
        IF lv_temp+0(1) = &apos;/&apos;.
          SHIFT lv_temp BY 1 PLACES LEFT.
        ENDIF.
        SHIFT lv_temp UP TO &apos;/&apos; LEFT.
        rv_path = reverse( lv_temp ).
      ENDIF.
    ELSEIF iv_cur_dir+lv_last(1) = &apos;/&apos;.  &quot; Append cd to cur_dir separated by /
      rv_path = iv_cur_dir &amp;&amp; iv_cd.
    ELSE.
      rv_path = iv_cur_dir &amp;&amp; &apos;/&apos; &amp;&amp; iv_cd.
    ENDIF.

    &quot; TODO: improve logic and cases

  ENDMETHOD.
  METHOD get_filename_from_syspath.

    DATA: lv_split TYPE c LENGTH 1,
          lv_index TYPE i,
          lt_split TYPE TABLE OF string.

    &quot; filename | c:\filename | /dir/filename | \\server\filename
    IF iv_path CA &apos;/&apos;.
      lv_split = &apos;/&apos;.
    ELSE.
      lv_split = &apos;\&apos;.
    ENDIF.

    SPLIT iv_path AT lv_split INTO TABLE lt_split.

    lv_index = lines( lt_split ).

    READ TABLE lt_split INDEX lv_index INTO rv_filename.

  ENDMETHOD.
  METHOD is_root.
    rv_yes = boolc( iv_path = &apos;/&apos; ).
  ENDMETHOD.
  METHOD is_subdir.

    DATA lv_len  TYPE i.
    DATA lv_last TYPE i.

    lv_len  = strlen( iv_parent ).
    lv_last = lv_len - 1.
    rv_yes  = boolc( strlen( iv_path ) &gt; lv_len
                 AND iv_path+0(lv_len) = iv_parent
                 AND ( iv_parent+lv_last(1) = &apos;/&apos; OR iv_path+lv_len(1) = &apos;/&apos; ) ).

  ENDMETHOD.
  METHOD split_file_location.

    DATA: lv_cnt TYPE i,
          lv_len TYPE i.

    FIND FIRST OCCURRENCE OF REGEX &apos;^/(.*/)?&apos; IN iv_fullpath
      MATCH COUNT lv_cnt
      MATCH LENGTH lv_len.

    IF lv_cnt &gt; 0.
      ev_path     = iv_fullpath+0(lv_len).
      ev_filename = iv_fullpath+lv_len.
    ELSE.
      CLEAR ev_path.
      ev_filename = iv_fullpath.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_LOGIN_MANAGER IMPLEMENTATION.
  METHOD append.

    FIELD-SYMBOLS: &lt;ls_auth&gt; LIKE LINE OF gt_auth.

    READ TABLE gt_auth WITH KEY uri = zcl_abapgit_url=&gt;host( iv_uri )
      TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
      APPEND INITIAL LINE TO gt_auth ASSIGNING &lt;ls_auth&gt;.
      &lt;ls_auth&gt;-uri           = zcl_abapgit_url=&gt;host( iv_uri ).
      &lt;ls_auth&gt;-authorization = iv_auth.
    ENDIF.

  ENDMETHOD.
  METHOD clear.

    CLEAR gt_auth.

  ENDMETHOD.
  METHOD load.

    DATA: ls_auth LIKE LINE OF gt_auth.

    READ TABLE gt_auth INTO ls_auth WITH KEY uri = zcl_abapgit_url=&gt;host( iv_uri ).
    IF sy-subrc = 0.
      rv_authorization = ls_auth-authorization.

      IF NOT ii_client IS INITIAL.
        ii_client-&gt;request-&gt;set_header_field(
          name  = &apos;authorization&apos;
          value = ls_auth-authorization ).                  &quot;#EC NOTEXT
        ii_client-&gt;propertytype_logon_popup = ii_client-&gt;co_disabled.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD save.

    DATA: lv_auth TYPE string.

    lv_auth = ii_client-&gt;request-&gt;get_header_field( &apos;authorization&apos; ). &quot;#EC NOTEXT

    IF NOT lv_auth IS INITIAL.
      append( iv_uri  = iv_uri
              iv_auth = lv_auth ).
    ENDIF.

  ENDMETHOD.
  METHOD set.

    DATA: lv_concat TYPE string.

    ASSERT NOT iv_uri IS INITIAL.

    IF iv_username IS INITIAL OR iv_password IS INITIAL.
      RETURN.
    ENDIF.

    CONCATENATE iv_username &apos;:&apos; iv_password INTO lv_concat.

    rv_auth = cl_http_utility=&gt;if_http_utility~encode_base64( lv_concat ).

    CONCATENATE &apos;Basic&apos; rv_auth INTO rv_auth
      SEPARATED BY space ##NO_TEXT.

    append( iv_uri  = iv_uri
            iv_auth = rv_auth ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_log IMPLEMENTATION.
  METHOD add.

    FIELD-SYMBOLS: &lt;ls_log&gt; LIKE LINE OF mt_log.

    APPEND INITIAL LINE TO mt_log ASSIGNING &lt;ls_log&gt;.
    &lt;ls_log&gt;-msg  = iv_msg.
    &lt;ls_log&gt;-type = iv_type.
    &lt;ls_log&gt;-rc   = iv_rc.

  ENDMETHOD.
  METHOD add_error.

    add( iv_msg  = iv_msg
         iv_type = &apos;E&apos; ).

  ENDMETHOD.
  METHOD add_info.

    add( iv_msg  = iv_msg
         iv_type = &apos;I&apos; ).

  ENDMETHOD.
  METHOD add_warning.

    add( iv_msg  = iv_msg
         iv_type = &apos;W&apos; ).

  ENDMETHOD.
  METHOD clear.
    CLEAR mt_log.
  ENDMETHOD.
  METHOD count.
    rv_count = lines( mt_log ).
  ENDMETHOD.
  METHOD has_rc.
* todo, this method is only used in unit tests

    READ TABLE mt_log WITH KEY rc = iv_rc TRANSPORTING NO FIELDS.
    rv_yes = boolc( sy-subrc = 0 ).
  ENDMETHOD.
  METHOD prepare_log_for_display.

    DATA: ls_log TYPE ty_log_out.

    FIELD-SYMBOLS: &lt;ls_log&gt; TYPE ty_log.

    LOOP AT mt_log ASSIGNING &lt;ls_log&gt;.

      CLEAR: ls_log.

      ls_log-msg = &lt;ls_log&gt;-msg.

      CASE &lt;ls_log&gt;-type.
        WHEN &apos;E&apos; OR &apos;A&apos; OR &apos;X&apos;.
          ls_log-type = icon_led_red.
        WHEN &apos;W&apos;.
          ls_log-type = icon_led_yellow.
        WHEN &apos;I&apos; OR &apos;S&apos;.
          ls_log-type = icon_led_green.
        WHEN OTHERS.
          ls_log-type = icon_led_inactive.
      ENDCASE.

      INSERT ls_log INTO TABLE rt_log_out.

    ENDLOOP.

  ENDMETHOD.
  METHOD show.

    DATA: lt_log         TYPE tty_log_out,
          lo_alv         TYPE REF TO cl_salv_table,
          lx_error       TYPE REF TO cx_salv_error,
          lo_form_header TYPE REF TO cl_salv_form_header_info,
          lo_columns     TYPE REF TO cl_salv_columns_table,
          lo_column      TYPE REF TO cl_salv_column,
          lo_functions   TYPE REF TO cl_salv_functions_list.

    lt_log = prepare_log_for_display( ).

    TRY.
        cl_salv_table=&gt;factory(
          IMPORTING
            r_salv_table = lo_alv
          CHANGING
            t_table      = lt_log ).

        lo_functions = lo_alv-&gt;get_functions( ).
        lo_functions-&gt;set_all( ).

        lo_columns = lo_alv-&gt;get_columns( ).

        lo_columns-&gt;set_optimize( ).

        lo_column = lo_columns-&gt;get_column( |TYPE| ).
        lo_column-&gt;set_medium_text( |Type| ).

        lo_column = lo_columns-&gt;get_column( |MSG| ).
        lo_column-&gt;set_medium_text( |Message| ).

        lo_alv-&gt;set_screen_popup( start_column = 10
                                  end_column   = 120
                                  start_line   = 4
                                  end_line     = 20 ).

        CREATE OBJECT lo_form_header
          EXPORTING
            text = iv_header_text.

        lo_alv-&gt;set_top_of_list( lo_form_header ).

        lo_alv-&gt;display( ).

      CATCH cx_salv_error INTO lx_error.
        MESSAGE lx_error TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

  ENDMETHOD.
  METHOD to_html.

    DATA: lv_class TYPE string,
          lv_icon  TYPE string.

    FIELD-SYMBOLS: &lt;ls_log&gt; LIKE LINE OF mt_log.

    CREATE OBJECT ro_html.

    IF count( ) = 0.
      RETURN.
    ENDIF.

    LOOP AT mt_log ASSIGNING &lt;ls_log&gt;.
      CASE &lt;ls_log&gt;-type.
        WHEN &apos;W&apos;.
          lv_icon  = &apos;alert&apos;.
          lv_class = &apos;warning&apos;.
        WHEN &apos;E&apos;.
          lv_icon  = &apos;flame&apos;.
          lv_class = &apos;error&apos;.
        WHEN OTHERS. &quot; ??? unexpected
          lv_icon  = &apos;flame&apos;.
          lv_class = &apos;error&apos;.
      ENDCASE.

      ro_html-&gt;add( |&lt;span class=&quot;{ lv_class }&quot;&gt;| ).
      ro_html-&gt;add_icon( lv_icon ).
      ro_html-&gt;add( &lt;ls_log&gt;-msg ).
      ro_html-&gt;add( &apos;&lt;/span&gt;&apos; ).
    ENDLOOP.

  ENDMETHOD.
  METHOD write.

    DATA: ls_log  LIKE LINE OF mt_log,
          lv_text TYPE string.
    LOOP AT mt_log INTO ls_log.
      lv_text = |{ ls_log-type }: { ls_log-msg }|.
      WRITE: / lv_text.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_LANGUAGE IMPLEMENTATION.
  METHOD class_constructor.

    DATA lv_dummy TYPE string.

    GET LOCALE LANGUAGE gv_login_language COUNTRY lv_dummy MODIFIER lv_dummy.

  ENDMETHOD.
  METHOD restore_login_language.

    SET LOCALE LANGUAGE gv_login_language.

  ENDMETHOD.
  METHOD set_current_language.

    SET LOCALE LANGUAGE iv_language.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_HASH IMPLEMENTATION.
  METHOD adler32.

    CONSTANTS: lc_adler TYPE i VALUE 65521,
               lc_max_b TYPE i VALUE 1800000000.

    DATA: lv_index TYPE i,
          lv_a     TYPE i VALUE 1,
          lv_b     TYPE i VALUE 0,
          lv_x     TYPE x LENGTH 2,
          lv_ca    TYPE c LENGTH 4,
          lv_cb    TYPE c LENGTH 4,
          lv_char8 TYPE c LENGTH 8.
    DO xstrlen( iv_xstring ) TIMES.
      lv_index = sy-index - 1.

      lv_a = lv_a + iv_xstring+lv_index(1).
      lv_b = lv_b + lv_a.

* delay the MOD operation until the integer might overflow
* articles describe 5552 additions are allowed, but this assumes unsigned integers
* instead of allowing a fixed number of additions before running MOD, then
* just compare value of lv_b, this is 1 operation less than comparing and adding
      IF lv_b &gt; lc_max_b.
        lv_a = lv_a MOD lc_adler.
        lv_b = lv_b MOD lc_adler.
      ENDIF.
    ENDDO.

    lv_a = lv_a MOD lc_adler.
    lv_b = lv_b MOD lc_adler.

    lv_x = lv_a.
    lv_ca = lv_x.

    lv_x = lv_b.
    lv_cb = lv_x.

    CONCATENATE lv_cb lv_ca INTO lv_char8.

    rv_checksum = lv_char8.

  ENDMETHOD.
  METHOD sha1.

    DATA: lv_len     TYPE i,
          lv_char10  TYPE c LENGTH 10,
          lv_string  TYPE string,
          lv_xstring TYPE xstring.
    lv_len = xstrlen( iv_data ).
    lv_char10 = lv_len.
    CONDENSE lv_char10.
    CONCATENATE iv_type lv_char10 INTO lv_string SEPARATED BY space.
    lv_xstring = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

    lv_string = lv_xstring.
    CONCATENATE lv_string &apos;00&apos; INTO lv_string.
    lv_xstring = lv_string.

    CONCATENATE lv_xstring iv_data INTO lv_xstring IN BYTE MODE.

    rv_sha1 = sha1_raw( lv_xstring ).

  ENDMETHOD.
  METHOD sha1_raw.

    DATA: lv_hash TYPE hash160.
    CALL FUNCTION &apos;CALCULATE_HASH_FOR_RAW&apos;
      EXPORTING
        data           = iv_data
      IMPORTING
        hash           = lv_hash
      EXCEPTIONS
        unknown_alg    = 1
        param_error    = 2
        internal_error = 3
        OTHERS         = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error while calculating SHA1&apos; ).
    ENDIF.

    rv_sha1 = lv_hash.

    TRANSLATE rv_sha1 TO LOWER CASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_DIFF IMPLEMENTATION.
  METHOD calculate_line_num_and_stats.

    DATA: lv_new TYPE i VALUE 1,
          lv_old TYPE i VALUE 1.

    FIELD-SYMBOLS: &lt;ls_diff&gt; LIKE LINE OF mt_diff.
    LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.
      &lt;ls_diff&gt;-new_num = lv_new.
      &lt;ls_diff&gt;-old_num = lv_old.

      CASE &lt;ls_diff&gt;-result. &quot; Line nums
        WHEN zif_abapgit_definitions=&gt;c_diff-delete.
          lv_old = lv_old + 1.
          CLEAR &lt;ls_diff&gt;-new_num.
        WHEN zif_abapgit_definitions=&gt;c_diff-insert.
          lv_new = lv_new + 1.
          CLEAR &lt;ls_diff&gt;-old_num.
        WHEN OTHERS.
          lv_new = lv_new + 1.
          lv_old = lv_old + 1.
      ENDCASE.

      CASE &lt;ls_diff&gt;-result. &quot; Stats
        WHEN zif_abapgit_definitions=&gt;c_diff-insert.
          ms_stats-insert = ms_stats-insert + 1.
        WHEN zif_abapgit_definitions=&gt;c_diff-delete.
          ms_stats-delete = ms_stats-delete + 1.
        WHEN zif_abapgit_definitions=&gt;c_diff-update.
          ms_stats-update = ms_stats-update + 1.
      ENDCASE.

    ENDLOOP.

  ENDMETHOD.
  METHOD compute.

    DATA: lt_trdirtab_old TYPE TABLE OF trdir,
          lt_trdirtab_new TYPE TABLE OF trdir,
          lt_trdir_delta  TYPE TABLE OF xtrdir.
    CALL FUNCTION &apos;SVRS_COMPUTE_DELTA_REPS&apos;
      TABLES
        texttab_old  = it_old
        texttab_new  = it_new
        trdirtab_old = lt_trdirtab_old
        trdirtab_new = lt_trdirtab_new
        trdir_delta  = lt_trdir_delta
        text_delta   = rt_delta.

  ENDMETHOD.
  METHOD constructor.

    DATA: lt_delta TYPE vxabapt255_tab,
          lt_new   TYPE abaptxt255_tab,
          lt_old   TYPE abaptxt255_tab.
    unpack( EXPORTING iv_new = iv_new
                      iv_old = iv_old
            IMPORTING et_new = lt_new
                      et_old = lt_old ).

    lt_delta = compute( it_new = lt_new
                        it_old = lt_old ).

    mt_diff = render( it_new   = lt_new
                      it_old   = lt_old
                      it_delta = lt_delta ).

    calculate_line_num_and_stats( ).
    map_beacons( ).
    shortlist( ).

  ENDMETHOD.
  METHOD get.
    rt_diff = mt_diff.
  ENDMETHOD.
  METHOD map_beacons.

    DEFINE _add_regex.
      CREATE OBJECT lo_regex
        EXPORTING pattern     = &amp;1
                  ignore_case = abap_true ##NO_TEXT.
      APPEND lo_regex TO lt_regex_set.
    END-OF-DEFINITION.

    DATA: lv_beacon_idx  TYPE i,
          lv_offs        TYPE i,
          lv_beacon_str  TYPE string,
          lv_beacon_2lev TYPE string,
          lv_submatch    TYPE string,
          lo_regex       TYPE REF TO cl_abap_regex,
          lt_regex_set   TYPE TABLE OF REF TO cl_abap_regex.

    FIELD-SYMBOLS: &lt;ls_diff&gt; LIKE LINE OF mt_diff.
    _add_regex &apos;^\s*(CLASS|FORM|MODULE|REPORT|METHOD)\s&apos;.
    _add_regex &apos;^\s*START-OF-&apos;.
    _add_regex &apos;^\s*INITIALIZATION(\s|\.)&apos;.

    LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.

      CLEAR lv_offs.
      &lt;ls_diff&gt;-beacon = lv_beacon_idx.

      LOOP AT lt_regex_set INTO lo_regex. &quot;
        FIND FIRST OCCURRENCE OF REGEX lo_regex IN &lt;ls_diff&gt;-new SUBMATCHES lv_submatch.
        IF sy-subrc = 0. &quot; Match
          lv_beacon_str = &lt;ls_diff&gt;-new.
          lv_submatch = to_upper( lv_submatch ).

          &quot; Get rid of comments and end of line
          FIND FIRST OCCURRENCE OF &apos;.&apos; IN lv_beacon_str MATCH OFFSET lv_offs.
          IF sy-subrc &lt;&gt; 0.
            FIND FIRST OCCURRENCE OF &apos;&quot;&apos; IN lv_beacon_str MATCH OFFSET lv_offs.
          ENDIF.

          IF lv_offs &gt; 0.
            lv_beacon_str = lv_beacon_str(lv_offs).
          ENDIF.

          IF lv_submatch = &apos;CLASS&apos;.
            lv_beacon_2lev = lv_beacon_str.
          ELSEIF lv_submatch = &apos;METHOD&apos;.
            lv_beacon_str = lv_beacon_2lev &amp;&amp; ` =&gt; ` &amp;&amp; lv_beacon_str.
          ENDIF.

          APPEND lv_beacon_str TO mt_beacons.
          lv_beacon_idx    = sy-tabix.
          &lt;ls_diff&gt;-beacon = lv_beacon_idx.
          EXIT. &quot;Loop
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.
  METHOD render.

    DEFINE _append.
      CLEAR ls_diff.
      ls_diff-new    = &amp;1.
      ls_diff-result = &amp;2.
      ls_diff-old    = &amp;3.
      APPEND ls_diff TO rt_diff.
    END-OF-DEFINITION.

    DATA: lv_oindex TYPE i VALUE 1,
          lv_nindex TYPE i VALUE 1,
          ls_new    LIKE LINE OF it_new,
          ls_old    LIKE LINE OF it_old,
          ls_diff   LIKE LINE OF rt_diff,
          lt_delta  LIKE it_delta,
          ls_delta  LIKE LINE OF it_delta.
    lt_delta = it_delta.

    DO.
      READ TABLE lt_delta INTO ls_delta WITH KEY number = lv_oindex.
      IF sy-subrc = 0.
        DELETE lt_delta INDEX sy-tabix.

        CASE ls_delta-vrsflag.
          WHEN zif_abapgit_definitions=&gt;c_diff-delete.
            _append &apos;&apos; zif_abapgit_definitions=&gt;c_diff-delete ls_delta-line.
            lv_oindex = lv_oindex + 1.
          WHEN zif_abapgit_definitions=&gt;c_diff-insert.
            _append ls_delta-line zif_abapgit_definitions=&gt;c_diff-insert &apos;&apos;.
            lv_nindex = lv_nindex + 1.
          WHEN zif_abapgit_definitions=&gt;c_diff-update.
            CLEAR ls_new.
            READ TABLE it_new INTO ls_new INDEX lv_nindex.
            ASSERT sy-subrc = 0.
            _append ls_new zif_abapgit_definitions=&gt;c_diff-update ls_delta-line.
            lv_nindex = lv_nindex + 1.
            lv_oindex = lv_oindex + 1.
          WHEN OTHERS.
            ASSERT 0 = 1.
        ENDCASE.
      ELSE.
        CLEAR ls_new.
        READ TABLE it_new INTO ls_new INDEX lv_nindex.    &quot;#EC CI_SUBRC
        lv_nindex = lv_nindex + 1.
        CLEAR ls_old.
        READ TABLE it_old INTO ls_old INDEX lv_oindex.    &quot;#EC CI_SUBRC
        lv_oindex = lv_oindex + 1.
        _append ls_new &apos;&apos; ls_old.
      ENDIF.

      IF lv_nindex &gt; lines( it_new ) AND lv_oindex &gt; lines( it_old ).
        EXIT. &quot; current loop
      ENDIF.
    ENDDO.

  ENDMETHOD.
  METHOD set_patch_new.

    DATA: lv_new_num TYPE i.
    FIELD-SYMBOLS: &lt;ls_diff&gt; TYPE zif_abapgit_definitions=&gt;ty_diff.

    LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.

      lv_new_num = &lt;ls_diff&gt;-new_num.

      IF lv_new_num = iv_line_new.
        EXIT.
      ENDIF.

    ENDLOOP.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Invalid new line number { iv_line_new }| ).
    ENDIF.

    &lt;ls_diff&gt;-patch_flag = iv_patch_flag.

  ENDMETHOD.
  METHOD set_patch_old.

    DATA: lv_old_num TYPE i.
    FIELD-SYMBOLS: &lt;ls_diff&gt; TYPE zif_abapgit_definitions=&gt;ty_diff.

    LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.

      lv_old_num = &lt;ls_diff&gt;-old_num.

      IF lv_old_num = iv_line_old.
        EXIT.
      ENDIF.

    ENDLOOP.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Invalid old line number { iv_line_old }| ).
    ENDIF.

    &lt;ls_diff&gt;-patch_flag = iv_patch_flag.

  ENDMETHOD.
  METHOD shortlist.

    DATA: lv_index TYPE i.

    FIELD-SYMBOLS: &lt;ls_diff&gt; LIKE LINE OF mt_diff.

    IF lines( mt_diff ) &lt; 20.
      LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.
        &lt;ls_diff&gt;-short = abap_true.
      ENDLOOP.
    ELSE.
      LOOP AT mt_diff TRANSPORTING NO FIELDS
          WHERE NOT result IS INITIAL AND short = abap_false.
        lv_index = sy-tabix.

        DO 8 TIMES. &quot; Backward
          READ TABLE mt_diff INDEX ( lv_index - sy-index ) ASSIGNING &lt;ls_diff&gt;.
          IF sy-subrc &lt;&gt; 0 OR &lt;ls_diff&gt;-short = abap_true. &quot; tab bound or prev marker
            EXIT.
          ENDIF.
          &lt;ls_diff&gt;-short = abap_true.
        ENDDO.

        DO 8 TIMES. &quot; Forward
          READ TABLE mt_diff INDEX ( lv_index + sy-index - 1 ) ASSIGNING &lt;ls_diff&gt;.
          IF sy-subrc &lt;&gt; 0. &quot; tab bound reached
            EXIT.
          ENDIF.
          CHECK &lt;ls_diff&gt;-short = abap_false. &quot; skip marked
          &lt;ls_diff&gt;-short = abap_true.
        ENDDO.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD stats.
    rs_count = ms_stats.
  ENDMETHOD.
  METHOD unpack.

    DATA: lv_new TYPE string,
          lv_old TYPE string.
    lv_new = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_new ).
    lv_old = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_old ).

    SPLIT lv_new AT zif_abapgit_definitions=&gt;c_newline INTO TABLE et_new.
    SPLIT lv_old AT zif_abapgit_definitions=&gt;c_newline INTO TABLE et_old.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_CONVERT IMPLEMENTATION.
  METHOD bitbyte_to_int.

    DATA: lv_bitbyte TYPE string,
          lv_len     TYPE i,
          lv_offset  TYPE i.

    lv_bitbyte = iv_bits.
    SHIFT lv_bitbyte LEFT DELETING LEADING &apos;0 &apos;.
    lv_len     = strlen( lv_bitbyte ).
    lv_offset  = lv_len - 1.

    rv_int = 0.
    DO lv_len TIMES.

      IF sy-index = 1.

        &quot;Intialize
        CASE lv_bitbyte+lv_offset(1).
          WHEN &apos;1&apos;.
            rv_int = 1.
        ENDCASE.

      ELSE.
        CASE lv_bitbyte+lv_offset(1).
          WHEN &apos;1&apos;.
            rv_int = rv_int + ( 2 ** ( sy-index - 1 ) ).
        ENDCASE.
      ENDIF.

      lv_offset = lv_offset - 1. &quot;Move Cursor

    ENDDO.

  ENDMETHOD.
  METHOD int_to_xstring4.
* returns xstring of length 4 containing the integer value iv_i

    DATA: lv_x TYPE x LENGTH 4.
    lv_x = iv_i.
    rv_xstring = lv_x.

  ENDMETHOD.
  METHOD split_string.

    FIND FIRST OCCURRENCE OF cl_abap_char_utilities=&gt;cr_lf IN iv_string.

    &quot; Convert string into table depending on separator type CR_LF vs. LF
    IF sy-subrc = 0.
      SPLIT iv_string AT cl_abap_char_utilities=&gt;cr_lf INTO TABLE rt_lines.
    ELSE.
      SPLIT iv_string AT cl_abap_char_utilities=&gt;newline INTO TABLE rt_lines.
    ENDIF.

  ENDMETHOD.
  METHOD string_to_xstring_utf8.

    DATA: lo_obj TYPE REF TO cl_abap_conv_out_ce.
    TRY.
        lo_obj = cl_abap_conv_out_ce=&gt;create( encoding = &apos;UTF-8&apos; ).

        lo_obj-&gt;convert( EXPORTING data = iv_string
                         IMPORTING buffer = rv_xstring ).

      CATCH cx_parameter_invalid_range
            cx_sy_codepage_converter_init
            cx_sy_conversion_codepage
            cx_parameter_invalid_type.                  &quot;#EC NO_HANDLER
    ENDTRY.

  ENDMETHOD.
  METHOD xstring_to_int.

    DATA: lv_xstring TYPE xstring,
          lv_x       TYPE x.
    lv_xstring = iv_xstring.
    WHILE xstrlen( lv_xstring ) &gt; 0.
      lv_x = lv_xstring(1).
      rv_i = rv_i * 256 + lv_x.
      lv_xstring = lv_xstring+1.
    ENDWHILE.

  ENDMETHOD.
  METHOD xstring_to_string_utf8.

    DATA: lv_len TYPE i,
          lo_obj TYPE REF TO cl_abap_conv_in_ce.
    TRY.
        lo_obj = cl_abap_conv_in_ce=&gt;create(
            input    = iv_data
            encoding = &apos;UTF-8&apos; ).
        lv_len = xstrlen( iv_data ).

        lo_obj-&gt;read( EXPORTING n    = lv_len
                      IMPORTING data = rv_string ).

      CATCH cx_parameter_invalid_range
            cx_sy_codepage_converter_init
            cx_sy_conversion_codepage
            cx_parameter_invalid_type.                  &quot;#EC NO_HANDLER
    ENDTRY.

  ENDMETHOD.
  METHOD x_to_bitbyte.

    CLEAR rv_bitbyte.

    GET BIT 1 OF iv_x INTO rv_bitbyte+0(1).
    GET BIT 2 OF iv_x INTO rv_bitbyte+1(1).
    GET BIT 3 OF iv_x INTO rv_bitbyte+2(1).
    GET BIT 4 OF iv_x INTO rv_bitbyte+3(1).
    GET BIT 5 OF iv_x INTO rv_bitbyte+4(1).
    GET BIT 6 OF iv_x INTO rv_bitbyte+5(1).
    GET BIT 7 OF iv_x INTO rv_bitbyte+6(1).
    GET BIT 8 OF iv_x INTO rv_bitbyte+7(1).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_UI_INJECTOR IMPLEMENTATION.
  METHOD set_gui_functions.

    zcl_abapgit_ui_factory=&gt;gi_gui_functions = ii_gui_functions.

  ENDMETHOD.
  METHOD set_popups.

    zcl_abapgit_ui_factory=&gt;gi_popups = ii_popups.

  ENDMETHOD.
  METHOD set_tag_popups.

    zcl_abapgit_ui_factory=&gt;gi_tag_popups = ii_tag_popups.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_ui_factory IMPLEMENTATION.

  METHOD get_popups.

    IF gi_popups IS INITIAL.
      CREATE OBJECT gi_popups TYPE zcl_abapgit_popups.
    ENDIF.

    ri_popups = gi_popups.

  ENDMETHOD.
  METHOD get_tag_popups.

    IF gi_tag_popups IS INITIAL.
      CREATE OBJECT gi_tag_popups TYPE zcl_abapgit_tag_popups.
    ENDIF.

    ri_tag_popups = gi_tag_popups.

  ENDMETHOD.
  METHOD get_gui_functions.

    IF gi_gui_functions IS INITIAL.
      CREATE OBJECT gi_gui_functions TYPE zcl_abapgit_gui_functions.
    ENDIF.

    ri_gui_functions = gi_gui_functions.

  ENDMETHOD.

  METHOD get_gui.

    DATA:
          li_router    TYPE REF TO zif_abapgit_gui_router,
          li_asset_man TYPE REF TO zif_abapgit_gui_asset_manager.

    IF go_gui IS INITIAL.
      CREATE OBJECT li_router TYPE zcl_abapgit_gui_router.
      CREATE OBJECT li_asset_man TYPE zcl_abapgit_gui_asset_manager.
      CREATE OBJECT go_gui
        EXPORTING
          ii_router    = li_router
          ii_asset_man = li_asset_man.
    ENDIF.
    ro_gui = go_gui.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_TAG_POPUPS IMPLEMENTATION.
  METHOD clean_up.

    IF mo_text_control IS BOUND.

      mo_text_control-&gt;finalize( ).
      mo_text_control-&gt;free(
        EXCEPTIONS
          cntl_error        = 1
          cntl_system_error = 2
          OTHERS            = 3 ).
      ASSERT sy-subrc = 0.

      CLEAR: mo_text_control.

    ENDIF.

    IF mo_docking_container IS BOUND.

      mo_docking_container-&gt;finalize( ).
      mo_docking_container-&gt;free(
        EXCEPTIONS
          cntl_error        = 1
          cntl_system_error = 2
          OTHERS            = 3 ).
      ASSERT sy-subrc = 0.

      CLEAR: mo_docking_container.

    ENDIF.

  ENDMETHOD.
  METHOD on_double_click.

    FIELD-SYMBOLS: &lt;ls_tag&gt; TYPE zcl_abapgit_tag_popups=&gt;ty_tag_out.

    READ TABLE mt_tags ASSIGNING &lt;ls_tag&gt;
                       INDEX row.
    IF sy-subrc &lt;&gt; 0 OR &lt;ls_tag&gt;-body IS INITIAL.
      RETURN.
    ENDIF.

    show_docking_container_with( &lt;ls_tag&gt;-body ).

  ENDMETHOD.
  METHOD prepare_tags_for_display.

    DATA: ls_tag_out LIKE LINE OF rt_tags_out.

    FIELD-SYMBOLS: &lt;ls_tag&gt; TYPE zif_abapgit_definitions=&gt;ty_git_tag.

    LOOP AT it_tags ASSIGNING &lt;ls_tag&gt;.

      CLEAR: ls_tag_out.

      MOVE-CORRESPONDING &lt;ls_tag&gt; TO ls_tag_out.

      ls_tag_out-name = zcl_abapgit_tag=&gt;remove_tag_prefix( ls_tag_out-name ).

      IF ls_tag_out-body IS NOT INITIAL.
        ls_tag_out-body_icon = |{ icon_display_text }|.
      ENDIF.

      INSERT ls_tag_out INTO TABLE rt_tags_out.

    ENDLOOP.

  ENDMETHOD.
  METHOD show_docking_container_with.

    IF mo_docking_container IS NOT BOUND.

      CREATE OBJECT mo_docking_container
        EXPORTING
          side                        = cl_gui_docking_container=&gt;dock_at_bottom
          extension                   = 120
        EXCEPTIONS
          cntl_error                  = 1
          cntl_system_error           = 2
          create_error                = 3
          lifetime_error              = 4
          lifetime_dynpro_dynpro_link = 5
          OTHERS                      = 6.
      ASSERT sy-subrc = 0.

    ENDIF.

    IF mo_text_control IS NOT BOUND.
      CREATE OBJECT mo_text_control
        EXPORTING
          parent                 = mo_docking_container
        EXCEPTIONS
          error_cntl_create      = 1
          error_cntl_init        = 2
          error_cntl_link        = 3
          error_dp_create        = 4
          gui_type_not_supported = 5
          OTHERS                 = 6.
      ASSERT sy-subrc = 0.

      mo_text_control-&gt;set_readonly_mode(
        EXCEPTIONS
          error_cntl_call_method = 1
          invalid_parameter      = 2
          OTHERS                 = 3 ).
      ASSERT sy-subrc = 0.

    ENDIF.

    mo_text_control-&gt;set_textstream(
      EXPORTING
        text                   = iv_text
      EXCEPTIONS
        error_cntl_call_method = 1
        not_supported_by_gui   = 2
        OTHERS                 = 3 ).
    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD zif_abapgit_tag_popups~tag_list_popup.

    DATA: lo_alv          TYPE REF TO cl_salv_table,
          lo_table_header TYPE REF TO cl_salv_form_header_info,
          lo_columns      TYPE REF TO cl_salv_columns_table,
          lx_alv          TYPE REF TO cx_salv_error,
          lt_tags         TYPE zif_abapgit_definitions=&gt;ty_git_tag_list_tt,
          lo_event        TYPE REF TO cl_salv_events_table.

    CLEAR: mt_tags.

    lt_tags = zcl_abapgit_factory=&gt;get_branch_overview( io_repo )-&gt;get_tags( ).

    IF lines( lt_tags ) = 0.
      zcx_abapgit_exception=&gt;raise( `There are no tags for this repository` ).
    ENDIF.

    mt_tags = prepare_tags_for_display( lt_tags ).

    TRY.
        cl_salv_table=&gt;factory(
          IMPORTING
            r_salv_table   = lo_alv
          CHANGING
            t_table        = mt_tags ).

        lo_columns = lo_alv-&gt;get_columns( ).

        lo_columns-&gt;get_column( `TYPE` )-&gt;set_technical( ).
        lo_columns-&gt;get_column( `DISPLAY_NAME` )-&gt;set_technical( ).
        lo_columns-&gt;get_column( `BODY` )-&gt;set_technical( ).

        lo_columns-&gt;get_column( `NAME` )-&gt;set_medium_text( &apos;Tag name&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;NAME&apos;
                                         position   = 1 ).

        lo_columns-&gt;get_column( `TAGGER_NAME` )-&gt;set_medium_text( &apos;Tagger&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;TAGGER_NAME&apos;
                                         position   = 2 ).

        lo_columns-&gt;get_column( `TAGGER_EMAIL` )-&gt;set_medium_text( &apos;Tagger E-Mail&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;TAGGER_EMAIL&apos;
                                         position   = 3 ).

        lo_columns-&gt;get_column( `MESSAGE` )-&gt;set_medium_text( &apos;Tag message&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;MESSAGE&apos;
                                         position   = 4 ).

        lo_columns-&gt;get_column( `BODY_ICON` )-&gt;set_medium_text( &apos;Body&apos; ).
        lo_columns-&gt;get_column( `BODY_ICON` )-&gt;set_output_length( 4 ).
        lo_columns-&gt;set_column_position( columnname = &apos;BODY_ICON&apos;
                                         position   = 5 ).

        lo_columns-&gt;get_column( `SHA1` )-&gt;set_output_length( 15 ).
        lo_columns-&gt;get_column( `SHA1` )-&gt;set_medium_text( &apos;SHA&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;SHA1&apos;
                                         position   = 6 ).

        lo_columns-&gt;get_column( `OBJECT` )-&gt;set_output_length( 15 ).
        lo_columns-&gt;get_column( `OBJECT` )-&gt;set_medium_text( &apos;Object&apos; ).
        lo_columns-&gt;set_column_position( columnname = &apos;OBJECT&apos;
                                         position   = 7 ).

        lo_columns-&gt;set_optimize( ).

        lo_alv-&gt;set_screen_popup( start_column = 7
                                  end_column   = 200
                                  start_line   = 1
                                  end_line     = 25 ).

        CREATE OBJECT lo_table_header
          EXPORTING
            text = `Tags`.

        lo_alv-&gt;set_top_of_list( lo_table_header ).

        lo_event = lo_alv-&gt;get_event( ).

        SET HANDLER on_double_click FOR lo_event.

        lo_alv-&gt;display( ).

      CATCH cx_salv_error INTO lx_alv.
        zcx_abapgit_exception=&gt;raise( lx_alv-&gt;get_text( ) ).
    ENDTRY.

    clean_up( ).

  ENDMETHOD.
  METHOD zif_abapgit_tag_popups~tag_select_popup.

    DATA: lt_tags             TYPE zif_abapgit_definitions=&gt;ty_git_tag_list_tt,
          lv_answer           TYPE c LENGTH 1,
          lt_selection        TYPE TABLE OF spopli,
          lv_name_with_prefix TYPE string.

    FIELD-SYMBOLS: &lt;ls_sel&gt; LIKE LINE OF lt_selection,
                   &lt;ls_tag&gt; LIKE LINE OF lt_tags.

    lt_tags = zcl_abapgit_factory=&gt;get_branch_overview( io_repo )-&gt;get_tags( ).

    IF lines( lt_tags ) = 0.
      zcx_abapgit_exception=&gt;raise( `There are no tags for this repository` ).
    ENDIF.

    LOOP AT lt_tags ASSIGNING &lt;ls_tag&gt;.

      INSERT INITIAL LINE INTO lt_selection INDEX 1 ASSIGNING &lt;ls_sel&gt;.
      &lt;ls_sel&gt;-varoption = zcl_abapgit_tag=&gt;remove_tag_prefix( &lt;ls_tag&gt;-name ).

    ENDLOOP.

    CALL FUNCTION &apos;POPUP_TO_DECIDE_LIST&apos;
      EXPORTING
        textline1          = &apos;Select tag&apos;
        titel              = &apos;Select tag&apos;
        start_col          = 30
        start_row          = 5
      IMPORTING
        answer             = lv_answer
      TABLES
        t_spopli           = lt_selection
      EXCEPTIONS
        not_enough_answers = 1
        too_much_answers   = 2
        too_much_marks     = 3
        OTHERS             = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_TO_DECIDE_LIST&apos; ).
    ENDIF.

    IF lv_answer = &apos;A&apos;.
      RETURN.
    ENDIF.

    READ TABLE lt_selection ASSIGNING &lt;ls_sel&gt; WITH KEY selflag = abap_true.
    ASSERT sy-subrc = 0.

    lv_name_with_prefix = zcl_abapgit_tag=&gt;add_tag_prefix( &lt;ls_sel&gt;-varoption ).

    READ TABLE lt_tags ASSIGNING &lt;ls_tag&gt; WITH KEY name = lv_name_with_prefix.
    ASSERT sy-subrc = 0.

    rs_tag = &lt;ls_tag&gt;.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SERVICES_REPO IMPLEMENTATION.
  METHOD gui_deserialize.

    DATA: ls_checks       TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks,
          lt_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt.
* find troublesome objects
    ls_checks = io_repo-&gt;deserialize_checks( ).

* and let the user decide what to do
    TRY.
        popup_overwrite( CHANGING ct_overwrite = ls_checks-overwrite ).
        popup_package_overwrite( CHANGING ct_overwrite = ls_checks-warning_package ).

        IF ls_checks-requirements-met = &apos;N&apos;.
          lt_requirements = io_repo-&gt;get_dot_abapgit( )-&gt;get_data( )-requirements.
          zcl_abapgit_requirement_helper=&gt;requirements_popup( lt_requirements ).
          ls_checks-requirements-decision = &apos;Y&apos;.
        ENDIF.

        IF ls_checks-transport-required = abap_true.
          ls_checks-transport-transport = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_transport_request(
            is_transport_type = ls_checks-transport-type ).
        ENDIF.

      CATCH zcx_abapgit_cancel.
        RETURN.
    ENDTRY.

* and pass decisions to deserialize
    io_repo-&gt;deserialize( ls_checks ).

  ENDMETHOD.
  METHOD new_offline.

    DATA: lo_repo  TYPE REF TO zcl_abapgit_repo,
          ls_popup TYPE zif_abapgit_popups=&gt;ty_popup.

    ls_popup  = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;repo_new_offline( ).
    IF ls_popup-cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;new_offline(
      iv_url     = ls_popup-url
      iv_package = ls_popup-package ).
    lo_repo-&gt;rebuild_local_checksums( ).

    zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( lo_repo-&gt;get_key( ) ). &quot; Set default repo for user
    toggle_favorite( lo_repo-&gt;get_key( ) ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD new_online.

    DATA: ls_popup TYPE zif_abapgit_popups=&gt;ty_popup.

    ls_popup = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;repo_popup( iv_url ).
    IF ls_popup-cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    ro_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;new_online(
      iv_url         = ls_popup-url
      iv_branch_name = ls_popup-branch_name
      iv_package     = ls_popup-package ).

    toggle_favorite( ro_repo-&gt;get_key( ) ).

* Set default repo for user
    zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( ro_repo-&gt;get_key( ) ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD open_se80.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation       = &apos;SHOW&apos;
        in_new_window   = abap_true
        object_name     = iv_package
        object_type     = &apos;DEVC&apos;
        with_objectlist = abap_true.

  ENDMETHOD.
  METHOD popup_overwrite.

    DATA: lt_columns  TYPE stringtab,
          lt_selected LIKE ct_overwrite,
          lv_column   LIKE LINE OF lt_columns,
          li_popups   TYPE REF TO zif_abapgit_popups.

    FIELD-SYMBOLS: &lt;ls_overwrite&gt; LIKE LINE OF ct_overwrite.
    IF lines( ct_overwrite ) = 0.
      RETURN.
    ENDIF.

    lv_column = &apos;OBJ_TYPE&apos;.
    INSERT lv_column INTO TABLE lt_columns.
    lv_column = &apos;OBJ_NAME&apos;.
    INSERT lv_column INTO TABLE lt_columns.

    li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
    li_popups-&gt;popup_to_select_from_list(
      EXPORTING
        it_list               = ct_overwrite
        iv_header_text         = |The following Objects have been modified locally.|
                            &amp;&amp; | Select the Objects which should be overwritten.|
        iv_select_column_text  = &apos;Overwrite?&apos;
        it_columns_to_display = lt_columns
      IMPORTING
        et_list               = lt_selected ).

    LOOP AT ct_overwrite ASSIGNING &lt;ls_overwrite&gt;.
      READ TABLE lt_selected WITH KEY
        obj_type = &lt;ls_overwrite&gt;-obj_type
        obj_name = &lt;ls_overwrite&gt;-obj_name
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        &lt;ls_overwrite&gt;-decision = &apos;Y&apos;.
      ELSE.
        &lt;ls_overwrite&gt;-decision = &apos;N&apos;.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD popup_package_overwrite.

    DATA: lv_question TYPE c LENGTH 200,
          lv_answer   TYPE c.

    FIELD-SYMBOLS: &lt;ls_overwrite&gt; LIKE LINE OF ct_overwrite.
    IF lines( ct_overwrite ) = 0.
      RETURN.
    ENDIF.

    LOOP AT ct_overwrite ASSIGNING &lt;ls_overwrite&gt;.
      CONCATENATE &apos;Overwrite object&apos; &lt;ls_overwrite&gt;-obj_type &lt;ls_overwrite&gt;-obj_name
        &apos;from package&apos; &lt;ls_overwrite&gt;-devclass
        INTO lv_question SEPARATED BY space.                &quot;#EC NOTEXT

      lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
        iv_titlebar              = &apos;Warning&apos;
        iv_text_question         = lv_question
        iv_text_button_1         = &apos;Ok&apos;
        iv_icon_button_1         = &apos;ICON_DELETE&apos;
        iv_text_button_2         = &apos;Cancel&apos;
        iv_icon_button_2         = &apos;ICON_CANCEL&apos;
        iv_default_button        = &apos;2&apos;
        iv_display_cancel_button = abap_false ).               &quot;#EC NOTEXT

      IF lv_answer = &apos;2&apos;.
        RAISE EXCEPTION TYPE zcx_abapgit_cancel.
      ENDIF.

* todo, let the user decide yes/no/cancel
      &lt;ls_overwrite&gt;-decision = &apos;Y&apos;.

    ENDLOOP.

  ENDMETHOD.
  METHOD purge.

    DATA: lt_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lv_answer   TYPE c LENGTH 1,
          lo_repo     TYPE REF TO zcl_abapgit_repo,
          lv_package  TYPE devclass,
          lv_question TYPE c LENGTH 100,
          ls_checks   TYPE zif_abapgit_definitions=&gt;ty_delete_checks.
    lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    lv_package = lo_repo-&gt;get_package( ).
    lt_tadir   = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read( lv_package ).

    IF lines( lt_tadir ) &gt; 0.

      lv_question = |This will DELETE all objects in package { lv_package
        } ({ lines( lt_tadir ) } objects) from the system|. &quot;#EC NOTEXT

      lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
        iv_titlebar              = &apos;Uninstall&apos;
        iv_text_question         = lv_question
        iv_text_button_1         = &apos;Delete&apos;
        iv_icon_button_1         = &apos;ICON_DELETE&apos;
        iv_text_button_2         = &apos;Cancel&apos;
        iv_icon_button_2         = &apos;ICON_CANCEL&apos;
        iv_default_button        = &apos;2&apos;
        iv_display_cancel_button = abap_false ).               &quot;#EC NOTEXT

      IF lv_answer = &apos;2&apos;.
        RAISE EXCEPTION TYPE zcx_abapgit_cancel.
      ENDIF.

    ENDIF.

    ls_checks = lo_repo-&gt;delete_checks( ).
    IF ls_checks-transport-required = abap_true.
      ls_checks-transport-transport = zcl_abapgit_ui_factory=&gt;get_popups(
                                        )-&gt;popup_transport_request(  ls_checks-transport-type ).
    ENDIF.

    zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;purge( io_repo   = lo_repo
                                                  is_checks = ls_checks ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD refresh.

    zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key )-&gt;refresh( ).

  ENDMETHOD.
  METHOD refresh_local_checksums.

    DATA: lv_answer   TYPE c,
          lv_question TYPE string,
          lo_repo     TYPE REF TO zcl_abapgit_repo.
    IF zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-update_local_checksum ) = abap_false.
      zcx_abapgit_exception=&gt;raise( &apos;Not authorized&apos; ).
    ENDIF.

    lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    lv_question =  &apos;This will rebuild and overwrite local repo checksums.&apos;.

    IF lo_repo-&gt;is_offline( ) = abap_false.
      lv_question = lv_question
                &amp;&amp; &apos; The logic: if local and remote file differs then:&apos;
                &amp;&amp; &apos; if remote branch is ahead then assume changes are remote,&apos;
                &amp;&amp; &apos; else (branches are equal) assume changes are local.&apos;
                &amp;&amp; &apos; This will lead to incorrect state for files changed on both sides.&apos;
                &amp;&amp; &apos; Please make sure you don&apos;&apos;t have ones like that.&apos;.
    ENDIF.

    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = &apos;Warning&apos;
      iv_text_question         = lv_question
      iv_text_button_1         = &apos;OK&apos;
      iv_icon_button_1         = &apos;ICON_DELETE&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_icon_button_2         = &apos;ICON_CANCEL&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).                 &quot;#EC NOTEXT

    IF lv_answer = &apos;2&apos;.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lo_repo-&gt;rebuild_local_checksums( ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD remote_attach.

    DATA: ls_popup TYPE zif_abapgit_popups=&gt;ty_popup,
          lo_repo  TYPE REF TO zcl_abapgit_repo_online.

    ls_popup = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;repo_popup(
      iv_title          = &apos;Attach repo to remote ...&apos;
      iv_url            = &apos;&apos;
      iv_package        = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key )-&gt;get_package( )
      iv_freeze_package = abap_true ).
    IF ls_popup-cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key )-&gt;switch_repo_type( iv_offline = abap_false ).
    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    lo_repo-&gt;set_url( ls_popup-url ).
    lo_repo-&gt;set_branch_name( ls_popup-branch_name ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD remote_change.

    DATA: ls_popup TYPE zif_abapgit_popups=&gt;ty_popup,
          lo_repo  TYPE REF TO zcl_abapgit_repo_online.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    ls_popup = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;repo_popup(
      iv_title          = &apos;Change repo remote ...&apos;
      iv_url            = lo_repo-&gt;get_url( )
      iv_package        = lo_repo-&gt;get_package( )
      iv_freeze_package = abap_true ).
    IF ls_popup-cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    lo_repo-&gt;set_url( ls_popup-url ).
    lo_repo-&gt;set_branch_name( ls_popup-branch_name ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD remote_detach.

    DATA: lv_answer TYPE c LENGTH 1.

    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = &apos;Make repository OFF-line&apos;
      iv_text_question         = &apos;This will detach the repo from remote and make it OFF-line&apos;
      iv_text_button_1         = &apos;Make OFF-line&apos;
      iv_icon_button_1         = &apos;ICON_WF_UNLINK&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_icon_button_2         = &apos;ICON_CANCEL&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).                 &quot;#EC NOTEXT

    IF lv_answer = &apos;2&apos;.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key )-&gt;switch_repo_type( iv_offline = abap_true ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD remove.

    DATA: lv_answer   TYPE c LENGTH 1,
          lo_repo     TYPE REF TO zcl_abapgit_repo,
          lv_package  TYPE devclass,
          lv_question TYPE c LENGTH 200.
    lo_repo     = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    lv_package  = lo_repo-&gt;get_package( ).
    lv_question = |This will remove the repository reference to the package { lv_package
      }. All objects will safely remain in the system.|.

    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = &apos;Remove&apos;
      iv_text_question         = lv_question
      iv_text_button_1         = &apos;Remove&apos;
      iv_icon_button_1         = &apos;ICON_WF_UNLINK&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_icon_button_2         = &apos;ICON_CANCEL&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).                 &quot;#EC NOTEXT

    IF lv_answer = &apos;2&apos;.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;delete( lo_repo ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD toggle_favorite.

    zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;toggle_favorite( iv_key ).

  ENDMETHOD.
  METHOD transport_to_branch.

    DATA:
      lo_repository          TYPE REF TO zcl_abapgit_repo_online,
      lo_transport_to_branch TYPE REF TO zcl_abapgit_transport_2_branch,
      lt_transport_headers   TYPE trwbo_request_headers,
      lt_transport_objects   TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
      ls_transport_to_branch TYPE zif_abapgit_definitions=&gt;ty_transport_to_branch.
    IF zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-transport_to_branch ) = abap_false.
      zcx_abapgit_exception=&gt;raise( &apos;Not authorized&apos; ).
    ENDIF.

    lo_repository ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_repository_key ).

    lt_transport_headers = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_select_transports( ).
    lt_transport_objects = zcl_abapgit_transport=&gt;to_tadir( lt_transport_headers ).
    IF lt_transport_objects IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Canceled or List of objects is empty &apos; ).
    ENDIF.

    ls_transport_to_branch = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_create_transp_branch(
      lt_transport_headers ).

    CREATE OBJECT lo_transport_to_branch.
    lo_transport_to_branch-&gt;create(
      io_repository          = lo_repository
      is_transport_to_branch = ls_transport_to_branch
      it_transport_objects   = lt_transport_objects ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SERVICES_GIT IMPLEMENTATION.
  METHOD commit.

    DATA: ls_comment TYPE zif_abapgit_definitions=&gt;ty_comment,
          li_user    TYPE REF TO zif_abapgit_persist_user.

    li_user = zcl_abapgit_persistence_user=&gt;get_instance( ).
    li_user-&gt;set_repo_git_user_name( iv_url      = io_repo-&gt;get_url( )
                                     iv_username = is_commit-committer_name ).
    li_user-&gt;set_repo_git_user_email( iv_url     = io_repo-&gt;get_url( )
                                      iv_email   = is_commit-committer_email ).

    IF is_commit-committer_name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Commit: Committer name empty&apos; ).
    ELSEIF is_commit-committer_email IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Commit: Committer email empty&apos; ).
    ELSEIF is_commit-author_email IS NOT INITIAL AND is_commit-author_name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Commit: Author name empty&apos; ). &quot; Opposite should be OK ?
    ELSEIF is_commit-comment IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Commit: empty comment&apos; ).
    ENDIF.

    ls_comment-committer-name  = is_commit-committer_name.
    ls_comment-committer-email = is_commit-committer_email.
    ls_comment-author-name     = is_commit-author_name.
    ls_comment-author-email    = is_commit-author_email.
    ls_comment-comment         = is_commit-comment.

    IF NOT is_commit-body IS INITIAL.
      CONCATENATE ls_comment-comment &apos;&apos; is_commit-body
        INTO ls_comment-comment SEPARATED BY zif_abapgit_definitions=&gt;c_newline.
    ENDIF.

    io_repo-&gt;push( is_comment = ls_comment
                   io_stage   = io_stage ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD create_branch.

    DATA: lv_name   TYPE string,
          lv_cancel TYPE abap_bool,
          lo_repo   TYPE REF TO zcl_abapgit_repo_online,
          li_popups TYPE REF TO zif_abapgit_popups.
    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
    li_popups-&gt;create_branch_popup(
      IMPORTING
        ev_name   = lv_name
        ev_cancel = lv_cancel ).
    IF lv_cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lo_repo-&gt;create_branch( lv_name ).

    MESSAGE &apos;Switched to new branch&apos; TYPE &apos;S&apos; ##NO_TEXT.

  ENDMETHOD.
  METHOD delete_branch.

    DATA: lo_repo   TYPE REF TO zcl_abapgit_repo_online,
          ls_branch TYPE zif_abapgit_definitions=&gt;ty_git_branch,
          lo_popups TYPE REF TO zif_abapgit_popups.
    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    lo_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
    ls_branch = lo_popups-&gt;branch_list_popup( iv_url         = lo_repo-&gt;get_url( )
                                              iv_hide_branch = lo_repo-&gt;get_branch_name( )
                                              iv_hide_head   = abap_true ).
    IF ls_branch IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_git_porcelain=&gt;delete_branch(
      iv_url    = lo_repo-&gt;get_url( )
      is_branch = ls_branch ).

    MESSAGE &apos;Branch deleted&apos; TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD delete_tag.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online,
          ls_tag  TYPE zif_abapgit_definitions=&gt;ty_git_tag,
          lv_text TYPE string.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    ls_tag = zcl_abapgit_ui_factory=&gt;get_tag_popups( )-&gt;tag_select_popup( lo_repo ).
    IF ls_tag IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_git_porcelain=&gt;delete_tag(
      iv_url = lo_repo-&gt;get_url( )
      is_tag = ls_tag ).

    lv_text = |Tag { zcl_abapgit_tag=&gt;remove_tag_prefix( ls_tag-name ) } deleted| ##NO_TEXT.

    MESSAGE lv_text TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD pull.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo.

    lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    lo_repo-&gt;refresh( ).

    zcl_abapgit_services_repo=&gt;gui_deserialize( lo_repo ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD reset.

    DATA: lo_repo                   TYPE REF TO zcl_abapgit_repo,
          lv_answer                 TYPE c LENGTH 1,
          lt_unnecessary_local_objs TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lt_selected               LIKE lt_unnecessary_local_objs,
          lt_columns                TYPE stringtab,
          ls_checks                 TYPE zif_abapgit_definitions=&gt;ty_delete_checks,
          li_popups                 TYPE REF TO zif_abapgit_popups.

    lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    IF lo_repo-&gt;get_local_settings( )-write_protected = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot reset. Local code is write-protected by repo config&apos; ).
    ENDIF.

* todo, separate UI and logic
    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = &apos;Warning&apos;
      iv_text_question         = &apos;Reset local objects?&apos;
      iv_text_button_1         = &apos;Ok&apos;
      iv_icon_button_1         = &apos;ICON_OKAY&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_icon_button_2         = &apos;ICON_CANCEL&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).                 &quot;#EC NOTEXT

    IF lv_answer = &apos;2&apos;.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lt_unnecessary_local_objs = lo_repo-&gt;get_unnecessary_local_objs( ).

    IF lines( lt_unnecessary_local_objs ) &gt; 0.

      INSERT `OBJECT` INTO TABLE lt_columns.
      INSERT `OBJ_NAME` INTO TABLE lt_columns.

      li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
      li_popups-&gt;popup_to_select_from_list(
        EXPORTING
          it_list              = lt_unnecessary_local_objs
          iv_header_text        = |Which unnecessary objects should be deleted?|
          iv_select_column_text = &apos;Delete?&apos;
          it_columns_to_display = lt_columns
        IMPORTING
          et_list              = lt_selected ).

      IF lines( lt_selected ) &gt; 0.
        ls_checks = lo_repo-&gt;delete_checks( ).
        IF ls_checks-transport-required = abap_true.
          ls_checks-transport-transport = zcl_abapgit_ui_factory=&gt;get_popups(
                                            )-&gt;popup_transport_request( ls_checks-transport-type ).
        ENDIF.

        zcl_abapgit_objects=&gt;delete( it_tadir  = lt_selected
                                     is_checks = ls_checks ).
* update repo cache
        lo_repo-&gt;refresh( ).
      ENDIF.

    ENDIF.

    zcl_abapgit_services_repo=&gt;gui_deserialize( lo_repo ).

  ENDMETHOD.
  METHOD switch_branch.

    DATA: lo_repo   TYPE REF TO zcl_abapgit_repo_online,
          ls_branch TYPE zif_abapgit_definitions=&gt;ty_git_branch.
    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    ls_branch = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;branch_list_popup(
      iv_url             = lo_repo-&gt;get_url( )
      iv_default_branch  = lo_repo-&gt;get_branch_name( )
      iv_show_new_option = abap_true ).
    IF ls_branch IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    IF ls_branch-name = zif_abapgit_popups=&gt;c_new_branch_label.
      create_branch( iv_key ).
      RETURN.
    ENDIF.

    lo_repo-&gt;set_branch_name( ls_branch-name ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD switch_tag.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online,
          ls_tag  TYPE zif_abapgit_definitions=&gt;ty_git_tag.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    ls_tag = zcl_abapgit_ui_factory=&gt;get_tag_popups( )-&gt;tag_select_popup( lo_repo ).
    IF ls_tag IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    lo_repo-&gt;set_branch_name( ls_tag-name ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD tag_overview.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).

    zcl_abapgit_ui_factory=&gt;get_tag_popups( )-&gt;tag_list_popup( lo_repo ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_services_abapgit IMPLEMENTATION.
  METHOD do_install.

    DATA: lo_repo   TYPE REF TO zcl_abapgit_repo_online,
          lv_answer TYPE c LENGTH 1.
    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = iv_title
      iv_text_question         = iv_text
      iv_text_button_1         = &apos;Continue&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).              &quot;#EC NOTEXT

    IF lv_answer &lt;&gt; &apos;1&apos;.
      RETURN.
    ENDIF.

    IF abap_false = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;is_repo_installed(
        iv_url              = iv_url
        iv_target_package   = iv_package ).

      zcl_abapgit_factory=&gt;get_sap_package( iv_package )-&gt;create_local( ).

      lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;new_online(
        iv_url         = iv_url
        iv_branch_name = &apos;refs/heads/master&apos;
        iv_package     = iv_package ) ##NO_TEXT.

      zcl_abapgit_services_repo=&gt;gui_deserialize( lo_repo ).

      zcl_abapgit_services_repo=&gt;toggle_favorite( lo_repo-&gt;get_key( ) ).
    ENDIF.

    COMMIT WORK.

  ENDMETHOD.
  METHOD install_abapgit.

    CONSTANTS lc_title TYPE c LENGTH 40 VALUE &apos;Install abapGit&apos;.
    DATA lv_text       TYPE c LENGTH 100.

    IF is_installed( ) = abap_true.
      lv_text = &apos;Seems like abapGit package is already installed. No changes to be done&apos;.
      zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_inform(
        iv_titlebar              = lc_title
        iv_text_message          = lv_text ).
      RETURN.
    ENDIF.

    lv_text = |Confirm to install current version of abapGit to package { c_package_abapgit }|.

    do_install( iv_title   = lc_title
                iv_text    = lv_text
                iv_url     = c_abapgit_url
                iv_package = c_package_abapgit ).

  ENDMETHOD.

  METHOD is_installed.

    DATA: ls_item TYPE zif_abapgit_definitions=&gt;ty_item.

    ls_item-obj_type = &apos;TRAN&apos;.
    ls_item-obj_name = c_abapgit_tcode.
    rv_installed = zcl_abapgit_objects=&gt;exists( ls_item ).

  ENDMETHOD.

  METHOD open_abapgit_homepage.

    cl_gui_frontend_services=&gt;execute(
      EXPORTING document = c_abapgit_homepage
      EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Opening page in external browser failed.&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD open_abapgit_wikipage.

    cl_gui_frontend_services=&gt;execute(
      EXPORTING document = c_abapgit_wikipage
      EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Opening page in external browser failed.&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD prepare_gui_startup.

    DATA: lv_repo_key    TYPE zif_abapgit_persistence=&gt;ty_value,
          lv_package     TYPE devclass,
          lv_package_adt TYPE devclass.

    IF zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( )-&gt;get_show_default_repo( ) = abap_false.
      &quot; Don&apos;t show the last seen repo at startup
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( || ).
    ENDIF.

    &quot; We have three special cases for gui startup
    &quot;   - open a specific repo by repo key
    &quot;   - open a specific repo by package name
    &quot;   - open a specific repo by package name provided by ADT
    &quot; These overrule the last shown repo

    GET PARAMETER ID zif_abapgit_definitions=&gt;c_spagpa_param_repo_key FIELD lv_repo_key.
    GET PARAMETER ID zif_abapgit_definitions=&gt;c_spagpa_param_package  FIELD lv_package.
    lv_package_adt = get_package_from_adt( ).

    IF lv_repo_key IS NOT INITIAL.

      SET PARAMETER ID zif_abapgit_definitions=&gt;c_spagpa_param_repo_key FIELD &apos;&apos;.
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( lv_repo_key ).

    ELSEIF lv_package IS NOT INITIAL.

      SET PARAMETER ID zif_abapgit_definitions=&gt;c_spagpa_param_package FIELD &apos;&apos;.
      set_start_repo_from_package( lv_package ).

    ELSEIF lv_package_adt IS NOT INITIAL.

      set_start_repo_from_package( lv_package_adt ).

    ENDIF.

  ENDMETHOD.
  METHOD set_start_repo_from_package.

    DATA: lo_repo          TYPE REF TO zcl_abapgit_repo,
          lt_r_package     TYPE RANGE OF devclass,
          ls_r_package     LIKE LINE OF lt_r_package,
          lt_superpackages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt,
          lo_package       TYPE REF TO zif_abapgit_sap_package,
          lt_repo_list     TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt.

    FIELD-SYMBOLS: &lt;lo_repo&gt;         TYPE LINE OF zif_abapgit_definitions=&gt;ty_repo_ref_tt,
                   &lt;lv_superpackage&gt; LIKE LINE OF lt_superpackages.

    lo_package = zcl_abapgit_factory=&gt;get_sap_package( iv_package ).

    IF lo_package-&gt;exists( ) = abap_false.
      RETURN.
    ENDIF.

    ls_r_package-sign   = &apos;I&apos;.
    ls_r_package-option = &apos;EQ&apos;.
    ls_r_package-low    = iv_package.
    INSERT ls_r_package INTO TABLE lt_r_package.

    &quot; Also consider superpackages. E.g. when some open $abapgit_ui, abapGit repo
    &quot; should be found via package $abapgit
    lt_superpackages = lo_package-&gt;list_superpackages( ).
    LOOP AT lt_superpackages ASSIGNING &lt;lv_superpackage&gt;.
      ls_r_package-low = &lt;lv_superpackage&gt;.
      INSERT ls_r_package INTO TABLE lt_r_package.
    ENDLOOP.

    lt_repo_list = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;list( ).

    LOOP AT lt_repo_list ASSIGNING &lt;lo_repo&gt;.

      IF &lt;lo_repo&gt;-&gt;get_package( ) IN lt_r_package.
        lo_repo = &lt;lo_repo&gt;.
        EXIT.
      ENDIF.

    ENDLOOP.

    IF lo_repo IS BOUND.
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( lo_repo-&gt;get_key( ) ).
    ENDIF.

  ENDMETHOD.
  METHOD get_package_from_adt.

    DATA: ls_item    TYPE zif_abapgit_definitions=&gt;ty_item,
          lr_context TYPE REF TO data,
          lt_fields  TYPE tihttpnvp.
    FIELD-SYMBOLS: &lt;ls_context&gt;    TYPE any,
                   &lt;lv_parameters&gt; TYPE string,
                   &lt;ls_field&gt;      LIKE LINE OF lt_fields.

    ls_item-obj_type = &apos;CLAS&apos;.
    ls_item-obj_name = &apos;CL_ADT_GUI_INTEGRATION_CONTEXT&apos;.

    IF zcl_abapgit_objects=&gt;exists( ls_item  ) = abap_false.
      &quot; ADT is not supported in this NW release
      RETURN.
    ENDIF.

    TRY.
        CREATE DATA lr_context TYPE (&apos;CL_ADT_GUI_INTEGRATION_CONTEXT=&gt;TY_CONTEXT_INFO&apos;).

        ASSIGN lr_context-&gt;* TO &lt;ls_context&gt;.
        ASSERT sy-subrc = 0.

        CALL METHOD (&apos;CL_ADT_GUI_INTEGRATION_CONTEXT&apos;)=&gt;read_context
          RECEIVING
            result = &lt;ls_context&gt;.

        ASSIGN COMPONENT &apos;PARAMETERS&apos;
               OF STRUCTURE &lt;ls_context&gt;
               TO &lt;lv_parameters&gt;.
        ASSERT sy-subrc = 0.

        lt_fields = cl_http_utility=&gt;string_to_fields(
                        cl_http_utility=&gt;unescape_url(
                            &lt;lv_parameters&gt; ) ).

        READ TABLE lt_fields ASSIGNING &lt;ls_field&gt;
                             WITH KEY name = &apos;p_package_name&apos;.
        IF sy-subrc = 0.
          rv_package = &lt;ls_field&gt;-value.

          &quot; We want to open the repo just once. Therefore we delete the parameters
          &quot; and initialize the ADT context.
          CLEAR &lt;lv_parameters&gt;.
          CALL METHOD (&apos;CL_ADT_GUI_INTEGRATION_CONTEXT&apos;)=&gt;initialize_instance
            EXPORTING
              context_info = &lt;ls_context&gt;.

        ENDIF.

      CATCH cx_root.
        &quot; Some problems with dynamic ADT access.
        &quot; Let&apos;s ignore it for now and fail silently
    ENDTRY.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_POPUPS IMPLEMENTATION.
  METHOD add_field.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF ct_fields.

    APPEND INITIAL LINE TO ct_fields ASSIGNING &lt;ls_field&gt;.
    &lt;ls_field&gt;-tabname    = iv_tabname.
    &lt;ls_field&gt;-fieldname  = iv_fieldname.
    &lt;ls_field&gt;-fieldtext  = iv_fieldtext.
    &lt;ls_field&gt;-value      = iv_value.
    &lt;ls_field&gt;-field_attr = iv_field_attr.
    &lt;ls_field&gt;-field_obl  = iv_obligatory.

  ENDMETHOD.
  METHOD create_new_table.

    &quot; create and populate a table on the fly derived from
    &quot; it_data with a select column

    DATA: lr_struct        TYPE REF TO data,
          lt_components    TYPE cl_abap_structdescr=&gt;component_table,
          lo_struct_descr  TYPE REF TO cl_abap_structdescr,
          lo_struct_descr2 TYPE REF TO cl_abap_structdescr.

    FIELD-SYMBOLS: &lt;lt_table&gt;     TYPE STANDARD TABLE,
                   &lt;ls_component&gt; TYPE abap_componentdescr,
                   &lt;lg_line&gt;      TYPE data,
                   &lt;lg_data&gt;      TYPE any.

    mo_table_descr ?= cl_abap_tabledescr=&gt;describe_by_data( it_list ).
    lo_struct_descr ?= mo_table_descr-&gt;get_table_line_type( ).
    lt_components = lo_struct_descr-&gt;get_components( ).

    INSERT INITIAL LINE INTO lt_components ASSIGNING &lt;ls_component&gt; INDEX 1.
    ASSERT sy-subrc = 0.

    &lt;ls_component&gt;-name = c_fieldname_selected.
    &lt;ls_component&gt;-type ?= cl_abap_datadescr=&gt;describe_by_name( &apos;FLAG&apos; ).

    lo_struct_descr2 = cl_abap_structdescr=&gt;create( lt_components ).
    mo_table_descr = cl_abap_tabledescr=&gt;create( lo_struct_descr2 ).

    CREATE DATA mr_table TYPE HANDLE mo_table_descr.
    ASSIGN mr_table-&gt;* TO &lt;lt_table&gt;.
    ASSERT sy-subrc = 0.

    CREATE DATA lr_struct TYPE HANDLE lo_struct_descr2.
    ASSIGN lr_struct-&gt;* TO &lt;lg_line&gt;.
    ASSERT sy-subrc = 0.

    LOOP AT it_list ASSIGNING &lt;lg_data&gt;.
      CLEAR &lt;lg_line&gt;.
      MOVE-CORRESPONDING &lt;lg_data&gt; TO &lt;lg_line&gt;.
      INSERT &lt;lg_line&gt; INTO TABLE &lt;lt_table&gt;.
    ENDLOOP.

  ENDMETHOD.
  METHOD extract_field_values.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF it_fields.

    CLEAR: ev_url,
           ev_package,
           ev_branch.

    READ TABLE it_fields INDEX 1 ASSIGNING &lt;ls_field&gt;.
    ASSERT sy-subrc = 0.
    ev_url = &lt;ls_field&gt;-value.

    READ TABLE it_fields INDEX 2 ASSIGNING &lt;ls_field&gt;.
    ASSERT sy-subrc = 0.
    ev_package = &lt;ls_field&gt;-value.
    TRANSLATE ev_package TO UPPER CASE.

    READ TABLE it_fields INDEX 3 ASSIGNING &lt;ls_field&gt;.
    ASSERT sy-subrc = 0.
    ev_branch = &lt;ls_field&gt;-value.

  ENDMETHOD.
  METHOD get_selected_rows.

    DATA: lv_condition TYPE string,
          lr_exporting TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_exporting&gt; TYPE any,
                   &lt;lt_table&gt;     TYPE STANDARD TABLE,
                   &lt;lg_line&gt;      TYPE any.

    lv_condition = |{ c_fieldname_selected } = ABAP_TRUE|.

    ASSIGN mr_table-&gt;* TO &lt;lt_table&gt;.
    ASSERT sy-subrc = 0.

    CREATE DATA lr_exporting LIKE LINE OF et_list.
    ASSIGN lr_exporting-&gt;* TO &lt;lg_exporting&gt;.

    LOOP AT &lt;lt_table&gt; ASSIGNING &lt;lg_line&gt; WHERE (lv_condition).
      CLEAR &lt;lg_exporting&gt;.
      MOVE-CORRESPONDING &lt;lg_line&gt; TO &lt;lg_exporting&gt;.
      APPEND &lt;lg_exporting&gt; TO et_list.
    ENDLOOP.

  ENDMETHOD.
  METHOD on_select_list_function_click.

    FIELD-SYMBOLS: &lt;lt_table&gt;    TYPE STANDARD TABLE,
                   &lt;lg_line&gt;     TYPE any,
                   &lt;lv_selected&gt; TYPE flag.

    ASSIGN mr_table-&gt;* TO &lt;lt_table&gt;.
    ASSERT sy-subrc = 0.

    CASE e_salv_function.
      WHEN &apos;O.K.&apos;.
        mv_cancel = abap_false.
        mo_select_list_popup-&gt;close_screen( ).

      WHEN &apos;ABR&apos;.
        &quot;Canceled: clear list to overwrite nothing
        CLEAR &lt;lt_table&gt;.
        mv_cancel = abap_true.
        mo_select_list_popup-&gt;close_screen( ).

      WHEN &apos;SALL&apos;.

        LOOP AT &lt;lt_table&gt; ASSIGNING &lt;lg_line&gt;.

          ASSIGN COMPONENT c_fieldname_selected
                 OF STRUCTURE &lt;lg_line&gt;
                 TO &lt;lv_selected&gt;.
          ASSERT sy-subrc = 0.

          &lt;lv_selected&gt; = abap_true.

        ENDLOOP.

        mo_select_list_popup-&gt;refresh( ).

      WHEN &apos;DSEL&apos;.

        LOOP AT &lt;lt_table&gt; ASSIGNING &lt;lg_line&gt;.

          ASSIGN COMPONENT c_fieldname_selected
                 OF STRUCTURE &lt;lg_line&gt;
                 TO &lt;lv_selected&gt;.
          ASSERT sy-subrc = 0.

          &lt;lv_selected&gt; = abap_false.

        ENDLOOP.

        mo_select_list_popup-&gt;refresh( ).

      WHEN OTHERS.
        CLEAR &lt;lt_table&gt;.
        mo_select_list_popup-&gt;close_screen( ).
    ENDCASE.

  ENDMETHOD.
  METHOD on_select_list_link_click.

    DATA: lv_line TYPE sytabix.

    FIELD-SYMBOLS: &lt;lt_table&gt;    TYPE STANDARD TABLE,
                   &lt;lg_line&gt;     TYPE any,
                   &lt;lv_selected&gt; TYPE flag.

    ASSIGN mr_table-&gt;* TO &lt;lt_table&gt;.
    ASSERT sy-subrc = 0.

    lv_line = row.

    READ TABLE &lt;lt_table&gt; ASSIGNING &lt;lg_line&gt;
                       INDEX lv_line.
    IF sy-subrc = 0.

      ASSIGN COMPONENT c_fieldname_selected
             OF STRUCTURE &lt;lg_line&gt;
             TO &lt;lv_selected&gt;.
      ASSERT sy-subrc = 0.

      IF &lt;lv_selected&gt; = abap_true.
        &lt;lv_selected&gt; = abap_false.
      ELSE.
        &lt;lv_selected&gt; = abap_true.
      ENDIF.

    ENDIF.

    mo_select_list_popup-&gt;refresh( ).
  ENDMETHOD.
  METHOD zif_abapgit_popups~branch_list_popup.

    DATA: lo_branches    TYPE REF TO zcl_abapgit_git_branch_list,
          lt_branches    TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt,
          lv_answer      TYPE c LENGTH 1,
          lv_default     TYPE i,
          lv_head_suffix TYPE string,
          lv_head_symref TYPE string,
          lt_selection   TYPE TABLE OF spopli.

    FIELD-SYMBOLS: &lt;ls_sel&gt;    LIKE LINE OF lt_selection,
                   &lt;ls_branch&gt; LIKE LINE OF lt_branches.
    lo_branches    = zcl_abapgit_git_transport=&gt;branches( iv_url ).
    lt_branches    = lo_branches-&gt;get_branches_only( ).
    lv_head_suffix = | ({ zif_abapgit_definitions=&gt;c_head_name })|.
    lv_head_symref = lo_branches-&gt;get_head_symref( ).

    IF iv_hide_branch IS NOT INITIAL.
      DELETE lt_branches WHERE name = iv_hide_branch.
    ENDIF.

    IF iv_hide_head IS NOT INITIAL.
      DELETE lt_branches WHERE name    = zif_abapgit_definitions=&gt;c_head_name
                            OR is_head = abap_true.
    ENDIF.

    IF lt_branches IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;No branch to select&apos; ).
    ENDIF.

    LOOP AT lt_branches ASSIGNING &lt;ls_branch&gt;.

      CHECK &lt;ls_branch&gt;-name IS NOT INITIAL. &quot; To ensure some below ifs

      IF &lt;ls_branch&gt;-is_head = abap_true.

        IF &lt;ls_branch&gt;-name = zif_abapgit_definitions=&gt;c_head_name. &quot; HEAD
          IF &lt;ls_branch&gt;-name &lt;&gt; lv_head_symref AND lv_head_symref IS NOT INITIAL.
            &quot; HEAD but other HEAD symref exists - ignore
            CONTINUE.
          ELSE.
            INSERT INITIAL LINE INTO lt_selection INDEX 1 ASSIGNING &lt;ls_sel&gt;.
            &lt;ls_sel&gt;-varoption = &lt;ls_branch&gt;-name.
          ENDIF.
        ELSE.
          INSERT INITIAL LINE INTO lt_selection INDEX 1 ASSIGNING &lt;ls_sel&gt;.
          &lt;ls_sel&gt;-varoption = &lt;ls_branch&gt;-display_name &amp;&amp; lv_head_suffix.
        ENDIF.

        IF lv_default &gt; 0. &quot; Shift down default if set
          lv_default = lv_default + 1.
        ENDIF.
      ELSE.
        APPEND INITIAL LINE TO lt_selection ASSIGNING &lt;ls_sel&gt;.
        &lt;ls_sel&gt;-varoption = &lt;ls_branch&gt;-display_name.
      ENDIF.

      IF &lt;ls_branch&gt;-name = iv_default_branch.
        IF &lt;ls_branch&gt;-is_head = abap_true.
          lv_default = 1.
        ELSE.
          lv_default = sy-tabix.
        ENDIF.
      ENDIF.

    ENDLOOP.

    IF iv_show_new_option = abap_true.
      APPEND INITIAL LINE TO lt_selection ASSIGNING &lt;ls_sel&gt;.
      &lt;ls_sel&gt;-varoption = zif_abapgit_popups=&gt;c_new_branch_label.
    ENDIF.

    CALL FUNCTION &apos;POPUP_TO_DECIDE_LIST&apos;
      EXPORTING
        textline1  = &apos;Select branch&apos;
        titel      = &apos;Select branch&apos;
        start_col  = 30
        start_row  = 5
        cursorline = lv_default
      IMPORTING
        answer     = lv_answer
      TABLES
        t_spopli   = lt_selection
      EXCEPTIONS
        OTHERS     = 1.                             &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_TO_DECIDE_LIST&apos; ).
    ENDIF.

    IF lv_answer = c_answer_cancel.
      RETURN.
    ENDIF.

    READ TABLE lt_selection ASSIGNING &lt;ls_sel&gt; WITH KEY selflag = abap_true.
    ASSERT sy-subrc = 0.

    IF iv_show_new_option = abap_true AND &lt;ls_sel&gt;-varoption = zif_abapgit_popups=&gt;c_new_branch_label.
      rs_branch-name = zif_abapgit_popups=&gt;c_new_branch_label.
    ELSE.
      REPLACE FIRST OCCURRENCE OF lv_head_suffix IN &lt;ls_sel&gt;-varoption WITH &apos;&apos;.
      READ TABLE lt_branches WITH KEY display_name = &lt;ls_sel&gt;-varoption ASSIGNING &lt;ls_branch&gt;.
      IF sy-subrc &lt;&gt; 0.
* branch name longer than 65 characters
        LOOP AT lt_branches ASSIGNING &lt;ls_branch&gt; WHERE display_name CS &lt;ls_sel&gt;-varoption.
          EXIT. &quot; current loop
        ENDLOOP.
      ENDIF.
      ASSERT &lt;ls_branch&gt; IS ASSIGNED.
      rs_branch = lo_branches-&gt;find_by_name( &lt;ls_branch&gt;-name ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~branch_popup_callback.

    DATA: lv_url          TYPE string,
          ls_package_data TYPE scompkdtln,
          ls_branch       TYPE zif_abapgit_definitions=&gt;ty_git_branch,
          lv_create       TYPE boolean.

    FIELD-SYMBOLS: &lt;ls_furl&gt;     LIKE LINE OF ct_fields,
                   &lt;ls_fbranch&gt;  LIKE LINE OF ct_fields,
                   &lt;ls_fpackage&gt; LIKE LINE OF ct_fields.

    CLEAR cs_error.

    IF iv_code = &apos;COD1&apos;.
      cv_show_popup = abap_true.

      READ TABLE ct_fields ASSIGNING &lt;ls_furl&gt; WITH KEY tabname = &apos;ABAPTXT255&apos;.
      IF sy-subrc &lt;&gt; 0 OR &lt;ls_furl&gt;-value IS INITIAL.
        MESSAGE &apos;Fill URL&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.       &quot;#EC NOTEXT
        RETURN.
      ENDIF.
      lv_url = &lt;ls_furl&gt;-value.

      ls_branch = branch_list_popup( lv_url ).
      IF ls_branch IS INITIAL.
        RETURN.
      ENDIF.

      READ TABLE ct_fields ASSIGNING &lt;ls_fbranch&gt; WITH KEY tabname = &apos;TEXTL&apos;.
      ASSERT sy-subrc = 0.
      &lt;ls_fbranch&gt;-value = ls_branch-name.

    ELSEIF iv_code = &apos;COD2&apos;.
      cv_show_popup = abap_true.

      READ TABLE ct_fields ASSIGNING &lt;ls_fpackage&gt; WITH KEY fieldname = &apos;DEVCLASS&apos;.
      ASSERT sy-subrc = 0.
      ls_package_data-devclass = &lt;ls_fpackage&gt;-value.

      popup_to_create_package(
        IMPORTING
          es_package_data = ls_package_data
          ev_create       = lv_create ).
      IF lv_create = abap_false.
        RETURN.
      ENDIF.

      zcl_abapgit_factory=&gt;get_sap_package( ls_package_data-devclass )-&gt;create( ls_package_data ).
      COMMIT WORK.

      &lt;ls_fpackage&gt;-value = ls_package_data-devclass.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~create_branch_popup.

    DATA: lt_fields TYPE TABLE OF sval.
    DATA: lv_name   TYPE spo_value.

    CLEAR: ev_name, ev_cancel.

    add_field( EXPORTING iv_tabname   = &apos;TEXTL&apos;
                         iv_fieldname = &apos;LINE&apos;
                         iv_fieldtext = &apos;Name&apos;
                         iv_value     = &apos;new-branch-name&apos;
               CHANGING  ct_fields    = lt_fields ).

    TRY.

        _popup_2_get_values( EXPORTING iv_popup_title = &apos;Create branch&apos; &quot;#EC NOTEXT
                             IMPORTING ev_value_1     = lv_name
                             CHANGING  ct_fields      = lt_fields ).

        ev_name = zcl_abapgit_git_branch_list=&gt;complete_heads_branch_name(
              zcl_abapgit_git_branch_list=&gt;normalize_branch_name( lv_name ) ).

      CATCH zcx_abapgit_cancel.
        ev_cancel = abap_true.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_popups~package_popup_callback.

    DATA: ls_package_data TYPE scompkdtln,
          lv_create       TYPE boolean.

    FIELD-SYMBOLS: &lt;ls_fpackage&gt; LIKE LINE OF ct_fields.

    CLEAR cs_error.

    IF iv_code = &apos;COD1&apos;.
      cv_show_popup = abap_true.

      READ TABLE ct_fields ASSIGNING &lt;ls_fpackage&gt; WITH KEY fieldname = &apos;DEVCLASS&apos;.
      ASSERT sy-subrc = 0.
      ls_package_data-devclass = &lt;ls_fpackage&gt;-value.

      popup_to_create_package( IMPORTING es_package_data = ls_package_data
                                         ev_create       = lv_create ).
      IF lv_create = abap_false.
        RETURN.
      ENDIF.

      zcl_abapgit_factory=&gt;get_sap_package( ls_package_data-devclass )-&gt;create( ls_package_data ).
      COMMIT WORK.

      &lt;ls_fpackage&gt;-value = ls_package_data-devclass.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_folder_logic.

    DATA: lt_fields       TYPE TABLE OF sval.
    DATA: lv_folder_logic TYPE spo_value.

    CLEAR: rv_folder_logic.

    add_field( EXPORTING iv_tabname   = &apos;TDEVC&apos;
                         iv_fieldname = &apos;INTSYS&apos;
                         iv_fieldtext = &apos;Folder logic&apos;
                         iv_value     = &apos;PREFIX&apos;
               CHANGING  ct_fields    = lt_fields ).

    TRY.

        _popup_2_get_values( EXPORTING iv_popup_title    = &apos;Export package&apos; &quot;#EC NOTEXT
                                       iv_no_value_check = abap_true
                             IMPORTING ev_value_1        = lv_folder_logic
                             CHANGING  ct_fields         = lt_fields ).

        rv_folder_logic = to_upper( lv_folder_logic ).

      CATCH zcx_abapgit_cancel.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_object.

    DATA: lt_fields      TYPE TABLE OF sval.
    DATA: lv_object_type TYPE spo_value.
    DATA: lv_object_name TYPE spo_value.

    CLEAR: rs_tadir-object, rs_tadir-obj_name.

    add_field( EXPORTING iv_tabname   = &apos;TADIR&apos;
                         iv_fieldname = &apos;OBJECT&apos;
                         iv_fieldtext = &apos;Type&apos;
               CHANGING ct_fields     = lt_fields ).

    add_field( EXPORTING iv_tabname   = &apos;TADIR&apos;
                         iv_fieldname = &apos;OBJ_NAME&apos;
                         iv_fieldtext = &apos;Name&apos;
               CHANGING ct_fields     = lt_fields ).

    TRY.

        _popup_2_get_values( EXPORTING iv_popup_title    = &apos;Object&apos; &quot;#EC NOTEXT
                                       iv_no_value_check = abap_true
                             IMPORTING ev_value_1        = lv_object_type
                                       ev_value_2        = lv_object_name
                             CHANGING  ct_fields         = lt_fields ).

        rs_tadir = zcl_abapgit_factory=&gt;get_tadir( )-&gt;read_single(
          iv_object   = to_upper( lv_object_type )
          iv_obj_name = to_upper( lv_object_name ) ).

      CATCH zcx_abapgit_cancel.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_package_export.

    DATA: lt_fields       TYPE TABLE OF sval.
    DATA: lv_package      TYPE spo_value.
    DATA: lv_folder_logic TYPE spo_value.

    add_field( EXPORTING iv_tabname   = &apos;TDEVC&apos;
                         iv_fieldname = &apos;DEVCLASS&apos;
                         iv_fieldtext = &apos;Package&apos;
               CHANGING  ct_fields    = lt_fields ).

    add_field( EXPORTING iv_tabname   = &apos;TDEVC&apos;
                         iv_fieldname = &apos;INTSYS&apos;
                         iv_fieldtext = &apos;Folder logic&apos;
                         iv_value     = &apos;PREFIX&apos;
               CHANGING  ct_fields    = lt_fields ).

    TRY.

        _popup_2_get_values( EXPORTING iv_popup_title    = &apos;Export package&apos; &quot;#EC NOTEXT
                                       iv_no_value_check = abap_true
                             IMPORTING ev_value_1        = lv_package
                                       ev_value_2        = lv_folder_logic
                             CHANGING  ct_fields         = lt_fields ).

        ev_package = to_upper( lv_package ).
        ev_folder_logic = to_upper( lv_folder_logic ).

      CATCH zcx_abapgit_cancel.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_confirm.

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        titlebar              = iv_titlebar
        text_question         = iv_text_question
        text_button_1         = iv_text_button_1
        icon_button_1         = iv_icon_button_1
        text_button_2         = iv_text_button_2
        icon_button_2         = iv_icon_button_2
        default_button        = iv_default_button
        display_cancel_button = iv_display_cancel_button
      IMPORTING
        answer                = rv_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.                        &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from POPUP_TO_CONFIRM&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_create_package.
    CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
      EXPORTING
        funcname           = &apos;PB_POPUP_PACKAGE_CREATE&apos;
      EXCEPTIONS
        function_not_exist = 1
        OTHERS             = 2.
    IF sy-subrc = 1.
* looks like the function module used does not exist on all
* versions since 702, so show an error
      zcx_abapgit_exception=&gt;raise( &apos;Your system does not support automatic creation of packages.&apos; &amp;&amp;
        &apos;Please, create the package manually.&apos; ).
    ENDIF.

    CALL FUNCTION &apos;PB_POPUP_PACKAGE_CREATE&apos;
      CHANGING
        p_object_data    = es_package_data
      EXCEPTIONS
        action_cancelled = 1.
    IF sy-subrc = 0.
      ev_create = abap_true.
    ELSE.
      ev_create = abap_false.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_create_transp_branch.
    DATA: lt_fields             TYPE TABLE OF sval,
          lv_transports_as_text TYPE string,
          ls_transport_header   LIKE LINE OF it_transport_headers.
    DATA: lv_branch_name        TYPE spo_value.
    DATA: lv_commit_text        TYPE spo_value.

    CLEAR: rs_transport_branch-branch_name, rs_transport_branch-commit_text.

    lv_transports_as_text = &apos;Transport(s)&apos;.
    LOOP AT it_transport_headers INTO ls_transport_header.
      CONCATENATE lv_transports_as_text &apos;_&apos; ls_transport_header-trkorr INTO lv_transports_as_text.
    ENDLOOP.

    add_field( EXPORTING iv_tabname   = &apos;TEXTL&apos;
                         iv_fieldname = &apos;LINE&apos;
                         iv_fieldtext = &apos;Branch name&apos;
                         iv_value     = lv_transports_as_text
               CHANGING ct_fields     = lt_fields ).

    add_field( EXPORTING iv_tabname   = &apos;ABAPTXT255&apos;
                         iv_fieldname = &apos;LINE&apos;
                         iv_fieldtext = &apos;Commit text&apos;
                         iv_value     = lv_transports_as_text
               CHANGING ct_fields     = lt_fields ).

    _popup_2_get_values( EXPORTING iv_popup_title    = &apos;Transport to new Branch&apos; &quot;#EC NOTEXT
                         IMPORTING ev_value_1        = lv_branch_name
                                   ev_value_2        = lv_commit_text
                         CHANGING  ct_fields         = lt_fields ).

    rs_transport_branch-branch_name = lv_branch_name.
    rs_transport_branch-commit_text = lv_commit_text.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_inform.

    DATA: lv_line1 TYPE char70,
          lv_line2 TYPE char70.

    lv_line1 = iv_text_message.
    IF strlen( iv_text_message ) &gt; 70.
      lv_line2 = iv_text_message+70.
    ENDIF.

    CALL FUNCTION &apos;POPUP_TO_INFORM&apos;
      EXPORTING
        titel = iv_titlebar
        txt1  = lv_line1
        txt2  = lv_line2.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_select_from_list.

    DATA:
      lo_events       TYPE REF TO cl_salv_events_table,
      lo_columns      TYPE REF TO cl_salv_columns_table,
      lt_columns      TYPE salv_t_column_ref,
      ls_column       TYPE salv_s_column_ref,
      lo_column       TYPE REF TO cl_salv_column_list,
      lo_table_header TYPE REF TO cl_salv_form_text.

    FIELD-SYMBOLS: &lt;lt_table&gt; TYPE STANDARD TABLE.

    CLEAR: et_list.

    create_new_table( it_list ).

    ASSIGN mr_table-&gt;* TO &lt;lt_table&gt;.
    ASSERT sy-subrc = 0.

    TRY.
        cl_salv_table=&gt;factory( IMPORTING r_salv_table = mo_select_list_popup
                                CHANGING  t_table = &lt;lt_table&gt; ).

        mo_select_list_popup-&gt;set_screen_status( pfstatus = &apos;102&apos;
                                                 report = &apos;SAPMSVIM&apos; ).

        mo_select_list_popup-&gt;set_screen_popup( start_column = 1
                                                end_column   = 65
                                                start_line   = 1
                                                end_line     = 20 ).

        lo_events = mo_select_list_popup-&gt;get_event( ).

        SET HANDLER on_select_list_link_click FOR lo_events.
        SET HANDLER on_select_list_function_click FOR lo_events.

        CREATE OBJECT lo_table_header
          EXPORTING
            text = iv_header_text.

        mo_select_list_popup-&gt;set_top_of_list( lo_table_header ).

        lo_columns = mo_select_list_popup-&gt;get_columns( ).
        lo_columns-&gt;set_optimize( abap_true ).
        lt_columns = lo_columns-&gt;get( ).

        LOOP AT lt_columns INTO ls_column.

          IF ls_column-columnname = c_fieldname_selected.
            lo_column ?= ls_column-r_column.
            lo_column-&gt;set_cell_type( if_salv_c_cell_type=&gt;checkbox_hotspot ).
            lo_column-&gt;set_output_length( 20 ).
            lo_column-&gt;set_short_text( |{ iv_select_column_text }| ).
            lo_column-&gt;set_medium_text( |{ iv_select_column_text }| ).
            lo_column-&gt;set_long_text( |{ iv_select_column_text }| ).
            CONTINUE.
          ENDIF.

          READ TABLE it_columns_to_display TRANSPORTING NO FIELDS
                                           WITH KEY table_line = ls_column-columnname.
          IF sy-subrc &lt;&gt; 0.
            ls_column-r_column-&gt;set_technical( abap_true ).
          ENDIF.

        ENDLOOP.

        mo_select_list_popup-&gt;display( ).

      CATCH cx_salv_msg.
        zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_TO_SELECT_FROM_LIST&apos; ).
    ENDTRY.

    IF mv_cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    get_selected_rows(
      IMPORTING
        et_list = et_list ).

    CLEAR: mo_select_list_popup,
           mr_table,
           mo_table_descr.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_to_select_transports.

* todo, method to be renamed, it only returns one transport

    DATA: lv_trkorr TYPE e070-trkorr,
          ls_trkorr LIKE LINE OF rt_trkorr.
    CALL FUNCTION &apos;TR_F4_REQUESTS&apos;
      IMPORTING
        ev_selected_request = lv_trkorr.

    IF NOT lv_trkorr IS INITIAL.
      ls_trkorr-trkorr = lv_trkorr.
      APPEND ls_trkorr TO rt_trkorr.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~popup_transport_request.

    DATA: lt_e071  TYPE STANDARD TABLE OF e071,
          lt_e071k TYPE STANDARD TABLE OF e071k.

    CALL FUNCTION &apos;TRINT_ORDER_CHOICE&apos;
      EXPORTING
        wi_order_type          = is_transport_type-request
        wi_task_type           = is_transport_type-task
      IMPORTING
        we_order               = rv_transport
      TABLES
        wt_e071                = lt_e071
        wt_e071k               = lt_e071k
      EXCEPTIONS
        no_correction_selected = 1
        display_mode           = 2
        object_append_error    = 3
        recursive_call         = 4
        wrong_order_type       = 5
        OTHERS                 = 6.

    IF sy-subrc = 1.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ELSEIF sy-subrc &gt; 1.
      zcx_abapgit_exception=&gt;raise( |Error from TRINT_ORDER_CHOICE { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_popups~repo_new_offline.

    DATA: lv_returncode TYPE c,
          lt_fields     TYPE TABLE OF sval,
          lv_icon_ok    TYPE icon-name,
          lv_button1    TYPE svalbutton-buttontext,
          lv_icon1      TYPE icon-name,
          lv_finished   TYPE abap_bool,
          lx_error      TYPE REF TO zcx_abapgit_exception.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF lt_fields.
    add_field( EXPORTING iv_tabname    = &apos;ABAPTXT255&apos;
                         iv_fieldname  = &apos;LINE&apos;
                         iv_fieldtext  = &apos;Name&apos;
                         iv_obligatory = abap_true
               CHANGING  ct_fields     = lt_fields ).

    add_field( EXPORTING iv_tabname    = &apos;TDEVC&apos;
                         iv_fieldname  = &apos;DEVCLASS&apos;
                         iv_fieldtext  = &apos;Package&apos;
                         iv_obligatory = abap_true
               CHANGING  ct_fields     = lt_fields ).

    WHILE lv_finished = abap_false.

      lv_icon_ok  = icon_okay.
      lv_button1 = &apos;Create package&apos; ##NO_TEXT.
      lv_icon1   = icon_folder.

      CALL FUNCTION &apos;POPUP_GET_VALUES_USER_BUTTONS&apos;
        EXPORTING
          popup_title       = &apos;New Offline Project&apos;
          programname       = sy-cprog
          formname          = &apos;PACKAGE_POPUP&apos;
          ok_pushbuttontext = &apos;&apos;
          icon_ok_push      = lv_icon_ok
          first_pushbutton  = lv_button1
          icon_button_1     = lv_icon1
          second_pushbutton = &apos;&apos;
          icon_button_2     = &apos;&apos;
        IMPORTING
          returncode        = lv_returncode
        TABLES
          fields            = lt_fields
        EXCEPTIONS
          error_in_fields   = 1
          OTHERS            = 2.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_GET_VALUES&apos; ).
      ENDIF.

      IF lv_returncode = c_answer_cancel.
        rs_popup-cancel = abap_true.
        RETURN.
      ENDIF.

      READ TABLE lt_fields INDEX 1 ASSIGNING &lt;ls_field&gt;.
      ASSERT sy-subrc = 0.
      rs_popup-url = &lt;ls_field&gt;-value.

      READ TABLE lt_fields INDEX 2 ASSIGNING &lt;ls_field&gt;.
      ASSERT sy-subrc = 0.
      TRANSLATE &lt;ls_field&gt;-value TO UPPER CASE.
      rs_popup-package = &lt;ls_field&gt;-value.

      lv_finished = abap_true.

      TRY.
          zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;validate_package( rs_popup-package ).

        CATCH zcx_abapgit_exception INTO lx_error.
          &quot; in case of validation errors we display the popup again
          MESSAGE lx_error TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
          CLEAR lv_finished.
      ENDTRY.

    ENDWHILE.

  ENDMETHOD.
  METHOD zif_abapgit_popups~repo_popup.

    DATA: lv_returncode TYPE c,
          lv_icon_ok    TYPE icon-name,
          lv_icon_br    TYPE icon-name,
          lt_fields     TYPE TABLE OF sval,
          lv_uattr      TYPE spo_fattr,
          lv_pattr      TYPE spo_fattr,
          lv_button2    TYPE svalbutton-buttontext,
          lv_icon2      TYPE icon-name,
          lv_package    TYPE tdevc-devclass,
          lv_url        TYPE abaptxt255-line,
          lv_branch     TYPE textl-line,
          lv_finished   TYPE abap_bool,
          lx_error      TYPE REF TO zcx_abapgit_exception.

    IF iv_freeze_url = abap_true.
      lv_uattr = &apos;05&apos;.
    ENDIF.

    IF iv_freeze_package = abap_true.
      lv_pattr = &apos;05&apos;.
    ENDIF.

    IF iv_package IS INITIAL. &quot; Empty package -&gt; can be created
      lv_button2 = &apos;Create package&apos; ##NO_TEXT.
      lv_icon2   = icon_folder.
    ENDIF.

    lv_package = iv_package.
    lv_url     = iv_url.
    lv_branch  = iv_branch.

    WHILE lv_finished = abap_false.

      CLEAR: lt_fields.

      add_field( EXPORTING iv_tabname    = &apos;ABAPTXT255&apos;
                           iv_fieldname  = &apos;LINE&apos;
                           iv_fieldtext  = &apos;Git clone URL&apos;
                           iv_value      = lv_url
                           iv_field_attr = lv_uattr
                 CHANGING ct_fields      = lt_fields ).

      add_field( EXPORTING iv_tabname    = &apos;TDEVC&apos;
                           iv_fieldname  = &apos;DEVCLASS&apos;
                           iv_fieldtext  = &apos;Package&apos;
                           iv_value      = lv_package
                           iv_field_attr = lv_pattr
                 CHANGING ct_fields      = lt_fields ).

      add_field( EXPORTING iv_tabname    = &apos;TEXTL&apos;
                           iv_fieldname  = &apos;LINE&apos;
                           iv_fieldtext  = &apos;Branch&apos;
                           iv_value      = lv_branch
                           iv_field_attr = &apos;05&apos;
                 CHANGING ct_fields      = lt_fields ).

      lv_icon_ok  = icon_okay.
      lv_icon_br  = icon_workflow_fork.

      CALL FUNCTION &apos;POPUP_GET_VALUES_USER_BUTTONS&apos;
        EXPORTING
          popup_title       = iv_title
          programname       = sy-cprog
          formname          = &apos;BRANCH_POPUP&apos;
          ok_pushbuttontext = &apos;OK&apos;
          icon_ok_push      = lv_icon_ok
          first_pushbutton  = &apos;Select branch&apos;
          icon_button_1     = lv_icon_br
          second_pushbutton = lv_button2
          icon_button_2     = lv_icon2
        IMPORTING
          returncode        = lv_returncode
        TABLES
          fields            = lt_fields
        EXCEPTIONS
          error_in_fields   = 1
          OTHERS            = 2.                              &quot;#EC NOTEXT

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_GET_VALUES&apos; ).
      ENDIF.

      IF lv_returncode = c_answer_cancel.
        rs_popup-cancel = abap_true.
        RETURN.
      ENDIF.

      extract_field_values(
        EXPORTING
          it_fields  = lt_fields
        IMPORTING
          ev_url     = lv_url
          ev_package = lv_package
          ev_branch  = lv_branch ).

      lv_finished = abap_true.

      TRY.
          zcl_abapgit_url=&gt;validate( |{ lv_url }| ).
          IF iv_freeze_package = abap_false.
            zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;validate_package( lv_package ).
          ENDIF.
        CATCH zcx_abapgit_exception INTO lx_error.
          MESSAGE lx_error TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
          &quot; in case of validation errors we display the popup again
          CLEAR lv_finished.
      ENDTRY.

    ENDWHILE.

    rs_popup-url         = lv_url.
    rs_popup-package     = lv_package.
    rs_popup-branch_name = lv_branch.

  ENDMETHOD.
  METHOD zif_abapgit_popups~run_page_class_popup.

    DATA: lt_fields TYPE TABLE OF sval.
    DATA: lv_name   TYPE spo_value.

    CLEAR: ev_name, ev_cancel.

    add_field( EXPORTING iv_tabname   = &apos;TEXTL&apos;
                         iv_fieldname = &apos;LINE&apos;
                         iv_fieldtext = &apos;Name&apos;
                         iv_value     = &apos;lcl_gui_page_&apos;
               CHANGING  ct_fields    = lt_fields ).

    TRY.

        _popup_2_get_values( EXPORTING iv_popup_title = &apos;Run page manually&apos; &quot;#EC NOTEXT
                             IMPORTING ev_value_1     = lv_name
                             CHANGING ct_fields       = lt_fields ).

        ev_name = to_upper( lv_name ).

      CATCH zcx_abapgit_cancel.
        ev_cancel = abap_true.
    ENDTRY.

  ENDMETHOD.
  METHOD _popup_2_get_values.

    DATA lv_answer TYPE char1.
    FIELD-SYMBOLS: &lt;ls_field&gt; TYPE sval.

    CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
      EXPORTING
        no_value_check = iv_no_value_check
        popup_title    = iv_popup_title
      IMPORTING
        returncode     = lv_answer
      TABLES
        fields         = ct_fields
      EXCEPTIONS
        OTHERS         = 1 ##NO_TEXT.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from POPUP_GET_VALUES&apos; ).
    ENDIF.

    IF lv_answer = c_answer_cancel.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    IF ev_value_1 IS SUPPLIED.
      READ TABLE ct_fields INDEX 1 ASSIGNING &lt;ls_field&gt;.
      ASSERT sy-subrc = 0.
      ev_value_1 = &lt;ls_field&gt;-value.
    ENDIF.

    IF ev_value_2 IS SUPPLIED.
      READ TABLE ct_fields INDEX 2 ASSIGNING &lt;ls_field&gt;.
      ASSERT sy-subrc = 0.
      ev_value_2 = &lt;ls_field&gt;-value.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PASSWORD_DIALOG IMPLEMENTATION.
  METHOD popup.

    PERFORM password_popup
      IN PROGRAM (sy-cprog)
      USING iv_repo_url
      CHANGING cv_user cv_pass.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_html_toolbar IMPLEMENTATION.
  METHOD add.
    DATA ls_item TYPE ty_item.

    ASSERT iv_typ = zif_abapgit_definitions=&gt;c_action_type-separator  &quot; sep doesn&apos;t have action
      OR iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick      &quot; click may have no action (assigned in JS)
      OR iv_typ = zif_abapgit_definitions=&gt;c_action_type-dummy        &quot; dummy may have no action
      OR iv_act IS INITIAL AND io_sub IS NOT INITIAL
      OR iv_act IS NOT INITIAL AND io_sub IS INITIAL. &quot; Only one supplied

    ASSERT NOT ( iv_chk &lt;&gt; abap_undefined AND io_sub IS NOT INITIAL ).

    ls_item-txt = iv_txt.
    ls_item-act = iv_act.
    ls_item-ico = iv_ico.
    ls_item-sub = io_sub.
    ls_item-opt = iv_opt.
    ls_item-typ = iv_typ.
    ls_item-cur = iv_cur.
    ls_item-chk = iv_chk.
    ls_item-aux = iv_aux.
    ls_item-id  = iv_id.

    APPEND ls_item TO mt_items.

  ENDMETHOD.
  METHOD constructor.
    mv_id = iv_id.
  ENDMETHOD.
  METHOD count.
    rv_count = lines( mt_items ).
  ENDMETHOD.
  METHOD render.

    DATA: lv_class TYPE string.

    CREATE OBJECT ro_html.

    lv_class = &apos;nav-container&apos; ##NO_TEXT.
    IF iv_right = abap_true.
      lv_class = lv_class &amp;&amp; &apos; float-right&apos;.
    ENDIF.

    ro_html-&gt;add( |&lt;div class=&quot;{ lv_class }&quot;&gt;| ).
    ro_html-&gt;add( render_items( iv_sort = iv_sort ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_as_droplist.

    DATA: lv_class TYPE string.

    CREATE OBJECT ro_html.

    lv_class = &apos;nav-container&apos; ##NO_TEXT.
    IF iv_right = abap_true.
      lv_class = lv_class &amp;&amp; &apos; float-right&apos;.
    ENDIF.
    IF iv_corner = abap_true.
      lv_class = lv_class &amp;&amp; &apos; corner&apos;.
    ENDIF.

    ro_html-&gt;add( |&lt;div class=&quot;{ lv_class }&quot;&gt;| ).
    ro_html-&gt;add( &apos;&lt;ul&gt;&lt;li&gt;&apos; ).
    ro_html-&gt;add_a( iv_txt = iv_label
                    iv_typ = zif_abapgit_definitions=&gt;c_action_type-sapevent
                    iv_act = iv_action ).
    ro_html-&gt;add( &apos;&lt;div class=&quot;minizone&quot;&gt;&lt;/div&gt;&apos; ).
    ro_html-&gt;add( render_items( iv_sort = iv_sort ) ).
    ro_html-&gt;add( &apos;&lt;/li&gt;&lt;/ul&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_items.

    DATA: lv_class     TYPE string,
          lv_icon      TYPE string,
          lv_id        TYPE string,
          lv_check     TYPE string,
          lv_aux       TYPE string,
          lv_has_icons TYPE abap_bool.

    FIELD-SYMBOLS &lt;ls_item&gt; LIKE LINE OF mt_items.

    CREATE OBJECT ro_html.

    IF iv_sort = abap_true.
      SORT mt_items BY txt ASCENDING AS TEXT.
    ENDIF.

    &quot; Check has icons or check boxes
    LOOP AT mt_items ASSIGNING &lt;ls_item&gt; WHERE ico IS NOT INITIAL OR chk &lt;&gt; abap_undefined.
      lv_has_icons = abap_true.
      lv_class     = &apos; class=&quot;with-icons&quot;&apos;.
      EXIT.
    ENDLOOP.

    IF mv_id IS NOT INITIAL.
      lv_id = | id=&quot;{ mv_id }&quot;|.
    ENDIF.

    ro_html-&gt;add( |&lt;ul{ lv_id }{ lv_class }&gt;| ).

    &quot; Render items
    LOOP AT mt_items ASSIGNING &lt;ls_item&gt;.
      CLEAR: lv_class, lv_icon.

      IF &lt;ls_item&gt;-typ = zif_abapgit_definitions=&gt;c_action_type-separator.
        ro_html-&gt;add( |&lt;li class=&quot;separator&quot;&gt;{ &lt;ls_item&gt;-txt }&lt;/li&gt;| ).
        CONTINUE.
      ENDIF.

      IF lv_has_icons = abap_true.
        IF &lt;ls_item&gt;-chk = abap_true.
          lv_icon  = zcl_abapgit_html=&gt;icon( &apos;check/blue&apos; ).
          lv_check = &apos; data-check=&quot;X&quot;&apos;.
        ELSEIF &lt;ls_item&gt;-chk = abap_false.
          lv_icon = zcl_abapgit_html=&gt;icon( &apos;check/grey&apos; ).
          lv_check = &apos; data-check=&quot;&quot;&apos;.
        ELSE. &quot; abap_undefined -&gt; not a check box
          lv_icon = zcl_abapgit_html=&gt;icon( &lt;ls_item&gt;-ico ).
        ENDIF.
      ENDIF.

      IF &lt;ls_item&gt;-cur = abap_true.
        lv_class = &apos; class=&quot;current-menu-item&quot;&apos;.
      ENDIF.

      IF &lt;ls_item&gt;-aux IS NOT INITIAL.
        lv_aux = | data-aux=&quot;{ &lt;ls_item&gt;-aux }&quot;|.
      ENDIF.

      ro_html-&gt;add( |&lt;li{ lv_class }{ lv_check }{ lv_aux }&gt;| ).
      IF &lt;ls_item&gt;-sub IS INITIAL.
        ro_html-&gt;add_a( iv_txt   = lv_icon &amp;&amp; &lt;ls_item&gt;-txt
                        iv_typ   = &lt;ls_item&gt;-typ
                        iv_act   = &lt;ls_item&gt;-act
                        iv_id    = &lt;ls_item&gt;-id
                        iv_opt   = &lt;ls_item&gt;-opt ).
      ELSE.
        ro_html-&gt;add_a( iv_txt   = lv_icon &amp;&amp; &lt;ls_item&gt;-txt
                        iv_typ   = zif_abapgit_definitions=&gt;c_action_type-dummy
                        iv_act   = &apos;&apos;
                        iv_id    = &lt;ls_item&gt;-id
                        iv_opt   = &lt;ls_item&gt;-opt ).
        ro_html-&gt;add( &lt;ls_item&gt;-sub-&gt;render_items( iv_sort ) ).
      ENDIF.
      ro_html-&gt;add( &apos;&lt;/li&gt;&apos; ).

    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/ul&gt;&apos; ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_html_action_utils IMPLEMENTATION.
  METHOD add_field.

    DATA ls_field LIKE LINE OF ct_field.

    FIELD-SYMBOLS &lt;lg_src&gt; TYPE any.

    ls_field-name = iv_name.

    CASE cl_abap_typedescr=&gt;describe_by_data( ig_field )-&gt;kind.
      WHEN cl_abap_typedescr=&gt;kind_elem.
        ls_field-value = ig_field.
      WHEN cl_abap_typedescr=&gt;kind_struct.
        ASSIGN COMPONENT iv_name OF STRUCTURE ig_field TO &lt;lg_src&gt;.
        ASSERT &lt;lg_src&gt; IS ASSIGNED.
        ls_field-value = &lt;lg_src&gt;.
      WHEN OTHERS.
        ASSERT 0 = 1.
    ENDCASE.

    APPEND ls_field TO ct_field.

  ENDMETHOD.
  METHOD dbkey_decode.

    DATA: lt_fields TYPE tihttpnvp.

    lt_fields = parse_fields_upper_case_name( cl_http_utility=&gt;unescape_url( |{ iv_string }| ) ).

    get_field( EXPORTING iv_name = &apos;TYPE&apos;  it_field = lt_fields CHANGING cg_field = rs_key-type ).
    get_field( EXPORTING iv_name = &apos;VALUE&apos; it_field = lt_fields CHANGING cg_field = rs_key-value ).

  ENDMETHOD.
  METHOD dbkey_encode.

    DATA: lt_fields TYPE tihttpnvp.

    add_field( EXPORTING iv_name = &apos;TYPE&apos;  ig_field = is_key-type CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;VALUE&apos; ig_field = is_key-value CHANGING ct_field = lt_fields ).

    rv_string = cl_http_utility=&gt;if_http_utility~fields_to_string( lt_fields ).

  ENDMETHOD.
  METHOD dir_decode.

    DATA: lt_fields TYPE tihttpnvp.

    lt_fields = parse_fields( iv_string ).
    get_field( EXPORTING iv_name = &apos;PATH&apos; it_field = lt_fields CHANGING cg_field = rv_path ).

  ENDMETHOD.
  METHOD dir_encode.

    DATA: lt_fields TYPE tihttpnvp.
    add_field( EXPORTING iv_name = &apos;PATH&apos; ig_field = iv_path CHANGING ct_field = lt_fields ).
    rv_string = cl_http_utility=&gt;if_http_utility~fields_to_string( lt_fields ).

  ENDMETHOD.
  METHOD field_keys_to_upper.

    FIELD-SYMBOLS &lt;ls_field&gt; LIKE LINE OF ct_fields.

    LOOP AT ct_fields ASSIGNING &lt;ls_field&gt;.
      &lt;ls_field&gt;-name = to_upper( &lt;ls_field&gt;-name ).
    ENDLOOP.

  ENDMETHOD.
  METHOD file_encode.

    DATA: lt_fields TYPE tihttpnvp.
    add_field( EXPORTING iv_name = &apos;KEY&apos;      ig_field = iv_key CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;PATH&apos;     ig_field = ig_file CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;FILENAME&apos; ig_field = ig_file CHANGING ct_field = lt_fields ).

    rv_string = cl_http_utility=&gt;if_http_utility~fields_to_string( lt_fields ).

  ENDMETHOD.
  METHOD file_obj_decode.

    DATA: lt_fields TYPE tihttpnvp.

    ASSERT eg_file IS SUPPLIED OR eg_object IS SUPPLIED OR ev_key IS SUPPLIED.

    CLEAR: ev_key, eg_file, eg_object.
    lt_fields = parse_fields_upper_case_name( iv_string ).

    get_field( EXPORTING iv_name = &apos;KEY&apos;      it_field = lt_fields CHANGING cg_field = ev_key ).

    IF eg_file IS SUPPLIED.
      get_field( EXPORTING iv_name = &apos;PATH&apos;     it_field = lt_fields CHANGING cg_field = eg_file ).
      get_field( EXPORTING iv_name = &apos;FILENAME&apos; it_field = lt_fields CHANGING cg_field = eg_file ).
    ENDIF.

    IF eg_object IS SUPPLIED.
      get_field( EXPORTING iv_name = &apos;OBJ_TYPE&apos; it_field = lt_fields CHANGING cg_field = eg_object ).
      get_field( EXPORTING iv_name = &apos;OBJ_NAME&apos; it_field = lt_fields CHANGING cg_field = eg_object ).
    ENDIF.

  ENDMETHOD.
  METHOD get_field.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF it_field,
                   &lt;lg_dest&gt;  TYPE any.
    READ TABLE it_field ASSIGNING &lt;ls_field&gt; WITH KEY name = iv_name.
    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    CASE cl_abap_typedescr=&gt;describe_by_data( cg_field )-&gt;kind.
      WHEN cl_abap_typedescr=&gt;kind_elem.
        cg_field = &lt;ls_field&gt;-value.
      WHEN cl_abap_typedescr=&gt;kind_struct.
        ASSIGN COMPONENT iv_name OF STRUCTURE cg_field TO &lt;lg_dest&gt;.
        ASSERT &lt;lg_dest&gt; IS ASSIGNED.
        &lt;lg_dest&gt; = &lt;ls_field&gt;-value.
      WHEN OTHERS.
        ASSERT 0 = 1.
    ENDCASE.

  ENDMETHOD.
  METHOD jump_decode.

    DATA: lt_fields TYPE tihttpnvp.

    lt_fields = parse_fields( iv_string ).

    get_field( EXPORTING iv_name = &apos;TYPE&apos; it_field = lt_fields CHANGING cg_field = ev_obj_type ).
    get_field( EXPORTING iv_name = &apos;NAME&apos; it_field = lt_fields CHANGING cg_field = ev_obj_name ).

  ENDMETHOD.
  METHOD jump_encode.

    DATA: lt_fields TYPE tihttpnvp.
    add_field( EXPORTING iv_name = &apos;TYPE&apos; ig_field = iv_obj_type CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;NAME&apos; ig_field = iv_obj_name CHANGING ct_field = lt_fields ).

    rv_string = cl_http_utility=&gt;if_http_utility~fields_to_string( lt_fields ).

  ENDMETHOD.
  METHOD obj_encode.

    DATA: lt_fields TYPE tihttpnvp.
    add_field( EXPORTING iv_name = &apos;KEY&apos;      ig_field = iv_key CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;OBJ_TYPE&apos; ig_field = ig_object CHANGING ct_field = lt_fields ).
    add_field( EXPORTING iv_name = &apos;OBJ_NAME&apos; ig_field = ig_object CHANGING ct_field = lt_fields ).

    rv_string = cl_http_utility=&gt;if_http_utility~fields_to_string( lt_fields ).

  ENDMETHOD.
  METHOD parse_fields.

    DATA: lt_substrings TYPE stringtab,
          ls_field      LIKE LINE OF rt_fields.

    FIELD-SYMBOLS: &lt;lv_substring&gt; LIKE LINE OF lt_substrings.
    SPLIT iv_string AT &apos;&amp;&apos; INTO TABLE lt_substrings.

    LOOP AT lt_substrings ASSIGNING &lt;lv_substring&gt;.

      CLEAR: ls_field.

      ls_field-name = substring_before( val = &lt;lv_substring&gt;
                                     sub = &apos;=&apos; ).
      ls_field-name = unescape( ls_field-name ).

      ls_field-value = substring_after( val = &lt;lv_substring&gt;
                                     sub = &apos;=&apos; ).
      ls_field-value = unescape( ls_field-value ).

      INSERT ls_field INTO TABLE rt_fields.

    ENDLOOP.

  ENDMETHOD.
  METHOD parse_fields_upper_case_name.

    rt_fields = parse_fields( iv_string ).
    field_keys_to_upper( CHANGING ct_fields = rt_fields ).

  ENDMETHOD.
  METHOD stage_decode.

    DATA: lt_fields TYPE tihttpnvp.

    lt_fields = parse_fields_upper_case_name( iv_getdata ).

    get_field( EXPORTING iv_name = &apos;KEY&apos;  it_field = lt_fields CHANGING cg_field = ev_key ).
    get_field( EXPORTING iv_name = &apos;SEED&apos; it_field = lt_fields CHANGING cg_field = ev_seed ).

    ASSERT NOT ev_key IS INITIAL.

  ENDMETHOD.
  METHOD unescape.
* do not use cl_http_utility as it does strange things with the encoding
    rv_string = iv_string.

* todo, more to be added here
    REPLACE ALL OCCURRENCES OF &apos;%3F&apos; IN rv_string WITH &apos;?&apos;.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_HTML IMPLEMENTATION.
  METHOD a.

    DATA: lv_class TYPE string,
          lv_href  TYPE string,
          lv_click TYPE string,
          lv_id    TYPE string,
          lv_style TYPE string,
          lv_span  TYPE string.

    lv_class = iv_class.

    IF iv_opt CA zif_abapgit_definitions=&gt;c_html_opt-strong.
      lv_class = lv_class &amp;&amp; &apos; emphasis&apos; ##NO_TEXT.
    ENDIF.
    IF iv_opt CA zif_abapgit_definitions=&gt;c_html_opt-cancel.
      lv_class = lv_class &amp;&amp; &apos; attention&apos; ##NO_TEXT.
    ENDIF.
    IF iv_opt CA zif_abapgit_definitions=&gt;c_html_opt-crossout.
      lv_class = lv_class &amp;&amp; &apos; crossout grey&apos; ##NO_TEXT.
    ENDIF.
    IF lv_class IS NOT INITIAL.
      SHIFT lv_class LEFT DELETING LEADING space.
      lv_class = | class=&quot;{ lv_class }&quot;|.
    ENDIF.

    lv_href  = &apos; href=&quot;#&quot;&apos;. &quot; Default, dummy
    IF iv_act IS NOT INITIAL OR iv_typ = zif_abapgit_definitions=&gt;c_action_type-dummy.
      CASE iv_typ.
        WHEN zif_abapgit_definitions=&gt;c_action_type-url.
          lv_href  = | href=&quot;{ iv_act }&quot;|.
        WHEN zif_abapgit_definitions=&gt;c_action_type-sapevent.
          lv_href  = | href=&quot;sapevent:{ iv_act }&quot;|.
        WHEN zif_abapgit_definitions=&gt;c_action_type-onclick.
          lv_href  = &apos; href=&quot;#&quot;&apos;.
          lv_click = | onclick=&quot;{ iv_act }&quot;|.
        WHEN zif_abapgit_definitions=&gt;c_action_type-dummy.
          lv_href  = &apos; href=&quot;#&quot;&apos;.
      ENDCASE.
    ENDIF.

    IF iv_id IS NOT INITIAL.
      lv_id = | id=&quot;{ iv_id }&quot;|.
    ENDIF.

    IF iv_style IS NOT INITIAL.
      lv_style = | style=&quot;{ iv_style }&quot;|.
    ENDIF.

    lv_span = |&lt;span class=&quot;tooltiptext hidden&quot;&gt;&lt;/span&gt;|.

    rv_str = |&lt;a{ lv_id }{ lv_class }{ lv_href }{ lv_click }{ lv_style }&gt;{ iv_txt }{ lv_span }&lt;/a&gt;|.

  ENDMETHOD.
  METHOD add.

    DATA: lv_type TYPE c,
          lo_html TYPE REF TO zcl_abapgit_html.

    FIELD-SYMBOLS: &lt;lt_tab&gt; TYPE string_table.

    DESCRIBE FIELD ig_chunk TYPE lv_type. &quot; Describe is faster than RTTI classes

    CASE lv_type.
      WHEN &apos;C&apos; OR &apos;g&apos;.  &quot; Char or string
        APPEND ig_chunk TO mt_buffer.
      WHEN &apos;h&apos;.         &quot; Table
        ASSIGN ig_chunk TO &lt;lt_tab&gt;. &quot; Assuming table of strings ! Will dump otherwise
        APPEND LINES OF &lt;lt_tab&gt; TO mt_buffer.
      WHEN &apos;r&apos;.         &quot; Object ref
        ASSERT ig_chunk IS BOUND. &quot; Dev mistake
        TRY.
            lo_html ?= ig_chunk.
          CATCH cx_sy_move_cast_error.
            ASSERT 1 = 0. &quot; Dev mistake
        ENDTRY.
        APPEND LINES OF lo_html-&gt;mt_buffer TO mt_buffer.
      WHEN OTHERS.
        ASSERT 1 = 0. &quot; Dev mistake
    ENDCASE.

  ENDMETHOD.
  METHOD add_a.

    add( a( iv_txt   = iv_txt
            iv_act   = iv_act
            iv_typ   = iv_typ
            iv_opt   = iv_opt
            iv_class = iv_class
            iv_id    = iv_id
            iv_style = iv_style ) ).

  ENDMETHOD.
  METHOD add_icon.

    add( icon( iv_name  = iv_name
               iv_class = iv_class
               iv_hint  = iv_hint ) ).

  ENDMETHOD.
  METHOD class_constructor.
    CREATE OBJECT go_single_tags_re
      EXPORTING
        pattern     = &apos;&lt;(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|LINK|META|PARAM|SOURCE|!)&apos;
        ignore_case = abap_false.
  ENDMETHOD.
  METHOD icon.

    DATA: lv_hint  TYPE string,
          lv_name  TYPE string,
          lv_color TYPE string,
          lv_class TYPE string.

    SPLIT iv_name AT &apos;/&apos; INTO lv_name lv_color.

    IF iv_hint IS NOT INITIAL.
      lv_hint  = | title=&quot;{ iv_hint }&quot;|.
    ENDIF.
    IF iv_class IS NOT INITIAL.
      lv_class = | { iv_class }|.
    ENDIF.
    IF lv_color IS NOT INITIAL.
      lv_color = | { lv_color }|.
    ENDIF.

    rv_str = |&lt;i class=&quot;octicon octicon-{ lv_name }{ lv_color }{ lv_class }&quot;{ lv_hint }&gt;&lt;/i&gt;|.

  ENDMETHOD.
  METHOD indent_line.

    DATA: ls_study TYPE ty_study_result,
          lv_x_str TYPE string.

    ls_study = study_line(
      is_context = cs_context
      iv_line    = cv_line ).

    &quot; First closing tag - shift back exceptionally
    IF (  ls_study-script_close = abap_true
       OR ls_study-style_close = abap_true
       OR ls_study-curly_close = abap_true
       OR ls_study-tag_close = abap_true )
       AND cs_context-indent &gt; 0.
      lv_x_str = repeat( val = ` ` occ = ( cs_context-indent - 1 ) * c_indent_size ).
      cv_line  = lv_x_str &amp;&amp; cv_line.
    ELSE.
      cv_line = cs_context-indent_str &amp;&amp; cv_line.
    ENDIF.

    &quot; Context status update
    CASE abap_true.
      WHEN ls_study-script_open.
        cs_context-within_js    = abap_true.
        cs_context-within_style = abap_false.
      WHEN ls_study-style_open.
        cs_context-within_js    = abap_false.
        cs_context-within_style = abap_true.
      WHEN ls_study-script_close OR ls_study-style_close.
        cs_context-within_js    = abap_false.
        cs_context-within_style = abap_false.
        ls_study-closings       = ls_study-closings + 1.
    ENDCASE.

    &quot; More-less logic chosen due to possible double tags in a line &apos;&lt;a&gt;&lt;b&gt;&apos;
    IF ls_study-openings &lt;&gt; ls_study-closings.
      IF ls_study-openings &gt; ls_study-closings.
        cs_context-indent = cs_context-indent + 1.
      ELSEIF cs_context-indent &gt; 0. &quot; AND ls_study-openings &lt; ls_study-closings
        cs_context-indent = cs_context-indent - 1.
      ENDIF.
      cs_context-indent_str = repeat( val = ` ` occ = cs_context-indent * c_indent_size ).
    ENDIF.

  ENDMETHOD.
  METHOD is_empty.
    rv_yes = boolc( lines( mt_buffer ) = 0 ).
  ENDMETHOD.
  METHOD render.

    DATA: ls_context TYPE ty_indent_context,
          lt_temp    TYPE string_table.

    FIELD-SYMBOLS: &lt;lv_line&gt;   LIKE LINE OF lt_temp,
                   &lt;lv_line_c&gt; LIKE LINE OF lt_temp.

    ls_context-no_indent_jscss = iv_no_indent_jscss.

    LOOP AT mt_buffer ASSIGNING &lt;lv_line&gt;.
      APPEND &lt;lv_line&gt; TO lt_temp ASSIGNING &lt;lv_line_c&gt;.
      indent_line( CHANGING cs_context = ls_context cv_line = &lt;lv_line_c&gt; ).
    ENDLOOP.

    CONCATENATE LINES OF lt_temp INTO rv_html SEPARATED BY zif_abapgit_definitions=&gt;c_newline.

  ENDMETHOD.
  METHOD study_line.

    DATA: lv_line TYPE string,
          lv_len  TYPE i.

    lv_line = to_upper( shift_left( val = iv_line sub = ` ` ) ).
    lv_len  = strlen( lv_line ).

    &quot; Some assumptions for simplification and speed
    &quot; - style &amp; scripts tag should be opened/closed in a separate line
    &quot; - style &amp; scripts opening and closing in one line is possible but only once

    &quot; TODO &amp; Issues
    &quot; - What if the string IS a well formed html already not just single line ?

    IF is_context-within_js = abap_true OR is_context-within_style = abap_true.

      IF is_context-within_js = abap_true AND lv_len &gt;= 8 AND lv_line(8) = &apos;&lt;/SCRIPT&apos;.
        rs_result-script_close = abap_true.
      ELSEIF is_context-within_style = abap_true AND lv_len &gt;= 7 AND lv_line(7) = &apos;&lt;/STYLE&apos;.
        rs_result-style_close = abap_true.
      ENDIF.

      IF is_context-no_indent_jscss = abap_false.
        IF lv_len &gt;= 1 AND lv_line(1) = &apos;}&apos;.
          rs_result-curly_close = abap_true.
        ENDIF.

        FIND ALL OCCURRENCES OF &apos;{&apos; IN lv_line MATCH COUNT rs_result-openings.
        FIND ALL OCCURRENCES OF &apos;}&apos; IN lv_line MATCH COUNT rs_result-closings.
      ENDIF.

    ELSE.
      IF lv_len &gt;= 7 AND lv_line(7) = &apos;&lt;SCRIPT&apos;.
        FIND FIRST OCCURRENCE OF &apos;&lt;/SCRIPT&apos; IN lv_line.
        IF sy-subrc &gt; 0. &quot; Not found
          rs_result-script_open = abap_true.
        ENDIF.
      ENDIF.
      IF lv_len &gt;= 6 AND lv_line(6) = &apos;&lt;STYLE&apos;.
        FIND FIRST OCCURRENCE OF &apos;&lt;/STYLE&apos; IN lv_line.
        IF sy-subrc &gt; 0. &quot; Not found
          rs_result-style_open = abap_true.
        ENDIF.
      ENDIF.
      IF lv_len &gt;= 2 AND lv_line(2) = &apos;&lt;/&apos;.
        rs_result-tag_close = abap_true.
      ENDIF.

      FIND ALL OCCURRENCES OF &apos;&lt;&apos;  IN lv_line MATCH COUNT rs_result-openings.
      FIND ALL OCCURRENCES OF &apos;&lt;/&apos; IN lv_line MATCH COUNT rs_result-closings.
      FIND ALL OCCURRENCES OF REGEX go_single_tags_re IN lv_line MATCH COUNT rs_result-singles.
      rs_result-openings = rs_result-openings - rs_result-closings - rs_result-singles.

    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_HOTKEYS IMPLEMENTATION.
  METHOD get_default_hotkeys_from_pages.

    DATA: lt_hotkey_actions TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action,
          lo_interface      TYPE REF TO cl_oo_interface,
          lv_class_name     TYPE abap_abstypename,
          lt_classes        TYPE seo_relkeys.

    FIELD-SYMBOLS: &lt;ls_class&gt; TYPE seorelkey.

    TRY.
        lo_interface ?= cl_oo_class=&gt;get_instance( |ZIF_ABAPGIT_GUI_PAGE_HOTKEY| ).

      CATCH cx_class_not_existent.
        &quot; hotkeys are only available with installed abapGit repository
        RETURN.
    ENDTRY.

    lt_classes = lo_interface-&gt;get_implementing_classes( ).
    IF io_page IS BOUND.
      lv_class_name = cl_abap_classdescr=&gt;get_class_name( io_page ).
      SHIFT lv_class_name LEFT DELETING LEADING &apos;\CLASS=&apos;.
    ENDIF.

    LOOP AT lt_classes ASSIGNING &lt;ls_class&gt;.
      CHECK lv_class_name IS INITIAL OR lv_class_name = &lt;ls_class&gt;-clsname.

      CALL METHOD (&lt;ls_class&gt;-clsname)=&gt;zif_abapgit_gui_page_hotkey~get_hotkey_actions
        RECEIVING
          rt_hotkey_actions = lt_hotkey_actions.

      INSERT LINES OF lt_hotkey_actions INTO TABLE rt_hotkey_actions.

    ENDLOOP.

    &quot; the global shortcuts are defined in the base class
    lt_hotkey_actions = zcl_abapgit_gui_page=&gt;get_hotkey_actions( ).
    INSERT LINES OF lt_hotkey_actions INTO TABLE rt_hotkey_actions.

    SORT rt_hotkey_actions.
    DELETE ADJACENT DUPLICATES FROM rt_hotkey_actions.

  ENDMETHOD.
  METHOD get_relevant_hotkeys_for_page.

    DATA: lo_settings                    TYPE REF TO zcl_abapgit_settings,
          lv_class_name                  TYPE abap_abstypename,
          lt_hotkey_actions_of_curr_page TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action,
          lv_save_tabix                  TYPE syst-tabix,
          lt_hotkey_actions              TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action.

    FIELD-SYMBOLS: &lt;ls_hotkey&gt;              TYPE zif_abapgit_definitions=&gt;ty_hotkey.

    lo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).

    rt_hotkeys = lo_settings-&gt;get_hotkeys( ).

    lv_class_name = cl_abap_classdescr=&gt;get_class_name( io_page ).

    TRY.
        CALL METHOD (lv_class_name)=&gt;zif_abapgit_gui_page_hotkey~get_hotkey_actions
          RECEIVING
            rt_hotkey_actions = lt_hotkey_actions_of_curr_page.

      CATCH cx_root.
        RETURN.
    ENDTRY.

    &quot; these are the global shortcuts
    lt_hotkey_actions = zcl_abapgit_gui_page=&gt;get_hotkey_actions( ).
    INSERT LINES OF lt_hotkey_actions INTO TABLE lt_hotkey_actions_of_curr_page.

    LOOP AT rt_hotkeys ASSIGNING &lt;ls_hotkey&gt;.

      lv_save_tabix = sy-tabix.

      READ TABLE lt_hotkey_actions_of_curr_page TRANSPORTING NO FIELDS
                                                WITH TABLE KEY action
                                                COMPONENTS action = &lt;ls_hotkey&gt;-action.
      IF sy-subrc &lt;&gt; 0.
        &quot; We only offer hotkeys which are supported by the current page or globally
        DELETE rt_hotkeys INDEX lv_save_tabix.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD should_show_hint.
    IF gv_hint_was_shown = abap_false.
      rv_yes = abap_true.
      gv_hint_was_shown = abap_true.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_VIEW_TUTORIAL IMPLEMENTATION.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;h1&gt;Tutorial&lt;/h1&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;hr&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;h2&gt;Adding and cloning repos&lt;/h2&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;p&gt;&lt;ul&gt;&apos; ).

    ro_html-&gt;add( `&lt;li&gt;To clone a remote repo (e.g. from github) click ` ).
    ro_html-&gt;add_a( iv_txt = &apos;+ Online&apos; iv_act = zif_abapgit_definitions=&gt;c_action-repo_newonline ).
    ro_html-&gt;add( &apos; from the top menu. This will copy a remote repo to your system.&lt;/li&gt;&apos; ).

    ro_html-&gt;add( `&lt;li&gt;To add a local package as a repo click ` ).
    ro_html-&gt;add_a( iv_txt = &apos;+ Offline&apos; iv_act = zif_abapgit_definitions=&gt;c_action-repo_newoffline ).
    ro_html-&gt;add( &apos; from the top menu. This will track a repo which already exist in&apos; ).
    ro_html-&gt;add( &apos; the system with abapGit. You&apos;&apos;ll be able to attach it to remote origin&apos; ).
    ro_html-&gt;add( &apos; or just serialize as a zip file&lt;/li&gt;&apos; ).

    ro_html-&gt;add( `&lt;li&gt;Go ` ).
    ro_html-&gt;add_a( iv_txt = &apos;Explore&apos; iv_act = zif_abapgit_definitions=&gt;c_action-go_explore ).
    ro_html-&gt;add( &apos; to find projects using abapGit&lt;/li&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/ul&gt;&lt;/p&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;h2&gt;Repository list and favorites&lt;/h2&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;p&gt;&lt;ul&gt;&apos; ).
    ro_html-&gt;add( |&lt;li&gt;To choose a repo press {
                  zcl_abapgit_html=&gt;icon( &apos;three-bars/blue&apos; ) } at the favorite bar.&lt;/li&gt;| ).
    ro_html-&gt;add( |&lt;li&gt;To favorite a repo click {
                  zcl_abapgit_html=&gt;icon( &apos;star/darkgrey&apos; ) } icon at repo toolbar.&lt;/li&gt;| ).
    ro_html-&gt;add( &apos;&lt;/ul&gt;&lt;/p&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;h2&gt;abapGit repository&lt;/h2&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;p&gt;&lt;ul&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;li&gt;&apos; ).
    IF zcl_abapgit_services_abapgit=&gt;is_installed( ) = abap_true.
      ro_html-&gt;add( &apos;abapGit installed in package&amp;nbsp;&apos; ).
      ro_html-&gt;add( zcl_abapgit_services_abapgit=&gt;c_package_abapgit ).
    ELSE.
      ro_html-&gt;add_a( iv_txt = &apos;install abapGit repo&apos; iv_act = zif_abapgit_definitions=&gt;c_action-abapgit_install ).
      ro_html-&gt;add( &apos; - To keep abapGit up-to-date (or also to contribute) you need to&apos; ).
      ro_html-&gt;add( &apos;install it as a repository.&apos; ).
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/li&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/ul&gt;&lt;/p&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.
    ev_state = zif_abapgit_definitions=&gt;c_event_state-not_handled.
  ENDMETHOD.
  METHOD zif_abapgit_gui_page~render.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;tutorial&quot;&gt;&apos; ).
    ro_html-&gt;add( render_content( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_VIEW_REPO IMPLEMENTATION.
  METHOD build_dir_jump_link.

    DATA: lv_path   TYPE string,
          lv_encode TYPE string.

    lv_path = iv_path.
    REPLACE FIRST OCCURRENCE OF mv_cur_dir IN lv_path WITH &apos;&apos;.
    lv_encode = zcl_abapgit_html_action_utils=&gt;dir_encode( lv_path ).

    rv_html = zcl_abapgit_html=&gt;a( iv_txt = lv_path
                                   iv_act = |{ c_actions-change_dir }?{ lv_encode }| ).

  ENDMETHOD.
  METHOD build_grid_menu.

    CREATE OBJECT ro_toolbar.

    IF mo_repo-&gt;has_remote_source( ) = abap_true.
      ro_toolbar-&gt;add(  &quot; Show/Hide files
        iv_txt = &apos;Show files&apos;
        iv_chk = boolc( NOT mv_hide_files = abap_true )
        iv_act = c_actions-toggle_hide_files ).

      ro_toolbar-&gt;add(  &quot; Show changes only
        iv_txt = &apos;Show changes only&apos;
        iv_chk = mv_changes_only
        iv_act = c_actions-toggle_changes ).
    ENDIF.

    ro_toolbar-&gt;add(  &quot; Show/Hide folders
      iv_txt = &apos;Show folders&apos;
      iv_chk = mv_show_folders
      iv_act = c_actions-toggle_folders ).

  ENDMETHOD.
  METHOD build_head_menu.

    DATA: lo_tb_advanced TYPE REF TO zcl_abapgit_html_toolbar,
          lo_tb_branch   TYPE REF TO zcl_abapgit_html_toolbar,
          lo_tb_tag      TYPE REF TO zcl_abapgit_html_toolbar,
          lv_key         TYPE zif_abapgit_persistence=&gt;ty_value,
          lv_wp_opt      LIKE zif_abapgit_definitions=&gt;c_html_opt-crossout,
          lv_crossout    LIKE zif_abapgit_definitions=&gt;c_html_opt-crossout,
          lv_pull_opt    LIKE zif_abapgit_definitions=&gt;c_html_opt-crossout.

    CREATE OBJECT ro_toolbar.
    CREATE OBJECT lo_tb_branch.
    CREATE OBJECT lo_tb_advanced.
    CREATE OBJECT lo_tb_tag.

    lv_key = mo_repo-&gt;get_key( ).

    IF mo_repo-&gt;get_local_settings( )-write_protected = abap_true.
      lv_wp_opt   = zif_abapgit_definitions=&gt;c_html_opt-crossout.
      lv_pull_opt = zif_abapgit_definitions=&gt;c_html_opt-crossout.
    ELSE.
      lv_pull_opt = zif_abapgit_definitions=&gt;c_html_opt-strong.
    ENDIF.

    &quot; Build branch drop-down ========================
    IF mo_repo-&gt;is_offline( ) = abap_false. &quot; Online ?
      lo_tb_branch-&gt;add( iv_txt = &apos;Overview&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_branch_overview }?{ lv_key }| ).
      lo_tb_branch-&gt;add( iv_txt = &apos;Switch&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_branch_switch }?{ lv_key }|
                         iv_opt = lv_wp_opt ).
      lo_tb_branch-&gt;add( iv_txt = &apos;Create&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_branch_create }?{ lv_key }| ).
      lo_tb_branch-&gt;add( iv_txt = &apos;Delete&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_branch_delete }?{ lv_key }| ).

      lo_tb_tag-&gt;add( iv_txt = &apos;Overview&apos;
                      iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_tag_overview }?{ lv_key }| ).
      lo_tb_tag-&gt;add( iv_txt = &apos;Switch&apos;
                      iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_tag_switch }?{ lv_key }|
                      iv_opt = lv_wp_opt ).
      lo_tb_tag-&gt;add( iv_txt = &apos;Create&apos;
                      iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_tag_create }?{ lv_key }| ).
      lo_tb_tag-&gt;add( iv_txt = &apos;Delete&apos;
                      iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_tag_delete }?{ lv_key }| ).

    ENDIF.

    &quot; Build advanced drop-down ========================
    IF iv_rstate IS NOT INITIAL OR iv_lstate IS NOT INITIAL. &quot; In case of asyncronicities
      lo_tb_advanced-&gt;add( iv_txt = &apos;Reset local&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_reset }?{ lv_key }|
                           iv_opt = lv_wp_opt ).
    ENDIF.
    IF mo_repo-&gt;is_offline( ) = abap_false. &quot; Online ?
      lo_tb_advanced-&gt;add( iv_txt = &apos;Background mode&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_background }?{ lv_key }| ).
      lo_tb_advanced-&gt;add( iv_txt = &apos;Change remote&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_remote_change }?{ lv_key }| ).
      lo_tb_advanced-&gt;add( iv_txt = &apos;Make off-line&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_remote_detach }?{ lv_key }| ).
      lo_tb_advanced-&gt;add( iv_txt = &apos;Force stage&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_stage }?{ lv_key }| ).

      CLEAR lv_crossout.
      IF zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-transport_to_branch ) = abap_false.
        lv_crossout = zif_abapgit_definitions=&gt;c_html_opt-crossout.
      ENDIF.
      lo_tb_advanced-&gt;add( iv_txt = &apos;Transport to Branch&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_transport_to_branch }?{ lv_key }|
                           iv_opt = lv_crossout ).

    ELSE.
      lo_tb_advanced-&gt;add( iv_txt = &apos;Make on-line&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_remote_attach }?{ lv_key }| ).
    ENDIF.
    lo_tb_advanced-&gt;add( iv_txt = &apos;Syntax Check&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_syntax_check }?{ lv_key }| ).
    lo_tb_advanced-&gt;add( iv_txt = &apos;Run Code Inspector&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_code_inspector }?{ lv_key }| ).
    lo_tb_advanced-&gt;add( iv_txt = &apos;Repo settings&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_settings }?{ lv_key }| ).

    CLEAR lv_crossout.
    IF zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-update_local_checksum ) = abap_false.
      lv_crossout = zif_abapgit_definitions=&gt;c_html_opt-crossout.
    ENDIF.
    lo_tb_advanced-&gt;add( iv_txt = &apos;Update local checksums&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_refresh_checksums }?{ lv_key }|
                         iv_opt = lv_crossout ).

    IF mo_repo-&gt;get_dot_abapgit( )-&gt;get_master_language( ) &lt;&gt; sy-langu.
      lo_tb_advanced-&gt;add( iv_txt = &apos;Open in master language&apos;
                           iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_open_in_master_lang }?{ lv_key }| ).
    ENDIF.

    lo_tb_advanced-&gt;add( iv_txt = &apos;Remove&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_remove }?{ lv_key }| ).

    CLEAR lv_crossout.
    IF mo_repo-&gt;get_local_settings( )-write_protected = abap_true
        OR zcl_abapgit_auth=&gt;is_allowed( zif_abapgit_auth=&gt;gc_authorization-uninstall ) = abap_false.
      lv_crossout = zif_abapgit_definitions=&gt;c_html_opt-crossout.
    ENDIF.
    lo_tb_advanced-&gt;add( iv_txt = &apos;Uninstall&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_purge }?{ lv_key }|
                         iv_opt = lv_crossout ).

    &quot; Build main toolbar ==============================
    IF mo_repo-&gt;is_offline( ) = abap_false. &quot; Online ?
      IF iv_rstate IS NOT INITIAL. &quot; Something new at remote
        ro_toolbar-&gt;add( iv_txt = &apos;Pull&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_pull }?{ lv_key }|
                         iv_opt = lv_pull_opt ).
      ENDIF.
      IF iv_lstate IS NOT INITIAL. &quot; Something new at local
        ro_toolbar-&gt;add( iv_txt = &apos;Stage&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_stage }?{ lv_key }|
                         iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ENDIF.
      IF iv_rstate IS NOT INITIAL OR iv_lstate IS NOT INITIAL. &quot; Any changes
        ro_toolbar-&gt;add( iv_txt = &apos;Show diff&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?key={ lv_key }|
                         iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ENDIF.
      ro_toolbar-&gt;add( iv_txt = &apos;Branch&apos;
                       io_sub = lo_tb_branch ) ##NO_TEXT.
      ro_toolbar-&gt;add( iv_txt = &apos;Tag&apos;
                       io_sub = lo_tb_tag ) ##NO_TEXT.
    ELSE.
      IF mo_repo-&gt;has_remote_source( ) = abap_true AND iv_rstate IS NOT INITIAL.
        ro_toolbar-&gt;add( iv_txt = &apos;Pull &lt;sup&gt;zip&lt;/sup&gt;&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_pull }?{ lv_key }|
                         iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
        ro_toolbar-&gt;add( iv_txt = &apos;Show diff&apos;
                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?key={ lv_key }|
                         iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ENDIF.
      ro_toolbar-&gt;add( iv_txt = &apos;Import &lt;sup&gt;zip&lt;/sup&gt;&apos;
                       iv_act = |{ zif_abapgit_definitions=&gt;c_action-zip_import }?{ lv_key }|
                       iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ro_toolbar-&gt;add( iv_txt = &apos;Export &lt;sup&gt;zip&lt;/sup&gt;&apos;
                       iv_act = |{ zif_abapgit_definitions=&gt;c_action-zip_export }?{ lv_key }|
                       iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
    ENDIF.

    ro_toolbar-&gt;add( iv_txt = &apos;Advanced&apos;
                     io_sub = lo_tb_advanced ) ##NO_TEXT.
    ro_toolbar-&gt;add( iv_txt = &apos;Refresh&apos;
                     iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_refresh }?{ lv_key }| ).
    ro_toolbar-&gt;add( iv_txt = zcl_abapgit_html=&gt;icon( iv_name = &apos;settings/grey70&apos; )
                     io_sub = build_grid_menu( ) ).

  ENDMETHOD.
  METHOD build_inactive_object_code.

    IF is_item-inactive = abap_true.
      rv_inactive_html_code = zcl_abapgit_html=&gt;icon(
        iv_name  = &apos;zap/orange&apos;
        iv_hint  = &apos;Object or object part is inactive&apos;
        iv_class = &apos;inactive&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD build_obj_jump_link.

    DATA: lv_encode TYPE string.

    lv_encode = zcl_abapgit_html_action_utils=&gt;jump_encode( iv_obj_type = is_item-obj_type
                                                    iv_obj_name = is_item-obj_name ).

    rv_html = zcl_abapgit_html=&gt;a( iv_txt = |{ is_item-obj_name }|
                                   iv_act = |{ zif_abapgit_definitions=&gt;c_action-jump }?{ lv_encode }| ).

  ENDMETHOD.
  METHOD constructor.

    DATA lo_settings TYPE REF TO zcl_abapgit_settings.

    super-&gt;constructor( ).

    mo_repo         = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    mv_cur_dir      = &apos;/&apos;. &quot; Root
    mv_hide_files   = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_hide_files( ).
    mv_changes_only = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_changes_only( ).

    &quot; Read global settings to get max # of objects to be listed
    lo_settings     = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).
    mv_max_lines    = lo_settings-&gt;get_max_lines( ).
    mv_max_setting  = mv_max_lines.

  ENDMETHOD.
  METHOD get_item_class.

    DATA lt_class TYPE TABLE OF string.

    IF is_item-is_dir = abap_true.
      APPEND &apos;folder&apos; TO lt_class.
    ELSEIF is_item-changes &gt; 0.
      APPEND &apos;modified&apos; TO lt_class.
    ELSEIF is_item-obj_name IS INITIAL.
      APPEND &apos;unsupported&apos; TO lt_class.
    ENDIF.

    IF lines( lt_class ) &gt; 0.
      rv_html = | class=&quot;{ concat_lines_of( table = lt_class sep = ` ` ) }&quot;|.
    ENDIF.

  ENDMETHOD.
  METHOD get_item_icon.

    CASE is_item-obj_type.
      WHEN &apos;PROG&apos; OR &apos;CLAS&apos; OR &apos;FUGR&apos;.
        rv_html = zcl_abapgit_html=&gt;icon( &apos;file-code/darkgrey&apos; ).
      WHEN &apos;W3MI&apos; OR &apos;W3HT&apos;.
        rv_html = zcl_abapgit_html=&gt;icon( &apos;file-binary/darkgrey&apos; ).
      WHEN &apos;&apos;.
        rv_html = space. &quot; no icon
      WHEN OTHERS.
        rv_html = zcl_abapgit_html=&gt;icon( &apos;file/darkgrey&apos; ).
    ENDCASE.

    IF is_item-is_dir = abap_true.
      rv_html = zcl_abapgit_html=&gt;icon( &apos;file-directory/darkgrey&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD open_in_master_language.

    CONSTANTS:
      lc_abapgit_tcode TYPE tcode VALUE `ZABAPGIT` ##NO_TEXT.

    DATA:
      lv_master_language TYPE spras,
      lt_spagpa          TYPE STANDARD TABLE OF rfc_spagpa,
      ls_spagpa          LIKE LINE OF lt_spagpa,
      ls_item            TYPE zif_abapgit_definitions=&gt;ty_item,
      lv_subrc           TYPE syst-subrc,
      lv_save_sy_langu   TYPE sy-langu.

    &quot; https://blogs.sap.com/2017/01/13/logon-language-sy-langu-and-rfc/

    lv_master_language = mo_repo-&gt;get_dot_abapgit( )-&gt;get_master_language( ).

    IF lv_master_language = sy-langu.
      zcx_abapgit_exception=&gt;raise( |Repo already opened in master language| ).
    ENDIF.

    ls_item-obj_name = lc_abapgit_tcode.
    ls_item-obj_type = |TRAN|.

    IF zcl_abapgit_objects=&gt;exists( ls_item ) = abap_false.
      zcx_abapgit_exception=&gt;raise( |Please install the abapGit repository| ).
    ENDIF.

    lv_save_sy_langu = sy-langu.
    SET LOCALE LANGUAGE lv_master_language.

    ls_spagpa-parid  = zif_abapgit_definitions=&gt;c_spagpa_param_repo_key.
    ls_spagpa-parval = mo_repo-&gt;get_key( ).
    INSERT ls_spagpa INTO TABLE lt_spagpa.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      DESTINATION &apos;NONE&apos;
      STARTING NEW TASK &apos;ABAPGIT&apos;
      EXPORTING
        tcode                   = lc_abapgit_tcode
      TABLES
        spagpa_tab              = lt_spagpa
      EXCEPTIONS
        call_transaction_denied = 1
        tcode_invalid           = 2
        communication_failure   = 3
        system_failure          = 4
        OTHERS                  = 5.

    lv_subrc = sy-subrc.

    SET LOCALE LANGUAGE lv_save_sy_langu.

    IF lv_subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from ABAP4_CALL_TRANSACTION. Subrc = { lv_subrc }| ).
    ENDIF.

    MESSAGE &apos;Repository opened in a new window&apos; TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD render_empty_package.

    DATA: lv_text TYPE string.

    IF mv_changes_only = abap_true.
      lv_text = |No changes|.
    ELSE.
      lv_text = |Empty package|.
    ENDIF.

    rv_html = |&lt;tr class=&quot;unsupported&quot;&gt;&lt;td class=&quot;paddings&quot;&gt;|
           &amp;&amp; |  &lt;center&gt;{ lv_text }&lt;/center&gt;|
           &amp;&amp; |&lt;/td&gt;&lt;/tr&gt;|.

  ENDMETHOD.
  METHOD render_head_line.

    DATA lo_toolbar TYPE REF TO zcl_abapgit_html_toolbar.

    CREATE OBJECT ro_html.
    lo_toolbar = build_head_menu( iv_lstate = iv_lstate iv_rstate = iv_rstate ).

    ro_html-&gt;add( &apos;&lt;div class=&quot;paddings&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&lt;tr&gt;&apos; ).

    IF mv_show_folders = abap_true.
      ro_html-&gt;add( |&lt;td class=&quot;current_dir&quot;&gt;{ mv_cur_dir }&lt;/td&gt;| ).
    ENDIF.

    ro_html-&gt;add( &apos;&lt;td class=&quot;right&quot;&gt;&apos; ).
    ro_html-&gt;add( lo_toolbar-&gt;render( iv_right = abap_true ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_item.

    DATA: lv_link    TYPE string,
          lv_colspan TYPE i.

    CREATE OBJECT ro_html.

    IF iv_render_transports = abap_false.
      lv_colspan = 2.
    ELSE.
      lv_colspan = 3.
    ENDIF.

    ro_html-&gt;add( |&lt;tr{ get_item_class( is_item ) }&gt;| ).

    IF is_item-obj_name IS INITIAL AND is_item-is_dir = abap_false.
      ro_html-&gt;add( |&lt;td colspan=&quot;{ lv_colspan }&quot;&gt;&lt;/td&gt;|
                 &amp;&amp; &apos;&lt;td class=&quot;object&quot;&gt;&apos;
                 &amp;&amp; &apos;&lt;i class=&quot;grey&quot;&gt;non-code and meta files&lt;/i&gt;&apos;
                 &amp;&amp; &apos;&lt;/td&gt;&apos; ).
    ELSE.
      ro_html-&gt;add( |&lt;td class=&quot;icon&quot;&gt;{ get_item_icon( is_item ) }&lt;/td&gt;| ).
      IF iv_render_transports = abap_true.
        ro_html-&gt;add( render_item_lock_column( is_item ) ).
      ENDIF.

      IF is_item-is_dir = abap_true. &quot; Subdir
        lv_link = build_dir_jump_link( is_item-path ).
        ro_html-&gt;add( |&lt;td class=&quot;dir&quot; colspan=&quot;2&quot;&gt;{ lv_link }&lt;/td&gt;| ).
      ELSE.
        lv_link = build_obj_jump_link( is_item ).
        ro_html-&gt;add( |&lt;td class=&quot;type&quot;&gt;{ is_item-obj_type }&lt;/td&gt;| ).
        ro_html-&gt;add( |&lt;td class=&quot;object&quot;&gt;{ lv_link } { build_inactive_object_code( is_item ) }&lt;/td&gt;| ).
      ENDIF.
    ENDIF.

    &quot; Files
    ro_html-&gt;add( &apos;&lt;td class=&quot;files&quot;&gt;&apos; ).
    ro_html-&gt;add( render_item_files( is_item ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    &quot; Command
    IF mo_repo-&gt;has_remote_source( ) = abap_true.
      ro_html-&gt;add( &apos;&lt;td class=&quot;cmd&quot;&gt;&apos; ).
      ro_html-&gt;add( render_item_command( is_item ) ).
      ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).

  ENDMETHOD.
  METHOD render_item_command.

    DATA: lv_difflink TYPE string,
          ls_file     LIKE LINE OF is_item-files.

    CREATE OBJECT ro_html.

    IF is_item-is_dir = abap_true. &quot; Directory

      ro_html-&gt;add( &apos;&lt;div&gt;&apos; ).
      ro_html-&gt;add( |&lt;span class=&quot;grey&quot;&gt;{ is_item-changes } changes&lt;/span&gt;| ).
      ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_item_state( iv_lstate = is_item-lstate
                                                          iv_rstate = is_item-rstate ) ).
      ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ELSEIF is_item-changes &gt; 0.

      IF mv_hide_files = abap_true AND is_item-obj_name IS NOT INITIAL.

        lv_difflink = zcl_abapgit_html_action_utils=&gt;obj_encode(
          iv_key    = mo_repo-&gt;get_key( )
          ig_object = is_item ).

        ro_html-&gt;add( &apos;&lt;div&gt;&apos; ).
        ro_html-&gt;add_a( iv_txt = |view diff ({ is_item-changes })|
                        iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?{ lv_difflink }| ).
        ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_item_state( iv_lstate = is_item-lstate
                                                            iv_rstate = is_item-rstate ) ).
        ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

      ELSE.
        LOOP AT is_item-files INTO ls_file.

          ro_html-&gt;add( &apos;&lt;div&gt;&apos; ).
          IF ls_file-is_changed = abap_true.
            lv_difflink = zcl_abapgit_html_action_utils=&gt;file_encode(
              iv_key  = mo_repo-&gt;get_key( )
              ig_file = ls_file ).
            ro_html-&gt;add_a( iv_txt = &apos;view diff&apos;
                            iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?{ lv_difflink }| ).
            ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_item_state( iv_lstate = ls_file-lstate
                                                                iv_rstate = ls_file-rstate ) ).
          ELSE.
            ro_html-&gt;add( &apos;&amp;nbsp;&apos; ).
          ENDIF.
          ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

        ENDLOOP.
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD render_item_files.

    DATA: ls_file     LIKE LINE OF is_item-files.

    CREATE OBJECT ro_html.

    IF mv_hide_files = abap_true AND is_item-obj_type IS NOT INITIAL.
      RETURN.
    ENDIF.

    LOOP AT is_item-files INTO ls_file.
      ro_html-&gt;add( |&lt;div&gt;{ ls_file-path &amp;&amp; ls_file-filename }&lt;/div&gt;| ).
    ENDLOOP.

  ENDMETHOD.
  METHOD render_item_lock_column.
    DATA: li_cts_api          TYPE REF TO zif_abapgit_cts_api,
          lv_transport        TYPE trkorr,
          lv_transport_string TYPE string,
          lv_icon_html        TYPE string.

    li_cts_api = zcl_abapgit_factory=&gt;get_cts_api( ).

    TRY.
        IF is_item-obj_type IS INITIAL OR is_item-obj_name IS INITIAL OR
           li_cts_api-&gt;is_object_type_lockable( is_item-obj_type ) = abap_false OR
           li_cts_api-&gt;is_object_locked_in_transport( iv_object_type = is_item-obj_type
                                                      iv_object_name = is_item-obj_name ) = abap_false.
          rv_html = |&lt;td class=&quot;icon&quot;&gt;&lt;/td&gt;|.
        ELSE.
          lv_transport = li_cts_api-&gt;get_current_transport_for_obj( iv_object_type             = is_item-obj_type
                                                                    iv_object_name             = is_item-obj_name
                                                                    iv_resolve_task_to_request = abap_false ).
          lv_transport_string = lv_transport.
          lv_icon_html = zcl_abapgit_html=&gt;a( iv_txt = zcl_abapgit_html=&gt;icon( iv_name = &apos;briefcase/darkgrey&apos;
                                                                               iv_hint = lv_transport_string )
                                              iv_act = |{ zif_abapgit_definitions=&gt;c_action-jump_transport }?| &amp;&amp;
                                                       lv_transport ).
          rv_html = |&lt;td class=&quot;icon&quot;&gt;| &amp;&amp;
                    |{ lv_icon_html }| &amp;&amp;
                    |&lt;/td&gt;|.
        ENDIF.
      CATCH zcx_abapgit_exception.
        ASSERT 1 = 2.
    ENDTRY.
  ENDMETHOD.
  METHOD render_parent_dir.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;tr class=&quot;folder&quot;&gt;&apos; ).
    ro_html-&gt;add( |&lt;td class=&quot;icon&quot;&gt;{ zcl_abapgit_html=&gt;icon( &apos;dir&apos; ) }&lt;/td&gt;| ).
    ro_html-&gt;add( |&lt;td class=&quot;object&quot; colspan=&quot;4&quot;&gt;{ build_dir_jump_link( &apos;..&apos; ) }&lt;/td&gt;| ).
    IF mo_repo-&gt;has_remote_source( ) = abap_true.
      ro_html-&gt;add( |&lt;td colspan=&quot;1&quot;&gt;&lt;/td&gt;| ). &quot; Dummy for online
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lv_path TYPE string.

    CASE iv_action.
      WHEN c_actions-toggle_hide_files. &quot; Toggle file diplay
        mv_hide_files   = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;toggle_hide_files( ).
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-change_dir.        &quot; Change dir
        lv_path         = zcl_abapgit_html_action_utils=&gt;dir_decode( iv_getdata ).
        mv_cur_dir      = zcl_abapgit_path=&gt;change_dir( iv_cur_dir = mv_cur_dir iv_cd = lv_path ).
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-toggle_folders.    &quot; Toggle folder view
        mv_show_folders = boolc( mv_show_folders &lt;&gt; abap_true ).
        mv_cur_dir      = &apos;/&apos;. &quot; Root
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-toggle_changes.    &quot; Toggle changes only view
        mv_changes_only = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;toggle_changes_only( ).
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-display_more.      &quot; Increase MAX lines limit
        mv_max_lines    = mv_max_lines + mv_max_setting.
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_open_in_master_lang.
        open_in_master_language( ).
        ev_state        = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~render.

    DATA: lt_repo_items        TYPE zif_abapgit_definitions=&gt;tt_repo_items,
          lo_browser           TYPE REF TO zcl_abapgit_repo_content_list,
          lx_error             TYPE REF TO zcx_abapgit_exception,
          lv_lstate            TYPE char1,
          lv_rstate            TYPE char1,
          lv_max               TYPE abap_bool,
          lv_max_str           TYPE string,
          lv_add_str           TYPE string,
          lo_log               TYPE REF TO zcl_abapgit_log,
          lv_render_transports TYPE abap_bool.

    FIELD-SYMBOLS &lt;ls_item&gt; LIKE LINE OF lt_repo_items.

    &quot; Reinit, for the case of type change
    mo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mo_repo-&gt;get_key( ) ).

    CREATE OBJECT ro_html.

    TRY.

        lv_render_transports = zcl_abapgit_factory=&gt;get_cts_api(
          )-&gt;is_chrec_possible_for_package( mo_repo-&gt;get_package( ) ).

        CREATE OBJECT lo_browser
          EXPORTING
            io_repo = mo_repo.

        lt_repo_items = lo_browser-&gt;list( iv_path         = mv_cur_dir
                                          iv_by_folders   = mv_show_folders
                                          iv_changes_only = mv_changes_only ).

        LOOP AT lt_repo_items ASSIGNING &lt;ls_item&gt;.
          zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = &lt;ls_item&gt;-lstate
                                     CHANGING cv_prev = lv_lstate ).
          zcl_abapgit_state=&gt;reduce( EXPORTING iv_cur = &lt;ls_item&gt;-rstate
                                     CHANGING cv_prev = lv_rstate ).
        ENDLOOP.

        ro_html-&gt;add( render_head_line( iv_lstate = lv_lstate
                                        iv_rstate = lv_rstate ) ).

        lo_log = lo_browser-&gt;get_log( ).
        IF mo_repo-&gt;is_offline( ) = abap_false AND lo_log-&gt;count( ) &gt; 0.
          ro_html-&gt;add( &apos;&lt;div class=&quot;log&quot;&gt;&apos; ).
          ro_html-&gt;add( lo_log-&gt;to_html( ) ). &quot; shows eg. list of unsupported objects
          ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
        ENDIF.

        ro_html-&gt;add( &apos;&lt;div class=&quot;repo_container&quot;&gt;&apos; ).

        &quot; Repo content table
        ro_html-&gt;add( &apos;&lt;table class=&quot;repo_tab&quot;&gt;&apos; ).

        IF zcl_abapgit_path=&gt;is_root( mv_cur_dir ) = abap_false.
          ro_html-&gt;add( render_parent_dir( ) ).
        ENDIF.

        IF lines( lt_repo_items ) = 0.
          ro_html-&gt;add( render_empty_package( ) ).
        ELSE.
          LOOP AT lt_repo_items ASSIGNING &lt;ls_item&gt;.
            IF mv_max_lines &gt; 0 AND sy-tabix &gt; mv_max_lines.
              lv_max = abap_true.
              EXIT. &quot; current loop
            ENDIF.
            ro_html-&gt;add( render_item( is_item = &lt;ls_item&gt; iv_render_transports = lv_render_transports ) ).
          ENDLOOP.
        ENDIF.

        ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

        IF lv_max = abap_true.
          ro_html-&gt;add( &apos;&lt;div class = &quot;dummydiv&quot;&gt;&apos; ).
          IF mv_max_lines = 1.
            lv_max_str = &apos;1 object&apos;.
          ELSE.
            lv_max_str = |first { mv_max_lines } objects|.
          ENDIF.
          lv_add_str = |+{ mv_max_setting }|.
          ro_html-&gt;add( |Only { lv_max_str } shown in list. Display {
            zcl_abapgit_html=&gt;a( iv_txt = lv_add_str iv_act = c_actions-display_more )
            } more. (Set in Advanced &gt; {
            zcl_abapgit_html=&gt;a( iv_txt = &apos;Settings&apos; iv_act = zif_abapgit_definitions=&gt;c_action-go_settings )
            } )| ).
          ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
        ENDIF.

        ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

      CATCH zcx_abapgit_exception INTO lx_error.
        ro_html-&gt;add( render_head_line( iv_lstate = lv_lstate iv_rstate = lv_rstate ) ).
        ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_error( ix_error = lx_error ) ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_ROUTER IMPLEMENTATION.
  METHOD abapgit_services_actions.

    CASE is_event_data-action.
        &quot; ABAPGIT services actions
      WHEN zif_abapgit_definitions=&gt;c_action-abapgit_home.                    &quot; Go abapGit homepage
        zcl_abapgit_services_abapgit=&gt;open_abapgit_homepage( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-abapgit_install.                 &quot; Install abapGit
        zcl_abapgit_services_abapgit=&gt;install_abapgit( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
  METHOD db_actions.

    CASE is_event_data-action.
        &quot; DB actions
      WHEN zif_abapgit_definitions=&gt;c_action-db_edit.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_db_edit
          EXPORTING
            is_key = zcl_abapgit_html_action_utils=&gt;dbkey_decode( is_event_data-getdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
        IF is_event_data-prev_page = &apos;PAGE_DB_DIS&apos;.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page_replacing.
        ENDIF.
      WHEN zif_abapgit_definitions=&gt;c_action-db_display.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_db_dis
          EXPORTING
            is_key = zcl_abapgit_html_action_utils=&gt;dbkey_decode( is_event_data-getdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
    ENDCASE.

  ENDMETHOD.
  METHOD general_page_routing.

    DATA: lv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = is_event_data-getdata. &quot; TODO refactor

    CASE is_event_data-action.
        &quot; General PAGE routing
      WHEN zif_abapgit_definitions=&gt;c_action-go_main.                          &quot; Go Main page
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_main.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_explore.                     &quot; Go Explore page
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_explore.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_repo_overview.               &quot; Go Repository overview
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_repo_over.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_db.                          &quot; Go DB util page
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_db.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_debuginfo.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_debuginfo.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_settings.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_settings.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_background_run.              &quot; Go background run page
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_bkg_run.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_background.                   &quot; Go Background page
        ei_page  = get_page_background( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_diff.                         &quot; Go Diff page
        ei_page  = get_page_diff(
          iv_getdata   = is_event_data-getdata
          iv_prev_page = is_event_data-prev_page ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page_w_bookmark.
      WHEN zif_abapgit_definitions=&gt;c_action-go_stage.                        &quot; Go Staging page
        ei_page  = get_page_stage( is_event_data-getdata ).
        IF is_event_data-prev_page = &apos;PAGE_DIFF&apos;.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
        ELSE.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page_w_bookmark.
        ENDIF.
      WHEN zif_abapgit_definitions=&gt;c_action-go_branch_overview.              &quot; Go repo branch overview
        ei_page  = get_page_branch_overview( is_event_data-getdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_playground.                   &quot; Create playground page
        ei_page  = get_page_playground( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-go_tutorial.                     &quot; Go to tutorial
        zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( &apos;&apos; ).        &quot; Clear show_id
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.          &quot; Assume we are on main page
    ENDCASE.

  ENDMETHOD.
  METHOD get_page_background.

    CREATE OBJECT ri_page TYPE zcl_abapgit_gui_page_bkg
      EXPORTING
        iv_key = iv_key.

  ENDMETHOD.
  METHOD get_page_branch_overview.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online,
          lo_page TYPE REF TO zcl_abapgit_gui_page_boverview,
          lv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = iv_getdata.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).

    CREATE OBJECT lo_page
      EXPORTING
        io_repo = lo_repo.

    ri_page = lo_page.

  ENDMETHOD.
  METHOD get_page_diff.

    DATA: ls_file   TYPE zif_abapgit_definitions=&gt;ty_file,
          ls_object TYPE zif_abapgit_definitions=&gt;ty_item,
          lo_page   TYPE REF TO zcl_abapgit_gui_page_diff,
          lv_key    TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    zcl_abapgit_html_action_utils=&gt;file_obj_decode(
      EXPORTING
        iv_string = iv_getdata
      IMPORTING
        ev_key    = lv_key
        eg_file   = ls_file
        eg_object = ls_object ).

    CREATE OBJECT lo_page
      EXPORTING
        iv_key    = lv_key
        is_file   = ls_file
        is_object = ls_object.

    ri_page = lo_page.

  ENDMETHOD.
  METHOD get_page_playground.
    DATA: lv_class_name TYPE string,
          lv_cancel     TYPE abap_bool,
          li_popups     TYPE REF TO zif_abapgit_popups.

    li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
    li_popups-&gt;run_page_class_popup(
      IMPORTING
        ev_name   = lv_class_name
        ev_cancel = lv_cancel ).

    IF lv_cancel = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    TRY.
        CREATE OBJECT ri_page TYPE (lv_class_name).
      CATCH cx_sy_create_object_error.
        zcx_abapgit_exception=&gt;raise( |Cannot create page class { lv_class_name }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD get_page_stage.

    DATA: lo_repo                TYPE REF TO zcl_abapgit_repo_online,
          lv_key                 TYPE zif_abapgit_persistence=&gt;ty_repo-key,
          lv_seed                TYPE string,
          lo_stage_page          TYPE REF TO zcl_abapgit_gui_page_stage,
          lo_code_inspector_page TYPE REF TO zcl_abapgit_gui_page_code_insp.

    FIND FIRST OCCURRENCE OF &apos;=&apos; IN iv_getdata.
    IF sy-subrc &lt;&gt; 0. &quot; Not found ? -&gt; just repo key in params
      lv_key = iv_getdata.
    ELSE.
      zcl_abapgit_html_action_utils=&gt;stage_decode(
        EXPORTING iv_getdata = iv_getdata
        IMPORTING ev_key     = lv_key
                  ev_seed    = lv_seed ).
    ENDIF.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).

    IF lo_repo-&gt;get_local_settings( )-code_inspector_check_variant IS NOT INITIAL.

      CREATE OBJECT lo_code_inspector_page
        EXPORTING
          io_repo = lo_repo.

      ri_page = lo_code_inspector_page.

    ELSE.

      &quot; force refresh on stage, to make sure the latest local and remote files are used
      lo_repo-&gt;refresh( ).

      CREATE OBJECT lo_stage_page
        EXPORTING
          io_repo = lo_repo
          iv_seed = lv_seed.

      ri_page = lo_stage_page.

    ENDIF.

  ENDMETHOD.
  METHOD git_services.

    DATA: lv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = is_event_data-getdata. &quot; TODO refactor

    CASE is_event_data-action.
        &quot; GIT actions
      WHEN zif_abapgit_definitions=&gt;c_action-git_pull.                      &quot; GIT Pull
        zcl_abapgit_services_git=&gt;pull( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_reset.                     &quot; GIT Reset
        zcl_abapgit_services_git=&gt;reset( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_branch_create.             &quot; GIT Create new branch
        zcl_abapgit_services_git=&gt;create_branch( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_branch_delete.             &quot; GIT Delete remote branch
        zcl_abapgit_services_git=&gt;delete_branch( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_branch_switch.             &quot; GIT Switch branch
        zcl_abapgit_services_git=&gt;switch_branch( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-go_tag_overview.               &quot; GIT Tag overview
        zcl_abapgit_services_git=&gt;tag_overview( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_tag_create.                &quot; GIT Tag create
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_tag
          EXPORTING
            io_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-git_tag_delete.                &quot; GIT Tag create
        zcl_abapgit_services_git=&gt;delete_tag( lv_key ).
        zcl_abapgit_services_repo=&gt;refresh( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-git_tag_switch.                &quot; GIT Switch Tag
        zcl_abapgit_services_git=&gt;switch_tag( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
  METHOD jump_display_transport.
    DATA: lv_transport TYPE trkorr.

    lv_transport = iv_getdata.

    CALL FUNCTION &apos;TR_DISPLAY_REQUEST&apos;
      EXPORTING
        i_trkorr = lv_transport.
  ENDMETHOD.
  METHOD zif_abapgit_gui_router~on_event.

    DATA: ls_event_data TYPE ty_event_data.

    ls_event_data-action    = iv_action.
    ls_event_data-prev_page = iv_prev_page.
    ls_event_data-getdata   = iv_getdata.
    ls_event_data-postdata  = it_postdata.
    general_page_routing(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    repository_services(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    git_services(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    zip_services(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    db_actions(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    abapgit_services_actions(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    remote_origin_manipulations(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    sap_gui_actions(
      EXPORTING
        is_event_data = ls_event_data
      IMPORTING
        ei_page      = ei_page
        ev_state     = ev_state ).

    IF ev_state IS INITIAL.
      ev_state = zif_abapgit_definitions=&gt;c_event_state-not_handled.
    ENDIF.

  ENDMETHOD.
  METHOD remote_origin_manipulations.

    DATA: lv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = is_event_data-getdata. &quot; TODO refactor

    CASE is_event_data-action.
        &quot; Remote ORIGIN manipulations
      WHEN zif_abapgit_definitions=&gt;c_action-repo_remote_attach.            &quot; Remote attach
        zcl_abapgit_services_repo=&gt;remote_attach( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_remote_detach.            &quot; Remote detach
        zcl_abapgit_services_repo=&gt;remote_detach( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_remote_change.            &quot; Remote change
        zcl_abapgit_services_repo=&gt;remote_change( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
  METHOD repository_services.

    DATA: lv_url TYPE string,
          lv_key TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = is_event_data-getdata. &quot; TODO refactor
    lv_url = is_event_data-getdata. &quot; TODO refactor

    CASE is_event_data-action.
        &quot; REPOSITORY services actions
      WHEN zif_abapgit_definitions=&gt;c_action-repo_newoffline.                 &quot; New offline repo
        zcl_abapgit_services_repo=&gt;new_offline( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_refresh.                    &quot; Repo refresh
        zcl_abapgit_services_repo=&gt;refresh( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_syntax_check.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_syntax
          EXPORTING
            io_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_code_inspector.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_code_insp
          EXPORTING
            io_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_purge.                      &quot; Repo remove &amp; purge all objects
        zcl_abapgit_services_repo=&gt;purge( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_remove.                     &quot; Repo remove
        zcl_abapgit_services_repo=&gt;remove( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_newonline.
        zcl_abapgit_services_repo=&gt;new_online( lv_url ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN &apos;install&apos;.    &quot; &apos;install&apos; is for explore page
        zcl_abapgit_services_repo=&gt;new_online( lv_url ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_refresh_checksums.          &quot; Rebuil local checksums
        zcl_abapgit_services_repo=&gt;refresh_local_checksums( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_toggle_fav.                 &quot; Toggle repo as favorite
        zcl_abapgit_services_repo=&gt;toggle_favorite( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_transport_to_branch.
        zcl_abapgit_services_repo=&gt;transport_to_branch( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-repo_settings.
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_repo_sett
          EXPORTING
            io_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
    ENDCASE.

  ENDMETHOD.
  METHOD sap_gui_actions.

    DATA: ls_item TYPE zif_abapgit_definitions=&gt;ty_item.

    CASE is_event_data-action.
        &quot; SAP GUI actions
      WHEN zif_abapgit_definitions=&gt;c_action-jump.                          &quot; Open object editor
        zcl_abapgit_html_action_utils=&gt;jump_decode(
          EXPORTING iv_string   = is_event_data-getdata
          IMPORTING ev_obj_type = ls_item-obj_type
                    ev_obj_name = ls_item-obj_name ).
        zcl_abapgit_objects=&gt;jump( ls_item ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-jump_pkg.                      &quot; Open SE80
        zcl_abapgit_services_repo=&gt;open_se80( |{ is_event_data-getdata }| ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-jump_transport.
        jump_display_transport( is_event_data-getdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
    ENDCASE.

  ENDMETHOD.
  METHOD zip_services.

    DATA: lv_key  TYPE zif_abapgit_persistence=&gt;ty_repo-key.
    lv_key = is_event_data-getdata. &quot; TODO refactor

    CASE is_event_data-action.
        &quot; ZIP services actions
      WHEN zif_abapgit_definitions=&gt;c_action-zip_import.                      &quot; Import repo from ZIP
        zcl_abapgit_zip=&gt;import( lv_key ).
        zcl_abapgit_services_repo=&gt;refresh( lv_key ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN zif_abapgit_definitions=&gt;c_action-zip_export.                      &quot; Export repo as ZIP
        zcl_abapgit_zip=&gt;export( zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key ) ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-zip_package.                     &quot; Export package as ZIP
        zcl_abapgit_zip=&gt;export_package( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-zip_transport.                   &quot; Export transport as ZIP
        zcl_abapgit_transport=&gt;zip( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN zif_abapgit_definitions=&gt;c_action-zip_object.                      &quot; Export object as ZIP
        zcl_abapgit_zip=&gt;export_object( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_gui_page_tag IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).

    mo_repo_online ?= io_repo.

    ms_control-page_title = &apos;TAG&apos;.
    mv_selected_type = c_tag_type-lightweight.

  ENDMETHOD.
  METHOD create_tag.

    DATA:
      ls_tag   TYPE zif_abapgit_definitions=&gt;ty_git_tag,
      lx_error TYPE REF TO zcx_abapgit_exception,
      lv_text  TYPE string.

    parse_tag_request(
      EXPORTING it_postdata = it_postdata
      IMPORTING eg_fields   = ls_tag ).

    IF ls_tag-name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |Please supply a tag name| ).
    ENDIF.

    ls_tag-name = zcl_abapgit_tag=&gt;add_tag_prefix( ls_tag-name ).
    ASSERT ls_tag-name CP &apos;refs/tags/+*&apos;.

    CASE mv_selected_type.
      WHEN c_tag_type-lightweight.

        ls_tag-type = zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag.

      WHEN c_tag_type-annotated.

        ls_tag-type = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.

      WHEN OTHERS.

        zcx_abapgit_exception=&gt;raise( |Invalid tag type: { mv_selected_type }| ).

    ENDCASE.

    TRY.
        zcl_abapgit_git_porcelain=&gt;create_tag( iv_url = mo_repo_online-&gt;get_url( )
                                               is_tag = ls_tag ).

      CATCH zcx_abapgit_exception INTO lx_error.
        zcx_abapgit_exception=&gt;raise( |Cannot create tag { ls_tag-name }. Error: &apos;{ lx_error-&gt;get_text( ) }&apos;| ).
    ENDTRY.

    IF ls_tag-type = zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag.
      lv_text = |Lightweight tag { zcl_abapgit_tag=&gt;remove_tag_prefix( ls_tag-name ) } created| ##NO_TEXT.
    ELSEIF ls_tag-type = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.
      lv_text = |Annotated tag { zcl_abapgit_tag=&gt;remove_tag_prefix( ls_tag-name ) } created| ##NO_TEXT.
    ENDIF.

    MESSAGE lv_text TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD parse_change_tag_type_request.

    FIELD-SYMBOLS: &lt;lv_postdata&gt; TYPE cnht_post_data_line.

    READ TABLE it_postdata ASSIGNING &lt;lv_postdata&gt;
                           INDEX 1.
    IF sy-subrc = 0.
      FIND FIRST OCCURRENCE OF REGEX `type=(.*)`
           IN &lt;lv_postdata&gt;
           SUBMATCHES mv_selected_type.
    ENDIF.

    mv_selected_type = condense( mv_selected_type ).

  ENDMETHOD.
  METHOD parse_tag_request.

    CONSTANTS: lc_replace TYPE string VALUE &apos;&lt;&lt;new&gt;&gt;&apos;.

    DATA: lv_string TYPE string,
          lt_fields TYPE tihttpnvp.

    FIELD-SYMBOLS &lt;lv_body&gt; TYPE string.

    CLEAR eg_fields.

    CONCATENATE LINES OF it_postdata INTO lv_string.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_crlf    IN lv_string WITH lc_replace.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_newline IN lv_string WITH lc_replace.
    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields_upper_case_name( lv_string ).

    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;SHA1&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;NAME&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;TAGGER_NAME&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;TAGGER_EMAIL&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;MESSAGE&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;BODY&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = eg_fields ).

    ASSIGN COMPONENT &apos;BODY&apos; OF STRUCTURE eg_fields TO &lt;lv_body&gt;.
    ASSERT &lt;lv_body&gt; IS ASSIGNED.
    REPLACE ALL OCCURRENCES OF lc_replace IN &lt;lv_body&gt; WITH zif_abapgit_definitions=&gt;c_newline.

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;repo&quot;&gt;&apos; ).
    ro_html-&gt;add( render_menu( ) ).
    ro_html-&gt;add( render_form( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_form.

    CONSTANTS: lc_body_col_max TYPE i VALUE 150.

    DATA: li_user      TYPE REF TO zif_abapgit_persist_user,
          lv_user      TYPE string,
          lv_email     TYPE string,
          lv_s_param   TYPE string,
          lo_settings  TYPE REF TO zcl_abapgit_settings,
          lv_body_size TYPE i,
          lt_type      TYPE stringtab,
          lv_selected  TYPE string.

    FIELD-SYMBOLS: &lt;lv_type&gt; LIKE LINE OF lt_type.
    li_user = zcl_abapgit_persistence_user=&gt;get_instance( ).

    lv_user = li_user-&gt;get_repo_git_user_name( mo_repo_online-&gt;get_url( ) ).
    IF lv_user IS INITIAL.
      lv_user = li_user-&gt;get_default_git_user_name( ).
    ENDIF.
    IF lv_user IS INITIAL.
      &quot; get default from user master record
      lv_user = zcl_abapgit_user_master_record=&gt;get_instance( sy-uname )-&gt;get_name( ).
    ENDIF.

    lv_email = li_user-&gt;get_repo_git_user_email( mo_repo_online-&gt;get_url( ) ).
    IF lv_email IS INITIAL.
      lv_email = li_user-&gt;get_default_git_user_email( ).
    ENDIF.
    IF lv_email IS INITIAL.
      &quot; get default from user master record
      lv_email = zcl_abapgit_user_master_record=&gt;get_instance( sy-uname )-&gt;get_email( ).
    ENDIF.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;form-container&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;form id=&quot;commit_form&quot; class=&quot;aligned-form grey70&quot;&apos;
               &amp;&amp; &apos; method=&quot;post&quot; action=&quot;sapevent:commit_post&quot;&gt;&apos; ).

    INSERT c_tag_type-lightweight
           INTO TABLE lt_type.

    INSERT c_tag_type-annotated
           INTO TABLE lt_type.

    ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;Tag type &lt;select name=&quot;folder_logic&quot; onchange=&quot;onTagTypeChange(this)&quot;&gt;&apos; ).

    LOOP AT lt_type ASSIGNING &lt;lv_type&gt;.

      IF mv_selected_type = &lt;lv_type&gt;.
        lv_selected = &apos;selected&apos;.
      ELSE.
        CLEAR: lv_selected.
      ENDIF.

      ro_html-&gt;add( |&lt;option value=&quot;{ &lt;lv_type&gt; }&quot; |
                 &amp;&amp; |{ lv_selected }&gt;|
                 &amp;&amp; |{ &lt;lv_type&gt; }&lt;/option&gt;| ).

    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/select&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;sha1&apos;
                                     iv_label = &apos;SHA1&apos;
                                     iv_value = mo_repo_online-&gt;get_sha1_remote( ) ) ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;name&apos;
                                     iv_label = &apos;tag name&apos; ) ).

    IF mv_selected_type = c_tag_type-annotated.

      ro_html-&gt;add( render_text_input( iv_name  = &apos;tagger_name&apos;
                                       iv_label = &apos;tagger name&apos;
                                       iv_value = lv_user ) ).

      ro_html-&gt;add( render_text_input( iv_name  = &apos;tagger_email&apos;
                                       iv_label = &apos;tagger e-mail&apos;
                                       iv_value = lv_email ) ).

      lo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).

      lv_s_param = lo_settings-&gt;get_commitmsg_comment_length( ).

      ro_html-&gt;add( render_text_input( iv_name       = &apos;message&apos;
                                       iv_label      = &apos;message&apos;
                                       iv_max_length = lv_s_param ) ).

      ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;label for=&quot;c-body&quot;&gt;body&lt;/label&gt;&apos; ).

      lv_body_size = lo_settings-&gt;get_commitmsg_body_size( ).
      IF lv_body_size &gt; lc_body_col_max.
        lv_body_size = lc_body_col_max.
      ENDIF.
      ro_html-&gt;add( |&lt;textarea id=&quot;c-body&quot; name=&quot;body&quot; rows=&quot;10&quot; cols=&quot;| &amp;&amp;
                    |{ lv_body_size }&quot;&gt;&lt;/textarea&gt;| ).

    ENDIF.

    ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; class=&quot;hidden-submit&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_menu.

    DATA lo_toolbar TYPE REF TO zcl_abapgit_html_toolbar.

    CREATE OBJECT ro_html.
    CREATE OBJECT lo_toolbar.

    lo_toolbar-&gt;add( iv_act = &apos;submitFormById(&apos;&apos;commit_form&apos;&apos;);&apos;
                     iv_txt = &apos;Create&apos;
                     iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                     iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ) ##NO_TEXT.

    lo_toolbar-&gt;add( iv_act = c_action-commit_cancel
                     iv_txt = &apos;Cancel&apos;
                     iv_opt = zif_abapgit_definitions=&gt;c_html_opt-cancel ) ##NO_TEXT.

    ro_html-&gt;add( &apos;&lt;div class=&quot;paddings&quot;&gt;&apos; ).
    ro_html-&gt;add( lo_toolbar-&gt;render( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_text_input.

    DATA lv_attrs TYPE string.

    CREATE OBJECT ro_html.

    IF iv_value IS NOT INITIAL.
      lv_attrs = | value=&quot;{ iv_value }&quot;|.
    ENDIF.

    IF iv_max_length IS NOT INITIAL.
      lv_attrs = | maxlength=&quot;{ iv_max_length }&quot;|.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
    ro_html-&gt;add( |&lt;label for=&quot;{ iv_name }&quot;&gt;{ iv_label }&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;input id=&quot;{ iv_name }&quot; name=&quot;{ iv_name }&quot; type=&quot;text&quot;{ lv_attrs }&gt;| ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;setInitialFocus(&quot;name&quot;);&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    CASE iv_action.
      WHEN c_action-commit_post.

        create_tag( it_postdata ).

        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.

      WHEN c_action-change_tag_type.

        parse_change_tag_type_request( it_postdata ).

        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.

      WHEN c_action-commit_cancel.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_SYNTAX IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;SYNTAX CHECK&apos;.
    mo_repo = io_repo.
  ENDMETHOD.
  METHOD render_content.

    DATA: li_syntax_check TYPE REF TO zif_abapgit_code_inspector.
    FIELD-SYMBOLS: &lt;ls_result&gt; LIKE LINE OF mt_result.

    li_syntax_check = zcl_abapgit_factory=&gt;get_syntax_check( mo_repo-&gt;get_package( ) ).

    mt_result = li_syntax_check-&gt;run( ).

    CREATE OBJECT ro_html.
    ro_html-&gt;add( &apos;&lt;div class=&quot;toc&quot;&gt;&apos; ).

    IF lines( mt_result ) = 0.
      ro_html-&gt;add( &apos;No errors&apos; ).
    ENDIF.

    LOOP AT mt_result ASSIGNING &lt;ls_result&gt;.
      render_result( io_html   = ro_html
                     iv_result = &lt;ls_result&gt; ).
    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_STAGE IMPLEMENTATION.
  METHOD build_menu.

    CREATE OBJECT ro_menu.

    IF lines( ms_files-local ) &gt; 0.
      ro_menu-&gt;add( iv_txt = |All diffs|
                    iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?key={ mo_repo-&gt;get_key( ) }| ).
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    DATA lv_ts TYPE timestamp.

    super-&gt;constructor( ).

    ms_control-page_title = &apos;STAGE&apos;.
    mo_repo               = io_repo.
    ms_files              = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( mo_repo ).
    mv_seed               = iv_seed.

    IF mv_seed IS INITIAL. &quot; Generate based on time unless obtained from diff page
      GET TIME STAMP FIELD lv_ts.
      mv_seed = |stage{ lv_ts }|.
    ENDIF.

    ms_control-page_menu  = build_menu( ).

  ENDMETHOD.
  METHOD find_changed_by.

    DATA: ls_local      LIKE LINE OF it_local,
          ls_changed_by LIKE LINE OF rt_changed_by.

    FIELD-SYMBOLS: &lt;ls_changed_by&gt; LIKE LINE OF rt_changed_by.
    LOOP AT it_local INTO ls_local WHERE NOT item IS INITIAL.
      ls_changed_by-item = ls_local-item.
      INSERT ls_changed_by INTO TABLE rt_changed_by.
    ENDLOOP.

    LOOP AT rt_changed_by ASSIGNING &lt;ls_changed_by&gt;.
      TRY.
          &lt;ls_changed_by&gt;-name = to_lower( zcl_abapgit_objects=&gt;changed_by( &lt;ls_changed_by&gt;-item ) ).
        CATCH zcx_abapgit_exception.
      ENDTRY.
    ENDLOOP.

  ENDMETHOD.
  METHOD find_transports.
    DATA: li_cts_api TYPE REF TO zif_abapgit_cts_api,
          ls_new     LIKE LINE OF rt_transports.

    FIELD-SYMBOLS: &lt;ls_local&gt; LIKE LINE OF it_local.

    li_cts_api = zcl_abapgit_factory=&gt;get_cts_api( ).

    TRY.
        LOOP AT it_local ASSIGNING &lt;ls_local&gt; WHERE item IS NOT INITIAL.
          IF &lt;ls_local&gt;-item-obj_type IS NOT INITIAL AND
             &lt;ls_local&gt;-item-obj_name IS NOT INITIAL AND
             &lt;ls_local&gt;-item-devclass IS NOT INITIAL.

            IF li_cts_api-&gt;is_chrec_possible_for_package( &lt;ls_local&gt;-item-devclass ) = abap_false.
              EXIT. &quot; Assume all other objects are also in packages without change recording

            ELSEIF li_cts_api-&gt;is_object_type_lockable( &lt;ls_local&gt;-item-obj_type ) = abap_true AND
                   li_cts_api-&gt;is_object_locked_in_transport( iv_object_type = &lt;ls_local&gt;-item-obj_type
                                                              iv_object_name = &lt;ls_local&gt;-item-obj_name ) = abap_true.

              ls_new-item = &lt;ls_local&gt;-item.

              ls_new-transport = li_cts_api-&gt;get_current_transport_for_obj(
                iv_object_type             = &lt;ls_local&gt;-item-obj_type
                iv_object_name             = &lt;ls_local&gt;-item-obj_name
                iv_resolve_task_to_request = abap_false ).

              INSERT ls_new INTO TABLE rt_transports.
            ENDIF.
          ENDIF.
        ENDLOOP.
      CATCH zcx_abapgit_exception.
        ASSERT 1 = 2.
    ENDTRY.
  ENDMETHOD.
  METHOD get_page_patch.

    DATA: lo_page   TYPE REF TO zcl_abapgit_gui_page_diff,
          lv_key    TYPE zif_abapgit_persistence=&gt;ty_repo-key,
          lo_stage  TYPE REF TO zcl_abapgit_stage.

    zcl_abapgit_html_action_utils=&gt;file_obj_decode(
      EXPORTING
        iv_string = iv_getdata
      IMPORTING
        ev_key    = lv_key ).

    CREATE OBJECT lo_stage.

    CREATE OBJECT lo_page
      EXPORTING
        iv_key        = lv_key
        iv_patch_mode = abap_true
        io_stage      = lo_stage.

    ri_page = lo_page.

  ENDMETHOD.
  METHOD process_stage_list.

    DATA: lv_string TYPE string,
          lt_fields TYPE tihttpnvp,
          ls_file   TYPE zif_abapgit_definitions=&gt;ty_file.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF ms_files-local,
                   &lt;ls_item&gt; LIKE LINE OF lt_fields.

    CONCATENATE LINES OF it_postdata INTO lv_string.
    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_string ).

    IF lines( lt_fields ) = 0.
      zcx_abapgit_exception=&gt;raise( &apos;process_stage_list: empty list&apos; ).
    ENDIF.

    LOOP AT lt_fields ASSIGNING &lt;ls_item&gt;.

      zcl_abapgit_path=&gt;split_file_location(
        EXPORTING
          iv_fullpath = &lt;ls_item&gt;-name
        IMPORTING
          ev_path     = ls_file-path
          ev_filename = ls_file-filename ).

      CASE &lt;ls_item&gt;-value.
        WHEN zcl_abapgit_stage=&gt;c_method-add.
          READ TABLE ms_files-local ASSIGNING &lt;ls_file&gt;
            WITH KEY file-path     = ls_file-path
                     file-filename = ls_file-filename.
          ASSERT sy-subrc = 0.
          io_stage-&gt;add(    iv_path     = &lt;ls_file&gt;-file-path
                            iv_filename = &lt;ls_file&gt;-file-filename
                            iv_data     = &lt;ls_file&gt;-file-data ).
        WHEN zcl_abapgit_stage=&gt;c_method-ignore.
          io_stage-&gt;ignore( iv_path     = ls_file-path
                            iv_filename = ls_file-filename ).
        WHEN zcl_abapgit_stage=&gt;c_method-rm.
          io_stage-&gt;rm(     iv_path     = ls_file-path
                            iv_filename = ls_file-filename ).
        WHEN zcl_abapgit_stage=&gt;c_method-skip.
          &quot; Do nothing
        WHEN OTHERS.
          zcx_abapgit_exception=&gt;raise( |process_stage_list: unknown method { &lt;ls_item&gt;-value }| ).
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.
  METHOD render_actions.

    DATA: lv_local_count TYPE i,
          lv_add_all_txt TYPE string,
          lv_param       TYPE string,
          ls_file        TYPE zif_abapgit_definitions=&gt;ty_file.

    CREATE OBJECT ro_html.
    lv_local_count = lines( ms_files-local ).
    IF lv_local_count &gt; 0.
      lv_add_all_txt = |Add all and commit ({ lv_local_count })|.
      &quot; Otherwise empty, but the element (id) is preserved for JS
    ENDIF.

    ro_html-&gt;add( &apos;&lt;table class=&quot;w100 margin-v5&quot;&gt;&lt;tr&gt;&apos; ).

    &quot; Action buttons
    ro_html-&gt;add( &apos;&lt;td class=&quot;indent5em&quot;&gt;&apos; ).
    ro_html-&gt;add_a( iv_act   = &apos;errorStub(event)&apos; &quot; Will be reinit by JS
                    iv_typ   = zif_abapgit_definitions=&gt;c_action_type-onclick
                    iv_id    = &apos;commitButton&apos;
                    iv_style = &apos;display: none&apos;
                    iv_txt   = &apos;Commit (&lt;span id=&quot;fileCounter&quot;&gt;&lt;/span&gt;)&apos;
                    iv_opt   = zif_abapgit_definitions=&gt;c_html_opt-strong ) ##NO_TEXT.
    ro_html-&gt;add_a( iv_act = |{ c_action-stage_all }|
                    iv_id  = &apos;commitAllButton&apos;
                    iv_txt = lv_add_all_txt ) ##NO_TEXT.

    lv_param = zcl_abapgit_html_action_utils=&gt;file_encode( iv_key  = mo_repo-&gt;get_key( )
                                                           ig_file = ls_file ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;td class=&quot;pad-sides&quot;&gt;&apos; ).
    ro_html-&gt;add_a(
      iv_txt = |Patch|
      iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_patch }?{ lv_param }| ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    &quot; Filter bar
    ro_html-&gt;add( &apos;&lt;td class=&quot;right&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;input class=&quot;stage-filter&quot; id=&quot;objectSearch&quot;&apos; &amp;&amp;
                  &apos; type=&quot;search&quot; placeholder=&quot;Filter objects&quot;&apos; &amp;&amp;
                  | value={ mv_filter_value }&gt;| ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;repo&quot;&gt;&apos; ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top( mo_repo ) ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_js_error_banner( ) ).

    ro_html-&gt;add( &apos;&lt;div class=&quot;stage-container&quot;&gt;&apos; ).
    ro_html-&gt;add( render_actions( ) ).
    ro_html-&gt;add( render_list( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_file.

    DATA: lv_param            TYPE string,
          lv_filename         TYPE string,
          lv_transport_string TYPE string,
          lv_transport_html   TYPE string.

    CREATE OBJECT ro_html.

    lv_transport_string = iv_transport.

    lv_filename = is_file-path &amp;&amp; is_file-filename.
* make sure whitespace is preserved in the DOM
    REPLACE ALL OCCURRENCES OF ` ` IN lv_filename WITH &apos;&amp;nbsp;&apos;.

    ro_html-&gt;add( |&lt;tr class=&quot;{ iv_context }&quot;&gt;| ).

    CASE iv_context.
      WHEN &apos;local&apos;.
        lv_param = zcl_abapgit_html_action_utils=&gt;file_encode(
          iv_key  = mo_repo-&gt;get_key( )
          ig_file = is_file ).

        lv_filename = zcl_abapgit_html=&gt;a(
          iv_txt = lv_filename
          iv_act = |{ zif_abapgit_definitions=&gt;c_action-go_diff }?{ lv_param }| ).

        IF iv_transport IS NOT INITIAL.
          lv_transport_html = zcl_abapgit_html=&gt;a(
            iv_txt = lv_transport_string
            iv_act = |{ zif_abapgit_definitions=&gt;c_action-jump_transport }?{ iv_transport }| ).
        ENDIF.
        ro_html-&gt;add( |&lt;td class=&quot;type&quot;&gt;{ is_item-obj_type }&lt;/td&gt;| ).
        ro_html-&gt;add( |&lt;td class=&quot;name&quot;&gt;{ lv_filename }&lt;/td&gt;| ).
        ro_html-&gt;add( |&lt;td class=&quot;user&quot;&gt;{ iv_changed_by }&lt;/td&gt;| ).
        ro_html-&gt;add( |&lt;td class=&quot;transport&quot;&gt;{ lv_transport_html }&lt;/td&gt;| ).
      WHEN &apos;remote&apos;.
        ro_html-&gt;add( &apos;&lt;td class=&quot;type&quot;&gt;-&lt;/td&gt;&apos; ).  &quot; Dummy for object type
        ro_html-&gt;add( |&lt;td class=&quot;name&quot;&gt;{ lv_filename }&lt;/td&gt;| ).
        ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).                &quot; Dummy for changed-by
        ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).                &quot; Dummy for transport
    ENDCASE.

    ro_html-&gt;add( |&lt;td class=&quot;status&quot;&gt;?&lt;/td&gt;| ).
    ro_html-&gt;add( &apos;&lt;td class=&quot;cmd&quot;&gt;&lt;/td&gt;&apos; ). &quot; Command added in JS

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).

  ENDMETHOD.
  METHOD render_list.

    DATA: lt_changed_by TYPE ty_changed_by_tt,
          ls_changed_by LIKE LINE OF lt_changed_by,
          lt_transports TYPE ty_transport_tt,
          ls_transport  LIKE LINE OF lt_transports.

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF ms_files-remote,
                   &lt;ls_local&gt;  LIKE LINE OF ms_files-local.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;table id=&quot;stageTab&quot; class=&quot;stage_tab w100&quot;&gt;&apos; ).

    lt_changed_by = find_changed_by( ms_files-local ).
    lt_transports = find_transports( ms_files-local ).

    &quot; Local changes
    LOOP AT ms_files-local ASSIGNING &lt;ls_local&gt;.
      AT FIRST.
        ro_html-&gt;add( &apos;&lt;thead&gt;&lt;tr class=&quot;local&quot;&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;Type&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;Files to add (click to see diff)&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;Changed by&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;Transport&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;&lt;/th&gt;&apos; ). &quot; Status
        ro_html-&gt;add( &apos;&lt;th class=&quot;cmd&quot;&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;a&gt;add&lt;/a&gt;&amp;#x2193; &lt;a&gt;reset&lt;/a&gt;&amp;#x2193;&apos; ).
        ro_html-&gt;add( &apos;&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/thead&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;tbody&gt;&apos; ).
      ENDAT.

      READ TABLE lt_changed_by INTO ls_changed_by WITH KEY item = &lt;ls_local&gt;-item. &quot;#EC CI_SUBRC
      READ TABLE lt_transports INTO ls_transport WITH KEY item = &lt;ls_local&gt;-item. &quot;#EC CI_SUBRC

      ro_html-&gt;add( render_file(
        iv_context = &apos;local&apos;
        is_file       = &lt;ls_local&gt;-file
        is_item       = &lt;ls_local&gt;-item
        iv_changed_by = ls_changed_by-name
        iv_transport  = ls_transport-transport ) ).

      CLEAR ls_transport.

      AT LAST.
        ro_html-&gt;add( &apos;&lt;/tbody&gt;&apos; ).
      ENDAT.
    ENDLOOP.

    &quot; Remote changes
    LOOP AT ms_files-remote ASSIGNING &lt;ls_remote&gt;.
      AT FIRST.
        ro_html-&gt;add( &apos;&lt;thead&gt;&lt;tr class=&quot;remote&quot;&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;&lt;/th&gt;&apos; ). &quot; Type
        ro_html-&gt;add( &apos;&lt;th colspan=&quot;3&quot;&gt;Files to remove or non-code&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;th&gt;&lt;/th&gt;&apos; ). &quot; Status
        ro_html-&gt;add( &apos;&lt;th class=&quot;cmd&quot;&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;a&gt;ignore&lt;/a&gt;&amp;#x2193; &lt;a&gt;remove&lt;/a&gt;&amp;#x2193; &lt;a&gt;reset&lt;/a&gt;&amp;#x2193;&apos; ).
        ro_html-&gt;add( &apos;&lt;/th&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/thead&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;tbody&gt;&apos; ).
      ENDAT.

      ro_html-&gt;add( render_file(
        iv_context = &apos;remote&apos;
        is_file    = &lt;ls_remote&gt; ) ).

      AT LAST.
        ro_html-&gt;add( &apos;&lt;/tbody&gt;&apos; ).
      ENDAT.
    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;var gStageParams = {&apos; ).
    ro_html-&gt;add( |  seed:            &quot;{ mv_seed }&quot;,| ). &quot; Unique page id
    ro_html-&gt;add( &apos;  formAction:      &quot;stage_commit&quot;,&apos; ).

    ro_html-&gt;add( &apos;  ids: {&apos; ).
    ro_html-&gt;add( &apos;    stageTab:      &quot;stageTab&quot;,&apos; ).
    ro_html-&gt;add( &apos;    commitBtn:     &quot;commitButton&quot;,&apos; ).
    ro_html-&gt;add( &apos;    commitAllBtn:  &quot;commitAllButton&quot;,&apos; ).
    ro_html-&gt;add( &apos;    objectSearch:  &quot;objectSearch&quot;,&apos; ).
    ro_html-&gt;add( &apos;    fileCounter:   &quot;fileCounter&quot;&apos; ).
    ro_html-&gt;add( &apos;  }&apos; ).

    ro_html-&gt;add( &apos;}&apos; ).
    ro_html-&gt;add( &apos;var gHelper = new StageHelper(gStageParams);&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

    DATA: ls_hotkey_action TYPE zif_abapgit_gui_page_hotkey=&gt;ty_hotkey_action.

    ls_hotkey_action-name           = |Patch|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-go_patch.
    ls_hotkey_action-default_hotkey = |p|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lo_stage  TYPE REF TO zcl_abapgit_stage,
          lv_string TYPE string,
          lt_fields TYPE tihttpnvp.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF ms_files-local.
    CREATE OBJECT lo_stage.

    CLEAR: ei_page, ev_state.

    CASE iv_action.
      WHEN c_action-stage_all.

        LOOP AT ms_files-local ASSIGNING &lt;ls_file&gt;.
          lo_stage-&gt;add( iv_path     = &lt;ls_file&gt;-file-path
                         iv_filename = &lt;ls_file&gt;-file-filename
                         iv_data     = &lt;ls_file&gt;-file-data ).
        ENDLOOP.

        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_commit
          EXPORTING
            io_repo  = mo_repo
            io_stage = lo_stage.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

      WHEN c_action-stage_commit.

        process_stage_list( it_postdata = it_postdata io_stage = lo_stage ).

        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_commit
          EXPORTING
            io_repo  = mo_repo
            io_stage = lo_stage.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

      WHEN c_action-stage_filter.

        CONCATENATE LINES OF it_postdata INTO lv_string.

        lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_string ).

        zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name  = &apos;filterValue&apos;
                                                            it_field = lt_fields
                                                  CHANGING  cg_field = mv_filter_value ).

        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.

      WHEN zif_abapgit_definitions=&gt;c_action-go_patch.                         &quot; Go Patch page

        ei_page  = get_page_patch(
          iv_getdata   = iv_getdata
          iv_prev_page = iv_prev_page ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

      WHEN OTHERS.
        RETURN.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_SETTINGS IMPLEMENTATION.
  METHOD build_settings.

    DATA: lv_i_param_value TYPE i,
          lv_column        TYPE string,
          lt_key_bindings  TYPE zif_abapgit_definitions=&gt;tty_hotkey.

    FIELD-SYMBOLS: &lt;ls_post_field&gt;  TYPE ihttpnvp,
                   &lt;ls_key_binding&gt; TYPE zif_abapgit_definitions=&gt;ty_hotkey.
    CREATE OBJECT mo_settings.
    mt_post_fields = it_post_fields.
    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;proxy_url&apos;.
    IF sy-subrc &lt;&gt; 0.
      mv_error = abap_true.
    ENDIF.
    mo_settings-&gt;set_proxy_url( &lt;ls_post_field&gt;-value ).

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;proxy_port&apos;.
    IF sy-subrc &lt;&gt; 0.
      mv_error = abap_true.
    ENDIF.
    mo_settings-&gt;set_proxy_port( &lt;ls_post_field&gt;-value ).

    IF is_post_field_checked( &apos;proxy_auth&apos; ) = abap_true.
      mo_settings-&gt;set_proxy_authentication( abap_true ).
    ELSE.
      mo_settings-&gt;set_proxy_authentication( abap_false ).
    ENDIF.

    IF is_post_field_checked( &apos;critical_tests&apos; ) = abap_true.
      mo_settings-&gt;set_run_critical_tests( abap_true ).
    ELSE.
      mo_settings-&gt;set_run_critical_tests( abap_false ).
    ENDIF.

    IF is_post_field_checked( &apos;experimental_features&apos; ) = abap_true.
      mo_settings-&gt;set_experimental_features( abap_true ).
    ELSE.
      mo_settings-&gt;set_experimental_features( abap_false ).
    ENDIF.

    IF is_post_field_checked( &apos;show_default_repo&apos; ) = abap_true.
      mo_settings-&gt;set_show_default_repo( abap_true ).
    ELSE.
      mo_settings-&gt;set_show_default_repo( abap_false ).
    ENDIF.

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;max_lines&apos;.
    IF sy-subrc = 0.
      lv_i_param_value = &lt;ls_post_field&gt;-value.
      mo_settings-&gt;set_max_lines( lv_i_param_value ).
    ELSE.
      mo_settings-&gt;set_max_lines( 0 ).
    ENDIF.

    IF is_post_field_checked( &apos;adt_jump_enabled&apos; ) = abap_true.
      mo_settings-&gt;set_adt_jump_enanbled( abap_true ).
    ELSE.
      mo_settings-&gt;set_adt_jump_enanbled( abap_false ).
    ENDIF.

    IF is_post_field_checked( &apos;link_hints_enabled&apos; ) = abap_true.
      mo_settings-&gt;set_link_hints_enabled( abap_true ).
    ELSE.
      mo_settings-&gt;set_link_hints_enabled( abap_false ).
    ENDIF.

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;link_hint_key&apos;.
    IF sy-subrc = 0.
      mo_settings-&gt;set_link_hint_key( |{ &lt;ls_post_field&gt;-value }| ).
    ENDIF.

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;link_hint_background_color&apos;.
    IF sy-subrc = 0.
      mo_settings-&gt;set_link_hint_background_color( |{ &lt;ls_post_field&gt;-value }| ).
    ENDIF.

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;comment_length&apos;.
    IF sy-subrc = 0.
      lv_i_param_value = &lt;ls_post_field&gt;-value.
      IF lv_i_param_value &lt; zcl_abapgit_settings=&gt;c_commitmsg_comment_length_dft.
        lv_i_param_value = zcl_abapgit_settings=&gt;c_commitmsg_comment_length_dft.
      ENDIF.
      mo_settings-&gt;set_commitmsg_comment_length( lv_i_param_value ).
    ELSE.
      mo_settings-&gt;set_commitmsg_comment_length( zcl_abapgit_settings=&gt;c_commitmsg_comment_length_dft ).
    ENDIF.

    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = &apos;body_size&apos;.
    IF sy-subrc = 0.
      lv_i_param_value = &lt;ls_post_field&gt;-value.
      IF lv_i_param_value &lt; zcl_abapgit_settings=&gt;c_commitmsg_body_size_dft.
        lv_i_param_value = zcl_abapgit_settings=&gt;c_commitmsg_body_size_dft.
      ENDIF.
      mo_settings-&gt;set_commitmsg_body_size( lv_i_param_value ).
    ELSE.
      mo_settings-&gt;set_commitmsg_body_size( zcl_abapgit_settings=&gt;c_commitmsg_body_size_dft ).
    ENDIF.
    LOOP AT mt_post_fields ASSIGNING &lt;ls_post_field&gt; WHERE name CP &apos;key*&apos;.

      FIND FIRST OCCURRENCE OF REGEX `key_(.*)_`
           IN &lt;ls_post_field&gt;-name
           SUBMATCHES lv_column.

      INSERT INITIAL LINE INTO TABLE lt_key_bindings ASSIGNING &lt;ls_key_binding&gt;.
      CASE lv_column.
        WHEN &apos;sequence&apos;.
          &lt;ls_key_binding&gt;-sequence = &lt;ls_post_field&gt;-value.
        WHEN &apos;action&apos;.
          &lt;ls_key_binding&gt;-action = &lt;ls_post_field&gt;-value.
      ENDCASE.
    ENDLOOP.

    DELETE lt_key_bindings WHERE sequence IS INITIAL
                           OR    action IS INITIAL.

    mo_settings-&gt;set_hotkeys( lt_key_bindings ).

  ENDMETHOD.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;SETTINGS&apos;.
  ENDMETHOD.
  METHOD get_default_hotkeys.

    DATA: lt_actions TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action,
          ls_hotkey  LIKE LINE OF rt_default_hotkeys.

    FIELD-SYMBOLS: &lt;ls_action&gt; LIKE LINE OF lt_actions.

    lt_actions = zcl_abapgit_hotkeys=&gt;get_default_hotkeys_from_pages( ).

    LOOP AT lt_actions ASSIGNING &lt;ls_action&gt;.
      ls_hotkey-action   = &lt;ls_action&gt;-action.
      ls_hotkey-sequence = &lt;ls_action&gt;-default_hotkey.
      INSERT ls_hotkey INTO TABLE rt_default_hotkeys.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_possible_hotkey_actions.

    DATA: ls_hotkey_action LIKE LINE OF rt_hotkey_actions.

    rt_hotkey_actions = zcl_abapgit_hotkeys=&gt;get_default_hotkeys_from_pages( ).

    &quot; insert empty row at the beginning, so that we can unset a hotkey
    INSERT ls_hotkey_action INTO rt_hotkey_actions INDEX 1.

  ENDMETHOD.
  METHOD is_post_field_checked.
    FIELD-SYMBOLS: &lt;ls_post_field&gt; TYPE ihttpnvp.
    READ TABLE mt_post_fields ASSIGNING &lt;ls_post_field&gt; WITH KEY name = iv_name.
    IF sy-subrc = 0.
      IF &lt;ls_post_field&gt;-value = abap_true &quot;HTML value when using standard netweaver GUI
      OR &lt;ls_post_field&gt;-value = &apos;on&apos;.     &quot;HTML value when using Netweaver Java GUI
        rv_return = abap_true.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD parse_post.

    DATA lv_serialized_post_data TYPE string.

    CONCATENATE LINES OF it_postdata INTO lv_serialized_post_data.
    rt_post_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_serialized_post_data ).

  ENDMETHOD.
  METHOD persist_settings.

    DATA lo_settings_persistence TYPE REF TO zcl_abapgit_persist_settings.

    lo_settings_persistence = zcl_abapgit_persist_settings=&gt;get_instance( ).
    lo_settings_persistence-&gt;modify( mo_settings ).
    MESSAGE &apos;Settings succesfully saved&apos; TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD read_settings.

    DATA lo_settings_persistence TYPE REF TO zcl_abapgit_persist_settings.

    lo_settings_persistence = zcl_abapgit_persist_settings=&gt;get_instance( ).
    mo_settings = lo_settings_persistence-&gt;read( ).

  ENDMETHOD.
  METHOD render_adt_jump_enabled.

    DATA lv_checked TYPE string.

    IF mo_settings-&gt;get_adt_jump_enabled( ) = abap_true.
      lv_checked = &apos;checked&apos;.
    ENDIF.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;h2&gt;ABAP Development Tools (ADT)&lt;/h2&gt;| ).
    ro_html-&gt;add( `&lt;input type=&quot;checkbox&quot; name=&quot;adt_jump_enabled&quot; value=&quot;X&quot; `
                   &amp;&amp; lv_checked &amp;&amp; ` &gt; Enable jump to ADT first` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
  ENDMETHOD.
  METHOD render_commit_msg.
    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;h2&gt;Commit Message&lt;/h2&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;comment_length&quot;&gt;Max. length of comment (recommendation 50)&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;input name=&quot;comment_length&quot; type=&quot;number&quot; step=&quot;10&quot; size=&quot;3&quot; maxlength=&quot;3&quot; min=&quot;50&quot;| &amp;&amp;
                  | value=&quot;{ mo_settings-&gt;get_commitmsg_comment_length( ) }&quot;&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;body_size&quot;&gt;Max. line size of body (recommendation 72)&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;input name=&quot;body_size&quot; type=&quot;number&quot; size=&quot;3&quot; maxlength=&quot;3&quot; min=&quot;50&quot;| &amp;&amp;
                  | value=&quot;{ mo_settings-&gt;get_commitmsg_body_size( ) }&quot;&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    read_settings( ).

    ro_html-&gt;add( render_form_begin( ) ).
    ro_html-&gt;add( render_section_begin( |Global settings| ) ).
    ro_html-&gt;add( render_proxy( ) ).
    ro_html-&gt;add( |&lt;hr&gt;| ).
    ro_html-&gt;add( render_commit_msg( ) ).
    ro_html-&gt;add( |&lt;hr&gt;| ).
    ro_html-&gt;add( render_development_internals( ) ).
    ro_html-&gt;add( render_section_end( ) ).
    ro_html-&gt;add( render_section_begin( |User specific settings| ) ).
    ro_html-&gt;add( render_start_up( ) ).
    ro_html-&gt;add( render_max_lines( ) ).
    ro_html-&gt;add( |&lt;hr&gt;| ).
    ro_html-&gt;add( render_adt_jump_enabled( ) ).
    ro_html-&gt;add( |&lt;hr&gt;| ).
    ro_html-&gt;add( render_link_hints( ) ).
    ro_html-&gt;add( |&lt;hr&gt;| ).
    ro_html-&gt;add( render_hotkeys( ) ).
    ro_html-&gt;add( render_section_end( ) ).
    ro_html-&gt;add( render_form_end( ) ).

  ENDMETHOD.
  METHOD render_development_internals.

    DATA: lv_critical_tests TYPE string,
          lv_experimental   TYPE string.

    IF mo_settings-&gt;get_run_critical_tests( ) = abap_true.
      lv_critical_tests = &apos;checked&apos;.
    ENDIF.

    IF mo_settings-&gt;get_experimental_features( ) = abap_true.
      lv_experimental = &apos;checked&apos;.
    ENDIF.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;h2&gt;abapGit Development Internals settings&lt;/h2&gt;| ).
    ro_html-&gt;add( `&lt;input type=&quot;checkbox&quot; name=&quot;critical_tests&quot; `
                   &amp;&amp; lv_critical_tests &amp;&amp; ` &gt; Enable critical unit tests (see LTCL_DANGEROUS)` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( `&lt;input type=&quot;checkbox&quot; name=&quot;experimental_features&quot; `
                   &amp;&amp; lv_experimental &amp;&amp; ` &gt; Enable experimental features` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).

  ENDMETHOD.
  METHOD render_form_begin.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( &apos;&lt;div class=&quot;settings_container&quot;&gt;&apos; ).
    ro_html-&gt;add( `&lt;form id=&quot;settings_form&quot; method=&quot;post&quot; action=&quot;sapevent:` &amp;&amp; c_action-save_settings &amp;&amp; `&quot;&gt;` ).

  ENDMETHOD.
  METHOD render_form_end.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; value=&quot;Save&quot; class=&quot;submit&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_hotkeys.

    DATA: lv_index    TYPE i,
          lt_hotkeys  TYPE zif_abapgit_definitions=&gt;tty_hotkey,
          lv_selected TYPE string,
          lt_actions  TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action.

    FIELD-SYMBOLS: &lt;ls_key_binding&gt; LIKE LINE OF lt_hotkeys,
                   &lt;ls_action&gt;      LIKE LINE OF lt_actions.

    lt_hotkeys = mo_settings-&gt;get_hotkeys( ).

    IF lines( lt_hotkeys ) = 0.
      lt_hotkeys = get_default_hotkeys( ).
    ENDIF.

    DO 3 TIMES.
      APPEND INITIAL LINE TO lt_hotkeys.
    ENDDO.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;h2&gt;Hotkeys&lt;/h2&gt;| ).
    ro_html-&gt;add( |(Only available with installed abapGit repo)| ).
    ro_html-&gt;add( |&lt;br/&gt;| ).
    ro_html-&gt;add( |&lt;br/&gt;| ).

    ro_html-&gt;add( &apos;&lt;table class=&quot;repo_tab&quot; id=&quot;key_bindings&quot; style=&quot;max-width: 300px;&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;action&lt;/th&gt;&lt;/tr&gt;&apos; ).

    lt_actions = get_possible_hotkey_actions( ).

    LOOP AT lt_hotkeys ASSIGNING &lt;ls_key_binding&gt;.

      lv_index = sy-tabix.

      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
      ro_html-&gt;add( |&lt;td&gt;&lt;input name=&quot;key_sequence_{ lv_index }&quot; maxlength=1 type=&quot;text&quot; | &amp;&amp;
                    |value=&quot;{ &lt;ls_key_binding&gt;-sequence }&quot;&gt;&lt;/td&gt;| ).

      ro_html-&gt;add( |&lt;td&gt;&lt;select name=&quot;key_action_{ lv_index }&quot;&gt;| ).

      LOOP AT lt_actions ASSIGNING &lt;ls_action&gt;.

        IF &lt;ls_key_binding&gt;-action = &lt;ls_action&gt;-action.
          lv_selected = &apos;selected&apos;.
        ELSE.
          CLEAR: lv_selected.
        ENDIF.

        ro_html-&gt;add( |&lt;option value=&quot;{ &lt;ls_action&gt;-action }&quot; |
                   &amp;&amp; |{ lv_selected }&gt;|
                   &amp;&amp; |{ &lt;ls_action&gt;-name }&lt;/option&gt;| ).

      ENDLOOP.

      ro_html-&gt;add( &apos;&lt;/select&gt;&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).

    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/select&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).

  ENDMETHOD.
  METHOD render_link_hints.

    DATA: lv_checked               TYPE string,
          lv_link_hint_key         TYPE char01,
          lv_link_background_color TYPE string.

    IF mo_settings-&gt;get_link_hints_enabled( ) = abap_true.
      lv_checked = &apos;checked&apos;.
    ENDIF.

    lv_link_hint_key = mo_settings-&gt;get_link_hint_key( ).
    lv_link_background_color = mo_settings-&gt;get_link_hint_background_color( ).

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;h2&gt;Vimium like link hints&lt;/h2&gt;| ).
    ro_html-&gt;add( `&lt;input type=&quot;checkbox&quot; name=&quot;link_hints_enabled&quot; value=&quot;X&quot; `
                   &amp;&amp; lv_checked &amp;&amp; ` &gt; Enable Vimium like link hints` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;input type=&quot;text&quot; name=&quot;link_hint_key&quot; size=&quot;1&quot; maxlength=&quot;1&quot; value=&quot;{ lv_link_hint_key }&quot; |
               &amp;&amp; |&gt; Single key to activate links| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;input type=&quot;text&quot; name=&quot;link_hint_background_color&quot; size=&quot;20&quot; maxlength=&quot;20&quot;|
               &amp;&amp; | value=&quot;{ lv_link_background_color }&quot;|
               &amp;&amp; |&gt; Background Color (HTML colors e.g. lightgreen or #42f47a)| ).

    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).

  ENDMETHOD.
  METHOD render_max_lines.
    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;h2&gt;List size&lt;/h2&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;max_lines&quot;&gt;Max. # of objects listed (0 = all)&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( `&lt;input name=&quot;max_lines&quot; type=&quot;text&quot; size=&quot;5&quot; value=&quot;` &amp;&amp; mo_settings-&gt;get_max_lines( ) &amp;&amp; `&quot;&gt;` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
  ENDMETHOD.
  METHOD render_proxy.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;h2&gt;Proxy&lt;/h2&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;proxy_url&quot;&gt;Proxy URL&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( `&lt;input name=&quot;proxy_url&quot; type=&quot;text&quot; size=&quot;50&quot; value=&quot;` &amp;&amp;
      mo_settings-&gt;get_proxy_url( ) &amp;&amp; `&quot;&gt;` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;proxy_port&quot;&gt;Proxy Port&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( `&lt;input name=&quot;proxy_port&quot; type=&quot;text&quot; size=&quot;5&quot; value=&quot;` &amp;&amp;
      mo_settings-&gt;get_proxy_port( ) &amp;&amp; `&quot;&gt;` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;label for=&quot;proxy_auth&quot;&gt;Proxy Authentication&lt;/label&gt;| ).
    IF mo_settings-&gt;get_proxy_authentication( ) = abap_true.
      ro_html-&gt;add( `&lt;input name=&quot;proxy_auth&quot; type=&quot;checkbox&quot; checked&gt;` ).
    ELSE.
      ro_html-&gt;add( `&lt;input name=&quot;proxy_auth&quot; type=&quot;checkbox&quot;&gt;` ).
    ENDIF.
    ro_html-&gt;add( |&lt;br&gt;| ).

    ro_html-&gt;add( |&lt;br&gt;| ).

  ENDMETHOD.
  METHOD render_section_begin.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;h1&gt;{ iv_header }&lt;/h1&gt;| ).
    ro_html-&gt;add( |&lt;div class=&quot;settings_section&quot;&gt;| ).

  ENDMETHOD.
  METHOD render_section_end.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;/div&gt;| ).

  ENDMETHOD.
  METHOD render_start_up.

    DATA lv_checked TYPE string.

    IF mo_settings-&gt;get_show_default_repo( ) = abap_true.
      lv_checked = &apos;checked&apos;.
    ENDIF.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;h2&gt;Start up&lt;/h2&gt;| ).
    ro_html-&gt;add( `&lt;input type=&quot;checkbox&quot; name=&quot;show_default_repo&quot; value=&quot;X&quot; `
                   &amp;&amp; lv_checked &amp;&amp; ` &gt; Show last repo` ).
    ro_html-&gt;add( |&lt;br&gt;| ).
    ro_html-&gt;add( |&lt;br&gt;| ).
  ENDMETHOD.
  METHOD validate_settings.

    IF ( mo_settings-&gt;get_proxy_url( ) IS NOT INITIAL AND  mo_settings-&gt;get_proxy_port( ) IS INITIAL ) OR
                 ( mo_settings-&gt;get_proxy_url( ) IS INITIAL AND  mo_settings-&gt;get_proxy_port( ) IS NOT INITIAL ).
      MESSAGE &apos;If specifying proxy, specify both URL and port&apos; TYPE &apos;W&apos;.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.
* todo, check input values eg INT

    DATA:
      lt_post_fields TYPE tihttpnvp.

    CASE iv_action.
      WHEN c_action-save_settings.
        lt_post_fields = parse_post( it_postdata ).

        build_settings( lt_post_fields ).
        validate_settings( ).

        IF mv_error = abap_true.
          MESSAGE &apos;Error when saving settings. Open an issue at https://github.com/larshp/abapGit&apos; TYPE &apos;E&apos;.
        ELSE.
          persist_settings( ).
        ENDIF.

        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_REPO_SETT IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;REPO SETTINGS&apos;.
    mo_repo = io_repo.
  ENDMETHOD.
  METHOD parse_post.

    DATA lv_serialized_post_data TYPE string.

    CONCATENATE LINES OF it_postdata INTO lv_serialized_post_data.
    rt_post_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_serialized_post_data ).

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( &apos;&lt;div class=&quot;settings_container&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;form id=&quot;settings_form&quot; method=&quot;post&quot; action=&quot;sapevent:&apos; &amp;&amp;
      c_action-save_settings &amp;&amp; &apos;&quot;&gt;&apos; ).

    render_dot_abapgit( ro_html ).
    render_local_settings( ro_html ).

    ro_html-&gt;add( &apos;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;Save&quot; class=&quot;submit&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_dot_abapgit.

    CONSTANTS: lc_requirement_edit_count TYPE i VALUE 5.
    DATA: ls_dot               TYPE zif_abapgit_dot_abapgit=&gt;ty_dot_abapgit,
          lv_selected          TYPE string,
          lt_folder_logic      TYPE stringtab,
          lv_req_index         TYPE i,
          lv_requirement_count TYPE i.

    FIELD-SYMBOLS: &lt;lv_folder_logic&gt; TYPE LINE OF stringtab,
                   &lt;ls_requirement&gt;  TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement.

    ls_dot = mo_repo-&gt;get_dot_abapgit( )-&gt;get_data( ).

    lv_requirement_count = lines( ls_dot-requirements ).
    IF lv_requirement_count &lt; lc_requirement_edit_count.
      DO - lv_requirement_count + lc_requirement_edit_count TIMES.
        INSERT INITIAL LINE INTO TABLE ls_dot-requirements.
      ENDDO.
    ENDIF.

    INSERT zif_abapgit_dot_abapgit=&gt;c_folder_logic-full
           INTO TABLE lt_folder_logic.

    INSERT zif_abapgit_dot_abapgit=&gt;c_folder_logic-prefix
           INTO TABLE lt_folder_logic.

    io_html-&gt;add( &apos;&lt;h2&gt;.abapgit.xml&lt;/h2&gt;&apos; ).
    io_html-&gt;add( &apos;Folder logic: &lt;select name=&quot;folder_logic&quot;&gt;&apos; ).

    LOOP AT lt_folder_logic ASSIGNING &lt;lv_folder_logic&gt;.

      IF ls_dot-folder_logic = &lt;lv_folder_logic&gt;.
        lv_selected = &apos;selected&apos;.
      ELSE.
        CLEAR: lv_selected.
      ENDIF.

      io_html-&gt;add( |&lt;option value=&quot;{ &lt;lv_folder_logic&gt; }&quot; |
                 &amp;&amp; |{ lv_selected }&gt;|
                 &amp;&amp; |{ &lt;lv_folder_logic&gt; }&lt;/option&gt;| ).

    ENDLOOP.

    io_html-&gt;add( &apos;&lt;/select&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    io_html-&gt;add( &apos;Starting folder: &lt;input name=&quot;starting_folder&quot; type=&quot;text&quot; size=&quot;10&quot; value=&quot;&apos; &amp;&amp;
      ls_dot-starting_folder &amp;&amp; &apos;&quot;&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    io_html-&gt;add( &apos;&lt;h3&gt;Requirements&lt;/h3&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;table class=&quot;repo_tab&quot; id=&quot;requirement-tab&quot; style=&quot;max-width: 300px;&quot;&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;tr&gt;&lt;th&gt;Software Component&lt;/th&gt;&lt;th&gt;Min Release&lt;/th&gt;&lt;th&gt;Min Patch&lt;/th&gt;&lt;/tr&gt;&apos; ).

    LOOP AT ls_dot-requirements ASSIGNING &lt;ls_requirement&gt;.
      lv_req_index = sy-tabix.

      io_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
      io_html-&gt;add( |&lt;td&gt;&lt;input name=&quot;req_com_{ lv_req_index }&quot; maxlength=30 type=&quot;text&quot; | &amp;&amp;
                    |value=&quot;{ &lt;ls_requirement&gt;-component }&quot;&gt;&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;&lt;input name=&quot;req_rel_{ lv_req_index }&quot; maxlength=10 type=&quot;text&quot; | &amp;&amp;
                    |value=&quot;{ &lt;ls_requirement&gt;-min_release }&quot;&gt;&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;&lt;input name=&quot;req_pat_{ lv_req_index }&quot; maxlength=10 type=&quot;text&quot; | &amp;&amp;
                    |value=&quot;{ &lt;ls_requirement&gt;-min_patch }&quot;&gt;&lt;/td&gt;| ).
      io_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ENDLOOP.

    io_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

  ENDMETHOD.
  METHOD render_local_settings.

    DATA: lv_checked  TYPE string,
          ls_settings TYPE zif_abapgit_persistence=&gt;ty_repo-local_settings.

    ls_settings = mo_repo-&gt;get_local_settings( ).

    io_html-&gt;add( &apos;&lt;h2&gt;Local settings&lt;/h2&gt;&apos; ).

    CLEAR lv_checked.
    IF ls_settings-write_protected = abap_true.
      lv_checked = | checked|.
    ENDIF.
    io_html-&gt;add( |Write protected &lt;input name=&quot;write_protected&quot; type=&quot;checkbox&quot;{ lv_checked }&gt;&lt;br&gt;| ).

    CLEAR lv_checked.
    IF ls_settings-ignore_subpackages = abap_true.
      lv_checked = | checked|.
    ENDIF.
    io_html-&gt;add( |Ignore subpackages &lt;input name=&quot;ignore_subpackages&quot; type=&quot;checkbox&quot;{ lv_checked }&gt;&lt;br&gt;| ).

    CLEAR lv_checked.
    IF ls_settings-only_local_objects = abap_true.
      lv_checked = | checked|.
    ENDIF.
    io_html-&gt;add( |Only local objects &lt;input name=&quot;only_local_objects&quot; type=&quot;checkbox&quot;{ lv_checked }&gt;&lt;br&gt;| ).

    io_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    io_html-&gt;add( &apos;Code inspector check variant: &lt;input name=&quot;check_variant&quot; type=&quot;text&quot; size=&quot;30&quot; value=&quot;&apos; &amp;&amp;
      ls_settings-code_inspector_check_variant &amp;&amp; &apos;&quot;&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    CLEAR lv_checked.
    IF ls_settings-block_commit = abap_true.
      lv_checked = | checked|.
    ENDIF.
    io_html-&gt;add( |Block commit commit/push if code inspection has erros: |
               &amp;&amp; |&lt;input name=&quot;block_commit&quot; type=&quot;checkbox&quot;{ lv_checked }&gt;&lt;br&gt;| ).
  ENDMETHOD.
  METHOD save.

    DATA: lt_post_fields TYPE tihttpnvp.
    lt_post_fields = parse_post( it_postdata ).

    save_dot_abap( lt_post_fields ).
    save_local_settings( lt_post_fields ).

    mo_repo-&gt;refresh( ).

  ENDMETHOD.
  METHOD save_dot_abap.

    DATA: lo_dot          TYPE REF TO zcl_abapgit_dot_abapgit,
          ls_post_field   LIKE LINE OF it_post_fields,
          lt_requirements TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement_tt.
    FIELD-SYMBOLS: &lt;ls_requirement&gt; TYPE zif_abapgit_dot_abapgit=&gt;ty_requirement.
    lo_dot = mo_repo-&gt;get_dot_abapgit( ).

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;folder_logic&apos;.
    ASSERT sy-subrc = 0.
    lo_dot-&gt;set_folder_logic( ls_post_field-value ).

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;starting_folder&apos;.
    ASSERT sy-subrc = 0.
    lo_dot-&gt;set_starting_folder( ls_post_field-value ).

    LOOP AT it_post_fields INTO ls_post_field WHERE name CP &apos;req_*&apos;.
      CASE ls_post_field-name+4(3).
        WHEN &apos;com&apos;.
          INSERT INITIAL LINE INTO TABLE lt_requirements ASSIGNING &lt;ls_requirement&gt;.
          &lt;ls_requirement&gt;-component = ls_post_field-value.
        WHEN &apos;rel&apos;.
          &lt;ls_requirement&gt;-min_release = ls_post_field-value.
        WHEN &apos;pat&apos;.
          &lt;ls_requirement&gt;-min_patch = ls_post_field-value.
      ENDCASE.
    ENDLOOP.

    SORT lt_requirements BY component min_release min_patch.
    DELETE lt_requirements WHERE component IS INITIAL.
    DELETE ADJACENT DUPLICATES FROM lt_requirements COMPARING ALL FIELDS.

    lo_dot-&gt;set_requirements( lt_requirements ).

    mo_repo-&gt;set_dot_abapgit( lo_dot ).

  ENDMETHOD.
  METHOD save_local_settings.

    DATA: ls_settings      TYPE zif_abapgit_persistence=&gt;ty_repo-local_settings,
          ls_post_field    LIKE LINE OF it_post_fields,
          lv_check_variant TYPE sci_chkv.
    ls_settings = mo_repo-&gt;get_local_settings( ).

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;write_protected&apos; value = &apos;on&apos;.
    IF sy-subrc = 0.
      ls_settings-write_protected = abap_true.
    ELSE.
      ls_settings-write_protected = abap_false.
    ENDIF.

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;ignore_subpackages&apos; value = &apos;on&apos;.
    IF sy-subrc = 0.
      ls_settings-ignore_subpackages = abap_true.
    ELSE.
      ls_settings-ignore_subpackages = abap_false.
    ENDIF.

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;only_local_objects&apos; value = &apos;on&apos;.
    IF sy-subrc = 0.
      ls_settings-only_local_objects = abap_true.
    ELSE.
      ls_settings-only_local_objects = abap_false.
    ENDIF.

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;check_variant&apos;.
    ASSERT sy-subrc = 0.
    lv_check_variant = to_upper( ls_post_field-value ).
    IF ls_post_field-value IS NOT INITIAL.
      zcl_abapgit_code_inspector=&gt;validate_check_variant( lv_check_variant ).
    ENDIF.
    ls_settings-code_inspector_check_variant = lv_check_variant.

    READ TABLE it_post_fields INTO ls_post_field WITH KEY name = &apos;block_commit&apos; value = &apos;on&apos;.
    IF sy-subrc = 0.
      ls_settings-block_commit = abap_true.
    ELSE.
      ls_settings-block_commit = abap_false.
    ENDIF.

    IF ls_settings-block_commit = abap_true
        AND ls_settings-code_inspector_check_variant IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |If block commit is active, a check variant has to be maintained.| ).
    ENDIF.

    mo_repo-&gt;set_local_settings( ls_settings ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    CASE iv_action.
      WHEN c_action-save_settings.
        save( it_postdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_gui_page_repo_over IMPLEMENTATION.
  METHOD add_direction_option.

    DATA: lv_selected TYPE string.

    IF iv_selected = abap_true.
      lv_selected = &apos;selected&apos;.
    ENDIF.

    io_html-&gt;add( |&lt;option value=&quot;{ iv_option }&quot; { lv_selected }&gt;|
               &amp;&amp; |{ to_mixed( iv_option ) }&lt;/option&gt;| ).

  ENDMETHOD.
  METHOD add_order_by_option.

    DATA: lv_selected TYPE string.

    IF mv_order_by = iv_option.
      lv_selected = &apos;selected&apos;.
    ENDIF.

    io_html-&gt;add( |&lt;option value=&quot;{ iv_option }&quot; { lv_selected }&gt;|
               &amp;&amp; |{ to_mixed( iv_option ) }&lt;/option&gt;| ).

  ENDMETHOD.
  METHOD apply_filter.

    IF mv_filter IS NOT INITIAL.

      DELETE ct_overview WHERE key             NS mv_filter
                           AND name            NS mv_filter
                           AND url             NS mv_filter
                           AND package         NS mv_filter
                           AND branch          NS mv_filter
                           AND created_by      NS mv_filter
                           AND created_at      NS mv_filter
                           AND deserialized_by NS mv_filter
                           AND deserialized_at NS mv_filter.

    ENDIF.

  ENDMETHOD.
  METHOD apply_order_by.

    DATA:
      lt_sort TYPE abap_sortorder_tab,
      ls_sort LIKE LINE OF lt_sort.

    IF mv_order_by IS NOT INITIAL.

      ls_sort-name       = mv_order_by.
      ls_sort-descending = mv_order_descending.
      ls_sort-astext     = abap_true.
      INSERT ls_sort INTO TABLE lt_sort.
      SORT ct_overview BY (lt_sort).

    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( ).
    ms_control-page_title = |Repository Overview|.
    mv_order_by = |NAME|.

    CALL FUNCTION &apos;GET_SYSTEM_TIMEZONE&apos;
      IMPORTING
        timezone            = mv_time_zone
      EXCEPTIONS
        customizing_missing = 1
        OTHERS              = 2.
    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD map_repo_list_to_overview.

    DATA: ls_overview LIKE LINE OF rt_overview,
          lo_repo_srv TYPE REF TO zcl_abapgit_repo,
          lv_date     TYPE d,
          lv_time     TYPE t.

    FIELD-SYMBOLS: &lt;ls_repo&gt; LIKE LINE OF it_repo_list.
    LOOP AT it_repo_list ASSIGNING &lt;ls_repo&gt;.

      CLEAR: ls_overview.
      lo_repo_srv = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( &lt;ls_repo&gt;-key ).

      ls_overview-favorite   = zcl_abapgit_persistence_user=&gt;get_instance(
        )-&gt;is_favorite_repo( &lt;ls_repo&gt;-key ).
      ls_overview-type       = &lt;ls_repo&gt;-offline.
      ls_overview-key        = &lt;ls_repo&gt;-key.
      ls_overview-name       = lo_repo_srv-&gt;get_name( ).
      ls_overview-url        = &lt;ls_repo&gt;-url.
      ls_overview-package    = &lt;ls_repo&gt;-package.
      ls_overview-branch     = zcl_abapgit_git_branch_list=&gt;get_display_name( &lt;ls_repo&gt;-branch_name ).
      ls_overview-created_by = &lt;ls_repo&gt;-created_by.

      IF &lt;ls_repo&gt;-created_at IS NOT INITIAL.
        CONVERT TIME STAMP &lt;ls_repo&gt;-created_at
                TIME ZONE mv_time_zone
                INTO DATE lv_date
                     TIME lv_time.

        ls_overview-created_at = |{ lv_date DATE = USER } { lv_time TIME = USER }|.
      ENDIF.

      ls_overview-deserialized_by = &lt;ls_repo&gt;-deserialized_by.

      IF &lt;ls_repo&gt;-deserialized_at IS NOT INITIAL.
        CONVERT TIME STAMP &lt;ls_repo&gt;-deserialized_at
                TIME ZONE mv_time_zone
                INTO DATE lv_date
                     TIME lv_time.

        ls_overview-deserialized_at = |{ lv_date DATE = USER } { lv_time TIME = USER }|.
      ENDIF.

      INSERT ls_overview INTO TABLE rt_overview.

    ENDLOOP.

  ENDMETHOD.
  METHOD parse_change_order_by.

    FIELD-SYMBOLS: &lt;lv_postdata&gt; TYPE cnht_post_data_line.

    READ TABLE it_postdata ASSIGNING &lt;lv_postdata&gt;
                           INDEX 1.
    IF sy-subrc = 0.
      FIND FIRST OCCURRENCE OF REGEX `orderBy=(.*)`
           IN &lt;lv_postdata&gt;
           SUBMATCHES mv_order_by.
    ENDIF.

    mv_order_by = condense( mv_order_by ).

  ENDMETHOD.
  METHOD parse_direction.

    DATA: lv_direction TYPE string.

    FIELD-SYMBOLS: &lt;lv_postdata&gt; TYPE cnht_post_data_line.

    CLEAR: mv_order_descending.

    READ TABLE it_postdata ASSIGNING &lt;lv_postdata&gt;
                           INDEX 1.
    IF sy-subrc = 0.
      FIND FIRST OCCURRENCE OF REGEX `direction=(.*)`
           IN &lt;lv_postdata&gt;
           SUBMATCHES lv_direction.
    ENDIF.

    IF condense( lv_direction ) = &apos;DESCENDING&apos;.
      mv_order_descending = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD parse_filter.

    FIELD-SYMBOLS: &lt;lv_postdata&gt; LIKE LINE OF it_postdata.

    READ TABLE it_postdata ASSIGNING &lt;lv_postdata&gt;
                           INDEX 1.
    IF sy-subrc = 0.
      FIND FIRST OCCURRENCE OF REGEX `filter=(.*)`
           IN &lt;lv_postdata&gt;
           SUBMATCHES mv_filter.
    ENDIF.

    mv_filter = condense( mv_filter ).

  ENDMETHOD.
  METHOD render_content.

    DATA: lt_overview TYPE tty_overview.
    lt_overview = map_repo_list_to_overview(
      zcl_abapgit_persist_factory=&gt;get_repo( )-&gt;list( ) ).

    apply_order_by( CHANGING ct_overview = lt_overview ).

    apply_filter( CHANGING ct_overview = lt_overview ).

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;div class=&quot;form-container&quot;&gt;| ).

    ro_html-&gt;add( |&lt;form id=&quot;commit_form&quot; class=&quot;grey70&quot;|
               &amp;&amp; | method=&quot;post&quot; action=&quot;sapevent:{ c_action-apply_filter }&quot;&gt;| ).

    render_header_bar( ro_html ).

    render_table( io_html     = ro_html
                  it_overview = lt_overview ).

    ro_html-&gt;add( |&lt;/div&gt;| ).

  ENDMETHOD.
  METHOD render_header_bar.

    io_html-&gt;add( |&lt;div class=&quot;row&quot;&gt;| ).

    render_order_by( io_html ).
    render_order_by_direction( io_html ).

    io_html-&gt;add( render_text_input( iv_name  = |filter|
                                     iv_label = |Filter: |
                                     iv_value = mv_filter ) ).

    io_html-&gt;add( |&lt;input type=&quot;submit&quot; class=&quot;hidden-submit&quot;&gt;| ).

    io_html-&gt;add( |&lt;/div&gt;| ).

    io_html-&gt;add( |&lt;/form&gt;| ).
    io_html-&gt;add( |&lt;/div&gt;| ).

  ENDMETHOD.
  METHOD render_order_by.

    io_html-&gt;add( |Order by: &lt;select name=&quot;order_by&quot; onchange=&quot;onOrderByChange(this)&quot;&gt;| ).

    add_order_by_option( iv_option = |TYPE|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |KEY|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |NAME|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |URL|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |PACKAGE|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |BRANCH|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |CREATED_BY|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |CREATED_AT|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |DESERIALIZED_BY|
                         io_html   = io_html ).

    add_order_by_option( iv_option = |DESERIALIZED_AT|
                         io_html   = io_html ).

    io_html-&gt;add( |&lt;/select&gt;| ).

  ENDMETHOD.
  METHOD render_order_by_direction.

    io_html-&gt;add( |&lt;select name=&quot;direction&quot; onchange=&quot;onDirectionChange(this)&quot;&gt;| ).

    add_direction_option( iv_option   = |ASCENDING|
                          iv_selected = mv_order_descending
                          io_html     = io_html ).

    add_direction_option( iv_option   = |DESCENDING|
                          iv_selected = mv_order_descending
                          io_html     = io_html ).

    io_html-&gt;add( |&lt;/select&gt;| ).

  ENDMETHOD.
  METHOD render_table.

    io_html-&gt;add( |&lt;div class=&quot;db_list&quot;&gt;| ).
    io_html-&gt;add( |&lt;table class=&quot;db_tab&quot;&gt;| ).

    render_table_header( io_html ).
    render_table_body( io_html     = io_html
                       it_overview = it_overview  ).

    io_html-&gt;add( |&lt;/tbody&gt;| ).
    io_html-&gt;add( |&lt;/table&gt;| ).

  ENDMETHOD.
  METHOD render_table_body.

    DATA: lv_trclass       TYPE string,
          lv_type_icon     TYPE string,
          lv_favorite_icon TYPE string.

    FIELD-SYMBOLS: &lt;ls_overview&gt; LIKE LINE OF it_overview.

    LOOP AT it_overview ASSIGNING &lt;ls_overview&gt;.

      CLEAR lv_trclass.
      IF sy-tabix = 1.
        lv_trclass = &apos; class=&quot;firstrow&quot;&apos; ##NO_TEXT.
      ENDIF.

      IF &lt;ls_overview&gt;-type = abap_true.
        lv_type_icon = &apos;plug/darkgrey&apos;.
      ELSE.
        lv_type_icon = &apos;cloud-upload/blue&apos;.
      ENDIF.

      IF &lt;ls_overview&gt;-favorite = abap_true.
        lv_favorite_icon = &apos;star/blue&apos;.
      ELSE.
        lv_favorite_icon = &apos;star/grey&apos;.
      ENDIF.

      io_html-&gt;add( |&lt;tr{ lv_trclass }&gt;| ).
      io_html-&gt;add( |&lt;td&gt;| ).
      io_html-&gt;add_a( iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_toggle_fav }?{ &lt;ls_overview&gt;-key }|
                      iv_txt = zcl_abapgit_html=&gt;icon( iv_name  = lv_favorite_icon
                                                       iv_class = &apos;pad-sides&apos;
                                                       iv_hint  = &apos;Click to toggle favorite&apos; ) ).
      io_html-&gt;add( |&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ zcl_abapgit_html=&gt;icon( lv_type_icon )  }&lt;/td&gt;| ).

      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-key }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ zcl_abapgit_html=&gt;a( iv_txt = &lt;ls_overview&gt;-name
                                                iv_act = |{ c_action-select }?{ &lt;ls_overview&gt;-key }| ) }&lt;/td&gt;| ).

      IF &lt;ls_overview&gt;-type = abap_false.
        io_html-&gt;add( |&lt;td&gt;{ io_html-&gt;a( iv_txt = &lt;ls_overview&gt;-url
                                         iv_act = |{ zif_abapgit_definitions=&gt;c_action-url }?|
                                               &amp;&amp; |{ &lt;ls_overview&gt;-url }| ) }&lt;/td&gt;| ).
      ELSE.
        io_html-&gt;add( |&lt;td&gt; &lt;/td&gt;| ).
      ENDIF.

      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-package }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-branch }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-created_by }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-created_at }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-deserialized_by }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;{ &lt;ls_overview&gt;-deserialized_at }&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;td&gt;| ).
      io_html-&gt;add( |&lt;/td&gt;| ).
      io_html-&gt;add( |&lt;/tr&gt;| ).

    ENDLOOP.

  ENDMETHOD.
  METHOD render_table_header.

    io_html-&gt;add( |&lt;thead&gt;| ).
    io_html-&gt;add( |&lt;tr&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Favorite&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Type&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Key&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Name&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Url&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Package&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Branch name&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Creator&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Created at [{ mv_time_zone }]&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Deserialized by&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;Deserialized at [{ mv_time_zone }]&lt;/th&gt;| ).
    io_html-&gt;add( |&lt;th&gt;&lt;/th&gt;| ).
    io_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).
    io_html-&gt;add( &apos;&lt;tbody&gt;&apos; ).

  ENDMETHOD.
  METHOD render_text_input.

    DATA lv_attrs TYPE string.

    CREATE OBJECT ro_html.

    IF iv_value IS NOT INITIAL.
      lv_attrs = | value=&quot;{ iv_value }&quot;|.
    ENDIF.

    IF iv_max_length IS NOT INITIAL.
      lv_attrs = | maxlength=&quot;{ iv_max_length }&quot;|.
    ENDIF.

    ro_html-&gt;add( |&lt;label for=&quot;{ iv_name }&quot;&gt;{ iv_label }&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;input id=&quot;{ iv_name }&quot; name=&quot;{ iv_name }&quot; type=&quot;text&quot;{ lv_attrs }&gt;| ).

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;setInitialFocus(&quot;filter&quot;);&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lv_key  TYPE zif_abapgit_persistence=&gt;ty_value.

    CASE iv_action.
      WHEN c_action-select.

        lv_key = iv_getdata.

        zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( lv_key ).

        TRY.
            zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key )-&gt;refresh( ).
          CATCH zcx_abapgit_exception ##NO_HANDLER.
        ENDTRY.

        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.

      WHEN c_action-change_order_by.

        parse_change_order_by( it_postdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.

      WHEN c_action-direction.

        parse_direction( it_postdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.

      WHEN c_action-apply_filter.

        parse_filter( it_postdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.

      WHEN OTHERS.

        super-&gt;zif_abapgit_gui_page~on_event(
          EXPORTING
            iv_action    = iv_action
            iv_prev_page = iv_prev_page
            iv_getdata   = iv_getdata
            it_postdata  = it_postdata
          IMPORTING
            ei_page      = ei_page
            ev_state     = ev_state  ).

    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_MERGE_RES IMPLEMENTATION.
  METHOD apply_merged_content.

    CONSTANTS: lc_replace TYPE string VALUE &apos;&lt;&lt;new&gt;&gt;&apos;.

    DATA: BEGIN OF ls_filedata,
            merge_content TYPE string,
          END OF ls_filedata.

    DATA: lv_string           TYPE string,
          lt_fields           TYPE tihttpnvp,
          lv_new_file_content TYPE xstring.

    FIELD-SYMBOLS: &lt;lv_postdata_line&gt; LIKE LINE OF it_postdata,
                   &lt;ls_conflict&gt;      TYPE zif_abapgit_definitions=&gt;ty_merge_conflict.

    LOOP AT it_postdata ASSIGNING &lt;lv_postdata_line&gt;.
      lv_string = |{ lv_string }{ &lt;lv_postdata_line&gt; }|.
    ENDLOOP.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_crlf    IN lv_string WITH lc_replace.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_newline IN lv_string WITH lc_replace.

    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields_upper_case_name( lv_string ).
    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name = &apos;MERGE_CONTENT&apos;
                                                        it_field = lt_fields
                                              CHANGING cg_field = ls_filedata ).
    ls_filedata-merge_content = cl_http_utility=&gt;unescape_url( escaped = ls_filedata-merge_content ).
    REPLACE ALL OCCURRENCES OF lc_replace IN ls_filedata-merge_content WITH zif_abapgit_definitions=&gt;c_newline.

    lv_new_file_content = zcl_abapgit_convert=&gt;string_to_xstring_utf8( ls_filedata-merge_content ).

    READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; INDEX mv_current_conflict_index.
    &lt;ls_conflict&gt;-result_sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-blob
                                                        iv_data = lv_new_file_content ).
    &lt;ls_conflict&gt;-result_data = lv_new_file_content.
    mo_merge-&gt;resolve_conflict( &lt;ls_conflict&gt; ).

  ENDMETHOD.
  METHOD build_menu.

    CREATE OBJECT ro_menu.
    ro_menu-&gt;add( iv_txt = &apos;Toggle merge mode&apos; iv_act = c_actions-toggle_mode ) ##NO_TEXT.
    ro_menu-&gt;add( iv_txt = &apos;Cancel&apos; iv_act = c_actions-cancel ) ##NO_TEXT.

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( ).

    mo_repo = io_repo.
    ms_control-page_title = &apos;Resolve Conflicts&apos;.
    ms_control-page_menu  = build_menu( ).

    mo_merge_page = io_merge_page.
    mo_merge = io_merge.
    mv_merge_mode = c_merge_mode-selection.
    mv_current_conflict_index = 1.
    mt_conflicts = io_merge-&gt;get_conflicts( ).

  ENDMETHOD.
  METHOD is_binary.

    DATA: lv_len TYPE i,
          lv_idx TYPE i,
          lv_x   TYPE x.

    FIELD-SYMBOLS &lt;lv_data&gt; LIKE iv_d1.
    IF iv_d1 IS NOT INITIAL. &quot; One of them might be new and so empty
      ASSIGN iv_d1 TO &lt;lv_data&gt;.
    ELSE.
      ASSIGN iv_d2 TO &lt;lv_data&gt;.
    ENDIF.

    lv_len = xstrlen( &lt;lv_data&gt; ).
    IF lv_len = 0.
      RETURN.
    ENDIF.

    IF lv_len &gt; 100.
      lv_len = 100.
    ENDIF.

    &quot; Simple char range test
    &quot; stackoverflow.com/questions/277521/how-to-identify-the-file-content-as-ascii-or-binary
    DO lv_len TIMES. &quot; I&apos;m sure there is more efficient way ...
      lv_idx = sy-index - 1.
      lv_x = &lt;lv_data&gt;+lv_idx(1).

      IF NOT ( lv_x BETWEEN 9 AND 13 OR lv_x BETWEEN 32 AND 126 ).
        rv_yes = abap_true.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.
  METHOD render_beacon.

    DATA: lv_beacon  TYPE string.

    CREATE OBJECT ro_html.

    IF is_diff_line-beacon &gt; 0.
      READ TABLE is_diff-o_diff-&gt;mt_beacons INTO lv_beacon INDEX is_diff_line-beacon.
    ELSE.
      lv_beacon = &apos;---&apos;.
    ENDIF.
    ro_html-&gt;add( &apos;&lt;thead class=&quot;nav_line&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).
    ro_html-&gt;add( |&lt;th colspan=&quot;3&quot;&gt;@@ { is_diff_line-new_num } @@ { lv_beacon }&lt;/th&gt;| ).

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).

  ENDMETHOD.
  METHOD render_content.

    resolve_diff( ).
    IF ms_diff_file IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;no conflict found&apos; ).
    ENDIF.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;div id=&quot;diff-list&quot; data-repo-key=&quot;{ mo_repo-&gt;get_key( ) }&quot;&gt;| ).
    ro_html-&gt;add( render_diff( ms_diff_file ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_diff.

    DATA: lv_target_content TYPE string.
    FIELD-SYMBOLS: &lt;ls_conflict&gt; TYPE zif_abapgit_definitions=&gt;ty_merge_conflict.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;div class=&quot;diff&quot; data-type=&quot;{ is_diff-type
      }&quot; data-changed-by=&quot;{ is_diff-changed_by
      }&quot; data-file=&quot;{ is_diff-path &amp;&amp; is_diff-filename }&quot;&gt;| ). &quot;#EC NOTEXT
    ro_html-&gt;add( render_diff_head( is_diff ) ).

    &quot; Content
    IF is_diff-type &lt;&gt; &apos;binary&apos;.

      IF mv_merge_mode EQ c_merge_mode-selection.
        ro_html-&gt;add( &apos;&lt;div class=&quot;diff_content&quot;&gt;&apos; ).       &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;table class=&quot;diff_tab syntax-hl&quot;&gt;&apos; ). &quot;#EC NOTEXT
        ro_html-&gt;add( render_table_head( ) ).
        ro_html-&gt;add( render_lines( is_diff ) ).
        ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).                         &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                           &quot;#EC NOTEXT
      ELSE.

        &quot;Table for Div-Table and textarea
        ro_html-&gt;add( &apos;&lt;div class=&quot;diff_content&quot;&gt;&apos; ).       &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&apos; ).                          &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;thead class=&quot;header&quot;&gt;&apos; ).           &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                             &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;th&gt;Code&lt;/th&gt;&apos; ).                    &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;th&gt;Merge - &apos; ).                     &quot;#EC NOTEXT
        ro_html-&gt;add_a( iv_act = &apos;submitFormById(&apos;&apos;merge_form&apos;&apos;);&apos; &quot;#EC NOTEXT
                        iv_txt = &apos;Apply&apos;
                        iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                        iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
        ro_html-&gt;add( &apos;&lt;/th&gt; &apos; ).                           &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                            &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).                         &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).

        &quot;Diff-Table of source and target file
        ro_html-&gt;add( &apos;&lt;table class=&quot;diff_tab syntax-hl&quot;&gt;&apos; ). &quot;#EC NOTEXT
        ro_html-&gt;add( render_table_head( ) ).
        ro_html-&gt;add( render_lines( is_diff ) ).
        ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).                         &quot;#EC NOTEXT

        READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; INDEX mv_current_conflict_index.
        IF sy-subrc EQ 0.
          lv_target_content = zcl_abapgit_convert=&gt;xstring_to_string_utf8( &lt;ls_conflict&gt;-target_data ).
          lv_target_content = escape( val = lv_target_content format = cl_abap_format=&gt;e_html_text ).
        ENDIF.

        ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).                            &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).                             &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;div class=&quot;form-container&quot;&gt;&apos; ).
        ro_html-&gt;add( |&lt;form id=&quot;merge_form&quot; class=&quot;aligned-form w100&quot; accept-charset=&quot;UTF-8&quot;| ).
        ro_html-&gt;add( |method=&quot;post&quot; action=&quot;sapevent:apply_merge&quot;&gt;| ).
        ro_html-&gt;add( |&lt;textarea id=&quot;merge_content&quot; name=&quot;merge_content&quot; class=&quot;w100&quot; | ).
        ro_html-&gt;add( |rows=&quot;{ lines( is_diff-o_diff-&gt;get( ) ) }&quot;&gt;{ lv_target_content }&lt;/textarea&gt;| ).
        ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; class=&quot;hidden-submit&quot;&gt;&apos; ).
        ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).                          &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                           &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).                            &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).                         &quot;#EC NOTEXT
        ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                           &quot;#EC NOTEXT
      ENDIF.
    ELSE.
      ro_html-&gt;add( &apos;&lt;div class=&quot;diff_content paddings center grey&quot;&gt;&apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;The content seems to be binary.&apos; ).    &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;Cannot display as diff.&apos; ).            &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                             &quot;#EC NOTEXT
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_diff_head.

    DATA: ls_stats TYPE zif_abapgit_definitions=&gt;ty_count.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;diff_head&quot;&gt;&apos; ).              &quot;#EC NOTEXT

    IF is_diff-type &lt;&gt; &apos;binary&apos; AND is_diff-o_diff IS NOT INITIAL.
      ls_stats = is_diff-o_diff-&gt;stats( ).
      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_ins&quot;&gt;+ { ls_stats-insert }&lt;/span&gt;| ).
      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_del&quot;&gt;- { ls_stats-delete }&lt;/span&gt;| ).
      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_upd&quot;&gt;~ { ls_stats-update }&lt;/span&gt;| ).
    ENDIF.

    ro_html-&gt;add( |&lt;span class=&quot;diff_name&quot;&gt;{ is_diff-filename }&lt;/span&gt;| ). &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_lines.

    DATA: lo_highlighter TYPE REF TO zcl_abapgit_syntax_highlighter,
          lt_diffs       TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
          lv_insert_nav  TYPE abap_bool.

    FIELD-SYMBOLS &lt;ls_diff&gt;  LIKE LINE OF lt_diffs.

    lo_highlighter = zcl_abapgit_syntax_highlighter=&gt;create( is_diff-filename ).
    CREATE OBJECT ro_html.

    lt_diffs = is_diff-o_diff-&gt;get( ).

    LOOP AT lt_diffs ASSIGNING &lt;ls_diff&gt;.
      IF &lt;ls_diff&gt;-short = abap_false.
        lv_insert_nav = abap_true.
        CONTINUE.
      ENDIF.

      IF lv_insert_nav = abap_true. &quot; Insert separator line with navigation
        ro_html-&gt;add( render_beacon( is_diff_line = &lt;ls_diff&gt; is_diff = is_diff ) ).
        lv_insert_nav = abap_false.
      ENDIF.

      IF lo_highlighter IS BOUND.
        &lt;ls_diff&gt;-new = lo_highlighter-&gt;process_line( &lt;ls_diff&gt;-new ).
        &lt;ls_diff&gt;-old = lo_highlighter-&gt;process_line( &lt;ls_diff&gt;-old ).
      ELSE.
        &lt;ls_diff&gt;-new = escape( val = &lt;ls_diff&gt;-new format = cl_abap_format=&gt;e_html_attr ).
        &lt;ls_diff&gt;-old = escape( val = &lt;ls_diff&gt;-old format = cl_abap_format=&gt;e_html_attr ).
      ENDIF.

      CONDENSE &lt;ls_diff&gt;-new_num. &quot;get rid of leading spaces
      CONDENSE &lt;ls_diff&gt;-old_num.

      ro_html-&gt;add( render_line_split( is_diff_line = &lt;ls_diff&gt;
                                       iv_fstate    = is_diff-fstate ) ).

    ENDLOOP.

  ENDMETHOD.
  METHOD render_line_split.

    DATA: lv_new  TYPE string,
          lv_old  TYPE string,
          lv_mark TYPE string,
          lv_bg   TYPE string.

    CREATE OBJECT ro_html.

    &quot; New line
    lv_mark = ` `.
    IF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-update.
      lv_bg = &apos; diff_upd&apos;.
      lv_mark = `~`.
    ELSEIF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-insert.
      lv_bg = &apos; diff_ins&apos;.
      lv_mark = `+`.
    ENDIF.
    lv_new = |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-new_num }&quot;&gt;&lt;/td&gt;|
          &amp;&amp; |&lt;td class=&quot;code{ lv_bg }&quot;&gt;{ lv_mark }{ is_diff_line-new }&lt;/td&gt;|.

    &quot; Old line
    CLEAR lv_bg.
    lv_mark = ` `.
    IF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-update.
      lv_bg = &apos; diff_upd&apos;.
      lv_mark = `~`.
    ELSEIF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-delete.
      lv_bg = &apos; diff_del&apos;.
      lv_mark = `-`.
    ENDIF.
    lv_old = |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-old_num }&quot;&gt;&lt;/td&gt;|
          &amp;&amp; |&lt;td class=&quot;code{ lv_bg }&quot;&gt;{ lv_mark }{ is_diff_line-old }&lt;/td&gt;|.

    &quot; render line, inverse sides if remote is newer
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                                 &quot;#EC NOTEXT
    ro_html-&gt;add( lv_old ). &quot; Target
    ro_html-&gt;add( lv_new ). &quot; Source
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                                &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_table_head.

    CREATE OBJECT ro_html.
    IF mv_merge_mode EQ c_merge_mode-selection.
      ro_html-&gt;add( &apos;&lt;thead class=&quot;header&quot;&gt;&apos; ).             &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                               &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;form id=&quot;target_form&quot; method=&quot;post&quot; action=&quot;sapevent:apply_target&quot;&gt;&apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;Target - &apos; &amp;&amp; mo_repo-&gt;get_branch_name( ) &amp;&amp; &apos; - &apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add_a( iv_act = &apos;submitFormById(&apos;&apos;target_form&apos;&apos;);&apos; &quot;#EC NOTEXT
                      iv_txt = &apos;Apply&apos;
                      iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                      iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ro_html-&gt;add( &apos;&lt;/th&gt; &apos; ).                             &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).                            &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;form id=&quot;source_form&quot; method=&quot;post&quot; action=&quot;sapevent:apply_source&quot;&gt;&apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;Source  - &apos; &amp;&amp; mo_merge-&gt;get_source_branch( ) &amp;&amp;&apos; - &apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add_a( iv_act = &apos;submitFormById(&apos;&apos;source_form&apos;&apos;);&apos; &quot;#EC NOTEXT
                      iv_txt = &apos;Apply&apos;
                      iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                      iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ).
      ro_html-&gt;add( &apos;&lt;/th&gt; &apos; ).                             &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).                            &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).                           &quot;#EC NOTEXT
    ELSE.
      ro_html-&gt;add( &apos;&lt;thead class=&quot;header&quot;&gt;&apos; ).             &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                               &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;Target - &apos; &amp;&amp; mo_repo-&gt;get_branch_name( ) &amp;&amp;&apos;&lt;/th&gt; &apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;Source - &apos; &amp;&amp; mo_merge-&gt;get_source_branch( ) &amp;&amp;&apos;&lt;/th&gt; &apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).                           &quot;#EC NOTEXT
    ENDIF.

  ENDMETHOD.
  METHOD resolve_diff.

    DATA: lv_offs TYPE i.
    FIELD-SYMBOLS: &lt;ls_conflict&gt; TYPE zif_abapgit_definitions=&gt;ty_merge_conflict.

    CLEAR ms_diff_file.

    READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; INDEX mv_current_conflict_index.
    IF sy-subrc NE 0.
      RETURN.
    ENDIF.

    ms_diff_file-path     = &lt;ls_conflict&gt;-path.
    ms_diff_file-filename = &lt;ls_conflict&gt;-filename.
    ms_diff_file-type = reverse( &lt;ls_conflict&gt;-filename ).

    FIND FIRST OCCURRENCE OF &apos;.&apos; IN ms_diff_file-type MATCH OFFSET lv_offs.
    ms_diff_file-type = reverse( substring( val = ms_diff_file-type len = lv_offs ) ).
    IF ms_diff_file-type &lt;&gt; &apos;xml&apos; AND ms_diff_file-type &lt;&gt; &apos;abap&apos;.
      ms_diff_file-type = &apos;other&apos;.
    ENDIF.

    IF ms_diff_file-type = &apos;other&apos;
    AND is_binary( iv_d1 = &lt;ls_conflict&gt;-source_data iv_d2 = &lt;ls_conflict&gt;-target_data ) = abap_true.
      ms_diff_file-type = &apos;binary&apos;.
    ENDIF.

    IF ms_diff_file-type &lt;&gt; &apos;binary&apos;.
      CREATE OBJECT ms_diff_file-o_diff
        EXPORTING
          iv_new = &lt;ls_conflict&gt;-source_data
          iv_old = &lt;ls_conflict&gt;-target_data.
    ENDIF.

  ENDMETHOD.
  METHOD toggle_merge_mode.

    IF mv_merge_mode EQ c_merge_mode-selection.
      mv_merge_mode = c_merge_mode-merge.
    ELSE.
      mv_merge_mode = c_merge_mode-selection.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    FIELD-SYMBOLS: &lt;ls_conflict&gt; TYPE zif_abapgit_definitions=&gt;ty_merge_conflict.

    CASE iv_action.
      WHEN c_actions-apply_merge
        OR c_actions-apply_source
        OR c_actions-apply_target
        OR c_actions-cancel.

        CASE iv_action.
          WHEN c_actions-apply_merge.
            apply_merged_content( it_postdata ).

          WHEN c_actions-apply_source.
            READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; INDEX mv_current_conflict_index.
            &lt;ls_conflict&gt;-result_sha1 = &lt;ls_conflict&gt;-source_sha1.
            &lt;ls_conflict&gt;-result_data = &lt;ls_conflict&gt;-source_data.
            mo_merge-&gt;resolve_conflict( &lt;ls_conflict&gt; ).

          WHEN c_actions-apply_target.
            READ TABLE mt_conflicts ASSIGNING &lt;ls_conflict&gt; INDEX mv_current_conflict_index.
            &lt;ls_conflict&gt;-result_sha1 = &lt;ls_conflict&gt;-target_sha1.
            &lt;ls_conflict&gt;-result_data = &lt;ls_conflict&gt;-target_data.
            mo_merge-&gt;resolve_conflict( &lt;ls_conflict&gt; ).

        ENDCASE.

        mv_current_conflict_index = mv_current_conflict_index + 1.
        IF mv_current_conflict_index &gt; lines( mt_conflicts ).
          CLEAR mv_current_conflict_index.
        ENDIF.

        IF mv_current_conflict_index IS NOT INITIAL.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
        ELSE.
          ei_page = mo_merge_page.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
        ENDIF.

      WHEN c_actions-toggle_mode.
        toggle_merge_mode( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.

    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_MERGE IMPLEMENTATION.
  METHOD build_menu.

    CREATE OBJECT ro_menu.

    ro_menu-&gt;add( iv_txt = &apos;Merge&apos; iv_act = c_actions-merge iv_cur = abap_false ) ##NO_TEXT.

    IF iv_with_conflict EQ abap_true.
      ro_menu-&gt;add( iv_txt = &apos;Resolve Conflicts&apos; iv_act = c_actions-res_conflicts ) ##NO_TEXT.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( ).

    mo_repo = io_repo.

    io_repo-&gt;set_branch_name( |refs/heads/{ iv_target }| ).

    CREATE OBJECT mo_merge
      EXPORTING
        io_repo          = io_repo
        iv_source_branch = iv_source.
    mo_merge-&gt;run( ).

    ms_control-page_title = &apos;MERGE&apos;.
    ms_control-page_menu  = build_menu( mo_merge-&gt;has_conflicts( ) ).

  ENDMETHOD.
  METHOD render_content.

    DEFINE _show_file.
      READ TABLE &amp;1 ASSIGNING &lt;ls_show&gt;
          WITH KEY path = &lt;ls_file&gt;-path name = &lt;ls_file&gt;-name.
      IF sy-subrc = 0.
        IF &lt;ls_show&gt;-sha1 = ls_result-sha1.
          ro_html-&gt;add( |&lt;td&gt;{
            &lt;ls_show&gt;-path }{ &lt;ls_show&gt;-name }&lt;/td&gt;&lt;td&gt;&lt;b&gt;{
            &lt;ls_show&gt;-sha1(7) }&lt;/b&gt;&lt;/td&gt;| ).
        ELSE.
          ro_html-&gt;add( |&lt;td&gt;{
            &lt;ls_show&gt;-path }{ &lt;ls_show&gt;-name }&lt;/td&gt;&lt;td&gt;{
            &lt;ls_show&gt;-sha1(7) }&lt;/td&gt;| ).
        ENDIF.
      ELSE.
        ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&apos; ).
      ENDIF.
    END-OF-DEFINITION.

    DATA: ls_merge  TYPE zif_abapgit_definitions=&gt;ty_merge,
          lt_files  LIKE ls_merge-stree,
          ls_result LIKE LINE OF ls_merge-result.

    FIELD-SYMBOLS: &lt;ls_show&gt; LIKE LINE OF lt_files,
                   &lt;ls_file&gt; LIKE LINE OF lt_files.

    ls_merge = mo_merge-&gt;get_result( ).

    &quot;If now exists no conflicts anymore, conflicts button should disappear
    ms_control-page_menu = build_menu( mo_merge-&gt;has_conflicts( ) ).

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;toc&quot;&gt;&apos; ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top(
      io_repo         = mo_repo
      iv_show_package = abap_false
      iv_show_branch  = abap_false ) ).

    ro_html-&gt;add( &apos;&lt;table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;Source&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
    ro_html-&gt;add( ls_merge-source-name ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;Target&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
    ro_html-&gt;add( ls_merge-target-name ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;Ancestor&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
    ro_html-&gt;add( ls_merge-common-commit ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    APPEND LINES OF ls_merge-stree TO lt_files.
    APPEND LINES OF ls_merge-ttree TO lt_files.
    APPEND LINES OF ls_merge-ctree TO lt_files.
    SORT lt_files BY path DESCENDING name ASCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_files COMPARING path name.

    ro_html-&gt;add( &apos;&lt;table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;u&gt;Source&lt;/u&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;u&gt;Target&lt;/u&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;u&gt;Ancestor&lt;/u&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;u&gt;Result&lt;/u&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    LOOP AT lt_files ASSIGNING &lt;ls_file&gt;.
      CLEAR ls_result.
      READ TABLE ls_merge-result INTO ls_result
        WITH KEY path = &lt;ls_file&gt;-path name = &lt;ls_file&gt;-name.

      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
      _show_file ls_merge-stree.
      _show_file ls_merge-ttree.
      _show_file ls_merge-ctree.
      _show_file ls_merge-result.
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;b&gt;&apos; ).
    ro_html-&gt;add( ls_merge-conflict ).
    ro_html-&gt;add( &apos;&lt;/b&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    CASE iv_action.
      WHEN c_actions-merge.
        IF mo_merge-&gt;has_conflicts( ) EQ abap_true.
          zcx_abapgit_exception=&gt;raise( &apos;conflicts exists&apos; ).
        ENDIF.

        IF mo_merge-&gt;get_result( )-stage-&gt;count( ) EQ 0.
          zcx_abapgit_exception=&gt;raise( &apos;nothing to merge&apos; ).
        ENDIF.

        IF mo_repo-&gt;get_local_settings( )-code_inspector_check_variant IS NOT INITIAL.

          CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_code_insp
            EXPORTING
              io_repo  = mo_repo
              io_stage = mo_merge-&gt;get_result( )-stage.

        ELSE.

          CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_commit
            EXPORTING
              io_repo  = mo_repo
              io_stage = mo_merge-&gt;get_result( )-stage.

        ENDIF.

        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

      WHEN c_actions-res_conflicts.

        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_merge_res
          EXPORTING
            io_repo       = mo_repo
            io_merge_page = me
            io_merge      = mo_merge.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_MAIN IMPLEMENTATION.
  METHOD build_main_menu.

    DATA: lo_advsub  TYPE REF TO zcl_abapgit_html_toolbar,
          lo_helpsub TYPE REF TO zcl_abapgit_html_toolbar.

    CREATE OBJECT ro_menu.
    CREATE OBJECT lo_advsub.
    CREATE OBJECT lo_helpsub.

    lo_advsub-&gt;add( iv_txt = &apos;Repository overview&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-go_repo_overview ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Database util&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-go_db ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Package to zip&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-zip_package ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Transport to zip&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-zip_transport ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Object to files&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-zip_object ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Test changed by&apos;
                    iv_act = c_actions-changed_by ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Page playground&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-go_playground ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Debug info&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-go_debuginfo ) ##NO_TEXT.
    lo_advsub-&gt;add( iv_txt = &apos;Settings&apos;
                    iv_act = zif_abapgit_definitions=&gt;c_action-go_settings ) ##NO_TEXT.

    lo_helpsub-&gt;add( iv_txt = &apos;Tutorial&apos;
                     iv_act = zif_abapgit_definitions=&gt;c_action-go_tutorial ) ##NO_TEXT.
    lo_helpsub-&gt;add( iv_txt = &apos;Documentation&apos;
                     iv_act = c_actions-documentation ) ##NO_TEXT.

    ro_menu-&gt;add( iv_txt = &apos;+ Online&apos;
                  iv_act = zif_abapgit_definitions=&gt;c_action-repo_newonline ) ##NO_TEXT.
    ro_menu-&gt;add( iv_txt = &apos;+ Offline&apos;
                  iv_act = zif_abapgit_definitions=&gt;c_action-repo_newoffline ) ##NO_TEXT.
    ro_menu-&gt;add( iv_txt = &apos;Explore&apos;
                  iv_act = zif_abapgit_definitions=&gt;c_action-go_explore ) ##NO_TEXT.

    ro_menu-&gt;add( iv_txt = &apos;Advanced&apos;
                  io_sub = lo_advsub ) ##NO_TEXT.
    ro_menu-&gt;add( iv_txt = &apos;Help&apos;
                  io_sub = lo_helpsub ) ##NO_TEXT.

  ENDMETHOD.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;HOME&apos;.
    ms_control-page_menu  = build_main_menu( ).
  ENDMETHOD.
  METHOD render_content.

    DATA: lt_repos    TYPE zif_abapgit_definitions=&gt;ty_repo_ref_tt,
          lx_error    TYPE REF TO zcx_abapgit_exception,
          lo_tutorial TYPE REF TO zcl_abapgit_gui_view_tutorial,
          lo_repo     LIKE LINE OF lt_repos.

    retrieve_active_repo( ). &quot; Get and validate key of user default repo

    CREATE OBJECT ro_html.

    TRY.
        lt_repos = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;list( ).
      CATCH zcx_abapgit_exception INTO lx_error.
        ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_error( ix_error = lx_error ) ).
        RETURN.
    ENDTRY.

    ro_html-&gt;add( render_toc( lt_repos ) ).

    IF mv_show IS INITIAL OR lines( lt_repos ) = 0.
      CREATE OBJECT lo_tutorial.
      ro_html-&gt;add( lo_tutorial-&gt;render( ) ).
    ELSE.
      lo_repo = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mv_show ).
      ro_html-&gt;add( render_repo( lo_repo ) ).
    ENDIF.

  ENDMETHOD.
  METHOD render_repo.

    DATA lo_news TYPE REF TO zcl_abapgit_news.

    CREATE OBJECT ro_html.

    lo_news = zcl_abapgit_news=&gt;create( io_repo ).

    ro_html-&gt;add( |&lt;div class=&quot;repo&quot; id=&quot;repo{ io_repo-&gt;get_key( ) }&quot;&gt;| ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top(
      io_repo               = io_repo
      io_news               = lo_news
      iv_interactive_branch = abap_true ) ).

    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_news( io_news = lo_news ) ).

    ro_html-&gt;add( mo_repo_content-&gt;render( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_toc.

    DATA: lo_pback      TYPE REF TO zcl_abapgit_persist_background,
          lv_current    TYPE abap_bool,
          lv_key        TYPE zif_abapgit_persistence=&gt;ty_repo-key,
          lv_icon       TYPE string,
          lo_repo       LIKE LINE OF it_repo_list,
          lo_favbar     TYPE REF TO zcl_abapgit_html_toolbar,
          lo_allbar     TYPE REF TO zcl_abapgit_html_toolbar,
          lt_favorites  TYPE zcl_abapgit_persistence_user=&gt;tt_favorites,
          lv_repo_title TYPE string.
    CREATE OBJECT ro_html.
    CREATE OBJECT lo_favbar.
    CREATE OBJECT lo_allbar.
    CREATE OBJECT lo_pback.

    lt_favorites = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_favorites( ).

    LOOP AT it_repo_list INTO lo_repo.
      lv_key     = lo_repo-&gt;get_key( ).
      lv_current = abap_false.
      IF lv_key = mv_show.
        lv_current = abap_true.
      ENDIF.

      lv_repo_title = lo_repo-&gt;get_name( ).
      IF lo_pback-&gt;exists( lv_key ) = abap_true.
        lv_repo_title = lv_repo_title &amp;&amp; &apos;&lt;sup&gt;bg&lt;/sup&gt;&apos;. &quot; Background marker
      ENDIF.

      READ TABLE lt_favorites TRANSPORTING NO FIELDS
        WITH KEY table_line = lv_key.

      IF sy-subrc = 0.
        DELETE lt_favorites INDEX sy-tabix. &quot; for later cleanup
        lo_favbar-&gt;add( iv_txt = lv_repo_title
                        iv_act = |{ c_actions-show }?{ lv_key }|
                        iv_cur = lv_current ).
      ENDIF.

      IF lo_repo-&gt;is_offline( ) = abap_true.
        lv_icon = &apos;plug/darkgrey&apos;.
      ELSE.
        lv_icon = &apos;cloud-upload/blue&apos;.
      ENDIF.

      lo_allbar-&gt;add( iv_txt = lv_repo_title
                      iv_act = |{ c_actions-show }?{ lv_key }|
                      iv_ico = lv_icon
                      iv_cur = lv_current ).
    ENDLOOP.

    &quot; Cleanup orphan favorites (for removed repos)
    LOOP AT lt_favorites INTO lv_key.
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;toggle_favorite( lv_key ).
    ENDLOOP.

    &quot; Render HTML
    ro_html-&gt;add( &apos;&lt;div id=&quot;toc&quot;&gt;&apos; )          ##NO_TEXT. &quot; TODO refactor html &amp; css
    ro_html-&gt;add( &apos;&lt;div class=&quot;toc_grid&quot;&gt;&apos; )  ##NO_TEXT.
    ro_html-&gt;add( &apos;&lt;div class=&quot;toc_row&quot;&gt;&apos; )   ##NO_TEXT.

**********************************************************************

    ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( |&lt;td class=&quot;pad-sides&quot;&gt;{
                  zcl_abapgit_html=&gt;icon( iv_name = &apos;star/blue&apos; iv_hint = &apos;Favorites&apos; )
                  }&lt;/td&gt;| ).

    ro_html-&gt;add( &apos;&lt;td class=&quot;pad-sides w100 favorites&quot;&gt;&apos; ). &quot; Maximize width
    IF lo_favbar-&gt;count( ) &gt; 0.
      ro_html-&gt;add( lo_favbar-&gt;render( iv_sort = abap_true ) ).
    ELSE.
      ro_html-&gt;add( |&lt;span class=&quot;grey&quot;&gt;No favorites so far. For more info please check {
                    zcl_abapgit_html=&gt;a( iv_txt = &apos;tutorial&apos; iv_act = zif_abapgit_definitions=&gt;c_action-go_tutorial )
                    }&lt;/span&gt;| ).
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
    ro_html-&gt;add( lo_allbar-&gt;render_as_droplist(
      iv_label  = zcl_abapgit_html=&gt;icon( iv_name = &apos;three-bars/blue&apos; )
      iv_action = c_actions-overview
      iv_right  = abap_true
      iv_sort   = abap_true ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/table&gt;&apos; ).

**********************************************************************

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD retrieve_active_repo.

    DATA: lv_show_old LIKE mv_show.

    TRY.
        zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;list( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    lv_show_old = mv_show.
    mv_show     = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_repo_show( ). &quot; Get default repo from user cfg

    IF mv_show IS NOT INITIAL.
      TRY. &quot; verify the key exists
          zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mv_show ).
        CATCH zcx_abapgit_exception.
          CLEAR mv_show.
          zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( mv_show ).
      ENDTRY.
    ENDIF.

    IF lv_show_old &lt;&gt; mv_show AND NOT mv_show IS INITIAL.
      CREATE OBJECT mo_repo_content
        EXPORTING
          iv_key = mv_show. &quot; Reinit content state
    ENDIF.

  ENDMETHOD.
  METHOD test_changed_by.

    DATA: ls_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir,
          lv_user  TYPE xubname,
          ls_item  TYPE zif_abapgit_definitions=&gt;ty_item.
    ls_tadir = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_object( ).
    IF ls_tadir IS INITIAL.
      RETURN.
    ENDIF.

    ls_item-obj_type = ls_tadir-object.
    ls_item-obj_name = ls_tadir-obj_name.

    lv_user = zcl_abapgit_objects=&gt;changed_by( ls_item ).

    MESSAGE lv_user TYPE &apos;S&apos;.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

    DATA: ls_hotkey_action TYPE zif_abapgit_gui_page_hotkey=&gt;ty_hotkey_action.

    ls_hotkey_action-name           = |abapGit settings|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-go_settings.
    ls_hotkey_action-default_hotkey = |x|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Stage changes|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-go_stage.
    ls_hotkey_action-default_hotkey = |s|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Switch branch|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-git_branch_switch.
    ls_hotkey_action-default_hotkey = |b|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Installed repo list|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-go_repo_overview.
    ls_hotkey_action-default_hotkey = |o|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Refresh repository|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-repo_refresh.
    ls_hotkey_action-default_hotkey = |r|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Pull|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-git_pull.
    ls_hotkey_action-default_hotkey = |p|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Add online repository|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-repo_newonline.
    ls_hotkey_action-default_hotkey = |n|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Uninstall repository|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-repo_purge.
    ls_hotkey_action-default_hotkey = |u|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Show diffs|.
    ls_hotkey_action-action         = zif_abapgit_definitions=&gt;c_action-go_diff.
    ls_hotkey_action-default_hotkey = |d|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lv_key           TYPE zif_abapgit_persistence=&gt;ty_repo-key,
          li_repo_overview TYPE REF TO zif_abapgit_gui_page.
    IF NOT mo_repo_content IS INITIAL.
      mo_repo_content-&gt;zif_abapgit_gui_page~on_event(
        EXPORTING
          iv_action    = iv_action
          iv_prev_page = iv_prev_page
          iv_getdata   = iv_getdata
          it_postdata  = it_postdata
        IMPORTING
          ei_page      = ei_page
          ev_state     = ev_state ).

      IF ev_state &lt;&gt; zif_abapgit_definitions=&gt;c_event_state-not_handled.
        RETURN.
      ENDIF.
    ENDIF.

    lv_key = iv_getdata.

    CASE iv_action.
      WHEN c_actions-show.
        zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_show( lv_key ).
        TRY.
            zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( lv_key )-&gt;refresh( ).
          CATCH zcx_abapgit_exception ##NO_HANDLER.
        ENDTRY.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-changed_by.
        test_changed_by( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN c_actions-documentation.
        zcl_abapgit_services_abapgit=&gt;open_abapgit_wikipage( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.
      WHEN c_actions-overview.
        CREATE OBJECT li_repo_overview TYPE zcl_abapgit_gui_page_repo_over.
        ei_page = li_repo_overview.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
      WHEN OTHERS.
        super-&gt;zif_abapgit_gui_page~on_event(
          EXPORTING
            iv_action    = iv_action
            iv_prev_page = iv_prev_page
            iv_getdata   = iv_getdata
            it_postdata  = it_postdata
          IMPORTING
            ei_page      = ei_page
            ev_state     = ev_state  ).
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_EXPLORE IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-redirect_url = c_explore_url.
  ENDMETHOD.
  METHOD render_content.
    ASSERT 1 = 1. &quot; Dummy
  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_DIFF IMPLEMENTATION.
  METHOD add_to_stage.

    DATA: lo_repo              TYPE REF TO zcl_abapgit_repo_online,
          lt_diff              TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
          lv_something_patched TYPE abap_bool,
          lv_patch             TYPE xstring,
          lo_git_add_patch     TYPE REF TO zcl_abapgit_git_add_patch.

    FIELD-SYMBOLS: &lt;ls_diff_file&gt; TYPE zcl_abapgit_gui_page_diff=&gt;ty_file_diff.

    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mv_repo_key ).

    LOOP AT mt_diff_files ASSIGNING &lt;ls_diff_file&gt;.

      lt_diff = &lt;ls_diff_file&gt;-o_diff-&gt;get( ).

      READ TABLE lt_diff TRANSPORTING NO FIELDS
                         WITH KEY patch_flag = abap_true.
      CHECK sy-subrc = 0.

      lv_something_patched = abap_true.

      CREATE OBJECT lo_git_add_patch
        EXPORTING
          it_diff = &lt;ls_diff_file&gt;-o_diff-&gt;get( ).

      lv_patch = lo_git_add_patch-&gt;get_patch_binary( ).

      mo_stage-&gt;add(
          iv_path     = &lt;ls_diff_file&gt;-path
          iv_filename = &lt;ls_diff_file&gt;-filename
          iv_data     = lv_patch ).

    ENDLOOP.

    IF lv_something_patched = abap_false.
      zcx_abapgit_exception=&gt;raise( |Nothing added| ).
    ENDIF.

  ENDMETHOD.
  METHOD append_diff.

    DATA:
      lv_offs    TYPE i,
      ls_r_dummy LIKE LINE OF it_remote ##NEEDED,
      ls_l_dummy LIKE LINE OF it_local  ##NEEDED.

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF it_remote,
                   &lt;ls_local&gt;  LIKE LINE OF it_local,
                   &lt;ls_diff&gt;   LIKE LINE OF mt_diff_files.
    READ TABLE it_remote ASSIGNING &lt;ls_remote&gt;
      WITH KEY filename = is_status-filename
               path     = is_status-path.
    IF sy-subrc &lt;&gt; 0.
      ASSIGN ls_r_dummy TO &lt;ls_remote&gt;.
    ENDIF.

    READ TABLE it_local ASSIGNING &lt;ls_local&gt;
      WITH KEY file-filename = is_status-filename
               file-path     = is_status-path.
    IF sy-subrc &lt;&gt; 0.
      ASSIGN ls_l_dummy TO &lt;ls_local&gt;.
    ENDIF.

    IF &lt;ls_local&gt; IS INITIAL AND &lt;ls_remote&gt; IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |DIFF: file not found { is_status-filename }| ).
    ENDIF.

    APPEND INITIAL LINE TO mt_diff_files ASSIGNING &lt;ls_diff&gt;.
    &lt;ls_diff&gt;-path     = is_status-path.
    &lt;ls_diff&gt;-filename = is_status-filename.
    &lt;ls_diff&gt;-lstate   = is_status-lstate.
    &lt;ls_diff&gt;-rstate   = is_status-rstate.

    IF &lt;ls_diff&gt;-lstate IS NOT INITIAL AND &lt;ls_diff&gt;-rstate IS NOT INITIAL.
      &lt;ls_diff&gt;-fstate = c_fstate-both.
    ELSEIF &lt;ls_diff&gt;-lstate IS NOT INITIAL.
      &lt;ls_diff&gt;-fstate = c_fstate-local.
    ELSE. &quot;rstate IS NOT INITIAL, lstate = empty.
      &lt;ls_diff&gt;-fstate = c_fstate-remote.
    ENDIF.

    &quot; Changed by
    IF &lt;ls_local&gt;-item-obj_type IS NOT INITIAL.
      &lt;ls_diff&gt;-changed_by = to_lower( zcl_abapgit_objects=&gt;changed_by( &lt;ls_local&gt;-item ) ).
    ENDIF.

    &quot; Extension
    IF &lt;ls_local&gt;-file-filename IS NOT INITIAL.
      &lt;ls_diff&gt;-type = reverse( &lt;ls_local&gt;-file-filename ).
    ELSE.
      &lt;ls_diff&gt;-type = reverse( &lt;ls_remote&gt;-filename ).
    ENDIF.

    FIND FIRST OCCURRENCE OF &apos;.&apos; IN &lt;ls_diff&gt;-type MATCH OFFSET lv_offs.
    &lt;ls_diff&gt;-type = reverse( substring( val = &lt;ls_diff&gt;-type len = lv_offs ) ).
    IF &lt;ls_diff&gt;-type &lt;&gt; &apos;xml&apos; AND &lt;ls_diff&gt;-type &lt;&gt; &apos;abap&apos;.
      &lt;ls_diff&gt;-type = &apos;other&apos;.
    ENDIF.

    IF &lt;ls_diff&gt;-type = &apos;other&apos;
       AND is_binary( iv_d1 = &lt;ls_remote&gt;-data iv_d2 = &lt;ls_local&gt;-file-data ) = abap_true.
      &lt;ls_diff&gt;-type = &apos;binary&apos;.
    ENDIF.

    &quot; Diff data
    IF &lt;ls_diff&gt;-type &lt;&gt; &apos;binary&apos;.
      IF &lt;ls_diff&gt;-fstate = c_fstate-remote. &quot; Remote file leading changes
        CREATE OBJECT &lt;ls_diff&gt;-o_diff
          EXPORTING
            iv_new = &lt;ls_remote&gt;-data
            iv_old = &lt;ls_local&gt;-file-data.
      ELSE.             &quot; Local leading changes or both were modified
        CREATE OBJECT &lt;ls_diff&gt;-o_diff
          EXPORTING
            iv_new = &lt;ls_local&gt;-file-data
            iv_old = &lt;ls_remote&gt;-data.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD apply_patch_all.

    DATA: lv_filename   TYPE string,
          lt_patch      TYPE string_table,
          lv_line_index TYPE string.

    FIELD-SYMBOLS: &lt;lv_patch&gt;     TYPE LINE OF string_table.

    SPLIT iv_patch AT &apos;,&apos; INTO TABLE lt_patch.

    LOOP AT lt_patch ASSIGNING &lt;lv_patch&gt;.

      get_patch_data(
        EXPORTING
          iv_patch      = &lt;lv_patch&gt;
          iv_action     = iv_action
        IMPORTING
          ev_filename   = lv_filename
          ev_line_index = lv_line_index ).

      apply_patch_for( iv_filename   = lv_filename
                       iv_line_index = lv_line_index
                       iv_patch_flag = iv_patch_flag ).

    ENDLOOP.

  ENDMETHOD.
  METHOD apply_patch_for.

    DATA: lo_diff      TYPE REF TO zcl_abapgit_diff,
          ls_diff_line TYPE zif_abapgit_definitions=&gt;ty_diff,
          lv_line      TYPE i.

    lo_diff = get_diff_object( iv_filename ).

    ls_diff_line = get_diff_line( io_diff       = lo_diff
                                  iv_line_index = iv_line_index ).

    CASE ls_diff_line-result.
      WHEN zif_abapgit_definitions=&gt;c_diff-update
        OR zif_abapgit_definitions=&gt;c_diff-insert.

        lv_line = ls_diff_line-new_num.

        lo_diff-&gt;set_patch_new( iv_line_new   = lv_line
                                iv_patch_flag = iv_patch_flag ).

      WHEN zif_abapgit_definitions=&gt;c_diff-delete.

        lv_line =  ls_diff_line-old_num.

        lo_diff-&gt;set_patch_old( iv_line_old   = lv_line
                                iv_patch_flag = iv_patch_flag ).

    ENDCASE.

  ENDMETHOD.
  METHOD build_menu.

    DATA: lo_sub   TYPE REF TO zcl_abapgit_html_toolbar,
          lt_types TYPE string_table,
          lt_users TYPE string_table.

    FIELD-SYMBOLS: &lt;ls_diff&gt; LIKE LINE OF mt_diff_files,
                   &lt;lv_i&gt;    TYPE string.

    &quot; Get unique
    LOOP AT mt_diff_files ASSIGNING &lt;ls_diff&gt;.
      APPEND &lt;ls_diff&gt;-type TO lt_types.
      APPEND &lt;ls_diff&gt;-changed_by TO lt_users.
    ENDLOOP.

    SORT: lt_types, lt_users.
    DELETE ADJACENT DUPLICATES FROM: lt_types, lt_users.

    CREATE OBJECT ro_menu.

    IF lines( lt_types ) &gt; 1 OR lines( lt_users ) &gt; 1.
      CREATE OBJECT lo_sub EXPORTING iv_id = &apos;diff-filter&apos;.

      &quot; File types
      IF lines( lt_types ) &gt; 1.
        lo_sub-&gt;add( iv_txt = &apos;TYPE&apos; iv_typ = zif_abapgit_definitions=&gt;c_action_type-separator ).
        LOOP AT lt_types ASSIGNING &lt;lv_i&gt;.
          lo_sub-&gt;add( iv_txt = &lt;lv_i&gt;
                       iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                       iv_aux = &apos;type&apos;
                       iv_chk = abap_true ).
        ENDLOOP.
      ENDIF.

      &quot; Changed by
      IF lines( lt_users ) &gt; 1.
        lo_sub-&gt;add( iv_txt = &apos;CHANGED BY&apos; iv_typ = zif_abapgit_definitions=&gt;c_action_type-separator ).
        LOOP AT lt_users ASSIGNING &lt;lv_i&gt;.
          lo_sub-&gt;add( iv_txt = &lt;lv_i&gt;
                       iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                       iv_aux = &apos;changed-by&apos;
                       iv_chk = abap_true ).
        ENDLOOP.
      ENDIF.

      ro_menu-&gt;add( iv_txt = &apos;Filter&apos;
                    io_sub = lo_sub ) ##NO_TEXT.
    ENDIF.

    IF mv_patch_mode = abap_true.
      ro_menu-&gt;add( iv_txt = &apos;Stage&apos;
                    iv_act = c_actions-stage
                    iv_id  = &apos;stage&apos;
                    iv_typ = zif_abapgit_definitions=&gt;c_action_type-dummy
                     ) ##NO_TEXT.
    ENDIF.

    ro_menu-&gt;add( iv_txt = &apos;Split/Unified view&apos;
                  iv_act = c_actions-toggle_unified ) ##NO_TEXT.

  ENDMETHOD.
  METHOD constructor.

    DATA: lt_remote TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lt_local  TYPE zif_abapgit_definitions=&gt;ty_files_item_tt,
          lt_status TYPE zif_abapgit_definitions=&gt;ty_results_tt,
          lo_repo   TYPE REF TO zcl_abapgit_repo,
          lv_ts     TYPE timestamp.

    FIELD-SYMBOLS: &lt;ls_status&gt; LIKE LINE OF lt_status.

    super-&gt;constructor( ).
    ms_control-page_title = &apos;DIFF&apos;.
    mv_unified            = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_diff_unified( ).
    mv_repo_key           = iv_key.
    mv_patch_mode         = iv_patch_mode.
    mo_stage              = io_stage.

    IF mv_patch_mode = abap_true.
      &quot; While patching we always want to be in split mode
      CLEAR: mv_unified.
    ENDIF.

    GET TIME STAMP FIELD lv_ts.
    mv_seed = |diff{ lv_ts }|. &quot; Generate based on time

    ASSERT is_file IS INITIAL OR is_object IS INITIAL. &quot; just one passed

    lo_repo   = zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( iv_key ).
    lt_remote = lo_repo-&gt;get_files_remote( ).
    lt_local  = lo_repo-&gt;get_files_local( ).
    lt_status = lo_repo-&gt;status( ).

    IF is_file IS NOT INITIAL.        &quot; Diff for one file

      READ TABLE lt_status ASSIGNING &lt;ls_status&gt;
        WITH KEY path = is_file-path filename = is_file-filename.

      append_diff( it_remote = lt_remote
                   it_local  = lt_local
                   is_status = &lt;ls_status&gt; ).

    ELSEIF is_object IS NOT INITIAL.  &quot; Diff for whole object

      LOOP AT lt_status ASSIGNING &lt;ls_status&gt;
          WHERE obj_type = is_object-obj_type
          AND   obj_name = is_object-obj_name
          AND   match IS INITIAL.
        append_diff( it_remote = lt_remote
                     it_local  = lt_local
                     is_status = &lt;ls_status&gt; ).
      ENDLOOP.

    ELSE.                             &quot; Diff for the whole repo

      LOOP AT lt_status ASSIGNING &lt;ls_status&gt; WHERE match IS INITIAL.
        append_diff( it_remote = lt_remote
                     it_local  = lt_local
                     is_status = &lt;ls_status&gt; ).
      ENDLOOP.

    ENDIF.

    IF lines( mt_diff_files ) = 0.
      zcx_abapgit_exception=&gt;raise( &apos;PAGE_DIFF ERROR: No diff files found&apos; ).
    ENDIF.

    ms_control-page_menu  = build_menu( ).

  ENDMETHOD.
  METHOD get_diff_line.

    DATA: lt_diff       TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
          lv_line_index TYPE sytabix.
    lv_line_index = iv_line_index.
    lt_diff = io_diff-&gt;get( ).

    READ TABLE lt_diff INTO rs_diff
                       INDEX lv_line_index.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Invalid line index { lv_line_index }| ).
    ENDIF.

  ENDMETHOD.
  METHOD get_diff_object.

    FIELD-SYMBOLS: &lt;ls_diff_file&gt; LIKE LINE OF mt_diff_files.

    READ TABLE mt_diff_files ASSIGNING &lt;ls_diff_file&gt;
                             WITH KEY filename = iv_filename.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Invalid filename { iv_filename }| ).
    ENDIF.

    ro_diff = &lt;ls_diff_file&gt;-o_diff.

  ENDMETHOD.
  METHOD get_patch_data.

    CLEAR: ev_filename, ev_line_index.

    IF iv_action &lt;&gt; c_patch_action-add AND iv_action &lt;&gt; c_patch_action-remove.
      zcx_abapgit_exception=&gt;raise( |Invalid action { iv_action }| ).
    ENDIF.

    FIND FIRST OCCURRENCE OF REGEX iv_action &amp;&amp; `_patch_(.*)_(\d+)`
         IN iv_patch
         SUBMATCHES ev_filename ev_line_index.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Invalid patch| ).
    ENDIF.

  ENDMETHOD.
  METHOD is_binary.

    DATA: lv_len TYPE i,
          lv_idx TYPE i,
          lv_x   TYPE x.

    FIELD-SYMBOLS &lt;lv_data&gt; LIKE iv_d1.
    IF iv_d1 IS NOT INITIAL. &quot; One of them might be new and so empty
      ASSIGN iv_d1 TO &lt;lv_data&gt;.
    ELSE.
      ASSIGN iv_d2 TO &lt;lv_data&gt;.
    ENDIF.

    lv_len = xstrlen( &lt;lv_data&gt; ).
    IF lv_len = 0.
      RETURN.
    ENDIF.

    IF lv_len &gt; 100.
      lv_len = 100.
    ENDIF.

    &quot; Simple char range test
    &quot; stackoverflow.com/questions/277521/how-to-identify-the-file-content-as-ascii-or-binary
    DO lv_len TIMES. &quot; I&apos;m sure there is more efficient way ...
      lv_idx = sy-index - 1.
      lv_x = &lt;lv_data&gt;+lv_idx(1).

      IF NOT ( lv_x BETWEEN 9 AND 13 OR lv_x BETWEEN 32 AND 126 ).
        rv_yes = abap_true.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.
  METHOD render_beacon.

    DATA: lv_beacon  TYPE string.

    CREATE OBJECT ro_html.

    IF is_diff_line-beacon &gt; 0.
      READ TABLE is_diff-o_diff-&gt;mt_beacons INTO lv_beacon INDEX is_diff_line-beacon.
    ELSE.
      lv_beacon = &apos;---&apos;.
    ENDIF.
    ro_html-&gt;add( &apos;&lt;thead class=&quot;nav_line&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).
    IF mv_unified = abap_true.
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).
      ro_html-&gt;add( |&lt;th&gt;@@ { is_diff_line-new_num } @@ { lv_beacon }&lt;/th&gt;| ).
    ELSE.
      ro_html-&gt;add( |&lt;th colspan=&quot;3&quot;&gt;@@ { is_diff_line-new_num } @@ { lv_beacon }&lt;/th&gt;| ).
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).

  ENDMETHOD.
  METHOD render_content.

    DATA: ls_diff_file LIKE LINE OF mt_diff_files,
          lo_progress  TYPE REF TO zcl_abapgit_progress.
    CREATE OBJECT ro_html.

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( mt_diff_files ).

    ro_html-&gt;add( |&lt;div id=&quot;diff-list&quot; data-repo-key=&quot;{ mv_repo_key }&quot;&gt;| ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_js_error_banner( ) ).
    LOOP AT mt_diff_files INTO ls_diff_file.
      lo_progress-&gt;show(
        iv_current = sy-tabix
        iv_text    = |Render Diff - { ls_diff_file-filename }| ).

      ro_html-&gt;add( render_diff( ls_diff_file ) ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_diff.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;div class=&quot;diff&quot; data-type=&quot;{ is_diff-type
      }&quot; data-changed-by=&quot;{ is_diff-changed_by
      }&quot; data-file=&quot;{ is_diff-path &amp;&amp; is_diff-filename }&quot;&gt;| ). &quot;#EC NOTEXT
    ro_html-&gt;add( render_diff_head( is_diff ) ).

    &quot; Content
    IF is_diff-type &lt;&gt; &apos;binary&apos;.
      ro_html-&gt;add( &apos;&lt;div class=&quot;diff_content&quot;&gt;&apos; ).         &quot;#EC NOTEXT
      ro_html-&gt;add( |&lt;table class=&quot;diff_tab syntax-hl&quot; id={ is_diff-filename }&gt;| ). &quot;#EC NOTEXT
      ro_html-&gt;add( render_table_head( is_diff ) ).
      ro_html-&gt;add( render_lines( is_diff ) ).
      ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).                           &quot;#EC NOTEXT
    ELSE.
      ro_html-&gt;add( &apos;&lt;div class=&quot;diff_content paddings center grey&quot;&gt;&apos; ). &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;The content seems to be binary.&apos; ).    &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;Cannot display as diff.&apos; ).            &quot;#EC NOTEXT
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_diff_head.

    DATA: ls_stats TYPE zif_abapgit_definitions=&gt;ty_count.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;diff_head&quot;&gt;&apos; ).              &quot;#EC NOTEXT

    IF is_diff-type &lt;&gt; &apos;binary&apos;.
      ls_stats = is_diff-o_diff-&gt;stats( ).
      IF is_diff-fstate = c_fstate-both. &quot; Merge stats into &apos;update&apos; if both were changed
        ls_stats-update = ls_stats-update + ls_stats-insert + ls_stats-delete.
        CLEAR: ls_stats-insert, ls_stats-delete.
      ENDIF.

      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_ins&quot;&gt;+ { ls_stats-insert }&lt;/span&gt;| ).
      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_del&quot;&gt;- { ls_stats-delete }&lt;/span&gt;| ).
      ro_html-&gt;add( |&lt;span class=&quot;diff_banner diff_upd&quot;&gt;~ { ls_stats-update }&lt;/span&gt;| ).
    ENDIF.

    ro_html-&gt;add( |&lt;span class=&quot;diff_name&quot;&gt;{ is_diff-path }{ is_diff-filename }&lt;/span&gt;| ). &quot;#EC NOTEXT
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_item_state(
      iv_lstate = is_diff-lstate
      iv_rstate = is_diff-rstate ) ).

    IF is_diff-fstate = c_fstate-both AND mv_unified = abap_true.
      ro_html-&gt;add( &apos;&lt;span class=&quot;attention pad-sides&quot;&gt;Attention: Unified mode&apos;
                 &amp;&amp; &apos; highlighting for MM assumes local file is newer ! &lt;/span&gt;&apos; ). &quot;#EC NOTEXT
    ENDIF.

    ro_html-&gt;add( |&lt;span class=&quot;diff_changed_by&quot;&gt;last change by: &lt;span class=&quot;user&quot;&gt;{
      is_diff-changed_by }&lt;/span&gt;&lt;/span&gt;| ).

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_lines.

    DATA: lo_highlighter TYPE REF TO zcl_abapgit_syntax_highlighter,
          lt_diffs       TYPE zif_abapgit_definitions=&gt;ty_diffs_tt,
          lv_insert_nav  TYPE abap_bool,
          lv_tabix       TYPE syst-tabix.

    FIELD-SYMBOLS &lt;ls_diff&gt;  LIKE LINE OF lt_diffs.

    lo_highlighter = zcl_abapgit_syntax_highlighter=&gt;create( is_diff-filename ).
    CREATE OBJECT ro_html.

    lt_diffs = is_diff-o_diff-&gt;get( ).

    LOOP AT lt_diffs ASSIGNING &lt;ls_diff&gt;.

      lv_tabix = sy-tabix.

      IF &lt;ls_diff&gt;-short = abap_false.
        lv_insert_nav = abap_true.
        CONTINUE.
      ENDIF.

      IF lv_insert_nav = abap_true. &quot; Insert separator line with navigation
        ro_html-&gt;add( render_beacon( is_diff_line = &lt;ls_diff&gt; is_diff = is_diff ) ).
        lv_insert_nav = abap_false.
      ENDIF.

      IF lo_highlighter IS BOUND.
        &lt;ls_diff&gt;-new = lo_highlighter-&gt;process_line( &lt;ls_diff&gt;-new ).
        &lt;ls_diff&gt;-old = lo_highlighter-&gt;process_line( &lt;ls_diff&gt;-old ).
      ELSE.
        &lt;ls_diff&gt;-new = escape( val = &lt;ls_diff&gt;-new format = cl_abap_format=&gt;e_html_attr ).
        &lt;ls_diff&gt;-old = escape( val = &lt;ls_diff&gt;-old format = cl_abap_format=&gt;e_html_attr ).
      ENDIF.

      CONDENSE &lt;ls_diff&gt;-new_num. &quot;get rid of leading spaces
      CONDENSE &lt;ls_diff&gt;-old_num.

      IF mv_unified = abap_true.
        ro_html-&gt;add( render_line_unified( is_diff_line = &lt;ls_diff&gt; ) ).
      ELSE.
        ro_html-&gt;add( render_line_split( is_diff_line = &lt;ls_diff&gt;
                                         iv_filename  = is_diff-filename
                                         iv_fstate    = is_diff-fstate
                                         iv_index     = lv_tabix ) ).
      ENDIF.

    ENDLOOP.

    IF mv_unified = abap_true.
      ro_html-&gt;add( render_line_unified( ) ). &quot; Release delayed lines
    ENDIF.

  ENDMETHOD.
  METHOD render_line_split.

    DATA: lv_new                 TYPE string,
          lv_old                 TYPE string,
          lv_mark                TYPE string,
          lv_bg                  TYPE string,
          lv_patch_line_possible TYPE abap_bool.

    CREATE OBJECT ro_html.

    &quot; New line
    lv_mark = ` `.
    IF is_diff_line-result IS NOT INITIAL.
      IF iv_fstate = c_fstate-both OR is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-update.
        lv_bg = &apos; diff_upd&apos;.
        lv_mark = `~`.
      ELSEIF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-insert.
        lv_bg = &apos; diff_ins&apos;.
        lv_mark = `+`.
      ENDIF.
    ENDIF.
    lv_new = |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-new_num }&quot;&gt;&lt;/td&gt;|
          &amp;&amp; |&lt;td class=&quot;code{ lv_bg }&quot;&gt;{ lv_mark }{ is_diff_line-new }&lt;/td&gt;|.

    IF lv_mark &lt;&gt; ` `.
      lv_patch_line_possible = abap_true.
    ENDIF.

    &quot; Old line
    CLEAR lv_bg.
    lv_mark = ` `.
    IF is_diff_line-result IS NOT INITIAL.
      IF iv_fstate = c_fstate-both OR is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-update.
        lv_bg = &apos; diff_upd&apos;.
        lv_mark = `~`.
      ELSEIF is_diff_line-result = zif_abapgit_definitions=&gt;c_diff-delete.
        lv_bg = &apos; diff_del&apos;.
        lv_mark = `-`.
      ENDIF.
    ENDIF.
    lv_old = |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-old_num }&quot;&gt;&lt;/td&gt;|
          &amp;&amp; |&lt;td class=&quot;code{ lv_bg }&quot;&gt;{ lv_mark }{ is_diff_line-old }&lt;/td&gt;|.

    IF lv_mark &lt;&gt; ` `.
      lv_patch_line_possible = abap_true.
    ENDIF.

    &quot; render line, inverse sides if remote is newer
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                                 &quot;#EC NOTEXT

    IF mv_patch_mode = abap_true.

      render_patch( io_html                = ro_html
                    iv_patch_line_possible = lv_patch_line_possible
                    iv_filename            = iv_filename
                    is_diff_line           = is_diff_line
                    iv_index               = iv_index ).

    ENDIF.

    IF iv_fstate = c_fstate-remote. &quot; Remote file leading changes
      ro_html-&gt;add( lv_old ). &quot; local
      ro_html-&gt;add( lv_new ). &quot; remote
    ELSE.             &quot; Local leading changes or both were modified
      ro_html-&gt;add( lv_new ). &quot; local
      ro_html-&gt;add( lv_old ). &quot; remote
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                                &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_line_unified.

    FIELD-SYMBOLS &lt;ls_diff_line&gt; LIKE LINE OF mt_delayed_lines.

    CREATE OBJECT ro_html.

    &quot; Release delayed subsequent update lines
    IF is_diff_line-result &lt;&gt; zif_abapgit_definitions=&gt;c_diff-update.
      LOOP AT mt_delayed_lines ASSIGNING &lt;ls_diff_line&gt;.
        ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                             &quot;#EC NOTEXT
        ro_html-&gt;add( |&lt;td class=&quot;num&quot; line-num=&quot;{ &lt;ls_diff_line&gt;-old_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;num&quot; line-num=&quot;&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;code diff_del&quot;&gt;-{ &lt;ls_diff_line&gt;-old }&lt;/td&gt;| ).
        ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                            &quot;#EC NOTEXT
      ENDLOOP.
      LOOP AT mt_delayed_lines ASSIGNING &lt;ls_diff_line&gt;.
        ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                             &quot;#EC NOTEXT
        ro_html-&gt;add( |&lt;td class=&quot;num&quot; line-num=&quot;&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;num&quot; line-num=&quot;{ &lt;ls_diff_line&gt;-new_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;code diff_ins&quot;&gt;+{ &lt;ls_diff_line&gt;-new }&lt;/td&gt;| ).
        ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                            &quot;#EC NOTEXT
      ENDLOOP.
      CLEAR mt_delayed_lines.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                                 &quot;#EC NOTEXT
    CASE is_diff_line-result.
      WHEN zif_abapgit_definitions=&gt;c_diff-update.
        APPEND is_diff_line TO mt_delayed_lines. &quot; Delay output of subsequent updates
      WHEN zif_abapgit_definitions=&gt;c_diff-insert.
        ro_html-&gt;add( |&lt;td class=&quot;num&quot; line-num=&quot;&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-new_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;code diff_ins&quot;&gt;+{ is_diff_line-new }&lt;/td&gt;| ).
      WHEN zif_abapgit_definitions=&gt;c_diff-delete.
        ro_html-&gt;add( |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-old_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;num&quot; line-num=&quot;&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;code diff_del&quot;&gt;-{ is_diff_line-old }&lt;/td&gt;| ).
      WHEN OTHERS. &quot;none
        ro_html-&gt;add( |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-old_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;num&quot; line-num=&quot;{ is_diff_line-new_num }&quot;&gt;&lt;/td&gt;|
                   &amp;&amp; |&lt;td class=&quot;code&quot;&gt; { is_diff_line-old }&lt;/td&gt;| ).
    ENDCASE.
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                                &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_patch.

    CONSTANTS:
      BEGIN OF c_css_class,
        patch_active TYPE string VALUE `patch-active` ##NO_TEXT,
        patch        TYPE string VALUE `patch` ##NO_TEXT,
      END OF c_css_class.

    DATA: lv_id          TYPE string,
          lv_left_class  TYPE string,
          lv_right_class TYPE string,
          lv_object      TYPE string.

    lv_object = iv_filename.

    IF iv_patch_line_possible = abap_true.

      lv_id = |patch_{ lv_object }_{ iv_index }|.

      io_html-&gt;add( |&lt;td class=&quot;{ c_css_class-patch }&quot;&gt;| ).

      lv_left_class = |{ c_patch_action-add } |.
      lv_right_class = |{ c_patch_action-remove } |.

      IF is_diff_line-patch_flag = abap_true.

        lv_left_class = lv_left_class &amp;&amp; |{ c_css_class-patch_active }|.

      ELSE.

        lv_right_class = lv_right_class &amp;&amp; |{ c_css_class-patch_active }|.

      ENDIF.

      io_html-&gt;add_a( iv_txt   = |{ c_patch_action-add }|
                      iv_act   = ||
                      iv_id    = |{ c_patch_action-add }_{ lv_id }|
                      iv_typ   = zif_abapgit_definitions=&gt;c_action_type-dummy
                      iv_class = lv_left_class ).
      io_html-&gt;add_a( iv_txt   = |{ c_patch_action-remove }|
                      iv_act   = ||
                      iv_id    = |{ c_patch_action-remove }_{ lv_id }|
                      iv_typ   = zif_abapgit_definitions=&gt;c_action_type-dummy
                      iv_class = lv_right_class ).

      io_html-&gt;add( |&lt;/td&gt;| ).

    ELSE.

      io_html-&gt;add( |&lt;td class=&quot;{ c_css_class-patch }&quot;&gt;| ).
      io_html-&gt;add( |&lt;/td&gt;| ).

    ENDIF.

  ENDMETHOD.
  METHOD render_patch_head.

    io_html-&gt;add( |&lt;th class=&quot;patch&quot;&gt;| ).

    io_html-&gt;add_a( iv_txt = |{ c_patch_action-add }|
                    iv_act = |patch_add_all(&apos;{ is_diff-filename }&apos;)|
                    iv_id  = |patch_add_all|
                    iv_typ = zif_abapgit_definitions=&gt;c_action_type-dummy ).

    io_html-&gt;add_a( iv_txt = |{ c_patch_action-remove }|
                    iv_act = |patch_remove_all(&apos;{ is_diff-filename }&apos;)|
                    iv_id  = |patch_remove_all|
                    iv_typ = zif_abapgit_definitions=&gt;c_action_type-dummy ).

    io_html-&gt;add( &apos;&lt;/th&gt;&apos; ).

  ENDMETHOD.
  METHOD render_table_head.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;thead class=&quot;header&quot;&gt;&apos; ).               &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).                                 &quot;#EC NOTEXT

    IF mv_unified = abap_true.
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;old&lt;/th&gt;&apos; ).           &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;new&lt;/th&gt;&apos; ).           &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;code&lt;/th&gt;&apos; ).                      &quot;#EC NOTEXT
    ELSE.

      IF mv_patch_mode = abap_true.

        render_patch_head( io_html = ro_html
                           is_diff = is_diff ).

      ENDIF.

      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;LOCAL&lt;/th&gt;&apos; ).                     &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th class=&quot;num&quot;&gt;&lt;/th&gt;&apos; ).              &quot;#EC NOTEXT
      ro_html-&gt;add( &apos;&lt;th&gt;REMOTE&lt;/th&gt;&apos; ).                    &quot;#EC NOTEXT

    ENDIF.

    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).                                &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).                             &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;var gHelper = new DiffHelper({&apos; ).
    ro_html-&gt;add( |  seed:        &quot;{ mv_seed }&quot;,| ).
    ro_html-&gt;add( &apos;  ids: {&apos; ).
    ro_html-&gt;add( &apos;    diffList:    &quot;diff-list&quot;,&apos; ).
    ro_html-&gt;add( &apos;    filterMenu:  &quot;diff-filter&quot;,&apos; ).
    ro_html-&gt;add( &apos;  }&apos; ).
    ro_html-&gt;add( &apos;});&apos; ).

    IF mv_patch_mode = abap_true.
      ro_html-&gt;add( &apos;preparePatch();&apos; ).
      ro_html-&gt;add( &apos;registerStagePatch();&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD start_staging.

    DATA: lv_string TYPE string,
          lt_fields TYPE tihttpnvp,
          lv_add    TYPE string,
          lv_remove TYPE string.

    CONCATENATE LINES OF it_postdata INTO lv_string.
    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_string ).

    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name  = c_patch_action-add
                                                        it_field = lt_fields
                                              CHANGING  cg_field = lv_add ).

    zcl_abapgit_html_action_utils=&gt;get_field( EXPORTING iv_name  = c_patch_action-remove
                                                        it_field = lt_fields
                                              CHANGING  cg_field = lv_remove ).

    apply_patch_all( iv_action     = c_patch_action-add
                     iv_patch      = lv_add
                     iv_patch_flag = abap_true ).

    apply_patch_all( iv_action     = c_patch_action-remove
                     iv_patch      = lv_remove
                     iv_patch_flag = abap_false ).

    add_to_stage( ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

    DATA: ls_hotkey_action LIKE LINE OF rt_hotkey_actions.

    ls_hotkey_action-name           = |Stage changes|.
    ls_hotkey_action-action         = |stagePatch|.
    ls_hotkey_action-default_hotkey = |s|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online.

    CASE iv_action.
      WHEN c_actions-toggle_unified. &quot; Toggle file diplay

        mv_unified = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;toggle_diff_unified( ).
        ev_state   = zif_abapgit_definitions=&gt;c_event_state-re_render.

      WHEN c_actions-stage.

        start_staging( it_postdata ).

        lo_repo  ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mv_repo_key ).
        CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_commit
          EXPORTING
            io_repo  = lo_repo
            io_stage = mo_stage.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_DEBUGINFO IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;DEBUG INFO&apos;.
  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;debug_info&quot; class=&quot;debug_container&quot;&gt;&apos; ).
    ro_html-&gt;add( render_debug_info( ) ).
    ro_html-&gt;add( render_supported_object_types( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_debug_info.

    DATA: lt_ver_tab     TYPE filetable,
          lv_rc          TYPE i,
          lv_gui_version TYPE string,
          ls_version     LIKE LINE OF lt_ver_tab.

    cl_gui_frontend_services=&gt;get_gui_version(
      CHANGING version_table = lt_ver_tab rc = lv_rc
      EXCEPTIONS OTHERS = 1 ).
    READ TABLE lt_ver_tab INTO ls_version INDEX 1.
    lv_gui_version = ls_version-filename.
    READ TABLE lt_ver_tab INTO ls_version INDEX 2.
    lv_gui_version = |{ lv_gui_version }.{ ls_version-filename }|.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( |&lt;p&gt;abapGit version: { zif_abapgit_version=&gt;gc_abap_version }&lt;/p&gt;| ).
    ro_html-&gt;add( |&lt;p&gt;XML version:     { zif_abapgit_version=&gt;gc_xml_version }&lt;/p&gt;| ).
    ro_html-&gt;add( |&lt;p&gt;GUI version:     { lv_gui_version }&lt;/p&gt;| ).
    ro_html-&gt;add( |&lt;p&gt;LCL_TIME:        { zcl_abapgit_time=&gt;get( ) }&lt;/p&gt;| ).
    ro_html-&gt;add( |&lt;p&gt;SY time:         { sy-datum } { sy-uzeit } { sy-tzone }&lt;/p&gt;| ).

  ENDMETHOD.
  METHOD render_supported_object_types.

    DATA: lv_list  TYPE string,
          lt_types TYPE zcl_abapgit_objects=&gt;ty_types_tt,
          lv_type  LIKE LINE OF lt_types.
    lt_types = zcl_abapgit_objects=&gt;supported_list( ).

    LOOP AT lt_types INTO lv_type.
      IF lv_list IS INITIAL.
        lv_list = lv_type.
      ELSE.
        lv_list = lv_list &amp;&amp; `, ` &amp;&amp; lv_type.
      ENDIF.
    ENDLOOP.

    rv_html = |&lt;p&gt;Supported objects: { lv_list }&lt;/p&gt;|.

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;debugOutput(&quot;Browser: &quot; + navigator.userAgent + &apos; &amp;&amp;
      &apos;&quot;&lt;br&gt;Frontend time: &quot; + new Date(), &quot;debug_info&quot;);&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_COMMIT IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).

    mo_repo   = io_repo.
    mo_stage  = io_stage.

    ms_control-page_title = &apos;COMMIT&apos;.
  ENDMETHOD.
  METHOD parse_commit_request.

    CONSTANTS: lc_replace TYPE string VALUE &apos;&lt;&lt;new&gt;&gt;&apos;.

    DATA: lv_string TYPE string,
          lt_fields TYPE tihttpnvp.

    FIELD-SYMBOLS &lt;lv_body&gt; TYPE string.

    CLEAR eg_fields.

    CONCATENATE LINES OF it_postdata INTO lv_string.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_crlf    IN lv_string WITH lc_replace.
    REPLACE ALL OCCURRENCES OF zif_abapgit_definitions=&gt;c_newline IN lv_string WITH lc_replace.
    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields_upper_case_name( lv_string ).

    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;COMMITTER_NAME&apos;
        it_field = lt_fields
      CHANGING
        cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;COMMITTER_EMAIL&apos;
        it_field = lt_fields
      CHANGING
        cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;AUTHOR_NAME&apos;
        it_field = lt_fields
      CHANGING
        cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;AUTHOR_EMAIL&apos;
        it_field = lt_fields
      CHANGING
      cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;COMMENT&apos;
        it_field = lt_fields
      CHANGING
      cg_field = eg_fields ).
    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;BODY&apos;
        it_field = lt_fields
      CHANGING
        cg_field = eg_fields ).

    ASSIGN COMPONENT &apos;BODY&apos; OF STRUCTURE eg_fields TO &lt;lv_body&gt;.
    ASSERT &lt;lv_body&gt; IS ASSIGNED.
    REPLACE ALL OCCURRENCES OF lc_replace IN &lt;lv_body&gt; WITH zif_abapgit_definitions=&gt;c_newline.

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;repo&quot;&gt;&apos; ).
    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top(
      io_repo         = mo_repo
      iv_show_package = abap_false
      iv_branch       = mo_repo-&gt;get_branch_name( ) ) ).

    ro_html-&gt;add( render_menu( ) ).
    ro_html-&gt;add( render_form( ) ).
    ro_html-&gt;add( render_stage( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_form.

    CONSTANTS: lc_body_col_max TYPE i VALUE 150.

    DATA: li_user      TYPE REF TO zif_abapgit_persist_user.
    DATA: lv_user      TYPE string.
    DATA: lv_email     TYPE string.
    DATA: lv_s_param   TYPE string.
    DATA: lo_settings  TYPE REF TO zcl_abapgit_settings.
    DATA: lv_body_size TYPE i.

* see https://git-scm.com/book/ch5-2.html
* commit messages should be max 50 characters
* body should wrap at 72 characters

    li_user = zcl_abapgit_persistence_user=&gt;get_instance( ).

    lv_user  = li_user-&gt;get_repo_git_user_name( mo_repo-&gt;get_url( ) ).
    IF lv_user IS INITIAL.
      lv_user  = li_user-&gt;get_default_git_user_name( ).
    ENDIF.
    IF lv_user IS INITIAL.
      &quot; get default from user master record
      lv_user = zcl_abapgit_user_master_record=&gt;get_instance( sy-uname )-&gt;get_name( ).
    ENDIF.

    lv_email = li_user-&gt;get_repo_git_user_email( mo_repo-&gt;get_url( ) ).
    IF lv_email IS INITIAL.
      lv_email = li_user-&gt;get_default_git_user_email( ).
    ENDIF.
    IF lv_email IS INITIAL.
      &quot; get default from user master record
      lv_email = zcl_abapgit_user_master_record=&gt;get_instance( sy-uname )-&gt;get_email( ).
    ENDIF.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;form-container&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;form id=&quot;commit_form&quot; class=&quot;aligned-form&quot;&apos;
               &amp;&amp; &apos; method=&quot;post&quot; action=&quot;sapevent:commit_post&quot;&gt;&apos; ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;committer_name&apos;
                                     iv_label = &apos;committer name&apos;
                                     iv_value = lv_user ) ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;committer_email&apos;
                                     iv_label = &apos;committer e-mail&apos;
                                     iv_value = lv_email ) ).

    lo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).

    lv_s_param = lo_settings-&gt;get_commitmsg_comment_length( ).

    ro_html-&gt;add( render_text_input( iv_name       = &apos;comment&apos;
                                     iv_label      = &apos;comment&apos;
                                     iv_max_length = lv_s_param ) ).

    ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;label for=&quot;c-body&quot;&gt;body&lt;/label&gt;&apos; ).

    lv_body_size = lo_settings-&gt;get_commitmsg_body_size( ).
    IF lv_body_size &gt; lc_body_col_max.
      lv_body_size = lc_body_col_max.
    ENDIF.
    ro_html-&gt;add( |&lt;textarea id=&quot;c-body&quot; name=&quot;body&quot; rows=&quot;10&quot; cols=&quot;| &amp;&amp;
                  |{ lv_body_size }&quot;&gt;&lt;/textarea&gt;| ).

    ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; class=&quot;hidden-submit&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;span class=&quot;cell&quot;&gt;&lt;/span&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;span class=&quot;cell sub-title&quot;&gt;Optionally,&apos;
               &amp;&amp; &apos; specify author (same as committer by default)&lt;/span&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;author_name&apos;
                                     iv_label = &apos;author name&apos; ) ).

    ro_html-&gt;add( render_text_input( iv_name  = &apos;author_email&apos;
                                     iv_label = &apos;author e-mail&apos; ) ).

    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_menu.

    DATA lo_toolbar TYPE REF TO zcl_abapgit_html_toolbar.

    CREATE OBJECT ro_html.
    CREATE OBJECT lo_toolbar.

    lo_toolbar-&gt;add( iv_act = &apos;submitFormById(&apos;&apos;commit_form&apos;&apos;);&apos;
                     iv_txt = &apos;Commit&apos;
                     iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                     iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ) ##NO_TEXT.

    lo_toolbar-&gt;add( iv_act = c_action-commit_cancel
                     iv_txt = &apos;Cancel&apos;
                     iv_opt = zif_abapgit_definitions=&gt;c_html_opt-cancel ) ##NO_TEXT.

    ro_html-&gt;add( &apos;&lt;div class=&quot;paddings&quot;&gt;&apos; ).
    ro_html-&gt;add( lo_toolbar-&gt;render( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_stage.

    DATA: lt_stage TYPE zcl_abapgit_stage=&gt;ty_stage_tt.

    FIELD-SYMBOLS: &lt;ls_stage&gt; LIKE LINE OF lt_stage.
    CREATE OBJECT ro_html.

    lt_stage = mo_stage-&gt;get_all( ).

    ro_html-&gt;add( &apos;&lt;table class=&quot;stage_tab&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;thead&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;th colspan=&quot;2&quot;&gt;Staged files&lt;/th&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;tbody&gt;&apos; ).
    LOOP AT lt_stage ASSIGNING &lt;ls_stage&gt;.
      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;td class=&quot;method&quot;&gt;&apos; ).
      ro_html-&gt;add( zcl_abapgit_stage=&gt;method_description( &lt;ls_stage&gt;-method ) ).
      ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
      ro_html-&gt;add( &lt;ls_stage&gt;-file-path &amp;&amp; &lt;ls_stage&gt;-file-filename ).
      ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/tbody&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

  ENDMETHOD.
  METHOD render_text_input.

    DATA lv_attrs TYPE string.

    CREATE OBJECT ro_html.

    IF iv_value IS NOT INITIAL.
      lv_attrs = | value=&quot;{ iv_value }&quot;|.
    ENDIF.

    IF iv_max_length IS NOT INITIAL.
      lv_attrs = | maxlength=&quot;{ iv_max_length }&quot;|.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;div class=&quot;row&quot;&gt;&apos; ).
    ro_html-&gt;add( |&lt;label for=&quot;{ iv_name }&quot;&gt;{ iv_label }&lt;/label&gt;| ).
    ro_html-&gt;add( |&lt;input id=&quot;{ iv_name }&quot; name=&quot;{ iv_name }&quot; type=&quot;text&quot;{ lv_attrs }&gt;| ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD scripts.

    ro_html = super-&gt;scripts( ).

    ro_html-&gt;add( &apos;setInitialFocus(&quot;comment&quot;);&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: ls_commit TYPE zcl_abapgit_services_git=&gt;ty_commit_fields.

    CASE iv_action.
      WHEN c_action-commit_post.

        parse_commit_request(
          EXPORTING it_postdata = it_postdata
          IMPORTING eg_fields   = ls_commit ).

        ls_commit-repo_key = mo_repo-&gt;get_key( ).

        zcl_abapgit_services_git=&gt;commit( is_commit   = ls_commit
                                  io_repo     = mo_repo
                                  io_stage    = mo_stage ).

        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back_to_bookmark.

      WHEN c_action-commit_cancel.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_CODI_BASE IMPLEMENTATION.
  METHOD jump.
    DATA: lo_test               TYPE REF TO cl_ci_test_root,
          ls_info               TYPE scir_rest,
          lo_result             TYPE REF TO cl_ci_result_root,
          lv_check_variant_name TYPE sci_chkv,
          lv_package            TYPE devclass.
    DATA: lv_adt_jump_enabled   TYPE abap_bool.
    DATA: lv_line_number        TYPE i.
    DATA: ls_item               TYPE zif_abapgit_definitions=&gt;ty_item.
    DATA: ls_sub_item           TYPE zif_abapgit_definitions=&gt;ty_item.

    FIELD-SYMBOLS: &lt;ls_result&gt; TYPE scir_alvlist.

    IF is_sub_item IS NOT INITIAL.
      READ TABLE mt_result WITH KEY objtype  = is_item-obj_type
                                    objname  = is_item-obj_name
                                    sobjtype = is_sub_item-obj_type
                                    sobjname = is_sub_item-obj_name
                                    line     = iv_line_number
                           ASSIGNING &lt;ls_result&gt;.
    ELSE.
      READ TABLE mt_result WITH KEY objtype = is_item-obj_type
                                    objname = is_item-obj_name
                                    line    = iv_line_number
                           ASSIGNING &lt;ls_result&gt;.
    ENDIF.
    ASSERT &lt;ls_result&gt; IS ASSIGNED.
    ls_item-obj_name = &lt;ls_result&gt;-objname.
    ls_item-obj_type = &lt;ls_result&gt;-objtype.

    ls_sub_item-obj_name = &lt;ls_result&gt;-sobjname.
    ls_sub_item-obj_type = &lt;ls_result&gt;-sobjtype.

    lv_package = mo_repo-&gt;get_package( ).
    lv_check_variant_name = mo_repo-&gt;get_local_settings( )-code_inspector_check_variant.

    &quot; see SCI_LCL_DYNP_530 / HANDLE_DOUBLE_CLICK

    lv_adt_jump_enabled = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( )-&gt;get_adt_jump_enabled( ).

    TRY.
        IF lv_adt_jump_enabled = abap_true.

          lv_line_number = &lt;ls_result&gt;-line.

          zcl_abapgit_objects_super=&gt;jump_adt( iv_obj_name     = ls_item-obj_name
                                               iv_obj_type     = ls_item-obj_type
                                               iv_sub_obj_name = ls_sub_item-obj_name
                                               iv_sub_obj_type = ls_sub_item-obj_type
                                               iv_line_number  = lv_line_number ).
          RETURN.

        ENDIF.
      CATCH zcx_abapgit_exception.
    ENDTRY.

    TRY.
        lo_test ?= cl_ci_tests=&gt;get_test_ref( &lt;ls_result&gt;-test ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Jump to object not supported in your NW release|  ).
    ENDTRY.

    lo_result = lo_test-&gt;get_result_node( &lt;ls_result&gt;-kind ).
    MOVE-CORRESPONDING &lt;ls_result&gt; TO ls_info.

    lo_result-&gt;set_info( ls_info ).
    lo_result-&gt;if_ci_test~navigate( ).

  ENDMETHOD.
  METHOD render_result.
    DATA: lv_class TYPE string,
          lv_line  TYPE string.

    io_html-&gt;add( &apos;&lt;div&gt;&apos; ).
    IF iv_result-sobjname IS INITIAL OR
       ( iv_result-sobjname = iv_result-objname AND
         iv_result-sobjtype = iv_result-sobjtype ).
      io_html-&gt;add_a( iv_txt = |{ iv_result-objtype } { iv_result-objname }|
                      iv_act = |{ iv_result-objtype }{ iv_result-objname }| &amp;&amp;
                               |{ c_object_separator }{ c_object_separator }{ iv_result-line }|
                      iv_typ = zif_abapgit_definitions=&gt;c_action_type-sapevent ).

    ELSE.
      io_html-&gt;add_a( iv_txt = |{ iv_result-objtype } { iv_result-objname }| &amp;&amp;
                               | &lt; { iv_result-sobjtype } { iv_result-sobjname }|
                      iv_act = |{ iv_result-objtype }{ iv_result-objname }| &amp;&amp;
                               |{ c_object_separator }{ iv_result-sobjtype }{ iv_result-sobjname }| &amp;&amp;
                               |{ c_object_separator }{ iv_result-line }|
                      iv_typ = zif_abapgit_definitions=&gt;c_action_type-sapevent ).

    ENDIF.
    io_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

    CASE iv_result-kind.
      WHEN &apos;E&apos;.
        lv_class = &apos;error&apos;.
      WHEN &apos;W&apos;.
        lv_class = &apos;warning&apos;.
      WHEN OTHERS.
        lv_class = &apos;grey&apos;.
    ENDCASE.

    CALL FUNCTION &apos;CONVERSION_EXIT_ALPHA_OUTPUT&apos;
      EXPORTING
        input  = iv_result-line
      IMPORTING
        output = lv_line.

    io_html-&gt;add( |&lt;div class=&quot;{ lv_class }&quot;&gt;Line { lv_line }: { iv_result-text }&lt;/div&gt;&lt;br&gt;| ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.
    DATA: ls_item          TYPE zif_abapgit_definitions=&gt;ty_item,
          ls_sub_item      TYPE zif_abapgit_definitions=&gt;ty_item,
          lv_main_object   TYPE string,
          lv_sub_object    TYPE string,
          lv_line_number_s TYPE string,
          lv_line_number   TYPE i.
    CASE iv_action.

      WHEN zif_abapgit_definitions=&gt;c_action-abapgit_home.
        RETURN.

      WHEN OTHERS.
        SPLIT iv_action AT c_object_separator INTO lv_main_object lv_sub_object lv_line_number_s.
        ls_item-obj_type = lv_main_object(4).
        ls_item-obj_name = lv_main_object+4(*).

        IF lv_sub_object IS NOT INITIAL.
          ls_sub_item-obj_type = lv_sub_object(4).
          ls_sub_item-obj_name = lv_sub_object+4(*).
        ENDIF.

        lv_line_number = lv_line_number_s.

        jump( is_item        = ls_item
              is_sub_item    = ls_sub_item
              iv_line_number = lv_line_number ).

        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.

    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_CODE_INSP IMPLEMENTATION.
  METHOD build_menu.

    DATA: lv_opt TYPE c LENGTH 1.

    CREATE OBJECT ro_menu.

    ro_menu-&gt;add( iv_txt = &apos;Re-Run&apos;
                  iv_act = c_actions-rerun
                  iv_cur = abap_false ) ##NO_TEXT.

    IF is_stage_allowed( ) = abap_false.
      lv_opt = zif_abapgit_definitions=&gt;c_html_opt-crossout.
    ENDIF.

    IF mo_repo-&gt;is_offline( ) = abap_true.
      RETURN.
    ENDIF.

    IF mo_stage IS BOUND.

      &quot; Staging info already available, we can directly
      &quot; offer to commit

      ro_menu-&gt;add( iv_txt = &apos;Commit&apos;
                    iv_act = c_actions-commit
                    iv_cur = abap_false
                    iv_opt = lv_opt ) ##NO_TEXT.

    ELSE.

      ro_menu-&gt;add( iv_txt = &apos;Stage&apos;
                    iv_act = c_actions-stage
                    iv_cur = abap_false
                    iv_opt = lv_opt ) ##NO_TEXT.

    ENDIF.

  ENDMETHOD.
  METHOD constructor.
    super-&gt;constructor( ).
    mo_repo ?= io_repo.
    mo_stage = io_stage.
    ms_control-page_title = &apos;Code Inspector&apos;.
    run_code_inspector( ).
  ENDMETHOD.
  METHOD has_inspection_errors.

    READ TABLE mt_result TRANSPORTING NO FIELDS
                         WITH KEY kind = &apos;E&apos;.
    rv_has_inspection_errors = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD is_stage_allowed.

    rv_is_stage_allowed =  boolc( NOT ( mo_repo-&gt;get_local_settings( )-block_commit = abap_true
                                           AND has_inspection_errors( ) = abap_true ) ).

  ENDMETHOD.
  METHOD render_content.

    DATA: lv_check_variant TYPE sci_chkv.

    FIELD-SYMBOLS: &lt;ls_result&gt; TYPE scir_alvlist.

    CREATE OBJECT ro_html.

    lv_check_variant = mo_repo-&gt;get_local_settings( )-code_inspector_check_variant.

    IF lv_check_variant IS INITIAL.
      ro_html-&gt;add( |No check variant maintained in repo settings.| ).
      RETURN.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;div class=&quot;toc&quot;&gt;&lt;br/&gt;&apos; ).

    ro_html-&gt;add( |Code inspector check variant: {
                    mo_repo-&gt;get_local_settings( )-code_inspector_check_variant
                  }&lt;br/&gt;| ).

    IF lines( mt_result ) = 0.
      ro_html-&gt;add( &apos;&lt;br/&gt;&lt;div class=&quot;success&quot;&gt;No code inspector findings&lt;/div&gt;&apos; ).
    ENDIF.

    ro_html-&gt;add( |&lt;br/&gt;| ).

    LOOP AT mt_result ASSIGNING &lt;ls_result&gt;.
      render_result( io_html   = ro_html
                     iv_result = &lt;ls_result&gt; ).
    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD run_code_inspector.

    mt_result = mo_repo-&gt;run_code_inspector( ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

    DATA: ls_hotkey_action LIKE LINE OF rt_hotkey_actions.

    ls_hotkey_action-name           = |Stage|.
    ls_hotkey_action-action         = c_actions-stage.
    ls_hotkey_action-default_hotkey = |s|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

    ls_hotkey_action-name           = |Re-Run|.
    ls_hotkey_action-action         = c_actions-rerun.
    ls_hotkey_action-default_hotkey = |r|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: lo_repo_online TYPE REF TO zcl_abapgit_repo_online.

    CASE iv_action.
      WHEN c_actions-stage.

        lo_repo_online ?= mo_repo.

        IF is_stage_allowed( ) = abap_true.
          &quot; we need to refresh as the source might have changed
          lo_repo_online-&gt;refresh( ).

          CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_stage
            EXPORTING
              io_repo = lo_repo_online.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

        ELSE.

          ei_page = me.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.

        ENDIF.

      WHEN c_actions-commit.

        lo_repo_online ?= mo_repo.

        IF is_stage_allowed( ) = abap_true.

          CREATE OBJECT ei_page TYPE zcl_abapgit_gui_page_commit
            EXPORTING
              io_repo  = lo_repo_online
              io_stage = mo_stage.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.

        ELSE.

          ei_page = me.
          ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.

        ENDIF.

      WHEN c_actions-rerun.

        run_code_inspector( ).

        ei_page = me.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN OTHERS.
        super-&gt;zif_abapgit_gui_page~on_event(
          EXPORTING
            iv_action             = iv_action
            iv_prev_page          = iv_prev_page
            iv_getdata            = iv_getdata
            it_postdata           = it_postdata
          IMPORTING
            ei_page               = ei_page
            ev_state              = ev_state ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~render.

    ms_control-page_menu = build_menu( ).
    ro_html = super-&gt;zif_abapgit_gui_page~render( ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_gui_page_boverview IMPLEMENTATION.

  METHOD body.
    DATA: lv_tag                 TYPE string.
    DATA: lv_branch_display_name TYPE string.

    FIELD-SYMBOLS: &lt;ls_commit&gt; LIKE LINE OF mt_commits,
                   &lt;ls_create&gt; LIKE LINE OF &lt;ls_commit&gt;-create.
    CREATE OBJECT ro_html.

    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top(
      io_repo         = mo_repo
      iv_show_package = abap_false
      iv_show_branch  = abap_false ) ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    ro_html-&gt;add( render_merge( ) ).

    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    ro_html-&gt;add( build_menu( )-&gt;render( ) ).

* see http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    ro_html-&gt;add( &apos;&lt;canvas id=&quot;gitGraph&quot;&gt;&lt;/canvas&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.&apos; &amp;&amp;
      &apos;cloudflare.com/ajax/libs/gitgraph.js/1.12.0/gitgraph.min.js&quot;&gt;&apos; &amp;&amp;
      &apos;&lt;/script&gt;&apos; ) ##NO_TEXT.

    ro_html-&gt;add( &apos;&lt;script type=&quot;text/javascript&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;var myTemplateConfig = {&apos; ).
    ro_html-&gt;add( &apos;colors: [ &quot;#979797&quot;, &quot;#008fb5&quot;, &quot;#f1c109&quot;, &quot;&apos;
      &amp;&amp; &apos;#095256&quot;, &quot;#087F8C&quot;, &quot;#5AAA95&quot;, &quot;#86A873&quot;, &quot;#BB9F06&quot; ],&apos; ) ##NO_TEXT.
    ro_html-&gt;add( &apos;branch: {&apos; ).
    ro_html-&gt;add( &apos;  lineWidth: 8,&apos; ).
    ro_html-&gt;add( &apos;  spacingX: 50&apos; ).
    ro_html-&gt;add( &apos;},&apos; ).
    ro_html-&gt;add( &apos;commit: {&apos; ).
    ro_html-&gt;add( &apos;  spacingY: -40,&apos; ).
    ro_html-&gt;add( &apos;  dot: { size: 12 },&apos; ).
    ro_html-&gt;add( &apos;  message: { font: &quot;normal 14pt Arial&quot; }&apos; ).
    ro_html-&gt;add( &apos;}&apos; ).
    ro_html-&gt;add( &apos;};&apos; ).
    ro_html-&gt;add( &apos;var gitgraph = new GitGraph({&apos; ).
    ro_html-&gt;add( &apos;  template: myTemplateConfig,&apos; ).
    ro_html-&gt;add( &apos;  orientation: &quot;vertical-reverse&quot;&apos; ).
    ro_html-&gt;add( &apos;});&apos; ).

    LOOP AT mt_commits ASSIGNING &lt;ls_commit&gt;.
      IF sy-tabix = 1.
* assumption: all branches are created from master, todo
        ro_html-&gt;add( |var {
          escape_branch( &lt;ls_commit&gt;-branch ) } = gitgraph.branch(&quot;{
          &lt;ls_commit&gt;-branch }&quot;);| ).
      ENDIF.

      IF &lt;ls_commit&gt;-compressed = abap_true.
        ro_html-&gt;add( |{ escape_branch( &lt;ls_commit&gt;-branch ) }.commit(\{message: &quot;{
          escape_message( &lt;ls_commit&gt;-message )
          }&quot;, dotColor: &quot;black&quot;, dotSize: 15, messageHashDisplay: false, messageAuthorDisplay: false\});| ).
      ELSEIF &lt;ls_commit&gt;-merge IS INITIAL.

        &quot; gitgraph doesn&apos;t support multiple tags per commit yet.
        &quot; Therefore we concatenate them.
        &quot; https://github.com/nicoespeon/gitgraph.js/issues/143

        lv_tag = concat_lines_of( table = &lt;ls_commit&gt;-tags
                                  sep   = ` | ` ).

        ro_html-&gt;add( |{ escape_branch( &lt;ls_commit&gt;-branch ) }.commit(\{message: &quot;{
          escape_message( &lt;ls_commit&gt;-message ) }&quot;, author: &quot;{
          &lt;ls_commit&gt;-author }&quot;, sha1: &quot;{
          &lt;ls_commit&gt;-sha1(7) }&quot;, tag: &quot;{ lv_tag }&quot;\});| ).
      ELSE.
        ro_html-&gt;add( |{ escape_branch( &lt;ls_commit&gt;-merge ) }.merge({
          escape_branch( &lt;ls_commit&gt;-branch ) }, \{message: &quot;{
          escape_message( &lt;ls_commit&gt;-message ) }&quot;, author: &quot;{
          &lt;ls_commit&gt;-author }&quot;, sha1: &quot;{
          &lt;ls_commit&gt;-sha1(7) }&quot;\});| ).
      ENDIF.

      LOOP AT &lt;ls_commit&gt;-create ASSIGNING &lt;ls_create&gt;.
        IF &lt;ls_create&gt;-name CS zcl_abapgit_branch_overview=&gt;c_deleted_branch_name_prefix.
          lv_branch_display_name = &apos;&apos;.
        ELSE.
          lv_branch_display_name = &lt;ls_create&gt;-name.
        ENDIF.

        ro_html-&gt;add( |var { escape_branch( &lt;ls_create&gt;-name ) } = {
                      escape_branch( &lt;ls_create&gt;-parent ) }.branch(&quot;{
                      lv_branch_display_name }&quot;);| ).
      ENDLOOP.

    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/script&gt;&apos; ).

  ENDMETHOD.
  METHOD build_menu.

    CREATE OBJECT ro_menu.

    IF mv_compress = abap_true.
      ro_menu-&gt;add(
        iv_txt = &apos;Uncompress Graph&apos;
        iv_act = c_actions-uncompress ) ##NO_TEXT.
    ELSE.
      ro_menu-&gt;add(
        iv_txt = &apos;Compress Graph&apos;
        iv_act = c_actions-compress ) ##NO_TEXT.
    ENDIF.

    ro_menu-&gt;add( iv_txt = &apos;Refresh&apos; iv_act = c_actions-refresh ) ##NO_TEXT.

  ENDMETHOD.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;BRANCH_OVERVIEW&apos;.
    mo_repo = io_repo.
    refresh( ).
  ENDMETHOD.
  METHOD decode_merge.

    DATA: lv_string TYPE string,
          lt_fields TYPE tihttpnvp.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF lt_fields.
    CONCATENATE LINES OF it_postdata INTO lv_string.

    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields( lv_string ).

    READ TABLE lt_fields ASSIGNING &lt;ls_field&gt; WITH KEY name = &apos;source&apos; ##NO_TEXT.
    ASSERT sy-subrc = 0.
    rs_merge-source = &lt;ls_field&gt;-value.

    READ TABLE lt_fields ASSIGNING &lt;ls_field&gt; WITH KEY name = &apos;target&apos; ##NO_TEXT.
    ASSERT sy-subrc = 0.
    rs_merge-target = &lt;ls_field&gt;-value.

  ENDMETHOD.
  METHOD escape_branch.

    rv_string = iv_string.

    TRANSLATE rv_string USING &apos;-_._&apos;.

    rv_string = |branch_{ rv_string }|.

  ENDMETHOD.
  METHOD escape_message.

    rv_string = iv_string.

    REPLACE ALL OCCURRENCES OF &apos;&quot;&apos; IN rv_string WITH &apos;\&quot;&apos;.

  ENDMETHOD.
  METHOD form_select.

    DATA: lv_name     TYPE string,
          lt_branches TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt.

    FIELD-SYMBOLS: &lt;ls_branch&gt; LIKE LINE OF lt_branches.
    CREATE OBJECT ro_html.

    lt_branches = mi_branch_overview-&gt;get_branches( ).

    ro_html-&gt;add( |&lt;select name=&quot;{ iv_name }&quot;&gt;| ).
    LOOP AT lt_branches ASSIGNING &lt;ls_branch&gt;.
      lv_name = &lt;ls_branch&gt;-name+11.
      ro_html-&gt;add( |&lt;option value=&quot;{ lv_name }&quot;&gt;{ lv_name }&lt;/option&gt;| ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/select&gt;&apos; ).

  ENDMETHOD.
  METHOD refresh.

    mi_branch_overview = zcl_abapgit_factory=&gt;get_branch_overview( mo_repo ).

    mt_commits = mi_branch_overview-&gt;get_commits( ).
    IF mv_compress = abap_true.
      mt_commits = mi_branch_overview-&gt;compress( mt_commits ).
    ENDIF.

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;toc&quot;&gt;&apos; ).
    ro_html-&gt;add( body( ) ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_merge.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;form id=&quot;commit_form&quot; method=&quot;post&quot; action=&quot;sapevent:merge&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;Merge&apos; ) ##NO_TEXT.
    ro_html-&gt;add( form_select( &apos;source&apos; ) ) ##NO_TEXT.
    ro_html-&gt;add( &apos;into&apos; ) ##NO_TEXT.
    ro_html-&gt;add( form_select( &apos;target&apos; ) ) ##NO_TEXT.
    ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: ls_merge TYPE ty_merge,
          lo_merge TYPE REF TO zcl_abapgit_gui_page_merge.
    CASE iv_action.
      WHEN c_actions-refresh.
        refresh( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-uncompress.
        mv_compress = abap_false.
        refresh( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-compress.
        mv_compress = abap_true.
        refresh( ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
      WHEN c_actions-merge.
        ls_merge = decode_merge( it_postdata ).
        CREATE OBJECT lo_merge
          EXPORTING
            io_repo   = mo_repo
            iv_source = ls_merge-source
            iv_target = ls_merge-target.
        ei_page = lo_merge.
        ev_state = zif_abapgit_definitions=&gt;c_event_state-new_page.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_BKG_RUN IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;BACKGROUND_RUN&apos;.
  ENDMETHOD.
  METHOD render_content.

    DATA: lv_text LIKE LINE OF mt_text.

    run( ).

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;toc&quot;&gt;&apos; ).
    LOOP AT mt_text INTO lv_text.
      ro_html-&gt;add( &apos;&lt;pre&gt;&apos; &amp;&amp; lv_text &amp;&amp; &apos;&lt;/pre&gt;&lt;br&gt;&apos; ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD run.

    DATA: lx_error TYPE REF TO zcx_abapgit_exception,
          lv_text  TYPE string,
          lv_line  TYPE i VALUE 1.
    TRY.
        zcl_abapgit_background=&gt;run( ).

        DO.
          READ LINE lv_line LINE VALUE INTO lv_text.
          IF sy-subrc &lt;&gt; 0.
            EXIT.
          ENDIF.
          APPEND lv_text TO mt_text.
          lv_line = lv_line + 1.
        ENDDO.
      CATCH zcx_abapgit_exception INTO lx_error.
        APPEND lx_error-&gt;get_text( ) TO mt_text.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.
    RETURN.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_BKG IMPLEMENTATION.
  METHOD build_menu.

    CREATE OBJECT ro_menu.

    ro_menu-&gt;add( iv_txt = &apos;Run background logic&apos;
                  iv_act = zif_abapgit_definitions=&gt;c_action-go_background_run ) ##NO_TEXT.

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( ).

    mv_key = iv_key.
    ms_control-page_title = &apos;BACKGROUND&apos;.
    ms_control-page_menu  = build_menu( ).

  ENDMETHOD.
  METHOD decode.

    DATA: lt_fields TYPE tihttpnvp.

    FIELD-SYMBOLS: &lt;ls_setting&gt; LIKE LINE OF rs_fields-settings.
    rs_fields-key = mv_key.

    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields_upper_case_name( iv_getdata ).

    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;METHOD&apos;
        it_field   = lt_fields
      CHANGING
        cg_field   = rs_fields ).
    IF rs_fields-method IS INITIAL.
      RETURN.
    ENDIF.

    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;USERNAME&apos;
        it_field   = lt_fields
      CHANGING
        cg_field   = rs_fields ).

    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;PASSWORD&apos;
        it_field   = lt_fields
      CHANGING
        cg_field   = rs_fields ).
    CALL METHOD (rs_fields-method)=&gt;zif_abapgit_background~get_settings
      CHANGING
        ct_settings = rs_fields-settings.
    LOOP AT rs_fields-settings ASSIGNING &lt;ls_setting&gt;.
      zcl_abapgit_html_action_utils=&gt;get_field(
        EXPORTING
          iv_name = &lt;ls_setting&gt;-key
          it_field   = lt_fields
        CHANGING
          cg_field   = &lt;ls_setting&gt;-value ).
    ENDLOOP.

    ASSERT NOT rs_fields IS INITIAL.

  ENDMETHOD.
  METHOD read_persist.

    DATA: lo_per TYPE REF TO zcl_abapgit_persist_background,
          lt_per TYPE zcl_abapgit_persist_background=&gt;tt_background.
    CREATE OBJECT lo_per.
    lt_per = lo_per-&gt;list( ).

    READ TABLE lt_per INTO rs_persist WITH KEY key = io_repo-&gt;get_key( ).
    IF sy-subrc &lt;&gt; 0.
      CLEAR rs_persist.
    ENDIF.

  ENDMETHOD.
  METHOD render.

    DATA: lo_repo TYPE REF TO zcl_abapgit_repo_online,
          ls_per  TYPE zcl_abapgit_persist_background=&gt;ty_background.
    lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( mv_key ).
    ls_per = read_persist( lo_repo ).
    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;toc&quot;&gt;&apos; ).

    ro_html-&gt;add( zcl_abapgit_gui_chunk_lib=&gt;render_repo_top( lo_repo ) ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    ro_html-&gt;add( render_methods( ls_per ) ).

    ro_html-&gt;add( &apos;&lt;u&gt;HTTP Authentication, optional&lt;/u&gt;&lt;br&gt;&apos; ) ##NO_TEXT.
    ro_html-&gt;add( &apos;(password will be saved in clear text)&lt;br&gt;&apos; ) ##NO_TEXT.
    ro_html-&gt;add( &apos;&lt;table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;Username:&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&apos; &amp;&amp;
      ls_per-username &amp;&amp; &apos;&quot;&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;Password:&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;&apos; &amp;&amp;
      ls_per-password &amp;&amp; &apos;&quot;&gt;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    ro_html-&gt;add( render_settings( ls_per ) ).

    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_content.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( render( ) ).

  ENDMETHOD.
  METHOD render_methods.

    DATA: lt_methods TYPE zcl_abapgit_background=&gt;ty_methods_tt,
          ls_method  LIKE LINE OF lt_methods,
          lv_checked TYPE string.
    CREATE OBJECT ro_html.

    lt_methods = zcl_abapgit_background=&gt;list_methods( ).

    ro_html-&gt;add( &apos;&lt;u&gt;Method&lt;/u&gt;&lt;br&gt;&apos; ) ##NO_TEXT.
    ro_html-&gt;add( |&lt;form method=&quot;get&quot; action=&quot;sapevent:{ zif_abapgit_definitions=&gt;c_action-bg_update }&quot;&gt;| ).

    IF is_per-method IS INITIAL.
      lv_checked = &apos; checked&apos; ##NO_TEXT.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;input type=&quot;radio&quot; name=&quot;method&quot; value=&quot;&quot;&apos; &amp;&amp;
      lv_checked &amp;&amp; &apos;&gt;Do nothing&lt;br&gt;&apos; ) ##NO_TEXT.

    LOOP AT lt_methods INTO ls_method.
      CLEAR lv_checked.
      IF is_per-method = ls_method-class.
        lv_checked = &apos; checked&apos; ##NO_TEXT.
      ENDIF.

      ro_html-&gt;add( &apos;&lt;input type=&quot;radio&quot; name=&quot;method&quot; value=&quot;&apos; &amp;&amp;
        ls_method-class &amp;&amp; &apos;&quot;&apos; &amp;&amp;
        lv_checked &amp;&amp; &apos;&gt;&apos; &amp;&amp;
        ls_method-description &amp;&amp; &apos;&lt;br&gt;&apos; ) ##NO_TEXT.
    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;br&gt;&apos; ).

  ENDMETHOD.
  METHOD render_settings.

    DATA: lt_settings LIKE is_per-settings,
          ls_setting  LIKE LINE OF lt_settings.
    CREATE OBJECT ro_html.

    IF is_per-method IS INITIAL.
      RETURN.
    ENDIF.

    lt_settings = is_per-settings.

* skip invalid values, from old background logic
    IF is_per-method &lt;&gt; &apos;push&apos; AND is_per-method &lt;&gt; &apos;pull&apos; AND is_per-method &lt;&gt; &apos;nothing&apos;.
      CALL METHOD (is_per-method)=&gt;zif_abapgit_background~get_settings
        CHANGING
          ct_settings = lt_settings.
    ENDIF.

    IF lines( lt_settings ) = 0.
      RETURN.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;table&gt;&apos; ).
    LOOP AT lt_settings INTO ls_setting.
      ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;td&gt;&apos; &amp;&amp; ls_setting-key &amp;&amp; &apos;:&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&apos; &amp;&amp;
        ls_setting-key &amp;&amp; &apos;&quot; value=&quot;&apos; &amp;&amp;
        ls_setting-value &amp;&amp; &apos;&quot;&gt;&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).

  ENDMETHOD.
  METHOD update.

    DATA lo_persistence TYPE REF TO zcl_abapgit_persist_background.

    CREATE OBJECT lo_persistence.

    IF is_bg_task-method IS INITIAL.
      lo_persistence-&gt;delete( is_bg_task-key ).
    ELSE.
      lo_persistence-&gt;modify( is_bg_task ).
    ENDIF.

    MESSAGE &apos;Saved&apos; TYPE &apos;S&apos; ##NO_TEXT.

    COMMIT WORK.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    CASE iv_action.
      WHEN zif_abapgit_definitions=&gt;c_action-bg_update.
        update( decode( iv_getdata ) ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE IMPLEMENTATION.
  METHOD add_hotkeys.

    DATA: lv_json    TYPE string,
          lt_hotkeys TYPE zif_abapgit_definitions=&gt;tty_hotkey.

    FIELD-SYMBOLS: &lt;ls_hotkey&gt; TYPE zif_abapgit_definitions=&gt;ty_hotkey.

    lt_hotkeys = zcl_abapgit_hotkeys=&gt;get_relevant_hotkeys_for_page( me ).

    lv_json = `{`.

    LOOP AT lt_hotkeys ASSIGNING &lt;ls_hotkey&gt;.

      IF sy-tabix &gt; 1.
        lv_json = lv_json &amp;&amp; |,|.
      ENDIF.

      lv_json = lv_json &amp;&amp; |  &quot;{ &lt;ls_hotkey&gt;-sequence }&quot; : &quot;{ &lt;ls_hotkey&gt;-action }&quot; |.

    ENDLOOP.

    lv_json = lv_json &amp;&amp; `}`.

    io_html-&gt;add( |setKeyBindings({ lv_json });| ).

  ENDMETHOD.
  METHOD call_browser.

    cl_gui_frontend_services=&gt;execute(
      EXPORTING
        document               = |{ iv_url }|
      EXCEPTIONS
        cntl_error             = 1
        error_no_gui           = 2
        bad_parameter          = 3
        file_not_found         = 4
        path_not_found         = 5
        file_extension_unknown = 6
        error_execute_failed   = 7
        synchronous_failed     = 8
        not_supported_by_gui   = 9
        OTHERS                 = 10 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD footer.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;footer&quot;&gt;&apos; ).                    &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;img src=&quot;img/logo&quot; alt=&quot;logo&quot;&gt;&apos; ).      &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&lt;tr&gt;&apos; ).             &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;td class=&quot;w40&quot;&gt;&lt;/td&gt;&apos; ).                &quot;#EC NOTEXT
    ro_html-&gt;add( |&lt;td&gt;&lt;span class=&quot;version&quot;&gt;{ zif_abapgit_version=&gt;gc_abap_version }&lt;/span&gt;&lt;/td&gt;| ). &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;td id=&quot;debug-output&quot; class=&quot;w40&quot;&gt;&lt;/td&gt;&apos; ). &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/table&gt;&apos; ).                        &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD get_hotkey_actions.

    &quot; these are the global shortcuts active on all pages

    DATA: ls_hotkey_action LIKE LINE OF rt_hotkey_actions.

    ls_hotkey_action-name           = |Show hotkeys help|.
    ls_hotkey_action-action         = c_global_page_action-showhotkeys.
    ls_hotkey_action-default_hotkey = |?|.
    INSERT ls_hotkey_action INTO TABLE rt_hotkey_actions.

  ENDMETHOD.
  METHOD html_head.

    DATA lv_font TYPE string.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;head&gt;&apos; ).                               &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&apos; ). &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11,10,9,8&quot; /&gt;&apos; ). &quot;#EC NOTEXT

    ro_html-&gt;add( &apos;&lt;title&gt;abapGit&lt;/title&gt;&apos; ).               &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/common.css&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;script type=&quot;text/javascript&quot; src=&quot;js/common.js&quot;&gt;&lt;/script&gt;&apos; ). &quot;#EC NOTEXT

    lv_font = |&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;|
      &amp;&amp; &apos;https://cdnjs.cloudflare.com/ajax/libs/octicons/4.4.0/font/octicons.min.css&apos;
      &amp;&amp; &apos;&quot;&gt;&apos;.                                         &quot;#EC NOTEXT
    ro_html-&gt;add( lv_font ). &quot; Web fonts

    ro_html-&gt;add( &apos;&lt;/head&gt;&apos; ).                              &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD link_hints.

    DATA: lo_settings         TYPE REF TO zcl_abapgit_settings,
          lv_link_hint_key    TYPE char01,
          lv_background_color TYPE string.

    lo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).

    lv_link_hint_key = lo_settings-&gt;get_link_hint_key( ).
    lv_background_color = lo_settings-&gt;get_link_hint_background_color( ).

    IF lo_settings-&gt;get_link_hints_enabled( ) = abap_true
    AND lv_link_hint_key IS NOT INITIAL.

      io_html-&gt;add( |setLinkHints(&quot;{ lv_link_hint_key }&quot;,&quot;{ lv_background_color }&quot;);| ).
      io_html-&gt;add( |setInitialFocusWithQuerySelector(&apos;a span&apos;, true);| ).
      io_html-&gt;add( |enableArrowListNavigation();| ).

    ENDIF.

  ENDMETHOD.
  METHOD redirect.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;!DOCTYPE html&gt;&apos; ).                      &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;html&gt;&apos; ).                               &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;head&gt;&apos; ).                               &quot;#EC NOTEXT
    ro_html-&gt;add( |&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url={
                  ms_control-redirect_url }&quot;&gt;| ).           &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/head&gt;&apos; ).                              &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/html&gt;&apos; ).                              &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD render_hotkey_overview.

    ro_html = zcl_abapgit_gui_chunk_lib=&gt;render_hotkey_overview( me ).

  ENDMETHOD.
  METHOD scripts.

    CREATE OBJECT ro_html.

    link_hints( ro_html ).
    add_hotkeys( ro_html ).

  ENDMETHOD.
  METHOD title.

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div id=&quot;header&quot;&gt;&apos; ).                    &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&lt;tr&gt;&apos; ).             &quot;#EC NOTEXT

    ro_html-&gt;add( |&lt;td class=&quot;logo&quot;&gt;{
                  zcl_abapgit_html=&gt;a( iv_txt = &apos;&lt;img src=&quot;img/logo&quot; alt=&quot;logo&quot;&gt;&apos;
                                       iv_id  = &apos;abapGitLogo&apos;
                                       iv_act = zif_abapgit_definitions=&gt;c_action-abapgit_home )
                  }&lt;/td&gt;| ).                                &quot;#EC NOTEXT

    ro_html-&gt;add( |&lt;td&gt;&lt;span class=&quot;page_title&quot;&gt; &amp;#x25BA; {
                  ms_control-page_title
                  }&lt;/span&gt;&lt;/td&gt;| ).                         &quot;#EC NOTEXT

    IF ms_control-page_menu IS BOUND.
      ro_html-&gt;add( &apos;&lt;td class=&quot;right&quot;&gt;&apos; ).                 &quot;#EC NOTEXT
      ro_html-&gt;add( ms_control-page_menu-&gt;render( iv_right = abap_true ) ).
      ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).                              &quot;#EC NOTEXT
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/table&gt;&apos; ).                        &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).                               &quot;#EC NOTEXT

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    CASE iv_action.
      WHEN zif_abapgit_definitions=&gt;c_action-url.

        call_browser( iv_getdata ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-no_more_act.

      WHEN OTHERS.

        ev_state = zif_abapgit_definitions=&gt;c_event_state-not_handled.

    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~render.

    DATA lo_script TYPE REF TO zcl_abapgit_html.

    &quot; Redirect
    IF ms_control-redirect_url IS NOT INITIAL.
      ro_html = redirect( ).
      RETURN.
    ENDIF.

    &quot; Real page
    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;!DOCTYPE html&gt;&apos; ).                      &quot;#EC NOTEXT
    ro_html-&gt;add( &apos;&lt;html&gt;&apos; ).                               &quot;#EC NOTEXT
    ro_html-&gt;add( html_head( ) ).
    ro_html-&gt;add( &apos;&lt;body&gt;&apos; ).                               &quot;#EC NOTEXT
    ro_html-&gt;add( title( ) ).
    ro_html-&gt;add( render_hotkey_overview( ) ).
    ro_html-&gt;add( render_content( ) ).
    ro_html-&gt;add( footer( ) ).
    ro_html-&gt;add( &apos;&lt;/body&gt;&apos; ).                              &quot;#EC NOTEXT

    lo_script = scripts( ).

    IF lo_script IS BOUND AND lo_script-&gt;is_empty( ) = abap_false.
      ro_html-&gt;add( &apos;&lt;script type=&quot;text/javascript&quot;&gt;&apos; ).
      ro_html-&gt;add( lo_script ).
      ro_html-&gt;add( &apos;confirmInitialized();&apos; ).
      ro_html-&gt;add( &apos;&lt;/script&gt;&apos; ).
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/html&gt;&apos; ).                              &quot;#EC NOTEXT

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_gui_functions IMPLEMENTATION.

  METHOD zif_abapgit_gui_functions~gui_is_available.

    CALL FUNCTION &apos;GUI_IS_AVAILABLE&apos;
      IMPORTING
        return = rv_gui_is_available.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_CHUNK_LIB IMPLEMENTATION.
  METHOD render_branch_span.

    DATA: lv_text  TYPE string,
          lv_class TYPE string.

    lv_text = zcl_abapgit_git_branch_list=&gt;get_display_name( iv_branch ).

    IF zcl_abapgit_git_branch_list=&gt;get_type( iv_branch ) = zif_abapgit_definitions=&gt;c_git_branch_type-branch.
      lv_class = &apos;branch branch_branch&apos;.
    ELSE.
      lv_class = &apos;branch&apos;.
    ENDIF.

    CREATE OBJECT ro_html.
    ro_html-&gt;add( |&lt;span class=&quot;{ lv_class }&quot;&gt;| ).
    ro_html-&gt;add_icon( iv_name = &apos;git-branch/darkgrey&apos; iv_hint = &apos;Current branch&apos; ).
    IF iv_interactive = abap_true.
      ro_html-&gt;add_a( iv_act = |{ zif_abapgit_definitions=&gt;c_action-git_branch_switch }?{ io_repo-&gt;get_key( ) }|
                      iv_txt = lv_text ).
    ELSE.
      ro_html-&gt;add( lv_text ).
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/span&gt;&apos; ).

  ENDMETHOD.
  METHOD render_error.

    DATA lv_error TYPE string.

    CREATE OBJECT ro_html.

    IF ix_error IS BOUND.
      lv_error = ix_error-&gt;get_text( ).
    ELSE.
      lv_error = iv_error.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;div class=&quot;dummydiv error&quot;&gt;&apos; ).
    ro_html-&gt;add( |{ zcl_abapgit_html=&gt;icon( &apos;alert/red&apos; ) } Error: { lv_error }| ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_hotkey_overview.

    DATA: lv_hint     TYPE string,
          lt_hotkeys  TYPE zif_abapgit_definitions=&gt;tty_hotkey,
          lt_actions  TYPE zif_abapgit_gui_page_hotkey=&gt;tty_hotkey_action,
          lo_settings TYPE REF TO zcl_abapgit_settings.

    FIELD-SYMBOLS: &lt;ls_hotkey&gt; TYPE zif_abapgit_definitions=&gt;ty_hotkey,
                   &lt;ls_action&gt; LIKE LINE OF lt_actions.

    lo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).
    lt_hotkeys  = lo_settings-&gt;get_hotkeys( ).
    lt_actions  = zcl_abapgit_hotkeys=&gt;get_default_hotkeys_from_pages( io_page ).

    CREATE OBJECT ro_html.

    &quot; Render hotkeys
    ro_html-&gt;add( &apos;&lt;ul class=&quot;hotkeys&quot;&gt;&apos; ).
    LOOP AT lt_hotkeys ASSIGNING &lt;ls_hotkey&gt;.

      READ TABLE lt_actions ASSIGNING &lt;ls_action&gt;
                            WITH TABLE KEY action
                            COMPONENTS action = &lt;ls_hotkey&gt;-action.
      IF sy-subrc = 0.
        ro_html-&gt;add( |&lt;li&gt;|
          &amp;&amp; |&lt;span class=&quot;key-id&quot;&gt;{ &lt;ls_hotkey&gt;-sequence }&lt;/span&gt;|
          &amp;&amp; |&lt;span class=&quot;key-descr&quot;&gt;{ &lt;ls_action&gt;-name }&lt;/span&gt;|
          &amp;&amp; |&lt;/li&gt;| ).
      ENDIF.

    ENDLOOP.
    ro_html-&gt;add( &apos;&lt;/ul&gt;&apos; ).

    &quot; Wrap
    READ TABLE lt_hotkeys ASSIGNING &lt;ls_hotkey&gt;
      WITH KEY action = zcl_abapgit_gui_page=&gt;c_global_page_action-showhotkeys.
    IF sy-subrc = 0.
      lv_hint = |Close window with &apos;{ &lt;ls_hotkey&gt;-sequence }&apos; or upper right corner &apos;X&apos;|.
    ENDIF.

    ro_html = render_infopanel(
      iv_div_id     = &apos;hotkeys&apos;
      iv_title      = &apos;Hotkeys&apos;
      iv_hint       = lv_hint
      iv_hide       = abap_true
      iv_scrollable = abap_false
      io_content    = ro_html ).

    IF &lt;ls_hotkey&gt; IS ASSIGNED AND zcl_abapgit_hotkeys=&gt;should_show_hint( ) = abap_true.
      ro_html-&gt;add( |&lt;div id=&quot;hotkeys-hint&quot; class=&quot;corner-hint&quot;&gt;|
        &amp;&amp; |Press &apos;{ &lt;ls_hotkey&gt;-sequence }&apos; to get keyboard shortcuts list|
        &amp;&amp; |&lt;/div&gt;| ).
    ENDIF.

  ENDMETHOD.
  METHOD render_infopanel.

    DATA lv_display TYPE string.
    DATA lv_class TYPE string.

    CREATE OBJECT ro_html.

    IF iv_hide = abap_true. &quot; Initially hide
      lv_display = &apos;display:none&apos;.
    ENDIF.

    lv_class = &apos;info-panel&apos;.
    IF iv_scrollable = abap_false. &quot; Initially hide
      lv_class = lv_class &amp;&amp; &apos; info-panel-fixed&apos;.
    ENDIF.

    ro_html-&gt;add( |&lt;div id=&quot;{ iv_div_id }&quot; class=&quot;{ lv_class }&quot; style=&quot;{ lv_display }&quot;&gt;| ).

    ro_html-&gt;add( |&lt;div class=&quot;info-title&quot;&gt;{ iv_title }|
               &amp;&amp; &apos;&lt;div class=&quot;float-right&quot;&gt;&apos;
               &amp;&amp; zcl_abapgit_html=&gt;a(
                    iv_txt   = &apos;&amp;#x274c;&apos;
                    iv_typ   = zif_abapgit_definitions=&gt;c_action_type-onclick
                    iv_act   = |toggleDisplay(&apos;{ iv_div_id }&apos;)|
                    iv_class = &apos;close-btn&apos; )
               &amp;&amp; &apos;&lt;/div&gt;&lt;/div&gt;&apos; ).

    IF iv_hint IS NOT INITIAL.
      ro_html-&gt;add( &apos;&lt;div class=&quot;info-hint&quot;&gt;&apos;
        &amp;&amp; zcl_abapgit_html=&gt;icon( iv_name = &apos;alert&apos; iv_class = &apos;pad-right&apos; )
        &amp;&amp; iv_hint
        &amp;&amp; &apos;&lt;/div&gt;&apos; ).
    ENDIF.

    ro_html-&gt;add( |&lt;div class=&quot;info-list&quot;&gt;| ).
    ro_html-&gt;add( io_content ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_item_state.

    DATA: lv_system TYPE string.

    FIELD-SYMBOLS &lt;lv_state&gt; TYPE char1.
    rv_html = &apos;&lt;span class=&quot;state-block&quot;&gt;&apos;.

    DO 2 TIMES.
      CASE sy-index.
        WHEN 1.
          ASSIGN iv_lstate TO &lt;lv_state&gt;.
          lv_system = &apos;Local:&apos;.
        WHEN 2.
          ASSIGN iv_rstate TO &lt;lv_state&gt;.
          lv_system = &apos;Remote:&apos;.
      ENDCASE.

      CASE &lt;lv_state&gt;.
        WHEN zif_abapgit_definitions=&gt;c_state-unchanged.  &quot;None or unchanged
          IF iv_lstate = zif_abapgit_definitions=&gt;c_state-added OR iv_rstate = zif_abapgit_definitions=&gt;c_state-added.
            rv_html = rv_html &amp;&amp; |&lt;span class=&quot;none&quot; title=&quot;{ lv_system } Not exists&quot;&gt;X&lt;/span&gt;|.
          ELSE.
            rv_html = rv_html &amp;&amp; |&lt;span class=&quot;none&quot; title=&quot;{ lv_system } No changes&quot;&gt;&amp;nbsp;&lt;/span&gt;|.
          ENDIF.
        WHEN zif_abapgit_definitions=&gt;c_state-modified.   &quot;Changed
          rv_html = rv_html &amp;&amp; |&lt;span class=&quot;changed&quot; title=&quot;{ lv_system } Modified&quot;&gt;M&lt;/span&gt;|.
        WHEN zif_abapgit_definitions=&gt;c_state-added.      &quot;Added new
          rv_html = rv_html &amp;&amp; |&lt;span class=&quot;added&quot; title=&quot;{ lv_system } Added new&quot;&gt;A&lt;/span&gt;|.
        WHEN zif_abapgit_definitions=&gt;c_state-mixed.      &quot;Multiple changes (multifile)
          rv_html = rv_html &amp;&amp; |&lt;span class=&quot;mixed&quot; title=&quot;{ lv_system } Multiple changes&quot;&gt;&amp;#x25A0;&lt;/span&gt;|.
        WHEN zif_abapgit_definitions=&gt;c_state-deleted.    &quot;Deleted
          rv_html = rv_html &amp;&amp; |&lt;span class=&quot;deleted&quot; title=&quot;{ lv_system } Deleted&quot;&gt;D&lt;/span&gt;|.
      ENDCASE.
    ENDDO.

    rv_html = rv_html &amp;&amp; &apos;&lt;/span&gt;&apos;.

  ENDMETHOD.
  METHOD render_js_error_banner.
    CREATE OBJECT ro_html.
    ro_html-&gt;add( &apos;&lt;div id=&quot;js-error-banner&quot; class=&quot;dummydiv error&quot;&gt;&apos; ).
    ro_html-&gt;add( |{ zcl_abapgit_html=&gt;icon( &apos;alert/red&apos; ) }| &amp;&amp;
                  &apos; If this does not disappear soon,&apos; &amp;&amp;
                  &apos; then there is a JS init error, please log an issue&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).
  ENDMETHOD.
  METHOD render_news.

    DATA: lv_text TYPE string,
          lv_hint TYPE string,
          lt_log  TYPE zcl_abapgit_news=&gt;tt_log.

    FIELD-SYMBOLS: &lt;ls_line&gt; LIKE LINE OF lt_log.

    CREATE OBJECT ro_html.

    IF io_news IS NOT BOUND OR io_news-&gt;has_news( ) = abap_false.
      RETURN.
    ENDIF.

    lt_log = io_news-&gt;get_log( ).

    &quot; Render news
    LOOP AT lt_log ASSIGNING &lt;ls_line&gt;.
      IF &lt;ls_line&gt;-is_header = abap_true.
        IF &lt;ls_line&gt;-pos_to_cur &gt; 0.
          lv_text = &lt;ls_line&gt;-text &amp;&amp; &apos;&lt;span class=&quot;version-marker update&quot;&gt;update&lt;/span&gt;&apos;.
        ELSEIF &lt;ls_line&gt;-pos_to_cur = 0.
          lv_text = &lt;ls_line&gt;-text &amp;&amp; &apos;&lt;span class=&quot;version-marker&quot;&gt;current&lt;/span&gt;&apos;.
        ELSE. &quot; &lt; 0
          lv_text = &lt;ls_line&gt;-text.
        ENDIF.
        ro_html-&gt;add( |&lt;h1&gt;{ lv_text }&lt;/h1&gt;| ).
      ELSE.
        ro_html-&gt;add( |&lt;li&gt;{ &lt;ls_line&gt;-text }&lt;/li&gt;| ).
      ENDIF.
    ENDLOOP.

    &quot; Wrap
    IF io_news-&gt;has_important( ) = abap_true.
      lv_hint = &apos;Please note changes marked with &quot;!&quot;&apos;.
    ENDIF.

    ro_html = render_infopanel(
      iv_div_id  = &apos;news&apos;
      iv_title   = &apos;Announcement of the latest changes&apos;
      iv_hint    = lv_hint
      iv_hide    = boolc( io_news-&gt;has_unseen( ) = abap_false )
      io_content = ro_html ).

  ENDMETHOD.
  METHOD render_repo_top.

    DATA: lo_repo_online TYPE REF TO zcl_abapgit_repo_online,
          lo_pback       TYPE REF TO zcl_abapgit_persist_background,
          lv_hint        TYPE string,
          lv_icon        TYPE string.
    CREATE OBJECT ro_html.
    CREATE OBJECT lo_pback.

    IF io_repo-&gt;is_offline( ) = abap_true.
      lv_icon = &apos;plug/darkgrey&apos; ##NO_TEXT.
      lv_hint = &apos;Offline repository&apos; ##NO_TEXT.
    ELSE.
      lv_icon = &apos;cloud-upload/blue&apos; ##NO_TEXT.
      lv_hint = &apos;On-line repository&apos; ##NO_TEXT.
    ENDIF.

    ro_html-&gt;add( &apos;&lt;table class=&quot;w100&quot;&gt;&lt;tr&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;td class=&quot;repo_name&quot;&gt;&apos; ).

    &quot; Repo type and name
    ro_html-&gt;add_icon( iv_name = lv_icon  iv_hint = lv_hint ).
    ro_html-&gt;add( |&lt;span class=&quot;name&quot;&gt;{ io_repo-&gt;get_name( ) }&lt;/span&gt;| ).
    IF io_repo-&gt;is_offline( ) = abap_false.
      lo_repo_online ?= io_repo.

      ro_html-&gt;add_a( iv_txt   = lo_repo_online-&gt;get_url( )
                      iv_act   = |{ zif_abapgit_definitions=&gt;c_action-url }?|
                              &amp;&amp; |{ lo_repo_online-&gt;get_url( ) }|
                      iv_class = |url| ).

    ENDIF.

    &quot; News
    IF io_news IS BOUND AND io_news-&gt;has_news( ) = abap_true.
      IF io_news-&gt;has_updates( ) = abap_true.
        lv_icon = &apos;arrow-up/warning&apos;.
      ELSE.
        lv_icon = &apos;arrow-up/grey80&apos;.
      ENDIF.
      ro_html-&gt;add_a( iv_act = |toggleDisplay(&apos;news&apos;)|
                      iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                      iv_txt = zcl_abapgit_html=&gt;icon( iv_name  = lv_icon
                                                       iv_class = &apos;pad-sides&apos;
                                                       iv_hint  = &apos;Display changelog&apos; ) ).
    ENDIF.
    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;td class=&quot;repo_attr right&quot;&gt;&apos; ).

    &quot; Fav
    IF abap_true = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;is_favorite_repo( io_repo-&gt;get_key( ) ).
      lv_icon = &apos;star/blue&apos; ##NO_TEXT.
    ELSE.
      lv_icon = &apos;star/grey&apos; ##NO_TEXT.
    ENDIF.
    ro_html-&gt;add_a( iv_act = |{ zif_abapgit_definitions=&gt;c_action-repo_toggle_fav }?{ io_repo-&gt;get_key( ) }|
                    iv_txt = zcl_abapgit_html=&gt;icon( iv_name  = lv_icon
                                                     iv_class = &apos;pad-sides&apos;
                                                     iv_hint  = &apos;Click to toggle favorite&apos; ) ).

    &quot; BG
    IF lo_pback-&gt;exists( io_repo-&gt;get_key( ) ) = abap_true.
      ro_html-&gt;add( &apos;&lt;span class=&quot;bg_marker&quot; title=&quot;background&quot;&gt;BG&lt;/span&gt;&apos; ).
    ENDIF.

    &quot; Write protect
    IF io_repo-&gt;get_local_settings( )-write_protected = abap_true.
      ro_html-&gt;add_icon( iv_name = &apos;lock/darkgrey&apos; iv_hint = &apos;Locked from pulls&apos; ).
    ENDIF.

    &quot; Branch
    IF io_repo-&gt;is_offline( ) = abap_false.
      lo_repo_online ?= io_repo.
      IF iv_show_branch = abap_true.
        IF iv_branch IS INITIAL.
          ro_html-&gt;add( render_branch_span( iv_branch      = lo_repo_online-&gt;get_branch_name( )
                                            io_repo        = lo_repo_online
                                            iv_interactive = iv_interactive_branch ) ).
        ELSE.
          ro_html-&gt;add( render_branch_span( iv_branch      = iv_branch
                                            io_repo        = lo_repo_online
                                            iv_interactive = iv_interactive_branch ) ).
        ENDIF.
      ENDIF.
    ENDIF.

    &quot; Package
    IF iv_show_package = abap_true.
      ro_html-&gt;add_icon( iv_name = &apos;package/darkgrey&apos; iv_hint = &apos;SAP package&apos; ).
      ro_html-&gt;add( &apos;&lt;span&gt;&apos; ).
      ro_html-&gt;add_a( iv_txt = io_repo-&gt;get_package( )
                      iv_act = |{ zif_abapgit_definitions=&gt;c_action-jump_pkg }?{ io_repo-&gt;get_package( ) }| ).
      ro_html-&gt;add( &apos;&lt;/span&gt;&apos; ).
    ENDIF.

    ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&lt;/table&gt;&apos; ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_ASSET_MANAGER IMPLEMENTATION.

  METHOD zif_abapgit_gui_asset_manager~get_all_assets.

    DATA:
          lt_assets TYPE zif_abapgit_gui_asset_manager=&gt;tt_web_assets,
          ls_asset  LIKE LINE OF lt_assets.

    ls_asset = get_textlike_asset( &apos;css/common.css&apos; ).
    APPEND ls_asset TO rt_assets.
    ls_asset = get_textlike_asset( &apos;js/common.js&apos; ).
    APPEND ls_asset TO rt_assets.

    lt_assets = get_inline_images( ).
    APPEND LINES OF lt_assets TO rt_assets.

  ENDMETHOD.
  METHOD get_textlike_asset.

* used by abapmerge
    DEFINE _inline.
      APPEND &amp;1 TO lt_data.
    END-OF-DEFINITION.

    DATA:
          lt_data      TYPE string_table,
          lv_mime_name TYPE wwwdatatab-objid,
          lv_str       TYPE string.

    CASE iv_asset_url.
      WHEN &apos;css/common.css&apos;.
        rs_asset-url     = iv_asset_url.
        rs_asset-type    = &apos;text&apos;.
        rs_asset-subtype = &apos;css&apos;.
        lv_mime_name     = &apos;ZABAPGIT_CSS_COMMON&apos;.
****************************************************
* abapmerge Pragma - ZABAPGIT_CSS_COMMON.W3MI.DATA.CSS
****************************************************
        _inline &apos;/*&apos;.
        _inline &apos; * ABAPGIT COMMON CSS&apos;.
        _inline &apos; */&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* GLOBALS */&apos;.
        _inline &apos;&apos;.
        _inline &apos;body {&apos;.
        _inline &apos;  font-family: Arial,Helvetica,sans-serif;&apos;.
        _inline &apos;  font-size:   12pt;&apos;.
        _inline &apos;  background:  #E8E8E8;&apos;.
        _inline &apos;  overflow-x:  hidden;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;a, a:visited {&apos;.
        _inline &apos;  color:            #4078c0;&apos;.
        _inline &apos;  text-decoration:  none;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;a:hover, a:active {&apos;.
        _inline &apos;  cursor: pointer;&apos;.
        _inline &apos;  text-decoration: underline;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;#abapGitLogo {&apos;.
        _inline &apos;  outline: none;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;img               { border: 0px; vertical-align: middle; }&apos;.
        _inline &apos;table             { border-collapse: collapse; }&apos;.
        _inline &apos;pre               { display: inline; }&apos;.
        _inline &apos;sup {&apos;.
        _inline &apos;  vertical-align: top;&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;  top: -0.5em;&apos;.
        _inline &apos;  font-size: 75%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;input, textarea, select {&apos;.
        _inline &apos;  padding: 3px 6px;&apos;.
        _inline &apos;  border: 1px solid #ddd;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;input:focus, textarea:focus {&apos;.
        _inline &apos;  border: 1px solid #8cadd9;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* COLOR PALETTE */&apos;.
        _inline &apos;.grey             { color: lightgrey  !important; }&apos;.
        _inline &apos;.grey70           { color: #b3b3b3    !important; }&apos;.
        _inline &apos;.grey80           { color: #ccc       !important; }&apos;.
        _inline &apos;.bgorange         { background-color: orange; }&apos;.
        _inline &apos;.darkgrey         { color: #808080    !important; }&apos;.
        _inline &apos;.attention        { color: red        !important; }&apos;.
        _inline &apos;.error            { color: #d41919    !important; }&apos;.
        _inline &apos;.warning          { color: #efb301    !important; }&apos;.
        _inline &apos;.success          { color: green       !important; }&apos;.
        _inline &apos;.blue             { color: #5e8dc9    !important; }&apos;.
        _inline &apos;.red              { color: red        !important; }&apos;.
        _inline &apos;.white            { color: white      !important; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* MODIFIERS */&apos;.
        _inline &apos;.emphasis         { font-weight: bold !important; }&apos;.
        _inline &apos;.crossout         { text-decoration: line-through !important; }&apos;.
        _inline &apos;.right            { text-align:right; }&apos;.
        _inline &apos;.center           { text-align:center; }&apos;.
        _inline &apos;.paddings         { padding: 0.5em 0.5em; }&apos;.
        _inline &apos;.pad-sides        { padding-left: 0.3em; padding-right: 0.3em; }&apos;.
        _inline &apos;.margin-v5        { margin-top: 0.5em; margin-bottom: 0.5em; }&apos;.
        _inline &apos;.indent5em        { padding-left: 0.5em; }&apos;.
        _inline &apos;.pad4px           { padding: 4px; }&apos;.
        _inline &apos;.w100             { width: 100%; }&apos;.
        _inline &apos;.w40              { width: 40%; }&apos;.
        _inline &apos;.float-right      { float: right; }&apos;.
        _inline &apos;.pad-right        { padding-right: 6px; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* STRUCTURE DIVS, HEADER &amp; FOOTER */&apos;.
        _inline &apos;div#header {&apos;.
        _inline &apos;  padding:          0.5em 0.5em;&apos;.
        _inline &apos;  border-bottom:    3px double lightgrey;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div#header td.logo       { width: 164px; }&apos;.
        _inline &apos;div#header td:not(.logo) { padding-top: 11px; } /* align with logo H */&apos;.
        _inline &apos;div#header span.page_title {&apos;.
        _inline &apos;  font-weight: normal;&apos;.
        _inline &apos;  font-size: 18pt;&apos;.
        _inline &apos;  color: #bbb;&apos;.
        _inline &apos;  padding-left: 0.4em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div#toc {&apos;.
        _inline &apos;  padding:          0.5em 1em;&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div#toc .favorites a { opacity: 0.5; }&apos;.
        _inline &apos;div#toc .favorites:hover a { opacity: 1; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;div#footer {&apos;.
        _inline &apos;  padding:          0.5em 1em;&apos;.
        _inline &apos;  border-top:       3px double lightgrey;&apos;.
        _inline &apos;  text-align:       center;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div#footer span.version {&apos;.
        _inline &apos;  display: block;&apos;.
        _inline &apos;  color: grey;&apos;.
        _inline &apos;  margin-top: 0.3em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;#debug-output {&apos;.
        _inline &apos;  text-align: right;&apos;.
        _inline &apos;  padding-right: 0.5em;&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  font-style: italic;&apos;.
        _inline &apos;  font-size: small;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.dummydiv {&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;  padding:          0.5em 1em;&apos;.
        _inline &apos;  text-align:       center;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* ERROR LOG */&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.log {&apos;.
        _inline &apos;  padding: 6px;&apos;.
        _inline &apos;  margin: 4px;&apos;.
        _inline &apos;  background-color: #fee6e6;&apos;.
        _inline &apos;  border: 1px #fdcece solid;&apos;.
        _inline &apos;  border-radius: 4px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.log &gt; span   { display:block; }&apos;.
        _inline &apos;div.log .octicon { padding-right: 6px; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* REPOSITORY */&apos;.
        _inline &apos;div.repo {&apos;.
        _inline &apos;  margin-top:       3px;&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;  padding: 0.5em 1em 0.5em 1em;&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_name span.name {&apos;.
        _inline &apos;  font-weight: bold;&apos;.
        _inline &apos;  color: #333;&apos;.
        _inline &apos;  font-size: 14pt;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_name a.url {&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  font-size: 12pt;&apos;.
        _inline &apos;  margin-left: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_name span.url {&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  font-size: 12pt;&apos;.
        _inline &apos;  margin-left: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_name img {&apos;.
        _inline &apos;  vertical-align: baseline;&apos;.
        _inline &apos;  margin: 0 5px 0 5px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr {&apos;.
        _inline &apos;  color: grey;&apos;.
        _inline &apos;  font-size: 12pt;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr span {&apos;.
        _inline &apos;  margin-left: 0.2em;&apos;.
        _inline &apos;  margin-right: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr span.bg_marker {&apos;.
        _inline &apos;  border: 1px solid #d2d2d2;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  background: #d8d8d8;&apos;.
        _inline &apos;  color: #fff;&apos;.
        _inline &apos;  font-size: 8pt;&apos;.
        _inline &apos;  padding: 4px 2px 3px 2px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr span.branch {&apos;.
        _inline &apos;  padding: 2px 4px;&apos;.
        _inline &apos;  border: 1px solid #d9d9d9;&apos;.
        _inline &apos;  border-radius: 4px;&apos;.
        _inline &apos;  background-color: #e2e2e2;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr span.branch_head {&apos;.
        _inline &apos;  border-color: #d8dff3;&apos;.
        _inline &apos;  background-color: #eceff9;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_attr span.branch_branch {&apos;.
        _inline &apos;  border-color: #e7d9b1;&apos;.
        _inline &apos;  background-color: #f8f0d8;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* MISC AND REFACTOR */&apos;.
        _inline &apos;.hidden-submit {&apos;.
        _inline &apos;  border: 0 none;&apos;.
        _inline &apos;  height: 0;&apos;.
        _inline &apos;  width: 0;&apos;.
        _inline &apos;  padding: 0;&apos;.
        _inline &apos;  margin: 0;&apos;.
        _inline &apos;  overflow: hidden;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* REPOSITORY TABLE*/&apos;.
        _inline &apos;div.repo_container {&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.repo_tab {&apos;.
        _inline &apos;  border: 1px solid #DDD;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  background: #fff;&apos;.
        _inline &apos;  width: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td {&apos;.
        _inline &apos;  border-top: 1px solid #eee;&apos;.
        _inline &apos;  vertical-align: middle;&apos;.
        _inline &apos;  color: #333;&apos;.
        _inline &apos;  padding-top: 2px;&apos;.
        _inline &apos;  padding-bottom: 2px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.icon {&apos;.
        _inline &apos;  width: 32px;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.icon:not(:first-child) {&apos;.
        _inline &apos;  width: 26px;&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.type {&apos;.
        _inline &apos;  width: 3em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.object {&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.files {&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd {&apos;.
        _inline &apos;  text-align: right;&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;  padding-right: 0.7em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab tr.unsupported    { color: lightgrey; }&apos;.
        _inline &apos;.repo_tab tr.modified       { background: #fbf7e9; }&apos;.
        _inline &apos;.repo_tab tr:first-child td { border-top: 0px; }&apos;.
        _inline &apos;.repo_tab td.current_dir    { color: #ccc; }&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block {&apos;.
        _inline &apos;  margin-left: 1em;&apos;.
        _inline &apos;  font-family: Consolas, Lucida Console, Courier, monospace;&apos;.
        _inline &apos;  font-size: x-small;&apos;.
        _inline &apos;  vertical-align: 13%;&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span {&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  padding: 0px 2px;&apos;.
        _inline &apos;  border: 1px solid #000;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span.added {&apos;.
        _inline &apos;  background-color: #69ad74;&apos;.
        _inline &apos;  border-color: #579e64;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span.changed {&apos;.
        _inline &apos;  background-color: #e0c150;&apos;.
        _inline &apos;  border-color: #d4af25;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span.mixed {&apos;.
        _inline &apos;  background-color: #e0c150;&apos;.
        _inline &apos;  border-color: #579e64;&apos;.
        _inline &apos;  color: #69ad74;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span.deleted {&apos;.
        _inline &apos;  background-color: #c76861;&apos;.
        _inline &apos;  border-color: #b8605a;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab td.cmd span.state-block span.none {&apos;.
        _inline &apos;  background-color: #e8e8e8;&apos;.
        _inline &apos;  border-color: #dbdbdb;&apos;.
        _inline &apos;  color: #c8c8c8;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.repo_tab .inactive       { color: orange; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* STAGE */&apos;.
        _inline &apos;div.stage-container { width: 850px; }&apos;.
        _inline &apos;input.stage-filter { width: 18em; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;.stage_tab {&apos;.
        _inline &apos;  border: 1px solid #DDD;&apos;.
        _inline &apos;  background: #fff;&apos;.
        _inline &apos;  margin-top: 0.2em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.stage_tab td {&apos;.
        _inline &apos;  border-top: 1px solid #eee;&apos;.
        _inline &apos;  color: #333;&apos;.
        _inline &apos;  vertical-align: middle;&apos;.
        _inline &apos;  padding: 2px 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.stage_tab th {&apos;.
        _inline &apos;  color: #BBB;&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;  font-weight: normal;&apos;.
        _inline &apos;  background-color: #edf2f9;&apos;.
        _inline &apos;  padding: 4px 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.stage_tab td.status {&apos;.
        _inline &apos;  width: 2em;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  background-color: #fafafa;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.stage_tab td.highlight {&apos;.
        _inline &apos;  color: #444 !important;&apos;.
        _inline &apos;  font-weight: bold;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.stage_tab td.cmd {  cursor: pointer; }&apos;.
        _inline &apos;.stage_tab td.cmd a { padding: 0px 4px; }&apos;.
        _inline &apos;.stage_tab th.cmd a { padding: 0px 4px; }&apos;.
        _inline &apos;.stage_tab td.method { color: #ccc; }&apos;.
        _inline &apos;.stage_tab td.user { color: #aaa; }&apos;.
        _inline &apos;.stage_tab td.type { color: #aaa; }&apos;.
        _inline &apos;.stage_tab tbody tr:first-child td { padding-top: 0.5em; }&apos;.
        _inline &apos;.stage_tab tbody tr:last-child td { padding-bottom: 0.5em; }&apos;.
        _inline &apos;.stage_tab mark {&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;  background-color: #79a0d2;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* COMMIT */&apos;.
        _inline &apos;div.form-container {&apos;.
        _inline &apos;  background-color: #F8F8F8;&apos;.
        _inline &apos;  padding: 1em 1em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;form.aligned-form {&apos;.
        _inline &apos;  display: table;&apos;.
        _inline &apos;  border-spacing: 2px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;form.aligned-form label {&apos;.
        _inline &apos;  color: #BBB;&apos;.
        _inline &apos;  padding-right: 1em;&apos;.
        _inline &apos;  vertical-align: middle;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;form.aligned-form select {&apos;.
        _inline &apos;  padding-right: 1em;&apos;.
        _inline &apos;  vertical-align: middle;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;form.aligned-form span.sub-title {&apos;.
        _inline &apos;  color: #BBB;&apos;.
        _inline &apos;  font-size: smaller;&apos;.
        _inline &apos;  padding-top: 8px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;form.aligned-form div.row { display: table-row; }&apos;.
        _inline &apos;form.aligned-form label { display: table-cell; }&apos;.
        _inline &apos;form.aligned-form input { display: table-cell; }&apos;.
        _inline &apos;form.aligned-form input[type=&quot;text&quot;] { width: 25em; }&apos;.
        _inline &apos;form.aligned-form span.cell { display: table-cell; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* SETTINGS STYLES */&apos;.
        _inline &apos;div.settings_container {&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;  font-size: 10pt;&apos;.
        _inline &apos;  color: #444;&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.settings_section {&apos;.
        _inline &apos;  margin-left:50px&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DIFF */&apos;.
        _inline &apos;div.diff {&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;  padding: 0.7em&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head {&apos;.
        _inline &apos;  padding-bottom: 0.7em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;span.diff_name {&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;  color: grey;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;span.diff_changed_by {&apos;.
        _inline &apos;  color: grey;&apos;.
        _inline &apos;  float: right;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;span.diff_changed_by span.user {&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  border: solid 1px #c2d4ea;&apos;.
        _inline &apos;  background-color: #d9e4f2;&apos;.
        _inline &apos;  padding: 1px 0.4em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;span.diff_name strong {&apos;.
        _inline &apos;  color: #333;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;span.diff_banner {&apos;.
        _inline &apos;  border-style: solid;&apos;.
        _inline &apos;  border-width: 1px;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  padding-left: 0.3em;&apos;.
        _inline &apos;  padding-right: 0.3em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.diff_ins {&apos;.
        _inline &apos;  border-color: #abf2ab;&apos;.
        _inline &apos;  background-color: #e0ffe0;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.diff_del {&apos;.
        _inline &apos;  border-color: #ff667d;&apos;.
        _inline &apos;  background-color: #ffccd4;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.diff_upd {&apos;.
        _inline &apos;  border-color: #dada00;&apos;.
        _inline &apos;  background-color: #ffffcc;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_content {&apos;.
        _inline &apos;  background: #fff;&apos;.
        _inline &apos;  border-top: 1px solid #DDD;&apos;.
        _inline &apos;  border-bottom: 1px solid #DDD;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.diff_content tbody tr td{&apos;.
        _inline &apos;  width: 50%;&apos;.
        _inline &apos;  vertical-align: top&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.diff_head span.state-block {&apos;.
        _inline &apos;  margin-left: 0.5em;&apos;.
        _inline &apos;  font-family: Consolas, Lucida Console, Courier, monospace;&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span {&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  padding: 0px 4px;&apos;.
        _inline &apos;  border: 1px solid #000;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span.added {&apos;.
        _inline &apos;  background-color: #69ad74;&apos;.
        _inline &apos;  border-color: #579e64;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span.changed {&apos;.
        _inline &apos;  background-color: #e0c150;&apos;.
        _inline &apos;  border-color: #d4af25;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span.mixed {&apos;.
        _inline &apos;  background-color: #e0c150;&apos;.
        _inline &apos;  border-color: #579e64;&apos;.
        _inline &apos;  color: #69ad74;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span.deleted {&apos;.
        _inline &apos;  background-color: #c76861;&apos;.
        _inline &apos;  border-color: #b8605a;&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.diff_head span.state-block span.none {&apos;.
        _inline &apos;  background-color: #e8e8e8;&apos;.
        _inline &apos;  border-color: #dbdbdb;&apos;.
        _inline &apos;  color: #c8c8c8;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DIFF TABLE */&apos;.
        _inline &apos;table.diff_tab {&apos;.
        _inline &apos;  font-family: Consolas, Courier, monospace;&apos;.
        _inline &apos;  font-size: 10pt;&apos;.
        _inline &apos;  width: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab td,th {&apos;.
        _inline &apos;  color: #444;&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;  padding-right: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab th {&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;  font-weight: normal;&apos;.
        _inline &apos;  padding-top: 3px;&apos;.
        _inline &apos;  padding-bottom: 3px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab thead.header th {&apos;.
        _inline &apos;  color: #EEE;&apos;.
        _inline &apos;  background-color: #BBB;&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;  font-weight: bold;&apos;.
        _inline &apos;  padding-left: 0.5em;&apos;.
        _inline &apos;  font-size: 9pt;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab thead.nav_line {&apos;.
        _inline &apos;  background-color: #edf2f9;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab thead.nav_line th {&apos;.
        _inline &apos;  color: #bbb;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab td.num, th.num {&apos;.
        _inline &apos;  width: 1%;&apos;.
        _inline &apos;  min-width: 2em;&apos;.
        _inline &apos;  padding-right: 8px;&apos;.
        _inline &apos;  padding-left:  8px;&apos;.
        _inline &apos;  text-align: right !important;&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  border-left: 1px solid #eee;&apos;.
        _inline &apos;  border-right: 1px solid #eee;&apos;.
        _inline &apos;  -ms-user-select: none;&apos;.
        _inline &apos;  user-select: none;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab td.patch, th.patch {&apos;.
        _inline &apos;  width: 1%;&apos;.
        _inline &apos;  min-width: 6em;&apos;.
        _inline &apos;  padding-right: 8px;&apos;.
        _inline &apos;  padding-left:  8px;&apos;.
        _inline &apos;  text-align: right !important;&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;  border-left: 1px solid #eee;&apos;.
        _inline &apos;  border-right: 1px solid #eee;&apos;.
        _inline &apos;  -ms-user-select: none;&apos;.
        _inline &apos;  user-select: none;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab td.num::before {&apos;.
        _inline &apos;  content: attr(line-num);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab code {&apos;.
        _inline &apos;  font-family: inherit;&apos;.
        _inline &apos;  white-space: pre;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.diff_tab td.code {&apos;.
        _inline &apos;  word-wrap: break-word;&apos;.
        _inline &apos;  white-space: pre-wrap;&apos;.
        _inline &apos;  overflow: visible;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;table.diff_tab tbody tr:first-child td { padding-top: 0.5em; }&apos;.
        _inline &apos;table.diff_tab tbody tr:last-child td { padding-bottom: 0.5em; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* STYLES for Syntax Highlighting */&apos;.
        _inline &apos;.syntax-hl span.keyword  { color: #0a69ce; }&apos;.
        _inline &apos;.syntax-hl span.text     { color: #48ce4f; }&apos;.
        _inline &apos;.syntax-hl span.comment  { color: #808080; font-style: italic; }&apos;.
        _inline &apos;.syntax-hl span.xml_tag  { color: #457ce3; }&apos;.
        _inline &apos;.syntax-hl span.attr     { color: #b777fb; }&apos;.
        _inline &apos;.syntax-hl span.attr_val { color: #7a02f9; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DEBUG INFO STYLES */&apos;.
        _inline &apos;div.debug_container {&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;  font-size: 10pt;&apos;.
        _inline &apos;  color: #444;&apos;.
        _inline &apos;  font-family: Consolas, Courier, monospace;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.debug_container p {&apos;.
        _inline &apos;  margin: 0px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DB ENTRIES */&apos;.
        _inline &apos;div.db_list {&apos;.
        _inline &apos;  background-color: #fff;&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;  overflow-x: auto;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;table.db_tab pre {&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  overflow: hidden;&apos;.
        _inline &apos;  word-wrap:break-word;&apos;.
        _inline &apos;  white-space: pre-wrap;&apos;.
        _inline &apos;  margin: 0px;&apos;.
        _inline &apos;  width: 30em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;table.db_tab tr.firstrow td { padding-top: 0.5em; }&apos;.
        _inline &apos;table.db_tab th {&apos;.
        _inline &apos;  color: #888888;&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;  border-bottom: 1px #ddd solid;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.db_tab td {&apos;.
        _inline &apos;  color: #333;&apos;.
        _inline &apos;  padding: 4px 8px;&apos;.
        _inline &apos;  vertical-align: middle;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.db_tab td.data {&apos;.
        _inline &apos;  color: #888;&apos;.
        _inline &apos;  font-style: italic;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;table.db_tab tbody tr:hover, tr:active {&apos;.
        _inline &apos;  background-color: #f4f4f4;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DB ENTRY DISPLAY */&apos;.
        _inline &apos;div.db_entry {&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.db_entry pre {&apos;.
        _inline &apos;  display: block;&apos;.
        _inline &apos;  font-size: 10pt;&apos;.
        _inline &apos;  overflow: hidden;&apos;.
        _inline &apos;  word-wrap:break-word;&apos;.
        _inline &apos;  white-space: pre-wrap;&apos;.
        _inline &apos;  background-color: #fcfcfc;&apos;.
        _inline &apos;  border: 1px #eaeaea solid;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  padding: 0.5em;&apos;.
        _inline &apos;  margin: 0.5em 0em;&apos;.
        _inline &apos;  width: 60em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.db_entry table.toolbar {&apos;.
        _inline &apos;  width: 50em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;table.tag {&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  border: 1px #b3c1cc solid;&apos;.
        _inline &apos;  background-color: #eee;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  margin-right: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.tag td { padding: 0.2em 0.5em; }&apos;.
        _inline &apos;table.tag td.label { background-color: #b3c1cc; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* DB ENTRY DISPLAY */&apos;.
        _inline &apos;div.db_entry textarea { margin: 0.5em 0em; }&apos;.
        _inline &apos;table.tag {&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  border: 1px #b3c1cc solid;&apos;.
        _inline &apos;  background-color: #eee;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  margin-right: 0.5em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;table.tag td { padding: 0.2em 0.5em; }&apos;.
        _inline &apos;table.tag td.label { background-color: #b3c1cc; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* TUTORIAL */&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.tutorial {&apos;.
        _inline &apos;  margin-top:       3px;&apos;.
        _inline &apos;  background-color: #f2f2f2;&apos;.
        _inline &apos;  padding: 0.5em 1em 0.5em 1em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.tutorial hr { border-color: #CCC; }&apos;.
        _inline &apos;div.tutorial li { margin: 2px 0px }&apos;.
        _inline &apos;div.tutorial h1 {&apos;.
        _inline &apos;  font-size: 18pt;&apos;.
        _inline &apos;  color: #404040;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;div.tutorial h2 {&apos;.
        _inline &apos;  font-size: 14pt;&apos;.
        _inline &apos;  color: #404040;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* NEW MENU */&apos;.
        _inline &apos;/* Special credits to example at https://codepen.io/philhoyt/pen/ujHzd */&apos;.
        _inline &apos;/* container div, aligned left, &apos;.
        _inline &apos;   but with .float-right modifier alignes right */&apos;.
        _inline &apos;.nav-container ul&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  list-style: none;&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;  float: left;&apos;.
        _inline &apos;  margin: 0;&apos;.
        _inline &apos;  padding: 0;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container.float-right ul { float: right; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul a&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  display: block;&apos;.
        _inline &apos;  text-decoration: none;&apos;.
        _inline &apos;  line-height: 30px;&apos;.
        _inline &apos;  padding: 0 12px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* clearfix https://css-tricks.com/snippets/css/clear-fix/ */&apos;.
        _inline &apos;.nav-container:after { clear: both; display: block; content: &quot;&quot;; } &apos;.
        _inline &apos;&apos;.
        _inline &apos;/* submenues align to left or right border of the active item&apos;.
        _inline &apos;   depending on .float-right modifier */&apos;.
        _inline &apos;.nav-container ul li&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;  float: left;&apos;.
        _inline &apos;  margin: 0;&apos;.
        _inline &apos;  padding: 0;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container.float-right ul ul { left: auto; right: 0; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul li.current-menu-item { font-weight: 700; }&apos;.
        _inline &apos;.nav-container ul li.block ul { display: block; }&apos;.
        _inline &apos;.nav-container ul li:hover &gt; ul { display: block; }&apos;.
        _inline &apos;.nav-container ul ul li:hover { background-color: #f6f6f6; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* special selection style for 1st level items (see also .corner below) */&apos;.
        _inline &apos;.nav-container &gt; ul &gt; li:hover &gt; a { &apos;.
        _inline &apos;  background-color: rgba(255, 255, 255, 0.5); &apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul ul&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  display: none;&apos;.
        _inline &apos;  position: absolute;&apos;.
        _inline &apos;  top: 100%;&apos;.
        _inline &apos;  left: 0;&apos;.
        _inline &apos;  z-index: 1;&apos;.
        _inline &apos;  background: #fff;&apos;.
        _inline &apos;  padding: 0;&apos;.
        _inline &apos;  box-shadow: 1px 1px 3px 0px #bbb;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul ul li&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  float: none;&apos;.
        _inline &apos;  min-width: 160px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul ul a&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  line-height: 120%;&apos;.
        _inline &apos;  padding: 8px 15px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container ul ul ul&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  top: 0;&apos;.
        _inline &apos;  left: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.nav-container.float-right ul ul ul&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  left: auto;&apos;.
        _inline &apos;  right: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* Minizone to extent hover area, &apos;.
        _inline &apos;   aligned to the left or to the right of the selected item &apos;.
        _inline &apos;   depending on .float-right modifier */&apos;.
        _inline &apos;.nav-container &gt; ul &gt; li &gt; div.minizone {&apos;.
        _inline &apos;  display: none;&apos;.
        _inline &apos;  z-index: 1;&apos;.
        _inline &apos;  position: absolute;&apos;.
        _inline &apos;  padding: 0px;&apos;.
        _inline &apos;  width: 16px;&apos;.
        _inline &apos;  height: 100%;&apos;.
        _inline &apos;  bottom: 0px;&apos;.
        _inline &apos;  left: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container &gt; ul &gt; li:hover div.minizone { display: block; }&apos;.
        _inline &apos;.nav-container.float-right &gt; ul &gt; li &gt; div.minizone {&apos;.
        _inline &apos;  left: auto;&apos;.
        _inline &apos;  right: 100%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* icons - text-align strictly left - otherwise look ugly&apos;.
        _inline &apos;   + bite a bit of left padding for nicer look &apos;.
        _inline &apos;   + forbids item text wrapping (maybe can be done differently) */&apos;.
        _inline &apos;.nav-container ul ul li a .octicon {&apos;.
        _inline &apos;  padding-right: 10px;&apos;.
        _inline &apos;  margin-left: -3px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container ul.with-icons li {&apos;.
        _inline &apos;  text-align: left;&apos;.
        _inline &apos;  white-space: nowrap;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* Special .corner modifier - hangs menu at the top right corner&apos;.
        _inline &apos;   and cancels 1st level background coloring */&apos;.
        _inline &apos;.nav-container.corner {&apos;.
        _inline &apos;  position: absolute;&apos;.
        _inline &apos;  right: 0px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container.corner &gt; ul &gt; li:hover &gt; a { background-color: inherit; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* Toolbar separator style */&apos;.
        _inline &apos;.nav-container ul ul li.separator&apos;.
        _inline &apos;{&apos;.
        _inline &apos;  font-size: x-small;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;  padding: 4px 0;&apos;.
        _inline &apos;  text-transform: uppercase;&apos;.
        _inline &apos;  color: #bbb;&apos;.
        _inline &apos;  border-bottom: 1px solid #eee;&apos;.
        _inline &apos;  border-top: 1px solid #eee;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;.nav-container ul ul li.separator:first-child { border-top: none; }&apos;.
        _inline &apos;.nav-container ul ul li.separator:hover { background-color: inherit; }&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* News Announcement */&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel { &apos;.
        _inline &apos;  position: absolute;&apos;.
        _inline &apos;  z-index: 99;&apos;.
        _inline &apos;  top: 36px;&apos;.
        _inline &apos;  left: 50%;&apos;.
        _inline &apos;  width: 40em;&apos;.
        _inline &apos;  margin-left: -20em;&apos;.
        _inline &apos;  background-color: white;&apos;.
        _inline &apos;  box-shadow: 1px 1px 3px 2px #dcdcdc;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel-fixed { &apos;.
        _inline &apos;  position: fixed;&apos;.
        _inline &apos;  top: 15%;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel div.info-hint {&apos;.
        _inline &apos;  text-transform: uppercase;&apos;.
        _inline &apos;  font-size: small;&apos;.
        _inline &apos;  padding: 8px 6px 0px;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;  color: #ccc;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel div.info-title {&apos;.
        _inline &apos;  text-transform: uppercase;&apos;.
        _inline &apos;  font-size: small;&apos;.
        _inline &apos;  padding: 6px;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;  color: #f8f8f8;&apos;.
        _inline &apos;  background-color: #888;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel div.info-title a.close-btn { &apos;.
        _inline &apos;  color: #d8d8d8; &apos;.
        _inline &apos;  padding-left: 12px; &apos;.
        _inline &apos;  padding-right: 2px;&apos;.
        _inline &apos;  position: relative;&apos;.
        _inline &apos;  bottom: 1px;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel div.info-list {&apos;.
        _inline &apos;  padding: 0.8em 0.7em 1em;&apos;.
        _inline &apos;  color: #444;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel li {&apos;.
        _inline &apos;  padding-left: 10px;&apos;.
        _inline &apos;  list-style-type: none;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel h1:first-child { margin: auto; }&apos;.
        _inline &apos;div.info-panel h1 { &apos;.
        _inline &apos;  font-size: inherit;&apos;.
        _inline &apos;  padding: 6px 4px;&apos;.
        _inline &apos;  margin: 4px auto auto;&apos;.
        _inline &apos;  text-decoration: underline;&apos;.
        _inline &apos;  font-weight: normal;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel .version-marker {&apos;.
        _inline &apos;  color: white;&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  margin-left: 20px;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  padding: 0px 6px;&apos;.
        _inline &apos;  border: #c0c0c0 1px solid;&apos;.
        _inline &apos;  background-color: #ccc;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel .update {&apos;.
        _inline &apos;  border: #e8ba30 1px solid;&apos;.
        _inline &apos;  background-color: #f5c538;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.info-panel div.info-list td {&apos;.
        _inline &apos;  padding-right: 1em&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* Tooltip text */&apos;.
        _inline &apos;.tooltiptext {&apos;.
        _inline &apos;    line-height: 15px;&apos;.
        _inline &apos;    width: 60px;&apos;.
        _inline &apos;    color: #000;&apos;.
        _inline &apos;    text-align: center;&apos;.
        _inline &apos;    padding: 5px 0;&apos;.
        _inline &apos;    border-radius: 6px;&apos;.
        _inline &apos;&apos;.
        _inline &apos;    /* Position the tooltip text */&apos;.
        _inline &apos;    position: absolute;&apos;.
        _inline &apos;    z-index: 1;&apos;.
        _inline &apos;    margin-left: -60px;&apos;.
        _inline &apos;    margin-top: -30px;&apos;.
        _inline &apos;&apos;.
        _inline &apos;    /* Fade in tooltip */&apos;.
        _inline &apos;    opacity: 1;&apos;.
        _inline &apos;    transition: opacity 0.3s;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;.hidden {&apos;.
        _inline &apos;  visibility: hidden;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* Tooltip arrow */&apos;.
        _inline &apos;.tooltiptext::after {&apos;.
        _inline &apos;    content: &quot;&quot;;&apos;.
        _inline &apos;    position: absolute;&apos;.
        _inline &apos;    top: 100%;&apos;.
        _inline &apos;    left: 50%;&apos;.
        _inline &apos;    margin-left: -5px;&apos;.
        _inline &apos;    border-width: 5px;&apos;.
        _inline &apos;    border-style: solid;&apos;.
        _inline &apos;    border-color: #555 transparent transparent transparent;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* diff-patch */&apos;.
        _inline &apos;.patch-active {&apos;.
        _inline &apos;  color: lightgrey !important; &apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/* HOTKEYS */&apos;.
        _inline &apos;&apos;.
        _inline &apos;ul.hotkeys {&apos;.
        _inline &apos;  list-style-type: none;&apos;.
        _inline &apos;  padding: 0;&apos;.
        _inline &apos;  margin: 0;&apos;.
        _inline &apos;  font-size: smaller;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;ul.hotkeys span.key-id {&apos;.
        _inline &apos;  background: #f0f0f0;&apos;.
        _inline &apos;  border: 1px solid #dcdcdc;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  padding: 1px 7px;&apos;.
        _inline &apos;  width: 0.5em;&apos;.
        _inline &apos;  display: inline-block;&apos;.
        _inline &apos;  text-align: center;&apos;.
        _inline &apos;  margin-top: 0.2em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;ul.hotkeys span.key-descr {&apos;.
        _inline &apos;  margin-left: 1.2em;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;div.corner-hint {&apos;.
        _inline &apos;  position: fixed;&apos;.
        _inline &apos;  bottom: 10px;&apos;.
        _inline &apos;  right: 10px;&apos;.
        _inline &apos;  color: #aaa;&apos;.
        _inline &apos;  border: 1px solid #ccc;&apos;.
        _inline &apos;  border-radius: 3px;&apos;.
        _inline &apos;  padding: 4px;&apos;.
        _inline &apos;  font-size: smaller;&apos;.
        _inline &apos;  opacity: 0.5;&apos;.
        _inline &apos;  background: white;&apos;.
        _inline &apos;  z-index: 99;&apos;.
        _inline &apos;}&apos;.
      WHEN &apos;js/common.js&apos;.
        rs_asset-url     = iv_asset_url.
        rs_asset-type    = &apos;text&apos;.
        rs_asset-subtype = &apos;javascript&apos;.
        lv_mime_name     = &apos;ZABAPGIT_JS_COMMON&apos;.
****************************************************
* abapmerge Pragma - ZABAPGIT_JS_COMMON.W3MI.DATA.JS
****************************************************
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * ABAPGIT JS function library&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Polyfills&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Bind polyfill (for IE7), taken from https://developer.mozilla.org/&apos;.
        _inline &apos;if (!Function.prototype.bind) {&apos;.
        _inline &apos;  Function.prototype.bind = function(oThis) {&apos;.
        _inline &apos;    if (typeof this !== &quot;function&quot;) {&apos;.
        _inline &apos;      throw new TypeError(&quot;Function.prototype.bind - subject is not callable&quot;);&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;&apos;.
        _inline &apos;    var aArgs   = Array.prototype.slice.call(arguments, 1),&apos;.
        _inline &apos;        fToBind = this,&apos;.
        _inline &apos;        fNOP    = function() {},&apos;.
        _inline &apos;        fBound  = function() {&apos;.
        _inline &apos;          return fToBind.apply(this instanceof fNOP&apos;.
        _inline &apos;                 ? this&apos;.
        _inline &apos;                 : oThis,&apos;.
        _inline &apos;                 aArgs.concat(Array.prototype.slice.call(arguments)));&apos;.
        _inline &apos;        };&apos;.
        _inline &apos;&apos;.
        _inline &apos;    if (this.prototype) {&apos;.
        _inline &apos;      fNOP.prototype = this.prototype;&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;    fBound.prototype = new fNOP();&apos;.
        _inline &apos;&apos;.
        _inline &apos;    return fBound;&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// String includes polyfill, taken from https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String/includes&apos;.
        _inline &apos;if (!String.prototype.includes) {&apos;.
        _inline &apos;  String.prototype.includes = function(search, start) {&apos;.
        _inline &apos;    &apos;&apos;use strict&apos;&apos;;&apos;.
        _inline &apos;    if (typeof start !== &apos;&apos;number&apos;&apos;) {&apos;.
        _inline &apos;      start = 0;&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;&apos;.
        _inline &apos;    if (start + search.length &gt; this.length) {&apos;.
        _inline &apos;      return false;&apos;.
        _inline &apos;    } else {&apos;.
        _inline &apos;      return this.indexOf(search, start) !== -1;&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Common functions&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Output text to the debug div&apos;.
        _inline &apos;function debugOutput(text, dstID) {&apos;.
        _inline &apos;  var stdout       = document.getElementById(dstID || &quot;debug-output&quot;);&apos;.
        _inline &apos;  var wrapped      = &quot;&lt;p&gt;&quot; + text + &quot;&lt;/p&gt;&quot;;&apos;.
        _inline &apos;  stdout.innerHTML = stdout.innerHTML + wrapped;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Create hidden form and submit with sapevent&apos;.
        _inline &apos;function submitSapeventForm(params, action, method) {&apos;.
        _inline &apos;  var form = document.createElement(&quot;form&quot;);&apos;.
        _inline &apos;  form.setAttribute(&quot;method&quot;, method || &quot;post&quot;);&apos;.
        _inline &apos;  form.setAttribute(&quot;action&quot;, &quot;sapevent:&quot; + action);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  for(var key in params) {&apos;.
        _inline &apos;    var hiddenField = document.createElement(&quot;input&quot;);&apos;.
        _inline &apos;    hiddenField.setAttribute(&quot;type&quot;, &quot;hidden&quot;);&apos;.
        _inline &apos;    hiddenField.setAttribute(&quot;name&quot;, key);&apos;.
        _inline &apos;    hiddenField.setAttribute(&quot;value&quot;, params[key]);&apos;.
        _inline &apos;    form.appendChild(hiddenField);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  document.body.appendChild(form);&apos;.
        _inline &apos;  form.submit();&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Set focus to a control&apos;.
        _inline &apos;function setInitialFocus(id) {&apos;.
        _inline &apos;  document.getElementById(id).focus();&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Set focus to a element with query selector&apos;.
        _inline &apos;function setInitialFocusWithQuerySelector(sSelector, bFocusParent) {&apos;.
        _inline &apos;  var oSelected = document.querySelector(sSelector);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (oSelected) {&apos;.
        _inline &apos;    if (bFocusParent) {&apos;.
        _inline &apos;      oSelected.parentElement.focus();&apos;.
        _inline &apos;    } else {&apos;.
        _inline &apos;      oSelected.focus();&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Submit an existing form&apos;.
        _inline &apos;function submitFormById(id) {&apos;.
        _inline &apos;  document.getElementById(id).submit();&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// JS error stub&apos;.
        _inline &apos;function errorStub(event) {&apos;.
        _inline &apos;  var element    = event.target || event.srcElement;&apos;.
        _inline &apos;  var targetName = element.id || element.name || &quot;???&quot;;&apos;.
        _inline &apos;  alert(&quot;JS Error, please log an issue (@&quot; + targetName + &quot;)&quot;);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// confirm JS initilization&apos;.
        _inline &apos;function confirmInitialized() {&apos;.
        _inline &apos;  var errorBanner = document.getElementById(&quot;js-error-banner&quot;);&apos;.
        _inline &apos;  if (errorBanner) {&apos;.
        _inline &apos;    errorBanner.style.display = &quot;none&quot;;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;  debugOutput(&quot;js: OK&quot;); // Final final confirmation :)&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Performance utils (for debugging)&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;var gPerf = [];&apos;.
        _inline &apos;&apos;.
        _inline &apos;function perfOut(prefix) {&apos;.
        _inline &apos;  var totals = {};&apos;.
        _inline &apos;  for (var i = gPerf.length - 1; i &gt;= 0; i--) {&apos;.
        _inline &apos;    if (!totals[gPerf[i].name]) totals[gPerf[i].name] = {count: 0, time: 0};&apos;.
        _inline &apos;    totals[gPerf[i].name].time  += gPerf[i].time;&apos;.
        _inline &apos;    totals[gPerf[i].name].count += 1;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var keys = Object.keys(totals);&apos;.
        _inline &apos;  for (var i = keys.length - 1; i &gt;= 0; i--) {&apos;.
        _inline &apos;    console.log(prefix&apos;.
        _inline &apos;      + &quot; &quot; + keys[i] + &quot;: &quot;&apos;.
        _inline &apos;      + totals[keys[i]].time.toFixed(3) + &quot;ms&quot;&apos;.
        _inline &apos;      + &quot; (&quot; + totals[keys[i]].count.toFixed() +&quot;)&quot;);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function perfLog(name, startTime) {&apos;.
        _inline &apos;  gPerf.push({name: name, time: window.performance.now() - startTime});&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function perfClear() {&apos;.
        _inline &apos;  gPerf = [];&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * TAG PAGE Logic&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;// somehow only functions on window are visible for the select tag&apos;.
        _inline &apos;window.onTagTypeChange = function(oSelectObject){&apos;.
        _inline &apos;  var sValue = oSelectObject.value;&apos;.
        _inline &apos;  submitSapeventForm({ &apos;&apos;type&apos;&apos;: sValue }, &quot;change_tag_type&quot;, &quot;post&quot;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Repo Overview Logic&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;// somehow only functions on window are visible for the select tag&apos;.
        _inline &apos;window.onOrderByChange = function(oSelectObject){&apos;.
        _inline &apos;  var sValue = oSelectObject.value;&apos;.
        _inline &apos;  submitSapeventForm({ &apos;&apos;orderBy&apos;&apos;: sValue }, &quot;change_order_by&quot;, &quot;post&quot;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;window.onDirectionChange = function(oSelectObject){&apos;.
        _inline &apos;  var sValue = oSelectObject.value;&apos;.
        _inline &apos;  submitSapeventForm({ &apos;&apos;direction&apos;&apos;: sValue }, &quot;direction&quot;, &quot;post&quot;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * STAGE PAGE Logic&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Stage helper constructor&apos;.
        _inline &apos;function StageHelper(params) {&apos;.
        _inline &apos;  this.pageSeed        = params.seed;&apos;.
        _inline &apos;  this.formAction      = params.formAction;&apos;.
        _inline &apos;  this.choiseCount     = 0;&apos;.
        _inline &apos;  this.lastFilterValue = &quot;&quot;;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // DOM nodes&apos;.
        _inline &apos;  this.dom = {&apos;.
        _inline &apos;    stageTab:     document.getElementById(params.ids.stageTab),&apos;.
        _inline &apos;    commitBtn:    document.getElementById(params.ids.commitBtn),&apos;.
        _inline &apos;    commitAllBtn: document.getElementById(params.ids.commitAllBtn),&apos;.
        _inline &apos;    objectSearch: document.getElementById(params.ids.objectSearch),&apos;.
        _inline &apos;    fileCounter:  document.getElementById(params.ids.fileCounter)&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Table columns (autodetection)&apos;.
        _inline &apos;  this.colIndex      = this.detectColumns();&apos;.
        _inline &apos;  this.filterTargets = [&quot;name&quot;, &quot;user&quot;, &quot;transport&quot;];&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Constants&apos;.
        _inline &apos;  this.HIGHLIGHT_STYLE = &quot;highlight&quot;;&apos;.
        _inline &apos;  this.STATUS = {&apos;.
        _inline &apos;    add:    &quot;A&quot;,&apos;.
        _inline &apos;    remove: &quot;R&quot;,&apos;.
        _inline &apos;    ignore: &quot;I&quot;,&apos;.
        _inline &apos;    reset:  &quot;?&quot;,&apos;.
        _inline &apos;    isValid: function (status) { return &quot;ARI?&quot;.indexOf(status) == -1; }&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.TEMPLATES = {&apos;.
        _inline &apos;    cmdReset:  &quot;&lt;a&gt;reset&lt;/a&gt;&quot;,&apos;.
        _inline &apos;    cmdLocal:  &quot;&lt;a&gt;add&lt;/a&gt;&quot;,&apos;.
        _inline &apos;    cmdRemote: &quot;&lt;a&gt;ignore&lt;/a&gt;&lt;a&gt;remove&lt;/a&gt;&quot;&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.setHooks();&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Hook global click listener on table, load/unload actions&apos;.
        _inline &apos;StageHelper.prototype.setHooks = function() {&apos;.
        _inline &apos;  this.dom.stageTab.onclick        = this.onTableClick.bind(this);&apos;.
        _inline &apos;  this.dom.commitBtn.onclick       = this.submit.bind(this);&apos;.
        _inline &apos;  this.dom.objectSearch.oninput    = this.onFilter.bind(this);&apos;.
        _inline &apos;  this.dom.objectSearch.onkeypress = this.onFilter.bind(this);&apos;.
        _inline &apos;  window.onbeforeunload            = this.onPageUnload.bind(this);&apos;.
        _inline &apos;  window.onload                    = this.onPageLoad.bind(this);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Detect column index&apos;.
        _inline &apos;StageHelper.prototype.detectColumns = function() {&apos;.
        _inline &apos;  var dataRow  = this.dom.stageTab.tBodies[0].rows[0];&apos;.
        _inline &apos;  var colIndex = {};&apos;.
        _inline &apos;&apos;.
        _inline &apos;  for (var i = dataRow.cells.length - 1; i &gt;= 0; i--) {&apos;.
        _inline &apos;    if (dataRow.cells[i].className) colIndex[dataRow.cells[i].className] = i;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  return colIndex;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Store table state on leaving the page&apos;.
        _inline &apos;StageHelper.prototype.onPageUnload = function() {&apos;.
        _inline &apos;  if (!window.sessionStorage) return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var data = this.collectData();&apos;.
        _inline &apos;  window.sessionStorage.setItem(this.pageSeed, JSON.stringify(data));&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Re-store table state on entering the page&apos;.
        _inline &apos;StageHelper.prototype.onPageLoad = function() {&apos;.
        _inline &apos;  var data = window.sessionStorage &amp;&amp; JSON.parse(window.sessionStorage.getItem(this.pageSeed));&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.iterateStageTab(true, function (row) {&apos;.
        _inline &apos;    var status = data &amp;&amp; data[row.cells[this.colIndex[&quot;name&quot;]].innerText];&apos;.
        _inline &apos;    this.updateRow(row, status || this.STATUS.reset);&apos;.
        _inline &apos;  });&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.updateMenu();&apos;.
        _inline &apos;  if (this.dom.objectSearch.value) {&apos;.
        _inline &apos;    this.applyFilterValue(this.dom.objectSearch.value);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;  debugOutput(&quot;StageHelper.onPageLoad: &quot; + ((data) ? &quot;from Storage&quot; : &quot;initial state&quot;));&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Table event handler, change status&apos;.
        _inline &apos;StageHelper.prototype.onTableClick = function (event) {&apos;.
        _inline &apos;  var target = event.target || event.srcElement;&apos;.
        _inline &apos;  if (!target) return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (target.tagName === &quot;A&quot;) {&apos;.
        _inline &apos;    var td = target.parentNode;&apos;.
        _inline &apos;  } else if (target.tagName === &quot;TD&quot;) {&apos;.
        _inline &apos;    var td = target;&apos;.
        _inline &apos;    if (td.children.length === 1 &amp;&amp; td.children[0].tagName === &quot;A&quot;) {&apos;.
        _inline &apos;      target = td.children[0];&apos;.
        _inline &apos;    } else return;&apos;.
        _inline &apos;  } else return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if ([&quot;TD&quot;,&quot;TH&quot;].indexOf(td.tagName) == -1 || td.className != &quot;cmd&quot;) return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var status    = this.STATUS[target.innerText]; // Convert anchor text to status&apos;.
        _inline &apos;  var targetRow = td.parentNode;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (td.tagName === &quot;TD&quot;) {&apos;.
        _inline &apos;    this.updateRow(targetRow, status);&apos;.
        _inline &apos;  } else { // TH&apos;.
        _inline &apos;    this.iterateStageTab(true, function (row) {&apos;.
        _inline &apos;      if (row.style.display !== &quot;none&quot;            // Not filtered out&apos;.
        _inline &apos;        &amp;&amp; row.className === targetRow.className  // Same context as header&apos;.
        _inline &apos;        ) {&apos;.
        _inline &apos;        this.updateRow(row, status);&apos;.
        _inline &apos;      }&apos;.
        _inline &apos;    });&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.updateMenu();&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Search object&apos;.
        _inline &apos;StageHelper.prototype.onFilter = function (e) {&apos;.
        _inline &apos;  if ( // Enter hit or clear, IE SUCKS !&apos;.
        _inline &apos;       e.type === &quot;input&quot; &amp;&amp; !e.target.value &amp;&amp; this.lastFilterValue&apos;.
        _inline &apos;    || e.type === &quot;keypress&quot; &amp;&amp; e.which === 13 ) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    this.applyFilterValue(e.target.value);&apos;.
        _inline &apos;    submitSapeventForm({ &apos;&apos;filterValue&apos;&apos;: e.target.value }, &quot;stage_filter&quot;, &quot;post&quot;);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;StageHelper.prototype.applyFilterValue = function(sFilterValue) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.lastFilterValue = sFilterValue;&apos;.
        _inline &apos;  this.iterateStageTab(true, this.applyFilterToRow, sFilterValue);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Apply filter to a single stage line - hide or show&apos;.
        _inline &apos;StageHelper.prototype.applyFilterToRow = function (row, filter) {&apos;.
        _inline &apos;  // Collect data cells&apos;.
        _inline &apos;  var targets = this.filterTargets.map(function(attr) {&apos;.
        _inline &apos;    var elem = row.cells[this.colIndex[attr]];&apos;.
        _inline &apos;    if (elem.firstChild &amp;&amp; elem.firstChild.tagName === &quot;A&quot;) elem = elem.firstChild;&apos;.
        _inline &apos;    return {&apos;.
        _inline &apos;      elem:      elem,&apos;.
        _inline &apos;      plainText: elem.innerText, // without tags&apos;.
        _inline &apos;      curHtml:   elem.innerHTML&apos;.
        _inline &apos;    };&apos;.
        _inline &apos;  }, this);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var isVisible = false;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Apply filter to cells, mark filtered text&apos;.
        _inline &apos;  for (var i = targets.length - 1; i &gt;= 0; i--) {&apos;.
        _inline &apos;    var target = targets[i];&apos;.
        _inline &apos;    target.newHtml = (filter)&apos;.
        _inline &apos;      ? target.plainText.replace(filter, &quot;&lt;mark&gt;&quot;+filter+&quot;&lt;/mark&gt;&quot;)&apos;.
        _inline &apos;      : target.plainText;&apos;.
        _inline &apos;    target.isChanged = target.newHtml !== target.curHtml;&apos;.
        _inline &apos;    isVisible        = isVisible || !filter || target.newHtml !== target.plainText;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Update DOM&apos;.
        _inline &apos;  row.style.display = isVisible ? &quot;&quot; : &quot;none&quot;;&apos;.
        _inline &apos;  for (var i = targets.length - 1; i &gt;= 0; i--) {&apos;.
        _inline &apos;    if (targets[i].isChanged) targets[i].elem.innerHTML = targets[i].newHtml;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Get how status should affect object counter&apos;.
        _inline &apos;StageHelper.prototype.getStatusImpact = function (status) {&apos;.
        _inline &apos;  if (typeof status !== &quot;string&quot;&apos;.
        _inline &apos;    || status.length !== 1&apos;.
        _inline &apos;    || this.STATUS.isValid(status) ) {&apos;.
        _inline &apos;    alert(&quot;Unknown status&quot;);&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    return (status !== this.STATUS.reset) ? 1 : 0;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Update table line&apos;.
        _inline &apos;StageHelper.prototype.updateRow = function (row, newStatus) {&apos;.
        _inline &apos;  var oldStatus = row.cells[this.colIndex[&quot;status&quot;]].innerText;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (oldStatus !== newStatus) {&apos;.
        _inline &apos;    this.updateRowStatus(row, newStatus);&apos;.
        _inline &apos;    this.updateRowCommand(row, newStatus);&apos;.
        _inline &apos;  } else if (!row.cells[this.colIndex[&quot;cmd&quot;]].children.length) {&apos;.
        _inline &apos;    this.updateRowCommand(row, newStatus); // For initial run&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.choiseCount += this.getStatusImpact(newStatus) - this.getStatusImpact(oldStatus);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Update Status cell (render set of commands)&apos;.
        _inline &apos;StageHelper.prototype.updateRowStatus = function (row, status) {&apos;.
        _inline &apos;  row.cells[this.colIndex[&quot;status&quot;]].innerText = status;&apos;.
        _inline &apos;  if (status === this.STATUS.reset) {&apos;.
        _inline &apos;    row.cells[this.colIndex[&quot;status&quot;]].classList.remove(this.HIGHLIGHT_STYLE);&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    row.cells[this.colIndex[&quot;status&quot;]].classList.add(this.HIGHLIGHT_STYLE);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Update Command cell (render set of commands)&apos;.
        _inline &apos;StageHelper.prototype.updateRowCommand = function (row, status) {&apos;.
        _inline &apos;  var cell = row.cells[this.colIndex[&quot;cmd&quot;]];&apos;.
        _inline &apos;  if (status === this.STATUS.reset) {&apos;.
        _inline &apos;    cell.innerHTML = (row.className == &quot;local&quot;)&apos;.
        _inline &apos;      ? this.TEMPLATES.cmdLocal&apos;.
        _inline &apos;      : this.TEMPLATES.cmdRemote;&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    cell.innerHTML = this.TEMPLATES.cmdReset;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Update menu items visibility&apos;.
        _inline &apos;StageHelper.prototype.updateMenu = function () {&apos;.
        _inline &apos;  this.dom.commitBtn.style.display    = (this.choiseCount &gt; 0) ? &quot;&quot;     : &quot;none&quot;;&apos;.
        _inline &apos;  this.dom.commitAllBtn.style.display = (this.choiseCount &gt; 0) ? &quot;none&quot; : &quot;&quot;;&apos;.
        _inline &apos;  this.dom.fileCounter.innerHTML      = this.choiseCount.toString();&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Submit stage state to the server&apos;.
        _inline &apos;StageHelper.prototype.submit = function () {&apos;.
        _inline &apos;  submitSapeventForm(this.collectData(), this.formAction);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Extract data from the table&apos;.
        _inline &apos;StageHelper.prototype.collectData = function () {&apos;.
        _inline &apos;  var data  = {};&apos;.
        _inline &apos;  this.iterateStageTab(false, function (row) {&apos;.
        _inline &apos;    data[row.cells[this.colIndex[&quot;name&quot;]].innerText] = row.cells[this.colIndex[&quot;status&quot;]].innerText;&apos;.
        _inline &apos;  });&apos;.
        _inline &apos;  return data;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Table iteration helper&apos;.
        _inline &apos;StageHelper.prototype.iterateStageTab = function (changeMode, cb /*, ...*/) {&apos;.
        _inline &apos;  var restArgs = Array.prototype.slice.call(arguments, 2);&apos;.
        _inline &apos;  var table    = this.dom.stageTab;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (changeMode) {&apos;.
        _inline &apos;    var scrollOffset = window.pageYOffset;&apos;.
        _inline &apos;    this.dom.stageTab.style.display = &quot;none&quot;;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  for (var b = 0, bN = table.tBodies.length; b &lt; bN; b++) {&apos;.
        _inline &apos;    var tbody = table.tBodies[b];&apos;.
        _inline &apos;    for (var r = 0, rN = tbody.rows.length; r &lt; rN; r++) {&apos;.
        _inline &apos;      args = [tbody.rows[r]].concat(restArgs);&apos;.
        _inline &apos;      cb.apply(this, args); // callback&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (changeMode) {&apos;.
        _inline &apos;    this.dom.stageTab.style.display = &quot;&quot;;&apos;.
        _inline &apos;    window.scrollTo(0, scrollOffset);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Check list wrapper&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;function CheckListWrapper(id, cbAction) {&apos;.
        _inline &apos;  this.id         = document.getElementById(id);&apos;.
        _inline &apos;  this.cbAction   = cbAction;&apos;.
        _inline &apos;  this.id.onclick = this.onClick.bind(this);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;CheckListWrapper.prototype.onClick = function(e) {&apos;.
        _inline &apos;  // Get nodes&apos;.
        _inline &apos;  var target = event.target || event.srcElement;&apos;.
        _inline &apos;  if (!target) return;&apos;.
        _inline &apos;  if (target.tagName !== &quot;A&quot;) { target = target.parentNode; } // icon clicked&apos;.
        _inline &apos;  if (target.tagName !== &quot;A&quot;) return;&apos;.
        _inline &apos;  if (target.parentNode.tagName !== &quot;LI&quot;) return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var nodeA    = target;&apos;.
        _inline &apos;  var nodeLi   = target.parentNode;&apos;.
        _inline &apos;  var nodeIcon = target.children[0];&apos;.
        _inline &apos;  if (!nodeIcon.classList.contains(&quot;octicon&quot;)) return;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Node updates&apos;.
        _inline &apos;  var option   = nodeA.innerText;&apos;.
        _inline &apos;  var oldState = nodeLi.getAttribute(&quot;data-check&quot;);&apos;.
        _inline &apos;  if (oldState === null) return; // no data-check attribute - non-checkbox&apos;.
        _inline &apos;  var newState = oldState === &quot;X&quot; ? false : true;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (newState) {&apos;.
        _inline &apos;    nodeIcon.classList.remove(&quot;grey&quot;);&apos;.
        _inline &apos;    nodeIcon.classList.add(&quot;blue&quot;);&apos;.
        _inline &apos;    nodeLi.setAttribute(&quot;data-check&quot;, &quot;X&quot;);&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    nodeIcon.classList.remove(&quot;blue&quot;);&apos;.
        _inline &apos;    nodeIcon.classList.add(&quot;grey&quot;);&apos;.
        _inline &apos;    nodeLi.setAttribute(&quot;data-check&quot;, &quot;&quot;);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Action callback&apos;.
        _inline &apos;  this.cbAction(nodeLi.getAttribute(&quot;data-aux&quot;), option, newState);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Diff page logic&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Diff helper constructor&apos;.
        _inline &apos;function DiffHelper(params) {&apos;.
        _inline &apos;  this.pageSeed    = params.seed;&apos;.
        _inline &apos;  this.counter     = 0;&apos;.
        _inline &apos;  this.stageAction = params.stageAction;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // DOM nodes&apos;.
        _inline &apos;  this.dom = {&apos;.
        _inline &apos;    diffList:    document.getElementById(params.ids.diffList),&apos;.
        _inline &apos;    stageButton: document.getElementById(params.ids.stageButton)&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.repoKey = this.dom.diffList.getAttribute(&quot;data-repo-key&quot;);&apos;.
        _inline &apos;  if (!this.repoKey) return; // Unexpected&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Checklist wrapper&apos;.
        _inline &apos;  if (document.getElementById(params.ids.filterMenu)) {&apos;.
        _inline &apos;    this.checkList = new CheckListWrapper(params.ids.filterMenu, this.onFilter.bind(this));&apos;.
        _inline &apos;    this.dom.filterButton = document.getElementById(params.ids.filterMenu).parentNode;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Hijack stage command&apos;.
        _inline &apos;  if (this.dom.stageButton) {&apos;.
        _inline &apos;    this.dom.stageButton.href    = &quot;#&quot;;&apos;.
        _inline &apos;    this.dom.stageButton.onclick = this.onStage.bind(this);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Action on filter click&apos;.
        _inline &apos;DiffHelper.prototype.onFilter = function(attr, target, state) {&apos;.
        _inline &apos;  this.applyFilter(attr, target, state);&apos;.
        _inline &apos;  this.highlightButton(state);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Hide/show diff based on params&apos;.
        _inline &apos;DiffHelper.prototype.applyFilter = function (attr, target, state) {&apos;.
        _inline &apos;  this.iterateDiffList(function(div) {&apos;.
        _inline &apos;    if (div.getAttribute(&quot;data-&quot;+attr) === target) {&apos;.
        _inline &apos;      div.style.display = state ? &quot;&quot; : &quot;none&quot;;&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  });&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Action on stage -&gt; save visible diffs as state for stage page&apos;.
        _inline &apos;DiffHelper.prototype.onStage = function (e) {&apos;.
        _inline &apos;  if (window.sessionStorage) {&apos;.
        _inline &apos;    var data = this.buildStageCache();&apos;.
        _inline &apos;    window.sessionStorage.setItem(this.pageSeed, JSON.stringify(data));&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;  var getParams = {key: this.repoKey, seed: this.pageSeed};&apos;.
        _inline &apos;  submitSapeventForm(getParams, this.stageAction, &quot;get&quot;);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Collect visible diffs&apos;.
        _inline &apos;DiffHelper.prototype.buildStageCache = function () {&apos;.
        _inline &apos;  var list = {};&apos;.
        _inline &apos;  this.iterateDiffList(function(div) {&apos;.
        _inline &apos;    var filename = div.getAttribute(&quot;data-file&quot;);&apos;.
        _inline &apos;    if (!div.style.display &amp;&amp; filename) { // No display override - visible !!&apos;.
        _inline &apos;      list[filename] = &quot;A&quot;; // Add&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  });&apos;.
        _inline &apos;  return list;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Table iterator&apos;.
        _inline &apos;DiffHelper.prototype.iterateDiffList = function (cb /*, ...*/) {&apos;.
        _inline &apos;  var restArgs = Array.prototype.slice.call(arguments, 1);&apos;.
        _inline &apos;  var diffList = this.dom.diffList;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  for (var i = 0, iN = diffList.children.length; i &lt; iN; i++) {&apos;.
        _inline &apos;    var div = diffList.children[i];&apos;.
        _inline &apos;    if (div.className !== &quot;diff&quot;) continue;&apos;.
        _inline &apos;    args = [div].concat(restArgs);&apos;.
        _inline &apos;    cb.apply(this, args); // callback&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Highlight Filter button if filter is activate&apos;.
        _inline &apos;DiffHelper.prototype.highlightButton = function(state) {&apos;.
        _inline &apos;  this.counter += state ? -1 : 1;&apos;.
        _inline &apos;  if (this.counter &gt; 0) {&apos;.
        _inline &apos;    this.dom.filterButton.classList.add(&quot;bgorange&quot;);&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    this.dom.filterButton.classList.remove(&quot;bgorange&quot;);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;/**********************************************************&apos;.
        _inline &apos; * Other functions&apos;.
        _inline &apos; **********************************************************/&apos;.
        _inline &apos;&apos;.
        _inline &apos;// News announcement&apos;.
        _inline &apos;function toggleDisplay(divId) {&apos;.
        _inline &apos;  var div = document.getElementById(divId);&apos;.
        _inline &apos;  if (div) div.style.display = (div.style.display) ? &apos;&apos;&apos;&apos; : &apos;&apos;none&apos;&apos;;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function KeyNavigation() {&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.onkeydown = function(oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (oEvent.defaultPrevented) {&apos;.
        _inline &apos;    return;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // navigate with arrows through list items and support pressing links with enter and space&apos;.
        _inline &apos;  if (oEvent.key === &quot;ENTER&quot; || oEvent.key === &quot;&quot;) {&apos;.
        _inline &apos;    this.onEnterOrSpace(oEvent);&apos;.
        _inline &apos;  } else if (/Down$/.test(oEvent.key)) {&apos;.
        _inline &apos;    this.onArrowDown(oEvent);&apos;.
        _inline &apos;  } else if (/Up$/.test(oEvent.key)) {&apos;.
        _inline &apos;    this.onArrowUp(oEvent);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.getLiSelected = function() {&apos;.
        _inline &apos;  return document.querySelector(&apos;&apos;li .selected&apos;&apos;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.getActiveElement = function () {&apos;.
        _inline &apos;  return document.activeElement;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.getActiveElementParent = function () {&apos;.
        _inline &apos;  return this.getActiveElement().parentElement;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.onEnterOrSpace = function (oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Enter or space clicks the selected link&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var liSelected = this.getLiSelected();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (liSelected) {&apos;.
        _inline &apos;    liSelected.firstElementChild.click();&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.onArrowDown = function (oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var&apos;.
        _inline &apos;    liNext,&apos;.
        _inline &apos;    liSelected = this.getLiSelected(),&apos;.
        _inline &apos;    oActiveElementParent = this.getActiveElementParent();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (liSelected) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    // we deselect the current li and select the next sibling&apos;.
        _inline &apos;    liNext = oActiveElementParent.nextElementSibling;&apos;.
        _inline &apos;    if (liNext) {&apos;.
        _inline &apos;      liSelected.classList.toggle(&apos;&apos;selected&apos;&apos;);&apos;.
        _inline &apos;      liNext.firstElementChild.focus();&apos;.
        _inline &apos;      oActiveElementParent.classList.toggle(&apos;&apos;selected&apos;&apos;);&apos;.
        _inline &apos;      oEvent.preventDefault();&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    // we don&apos;&apos;t have any li selected, we have lookup where to start...&apos;.
        _inline &apos;    // the right element should have been activated in fnTooltipActivate&apos;.
        _inline &apos;    liNext = this.getActiveElement().nextElementSibling;&apos;.
        _inline &apos;    if (liNext) {&apos;.
        _inline &apos;      liNext.classList.toggle(&apos;&apos;selected&apos;&apos;);&apos;.
        _inline &apos;      liNext.firstElementChild.firstElementChild.focus();&apos;.
        _inline &apos;      oEvent.preventDefault();&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;&apos;.
        _inline &apos;KeyNavigation.prototype.onArrowUp = function (oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var&apos;.
        _inline &apos;    liSelected = this.getLiSelected(),&apos;.
        _inline &apos;    liPrevious = this.getActiveElementParent().previousElementSibling;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (liSelected &amp;&amp; liPrevious) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    liSelected.classList.toggle(&apos;&apos;selected&apos;&apos;);&apos;.
        _inline &apos;    liPrevious.firstElementChild.focus();&apos;.
        _inline &apos;    this.getActiveElementParent().classList.toggle(&apos;&apos;selected&apos;&apos;);&apos;.
        _inline &apos;    oEvent.preventDefault();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// this functions enables the navigation with arrows through list items (li)&apos;.
        _inline &apos;// e.g. in dropdown menus&apos;.
        _inline &apos;function enableArrowListNavigation() {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oKeyNavigation = new KeyNavigation();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  document.addEventListener(&apos;&apos;keydown&apos;&apos;, oKeyNavigation.onkeydown.bind(oKeyNavigation));&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function LinkHints(sLinkHintKey, sColor){&apos;.
        _inline &apos;  this.sLinkHintKey = sLinkHintKey;&apos;.
        _inline &apos;  this.sColor = sColor;&apos;.
        _inline &apos;  this.oTooltipMap = {};&apos;.
        _inline &apos;  this.bTooltipsOn = false;&apos;.
        _inline &apos;  this.sPending = &quot;&quot;;&apos;.
        _inline &apos;  this.aTooltipElements = document.querySelectorAll(&apos;&apos;a span&apos;&apos;);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnRenderTooltip = function (oTooltip, iTooltipCounter) {&apos;.
        _inline &apos;  if (this.bTooltipsOn) {&apos;.
        _inline &apos;    oTooltip.classList.remove(&apos;&apos;hidden&apos;&apos;);&apos;.
        _inline &apos;  } else {&apos;.
        _inline &apos;    oTooltip.classList.add(&apos;&apos;hidden&apos;&apos;);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;  oTooltip.innerHTML = iTooltipCounter;&apos;.
        _inline &apos;  oTooltip.style.backgroundColor = this.sColor;&apos;.
        _inline &apos;  this.oTooltipMap[iTooltipCounter] = oTooltip;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.getTooltipStartValue = function(iToolTipCount){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // if whe have 333 tooltips we start from 100&apos;.
        _inline &apos;  return Math.pow(10,iToolTipCount.toString().length - 1);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnRenderTooltips = function () {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // all possible links which should be accessed via tooltip have&apos;.
        _inline &apos;  // sub span which is hidden by default. If we like to show the&apos;.
        _inline &apos;  // tooltip we have to toggle the css class &apos;&apos;hidden&apos;&apos;.&apos;.
        _inline &apos;  //&apos;.
        _inline &apos;  // We use numeric values for the tooltip label. Maybe we can&apos;.
        _inline &apos;  // support also alphanumeric chars in the future. Then we have to&apos;.
        _inline &apos;  // calculate permutations and that&apos;&apos;s work. So for the sake of simplicity&apos;.
        _inline &apos;  // we stick to numeric values and just increment them.&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var&apos;.
        _inline &apos;    iTooltipCounter = this.getTooltipStartValue(this.aTooltipElements.length);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  [].forEach.call(this.aTooltipElements, function(oTooltip){&apos;.
        _inline &apos;    iTooltipCounter += 1;&apos;.
        _inline &apos;    this.fnRenderTooltip(oTooltip, iTooltipCounter);&apos;.
        _inline &apos;  }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnToggleAllTooltips = function () {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.sPending = &quot;&quot;;&apos;.
        _inline &apos;  this.bTooltipsOn = !this.bTooltipsOn;&apos;.
        _inline &apos;  this.fnRenderTooltips();&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnRemoveAllTooltips = function () {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.sPending = &quot;&quot;;&apos;.
        _inline &apos;  this.bTooltipsOn = false;&apos;.
        _inline &apos;&apos;.
        _inline &apos;  [].forEach.call(this.aTooltipElements, function (oTooltip) {&apos;.
        _inline &apos;    oTooltip.classList.add(&apos;&apos;hidden&apos;&apos;);&apos;.
        _inline &apos;  });&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnFilterTooltips = function (sPending) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  Object&apos;.
        _inline &apos;    .keys(this.oTooltipMap)&apos;.
        _inline &apos;    .forEach(function (sKey) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;      // we try to partially match, but only from the beginning!&apos;.
        _inline &apos;      var regex = new RegExp(&quot;^&quot; + this.sPending);&apos;.
        _inline &apos;      var oTooltip = this.oTooltipMap[sKey];&apos;.
        _inline &apos;&apos;.
        _inline &apos;      if (regex.test(sKey)) {&apos;.
        _inline &apos;        // we have a partial match, grey out the matched part&apos;.
        _inline &apos;        oTooltip.innerHTML = sKey.replace(regex, &quot;&lt;div style=&apos;&apos;display:inline;color:lightgray&apos;&apos;&gt;&quot; + this.sPending + &apos;&apos;&lt;/div&gt;&apos;&apos;);&apos;.
        _inline &apos;      } else {&apos;.
        _inline &apos;        // and hide the not matched tooltips&apos;.
        _inline &apos;        oTooltip.classList.add(&apos;&apos;hidden&apos;&apos;);&apos;.
        _inline &apos;      }&apos;.
        _inline &apos;&apos;.
        _inline &apos;    }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnActivateDropDownMenu = function (oTooltip) {&apos;.
        _inline &apos;  // to enable link hint navigation for drop down menu, we must expand&apos;.
        _inline &apos;  // like if they were hovered&apos;.
        _inline &apos;  oTooltip.parentElement.parentElement.classList.toggle(&quot;block&quot;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.fnTooltipActivate = function (oTooltip) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // a tooltips was successfully specified, so we try to trigger the link&apos;.
        _inline &apos;  // and remove all tooltips&apos;.
        _inline &apos;  this.fnRemoveAllTooltips();&apos;.
        _inline &apos;  oTooltip.parentElement.click();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // in case it is a dropdownmenu we have to expand and focus it&apos;.
        _inline &apos;  this.fnActivateDropDownMenu(oTooltip);&apos;.
        _inline &apos;  oTooltip.parentElement.focus();&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;LinkHints.prototype.onkeypress = function(oEvent){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (oEvent.defaultPrevented) {&apos;.
        _inline &apos;    return;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var activeElementType = ((document.activeElement &amp;&amp; document.activeElement.nodeName) || &quot;&quot;);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // link hints are disabled for input and textareas for obvious reasons.&apos;.
        _inline &apos;  // Maybe we must add other types here in the future&apos;.
        _inline &apos;  if (oEvent.key === this.sLinkHintKey &amp;&amp; activeElementType !== &quot;INPUT&quot; &amp;&amp; activeElementType !== &quot;TEXTAREA&quot;) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    this.fnToggleAllTooltips();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  } else if (this.bTooltipsOn === true) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    // the user tries to reach a tooltip&apos;.
        _inline &apos;    this.sPending += oEvent.key;&apos;.
        _inline &apos;    var oTooltip = this.oTooltipMap[this.sPending];&apos;.
        _inline &apos;&apos;.
        _inline &apos;    if (oTooltip) {&apos;.
        _inline &apos;      // we are there, we have a fully specified tooltip. Let&apos;&apos;s activate it&apos;.
        _inline &apos;      this.fnTooltipActivate(oTooltip);&apos;.
        _inline &apos;    } else {&apos;.
        _inline &apos;      // we are not there yet, but let&apos;&apos;s filter the link so that only&apos;.
        _inline &apos;      // the partially matched are shown&apos;.
        _inline &apos;      this.fnFilterTooltips(this.sPending);&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;// Vimium like link hints&apos;.
        _inline &apos;function setLinkHints(sLinkHintKey, sColor) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (!sLinkHintKey || !sColor) {&apos;.
        _inline &apos;    return;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oLinkHint = new LinkHints(sLinkHintKey, sColor);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  document.addEventListener(&quot;keypress&quot;, oLinkHint.onkeypress.bind(oLinkHint));&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function Hotkeys(oKeyMap){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.oKeyMap = oKeyMap || {};&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // these are the hotkeys provided by the backend&apos;.
        _inline &apos;  Object.keys(this.oKeyMap).forEach(function(sKey){&apos;.
        _inline &apos;&apos;.
        _inline &apos;    var action = this.oKeyMap[sKey];&apos;.
        _inline &apos;&apos;.
        _inline &apos;    // We replace the actions with callback functions to unify&apos;.
        _inline &apos;    // the hotkey execution&apos;.
        _inline &apos;    this.oKeyMap[sKey] = function(oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;      // We have either a js function on this&apos;.
        _inline &apos;      if (this[action]) {&apos;.
        _inline &apos;        this[action].call(this);&apos;.
        _inline &apos;        return;&apos;.
        _inline &apos;      }&apos;.
        _inline &apos;&apos;.
        _inline &apos;      // Or a global function&apos;.
        _inline &apos;      if (window[action]) {&apos;.
        _inline &apos;        window[action].call(this);&apos;.
        _inline &apos;      }&apos;.
        _inline &apos;&apos;.
        _inline &apos;      // Or a SAP event&apos;.
        _inline &apos;      var sUiSapEvent = this.getSapEvent(action);&apos;.
        _inline &apos;      if (sUiSapEvent) {&apos;.
        _inline &apos;        submitSapeventForm({}, sUiSapEvent, &quot;post&quot;);&apos;.
        _inline &apos;        oEvent.preventDefault();&apos;.
        _inline &apos;        return;&apos;.
        _inline &apos;      }&apos;.
        _inline &apos;&apos;.
        _inline &apos;    };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;Hotkeys.prototype.showHotkeys = function() {&apos;.
        _inline &apos;  var elHotkeys = document.querySelector(&apos;&apos;#hotkeys&apos;&apos;);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (elHotkeys) {&apos;.
        _inline &apos;    elHotkeys.style.display = (elHotkeys.style.display) ? &apos;&apos;&apos;&apos; : &apos;&apos;none&apos;&apos;;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Hotkeys.prototype.getSapEvent = function(sSapEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var fnNormalizeSapEventHref = function(sSapEvent, oSapEvent) {&apos;.
        _inline &apos;    if (new RegExp(sSapEvent + &quot;$&quot; ).test(oSapEvent.href)&apos;.
        _inline &apos;    || (new RegExp(sSapEvent + &quot;\\?&quot; ).test(oSapEvent.href))) {&apos;.
        _inline &apos;      return oSapEvent.href.replace(&quot;sapevent:&quot;,&quot;&quot;);&apos;.
        _inline &apos;    }&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var aSapEvents = document.querySelectorAll(&apos;&apos;a[href^=&quot;sapevent:&apos;&apos; + sSapEvent + &apos;&apos;&quot;]&apos;&apos;);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var aFilteredAndNormalizedSapEvents =&apos;.
        _inline &apos;        [].map.call(aSapEvents, function(oSapEvent){&apos;.
        _inline &apos;          return fnNormalizeSapEventHref(sSapEvent, oSapEvent);&apos;.
        _inline &apos;        })&apos;.
        _inline &apos;        .filter(function(elem){&apos;.
        _inline &apos;          // remove false positives&apos;.
        _inline &apos;          return (elem &amp;&amp; !elem.includes(&quot;sapevent:&quot;));&apos;.
        _inline &apos;        });&apos;.
        _inline &apos;&apos;.
        _inline &apos;  return (aFilteredAndNormalizedSapEvents &amp;&amp; aFilteredAndNormalizedSapEvents[0]);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Hotkeys.prototype.onkeydown = function(oEvent){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (oEvent.defaultPrevented) {&apos;.
        _inline &apos;      return;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var activeElementType = ((document.activeElement &amp;&amp; document.activeElement.nodeName) || &quot;&quot;);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (activeElementType === &quot;INPUT&quot; || activeElementType === &quot;TEXTAREA&quot;) {&apos;.
        _inline &apos;    return;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var&apos;.
        _inline &apos;    sKey = oEvent.key || String.fromCharCode(oEvent.keyCode),&apos;.
        _inline &apos;    fnHotkey = this.oKeyMap[sKey];&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (fnHotkey) {&apos;.
        _inline &apos;    fnHotkey.call(this, oEvent);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;function setKeyBindings(oKeyMap){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oHotkeys = new Hotkeys(oKeyMap);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  document.addEventListener(&apos;&apos;keypress&apos;&apos;, oHotkeys.onkeydown.bind(oHotkeys));&apos;.
        _inline &apos;  setTimeout(function(){ &apos;.
        _inline &apos;    var div = document.getElementById(&quot;hotkeys-hint&quot;);&apos;.
        _inline &apos;    if (div) div.style.opacity = 0.2;&apos;.
        _inline &apos;  }, 4900);&apos;.
        _inline &apos;  setTimeout(function(){ toggleDisplay(&quot;hotkeys-hint&quot;) }, 5000);&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;/*&apos;.
        _inline &apos;  Patch / git add -p&apos;.
        _inline &apos;  */&apos;.
        _inline &apos;&apos;.
        _inline &apos;function CSSPatchClassCombination(sClassLinkClicked, sClassCorrespondingLink){&apos;.
        _inline &apos;  this.sClassLinkClicked = sClassLinkClicked;&apos;.
        _inline &apos;  this.sClassCorrespondingLink = sClassCorrespondingLink;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function Patch() {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.CSS_CLASS = {&apos;.
        _inline &apos;    ADD: &apos;&apos;add&apos;&apos;,&apos;.
        _inline &apos;    REMOVE: &apos;&apos;remove&apos;&apos;,&apos;.
        _inline &apos;    PATCH: &apos;&apos;patch&apos;&apos;,&apos;.
        _inline &apos;    PATCH_ACTIVE: &apos;&apos;patch-active&apos;&apos;&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.ID = {&apos;.
        _inline &apos;    STAGE: &apos;&apos;stage&apos;&apos;,&apos;.
        _inline &apos;    PATCH_ADD_ALL: &apos;&apos;patch_add_all&apos;&apos;,&apos;.
        _inline &apos;    PATCH_REMOVE_ALL: &apos;&apos;patch_remove_all&apos;&apos;&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.ACTION = {&apos;.
        _inline &apos;    PATCH_STAGE: &apos;&apos;patch_stage&apos;&apos;&apos;.
        _inline &apos;  };&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.ADD_REMOVE = new CSSPatchClassCombination(this.CSS_CLASS.ADD, this.CSS_CLASS.REMOVE);&apos;.
        _inline &apos;  this.REMOVE_ADD = new CSSPatchClassCombination(this.CSS_CLASS.REMOVE, this.CSS_CLASS.ADD);&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.preparePatch = function(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.registerClickHandlerSingleLine();&apos;.
        _inline &apos;  this.registerClickHandlerAllFile();&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.registerClickHandlerSingleLine = function(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // registers the link handlers for add and remove single lines&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.registerClickHandlerForPatchLink(this.ADD_REMOVE);&apos;.
        _inline &apos;  this.registerClickHandlerForPatchLink(this.REMOVE_ADD);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.registerClickHandlerAllFile = function(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // registers the link handlers for add and remove all changes for a file&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.registerClickHandlerForPatchLinkAll(&apos;&apos;#&apos;&apos; + this.ID.PATCH_ADD_ALL, this.ADD_REMOVE);&apos;.
        _inline &apos;  this.registerClickHandlerForPatchLinkAll(&apos;&apos;#&apos;&apos; + this.ID.PATCH_REMOVE_ALL, this.REMOVE_ADD);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.registerClickHandlerForPatchLink = function(oClassCombination) {&apos;.
        _inline &apos;  // register onclick handler. When a link is clicked it is&apos;.
        _inline &apos;  // deactivated and its corresponding link gets active&apos;.
        _inline &apos;  //&apos;.
        _inline &apos;  // e.g. if you click on &apos;&apos;add&apos;&apos; add is deactivated and &apos;&apos;remove&apos;&apos;&apos;.
        _inline &apos;  // is activated.&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var elLinkAll = document.querySelectorAll(&apos;&apos;.&apos;&apos; + this.CSS_CLASS.PATCH + &apos;&apos; a.&apos;&apos; + oClassCombination.sClassLinkClicked);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  [].forEach.call(elLinkAll,function(elLink){&apos;.
        _inline &apos;&apos;.
        _inline &apos;    elLink.addEventListener(&apos;&apos;click&apos;&apos;,function(oEvent){&apos;.
        _inline &apos;      this.togglePatchActiveForClassLink(oEvent, elLink, oClassCombination);&apos;.
        _inline &apos;    }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.togglePatchActive = function(oEvent, elClicked, elCorrespondingLink){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  if (!elClicked.classList.contains(this.CSS_CLASS.PATCH_ACTIVE)){&apos;.
        _inline &apos;    elClicked.classList.toggle(this.CSS_CLASS.PATCH_ACTIVE);&apos;.
        _inline &apos;    elCorrespondingLink.classList.toggle(this.CSS_CLASS.PATCH_ACTIVE);&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;&apos;.
        _inline &apos;  oEvent.preventDefault();&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.togglePatchActiveForClassLink = function(oEvent, elClicked, oClassCombination) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var sCorrespondingLinkId = this.getCorrespodingLinkId(elClicked.id, oClassCombination);&apos;.
        _inline &apos;  var elCorrespondingLink = document.querySelector(&apos;&apos;#&apos;&apos; + this.escapeDots(sCorrespondingLinkId));&apos;.
        _inline &apos;&apos;.
        _inline &apos;  this.togglePatchActive(oEvent, elClicked, elCorrespondingLink);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.getCorrespodingLinkId = function(sClickedLinkId, oClassCombination){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // e.g.&apos;.
        _inline &apos;  //&apos;.
        _inline &apos;  //   add_patch_z_test_git_add_p.prog.abap_28 =&gt; remove_patch_z_test_git_add_p.prog.abap_28&apos;.
        _inline &apos;  //&apos;.
        _inline &apos;  // and vice versa&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oRegexPatchClassPrefix = new RegExp(&apos;&apos;^&apos;&apos; + oClassCombination.sClassLinkClicked );&apos;.
        _inline &apos;  return sClickedLinkId.replace(oRegexPatchClassPrefix, oClassCombination.sClassCorrespondingLink);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.escapeDots = function(sFileName){&apos;.
        _inline &apos;  return sFileName.replace(/\./g,&apos;&apos;\\.&apos;&apos;);&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.patchLinkClickAll = function(oClassCombination) {&apos;.
        _inline &apos;  return function(oEvent) {&apos;.
        _inline &apos;&apos;.
        _inline &apos;    var sTableId = oEvent.srcElement.parentElement.parentElement.parentElement.parentElement.id;&apos;.
        _inline &apos;    var elAddAll = document.querySelectorAll(&apos;&apos;#&apos;&apos; + this.escapeDots(sTableId) + &apos;&apos; a.&apos;&apos; + oClassCombination.sClassLinkClicked);&apos;.
        _inline &apos;&apos;.
        _inline &apos;    [].forEach.call(elAddAll,function(elem){&apos;.
        _inline &apos;      this.togglePatchActiveForClassLink(oEvent, elem, oClassCombination);&apos;.
        _inline &apos;    }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;    oEvent.preventDefault();&apos;.
        _inline &apos;&apos;.
        _inline &apos;  }&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.registerClickHandlerForPatchLinkAll = function(sSelector, oClassCombination){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var elAll = document.querySelectorAll(sSelector);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  [].forEach.call(elAll, function(elem){&apos;.
        _inline &apos;    elem.addEventListener(&apos;&apos;click&apos;&apos;, this.patchLinkClickAll(oClassCombination).bind(this));&apos;.
        _inline &apos;  }.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.registerStagePatch = function registerStagePatch(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var elStage = document.querySelector(&apos;&apos;#&apos;&apos; + this.ID.STAGE);&apos;.
        _inline &apos;  elStage.addEventListener(&apos;&apos;click&apos;&apos;, this.stagePatch.bind(this));&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // for hotkeys&apos;.
        _inline &apos;  window.stagePatch = function(){&apos;.
        _inline &apos;    this.stagePatch();&apos;.
        _inline &apos;  }.bind(this);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.stagePatch = function() {&apos;.
        _inline &apos;&apos;.
        _inline &apos;  // Collect add and remove info and submit to backend&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var aAddPatch = this.collectActiveElementsForSelector(&apos;&apos;.&apos;&apos; + this.CSS_CLASS.PATCH +&apos;&apos; a.&apos;&apos; + this.CSS_CLASS.ADD);&apos;.
        _inline &apos;  var aRemovePatch = this.collectActiveElementsForSelector(&apos;&apos;.&apos;&apos; + this.CSS_CLASS.PATCH + &apos;&apos; a.&apos;&apos; + this.CSS_CLASS.REMOVE);&apos;.
        _inline &apos;&apos;.
        _inline &apos;  submitSapeventForm({&apos;&apos;add&apos;&apos;: aAddPatch, &apos;&apos;remove&apos;&apos;: aRemovePatch}, this.ACTION.PATCH_STAGE, &quot;post&quot;);&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;Patch.prototype.collectActiveElementsForSelector = function(sSelector){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  return [].slice.call(document.querySelectorAll(sSelector))&apos;.
        _inline &apos;    .filter(function(elem){&apos;.
        _inline &apos;      return elem.classList.contains(this.CSS_CLASS.PATCH_ACTIVE);&apos;.
        _inline &apos;    }.bind(this))&apos;.
        _inline &apos;    .map(function(elem){&apos;.
        _inline &apos;      return elem.id;&apos;.
        _inline &apos;    });&apos;.
        _inline &apos;&apos;.
        _inline &apos;};&apos;.
        _inline &apos;&apos;.
        _inline &apos;&apos;.
        _inline &apos;function preparePatch(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oPatch = new Patch();&apos;.
        _inline &apos;  oPatch.preparePatch();&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
        _inline &apos;&apos;.
        _inline &apos;function registerStagePatch(){&apos;.
        _inline &apos;&apos;.
        _inline &apos;  var oPatch = new Patch();&apos;.
        _inline &apos;  oPatch.registerStagePatch();&apos;.
        _inline &apos;&apos;.
        _inline &apos;}&apos;.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |No inline resource: { iv_asset_url }| ).
    ENDCASE.

    IF lt_data IS NOT INITIAL.
      CONCATENATE LINES OF lt_data INTO lv_str SEPARATED BY zif_abapgit_definitions=&gt;c_newline.
      rs_asset-content = string_to_xstring( lv_str ).
    ELSE.
      rs_asset-content = get_mime_asset( lv_mime_name ).
    ENDIF.

    IF rs_asset-content IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |Failed to get GUI resource: { iv_asset_url }| ).
    ENDIF.

  ENDMETHOD.
  METHOD get_inline_images.

    DATA:
      lv_base64 TYPE string,
      ls_image  LIKE LINE OF rt_images.

* see https://github.com/larshp/abapGit/issues/201 for source SVG
    ls_image-url     = &apos;img/logo&apos; ##NO_TEXT.
    ls_image-type    = &apos;image&apos;.
    ls_image-subtype = &apos;pmg&apos;.
    lv_base64 =
         &apos;iVBORw0KGgoAAAANSUhEUgAAAKMAAAAoCAYAAACSG0qbAAAABHNCSVQICAgIfAhkiAAA&apos;
      &amp;&amp; &apos;AAlwSFlzAAAEJQAABCUBprHeCQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9y&apos;
      &amp;&amp; &apos;Z5vuPBoAAA8VSURBVHic7Zx7cJzVeYef31nJAtvYko1JjM3FYHlXimwZkLWyLEMcwIGQ&apos;
      &amp;&amp; &apos;cEkDJWmTltLStGkoDCkzwBAuCemUlksDNCkhJTTTljJpZhIuBQxxAWPvyuYiW7UkG8Il&apos;
      &amp;&amp; &apos;UByIsS1sLEu75+0fu5JXu9/etAJz0TOzM/rOec85765+37m+3yczY8w0NU3qrwv9npfa&apos;
      &amp;&amp; &apos;Hfx02pPPd469sgk+7misYnyjpWXy5IOG7kd8ZjjNjEtr13TdOm7eTfCxwo2lUJAQASRu&apos;
      &amp;&amp; &apos;2dnRfMn4uDbBx42yxZhPiMNMCHKCsVK2GGuqqqoQUwrZTAhygrFQshjfaGmZ/M7yxQtm&apos;
      &amp;&amp; &apos;xGL9/qDqzwLxQvYTgpygXEoS4/DQ7LE1O05atLBu1YZdE4KcYLwpupoOmCO+5Z2dXPfE&apos;
      &amp;&amp; &apos;xk07Tm2ZroGhBwX1wAygKqiOiVX2Rw9Jam/gyH0wuGGzvTEudRYSY4HFyogghxN2n7Sw&apos;
      &amp;&amp; &apos;IendvcCioLoOtCCXNeqohOf0oDwPq9f3Wt/77dOHlWhYzUj/BRybTnrGEnZO5wv2m0rq&apos;
      &amp;&amp; &apos;DezJoOiqeZbzegzpk6TVPPWJTT39y5svMogF1ZcesjlQgkwYp4F+EJQXwv4E+MiLUZJa&apos;
      &amp;&amp; &apos;F7AIcRq4hWZ2mMRhQD/oZcErXv7FScaja3rt/wpU9E/sFyLACQq57wB/XIl/gWIstn2T&apos;
      &amp;&amp; &apos;xpHVre7ZW71p8sFDeQscSEHKu3pTBadNH2Lq61VT57iwNazLgaNSqYaUaWXLDZCJIbBo&apos;
      &amp;&amp; &apos;g3tK2A2xHns0oMrm3CRrqdTPnAVMiUIEmLlz2XGLMxNmH7YrifFcoUIHalHj8f8p6UfA&apos;
      &amp;&amp; &apos;O+932weStno1zghps6Q7GBFiUYRxopkeaZ2vIwLyfxtQ4vV8lbWHNScacf+T/vwqn90o&apos;
      &amp;&amp; &apos;MZYhRADJ+bv725vmj6Q8tHWffPKUD6IgO/tsfawneRHYd97Pdg8kSyJaZiGtBY4pYPYO&apos;
      &amp;&amp; &apos;kH84C0Cyv8tKSiK7OZ99EpYAJ2V8AhkRY5lCHGaxhaq+BLCzY/EXd5y0aOG0td1vf1AF&apos;
      &amp;&amp; &apos;CWCw7/1u80DQEtahQvcB03MyjQfM7Hwnmxfv9dPivX5SssqOwuzPSqk71mN3ymw5ZtdK&apos;
      &amp;&amp; &apos;dmVIdly8xx7JZ29yy0qptwrGLMRRCA6T1w93nLTo5Lq13Zv625tOMRd6DLF4v0lWmQO8&apos;
      &amp;&amp; &apos;qPko45y7TWaHZyUnwa6M99mN2fYbuu1V4K5oxF1B4Z4UgFifrQHWFLNbvkh1QheV5DNN&apos;
      &amp;&amp; &apos;TZMqFWIGs5zX48M95PTqGa3TZ4erzbvj8/WUErf0L2++uNyGJLn2Js1oDeuYlkbNbmlR&apos;
      &amp;&amp; &apos;deXup2hq0qS2es2VlHMDFaOlRdXL5uuwlnodG23QTEljCkbJV3d7WHOK+dXWqHqZnZeb&apos;
      &amp;&amp; &apos;Y1fGe3OFOArRU5GTGbSHNWdwUL8Epo1qIQ9V/bXu3HES4jCznNfjb7e1zZ8Ri/UD1MLz&apos;
      &amp;&amp; &apos;u05s/huMx4IKGNy4+8Tj/2Pqk8++Vaji86TQqxEuNNM5rWGtSCaokSDkgd0QjbidoPvN&apos;
      &amp;&amp; &apos;+5s7t9jz5TgdbdBMvLsG2cop6FgLUdUaZk804jYKuyrWa6vzlT2+XrOqQnxd6KwQOj5R&apos;
      &amp;&amp; &apos;hULpL9Yaxkcj7g3QT6zK397ZbdtGtbtAZ+B0U3adkt0c67E7OyI6fFDuSpktC6HGpJjU&apos;
      &amp;&amp; &apos;GmZ3NOI2mdnVnX32eHZZ7903hGXfBG8mp3J7sd/B0DPCTgUmBf9O7lmMybk56or3Jn8f&apos;
      &amp;&amp; &apos;oLVB7Q5dZ9Iy4OBsw2jYbUUk96fwQrzHf955iBZzsDA+aL9k1owZ20fNzaY/tfFXwK48&apos;
      &amp;&amp; &apos;ldQkSZ5YqJXmZk15JaJfmOmfgdOAmgCzWrCvyum5aIO+Uor3AIbOx7QV2TeBMPu3vKYA&apos;
      &amp;&amp; &apos;Sw091hbWt4PKRhu0oDqkmND1wAnk3vkOmAN2lRLa2hrWMVm5Tek2R3286YzWiK4eQltk&apos;
      &amp;&amp; &apos;9g1gMfsFMhVYKunR1obQddk+SXZqwLe8acMGe7fYb9HZk7wm3utrBmpsqiXsyClHMHK6&apos;
      &amp;&amp; &apos;0hLWoRjHBfmLbP9K3bPYjFPIFWLaQeZnlZ8H4JyFflrMwcK4wG63v3/ycZnXOzqalxE0&apos;
      &amp;&amp; &apos;mU7x9rvvVv93oVZqBtzNGGeU7Jbp9pZGzS7ReiVQVyDfmXRda4PaA9p5mBLmWGmmSron&apos;
      &amp;&amp; &apos;M0FytUGGgjPTAi8UIeVk9u1og5YOJ0QbNBOjIac+Y22JPgLQ1WV7Ol+w36xebYnhtGpj&apos;
      &amp;&amp; &apos;FjBYTj3l4KY9/dx6My4d74pN/Ki/Y9HpSG5HR/Nyh/1DHtO9OM6dvWFDwbtWslOykt6U&apos;
      &amp;&amp; &apos;s5VWZbOFnQtsyMqvc56Ty3T7NeBhLGAfDZDpe5nX6V5uXpbZ43K2NGQ2V9glwLas/I62&apos;
      &amp;&amp; &apos;hfrE8EWsJ3mFsGYs+OQqze+A1cBLgbmma4f/9AmOJGBe5vKVLYN1W6wnOWSHmdkVhexM&apos;
      &amp;&amp; &apos;PG6yC0x2AbmjoQ3njdh4uwrSw1Htmq5bd3Y0I3FLpQ5n0GTSQ7s6Fva70RPYTPbi+Pz0&apos;
      &amp;&amp; &apos;J7ryboRC+m5PnRfsJjVEAfp5bLNflTb52dKIBj36RWY5ZyX2WCLukvbX67ZYHFLHZtGw&apos;
      &amp;&amp; &apos;+1fD/jDL8qQljWpav9m6Uw3wKYzXgUNJTxsk+0Fssw0L6x+j4dCx6eF/BEtwDBkbx7Fe&apos;
      &amp;&amp; &apos;29gWCa0yrC2rvXXO26WZfrWG3V2kji8zWbm0QUev67GX5ZgZ8A0H121hXIIZNrxou9oW&apos;
      &amp;&amp; &apos;6m4b4m/z2aTP+fsAohF3PaNHROvssZ8ElRs5DnyPBAkovxDFF4oJESDeY9tJD4Ur5umg&apos;
      &amp;&amp; &apos;PSFm1Uy23Zk2SaM7e43p5Y4uxUMzu2f4H56+tuZmff2gfTqHrGEy5DkW6Abo7LH7gfsB&apos;
      &amp;&amp; &apos;2uo1LQGzBmoYFSwg57vNcjqqo4F1JXh2S7Zfx83TZZNqdD6MXkQkU369jONgcmfxe83M&apos;
      &amp;&amp; &apos;B7XQEdEhg1B0HzDk2ZHpy3vBqLPpMQhyi/f2AIA3WyPZG6KkeVpKiE925awEi7H6JRsA&apos;
      &amp;&amp; &apos;cqJDfIi9oayfW8ZB5dY/TFeX7YlGQg+RmgJkcnSQfWyr9QP92enmGcgeNCvx67mXbGdb&apos;
      &amp;&amp; &apos;xD1hjI5AklJ+ydgTUGz6iiZNXd09+gYGGIRlQgXn6wDesZYSRFsJOYES5QjSw7fqnu7q&apos;
      &amp;&amp; &apos;Bqh7uqu7f3nzdw3uKFJszEIcpqVRs12SRuAYiTrJ1YXMzSGgS6iQnHmWyQWe70pySz/F&apos;
      &amp;&amp; &apos;MZagMWnMlaiTuTqTTih7s7IIHm1T1ncVI37l3BAAA4McAYF7iAvG17uxExi1U6Igd9XN&apos;
      &amp;&amp; &apos;Dj+UmZA8qPrf3MDQbeSPIN8Ldub0JzeWLcT2I3Swn8JFhr4VQnMze5uKnv0ugOHfUXa3&apos;
      &amp;&amp; &apos;ZhySedkR0eGDuMtbw/rTZCI1pA9PF0yWf4e3MnJ7YKXm0pOr6H03QRIIZeYnUj1njhid&apos;
      &amp;&amp; &apos;8aaRscKX/VGWSRLsCjnK2rcdC3njGUsQ5PSdv92yqJaMk5WBoRMpJsSnNgZufBdCkmsN&apos;
      &amp;&amp; &apos;60FgRbllK8PNzOlttT/qpz2sOUnpeWGHvq9ewcyc28/7XQCru213NOL+l6wgZ0kXAjnD&apos;
      &amp;&amp; &apos;cazP7gXuTdu41rCyxbgr3mt/P16+F6LgUVXtmq5bC237yNsNu5YtPBZgx4kLFznZ1XlM&apos;
      &amp;&amp; &apos;BzB/1liECBAN801yhfiq0HflbKXz1ojZ4qCylSBsbm6q/93wX0n0Q1Ir6UzWYXaZyZaF&apos;
      &amp;&amp; &apos;qqxeZn813n4ZlhPWJWXMo00P5OTDF5c0qmm8fRlPip6bFhHk6Ti3ddfy5i3OXBemJQE2&apos;
      &amp;&amp; &apos;A5g/c/qaTasC8krC0KdzE+3qWG/y6thmW7Vui/UkQ7w51vqDaGnRZFInPdlshNQ2C8oJ&apos;
      &amp;&amp; &apos;h0oqaefF++zmzh5bu7bbXrBxjp88bp5qgZzNdyfWD/9t+B+TO4GW8/p+R0SHcGBxLWEF&apos;
      &amp;&amp; &apos;jiQlHeIXEaRIPZAVRMVCTDcQCUh8LfOyaqjgCcr+YpY7NRFa2VY/egsqtNtdw8ie5gjJ&apos;
      &amp;&amp; &apos;oUTqicjofOYA2f/YgcR03s5MMBF4wlIa7rMr5mnUyru6xl0LZAeFvDG3l83DF5199muk&apos;
      &amp;&amp; &apos;oJO1FUMoviSi8Nh9Kg+Ru7qvUvCqPO+cMZsxbPsM4HXW9KcrEyKApTa7s9BVSyLaF3Ik&apos;
      &amp;&amp; &apos;SbLSQros18RyInkkV2u5q+6zLaS+aCT0oJl/QVI78IWcsvDos1vtLYCE551QKNuCKW63&apos;
      &amp;&amp; &apos;+157g36cMOYI9yWhC3K+j4KDEHKxC9+t0altDaFHwL/kvVZIBJw761/uM5/MTJlU7S/Z&apos;
      &amp;&amp; &apos;N6hTBNlhZA0OPReNuGdM6nL4jR4G5ZnRusAtKmVHwg1Slcxe11nODZJKh1fJ6kwM3dQa&apos;
      &amp;&amp; &apos;VgOw3omjkGuL9/o/L/vFTzs7mi8pQZBpIT4f9PxE2bRFQncY9pdjKDoExDH7ebzPbgFo&apos;
      &amp;&amp; &apos;bQjdng48KBfvzZau77ORN61FI66PsW2N7ARiZnZTZ589BtAWCV1v5J1zF+JNVdui2CbL&apos;
      &amp;&amp; &apos;OcJsq1ejD2lVgCDL4e14r58J0N6k+cmEu0HYIssdrbxgnaGeeG9yJEg32hC6GbOix81y&apos;
      &amp;&amp; &apos;trTsWLtiixpgQNLZ4yVEgCT++xSP0H7C0N1ZadVAh6SR3kRm2WfJO0H/XqTuQcn+IlOI&apos;
      &amp;&amp; &apos;AFjRVaZhus3g2az0WuA0wcIi5QP3DDNIIPtakBABYltts7AO4OEi9eTFYGCksSRzwM4L&apos;
      &amp;&amp; &apos;ECKAM1gG9tVR5UP+RkqZN5s7a0yBnwUEOSDp7GlPPp83BH0srO+1PmQrDIIen9wOdnln&apos;
      &amp;&amp; &apos;n31G5n9ZtDLL6ck2x3uTf6DUee8rASX6vNnyWI/dmZ0R77O7LNXLBkWy9CE7Pd6XvNih&apos;
      &amp;&amp; &apos;QkEQeZHZl9PBFtsDstebtyWFwv0B4r32UrzXn+6xDtBdwIslNL0N+JnMvravxiraFO/s&apos;
      &amp;&amp; &apos;tm0y+xzQlcfkddCNCe/vGfP7GQH6lzdfbHAjqSCBHZK+PN5CzESSlixgnhMLzXAeXp+3&apos;
      &amp;&amp; &apos;hWfuM0sWL10abQv1CdtHixzvmtiYPhcvSFOTJk1NEPEQkWdPUry4oc96y2o3YJiWs5Wx&apos;
      &amp;&amp; &apos;zbYq83THHHu9Y1N2kG45tDRqdsgzxxuznKPOGbsTsN2M7d6zfXhePJ5Ici1h6mUcAcw0&apos;
      &amp;&amp; &apos;8Zo5fp35NoqKxAjwTrRhZmLSpPY9ySmPzV27dm+lTn9cKSTGA+XT+03Jq+l8HBLv2Q7c&apos;
      &amp;&amp; &apos;X9K+ygQTFGDcHhaaoGJyouDNV7JH+eGj4mF6gspoC+tzJt1ObsT4MDsF2zxs886+Ml5v&apos;
      &amp;&amp; &apos;/PogUvEwPUGFiE+SX4gAtQa1gkhV7onQR4oJMR5oxC6stDeghd7Dh6E+CPw/HL4vVO2f&apos;
      &amp;&amp; &apos;cpUAAAAASUVORK5CYII=&apos;.
    ls_image-content = base64_to_xstring( lv_base64 ).
    APPEND ls_image TO rt_images.

  ENDMETHOD.
  METHOD get_mime_asset.

    DATA: ls_key    TYPE wwwdatatab,
          lv_size_c TYPE wwwparams-value,
          lv_size   TYPE i,
          lt_w3mime TYPE STANDARD TABLE OF w3mime.

    ls_key-relid = &apos;MI&apos;.
    ls_key-objid = iv_mime_name.

    &quot; Get exact file size
    CALL FUNCTION &apos;WWWPARAMS_READ&apos;
      EXPORTING
        relid            = ls_key-relid
        objid            = ls_key-objid
        name             = &apos;filesize&apos;
      IMPORTING
        value            = lv_size_c
      EXCEPTIONS
        entry_not_exists = 1.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    lv_size = lv_size_c.

    &quot; Get binary data
    CALL FUNCTION &apos;WWWDATA_IMPORT&apos;
      EXPORTING
        key               = ls_key
      TABLES
        mime              = lt_w3mime
      EXCEPTIONS
        wrong_object_type = 1
        import_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    rv_xdata = bintab_to_xstring(
      iv_size   = lv_size
      it_bintab = lt_w3mime ).

  ENDMETHOD.
  METHOD string_to_xstring.

    CALL FUNCTION &apos;SCMS_STRING_TO_XSTRING&apos;
      EXPORTING
        text   = iv_str
      IMPORTING
        buffer = rv_xstr
      EXCEPTIONS
        OTHERS = 1.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD base64_to_xstring.

    CALL FUNCTION &apos;SSFC_BASE64_DECODE&apos;
      EXPORTING
        b64data = iv_base64
      IMPORTING
        bindata = rv_xstr
      EXCEPTIONS
        OTHERS  = 1.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD bintab_to_xstring.

    CALL FUNCTION &apos;SCMS_BINARY_TO_XSTRING&apos;
      EXPORTING
        input_length = iv_size
      IMPORTING
        buffer       = rv_xstr
      TABLES
        binary_tab   = it_bintab
      EXCEPTIONS
        failed       = 1 ##FM_SUBRC_OK.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD xstring_to_bintab.

    CALL FUNCTION &apos;SCMS_XSTRING_TO_BINARY&apos;
    EXPORTING
      buffer        = iv_xstr
    IMPORTING
      output_length = ev_size
    TABLES
      binary_tab    = et_bintab.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_GUI IMPLEMENTATION.
  METHOD back.

    DATA: lv_index TYPE i,
          ls_stack LIKE LINE OF mt_stack.

    lv_index = lines( mt_stack ).

    IF lv_index = 0.
      rv_exit = abap_true.
      RETURN.
    ENDIF.

    DO lv_index TIMES.
      READ TABLE mt_stack INDEX lv_index INTO ls_stack.
      ASSERT sy-subrc = 0.

      DELETE mt_stack INDEX lv_index.
      ASSERT sy-subrc = 0.

      lv_index = lv_index - 1.

      IF iv_to_bookmark = abap_false OR ls_stack-bookmark = abap_true.
        EXIT.
      ENDIF.
    ENDDO.

    mi_cur_page = ls_stack-page. &quot; last page always stays
    render( ).

  ENDMETHOD.
  METHOD cache_asset.

    DATA: lv_xstr  TYPE xstring,
          lt_xdata TYPE lvc_t_mime,
          lv_size  TYPE int4.

    ASSERT iv_text IS SUPPLIED OR iv_xdata IS SUPPLIED.

    IF iv_text IS SUPPLIED. &quot; String input
      lv_xstr = zcl_abapgit_gui_asset_manager=&gt;string_to_xstring( iv_text ).
    ELSE. &quot; Raw input
      lv_xstr = iv_xdata.
    ENDIF.

    zcl_abapgit_gui_asset_manager=&gt;xstring_to_bintab(
      EXPORTING
        iv_xstr   = lv_xstr
      IMPORTING
        ev_size   = lv_size
        et_bintab = lt_xdata ).

    mo_html_viewer-&gt;load_data(
      EXPORTING
        type         = iv_type
        subtype      = iv_subtype
        size         = lv_size
        url          = iv_url
      IMPORTING
        assigned_url = rv_url
      CHANGING
        data_table   = lt_xdata
      EXCEPTIONS
        OTHERS       = 1 ) ##NO_TEXT.

    ASSERT sy-subrc = 0. &quot; Image data error

  ENDMETHOD.
  METHOD cache_html.

    rv_url = cache_asset( iv_text    = iv_text
                          iv_type    = &apos;text&apos;
                          iv_subtype = &apos;html&apos; ).

  ENDMETHOD.
  METHOD call_page.

    DATA: ls_stack TYPE ty_page_stack.

    IF iv_replacing = abap_false AND NOT mi_cur_page IS INITIAL.
      ls_stack-page     = mi_cur_page.
      ls_stack-bookmark = iv_with_bookmark.
      APPEND ls_stack TO mt_stack.
    ENDIF.

    mi_cur_page = ii_page.
    render( ).

  ENDMETHOD.
  METHOD constructor.

    mi_router    = ii_router.
    mi_asset_man = ii_asset_man.
    startup( ).

  ENDMETHOD.

  METHOD get_current_page_name.
    IF mi_cur_page IS BOUND.
      rv_page_name =
        cl_abap_classdescr=&gt;describe_by_object_ref( mi_cur_page
          )-&gt;get_relative_name( ).
    ENDIF.&quot; ELSE - return is empty =&gt; initial page

  ENDMETHOD.
  METHOD go_home.

    on_event( action = |{ zif_abapgit_definitions=&gt;c_action-go_main }| ). &quot; doesn&apos;t accept strings directly

  ENDMETHOD.
  METHOD handle_action.

    DATA: lx_exception TYPE REF TO zcx_abapgit_exception,
          li_page      TYPE REF TO zif_abapgit_gui_page,
          lv_state     TYPE i.

    TRY.
        IF mi_cur_page IS BOUND.
          mi_cur_page-&gt;on_event(
            EXPORTING
              iv_action    = iv_action
              iv_prev_page = get_current_page_name( )
              iv_getdata   = iv_getdata
              it_postdata  = it_postdata
            IMPORTING
              ei_page      = li_page
              ev_state     = lv_state ).
        ENDIF.

        IF lv_state IS INITIAL.
          mi_router-&gt;on_event(
            EXPORTING
              iv_action    = iv_action
              iv_prev_page = get_current_page_name( )
              iv_getdata   = iv_getdata
              it_postdata  = it_postdata
            IMPORTING
              ei_page      = li_page
              ev_state     = lv_state ).
        ENDIF.

        CASE lv_state.
          WHEN zif_abapgit_definitions=&gt;c_event_state-re_render.
            render( ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-new_page.
            call_page( li_page ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-new_page_w_bookmark.
            call_page( ii_page = li_page iv_with_bookmark = abap_true ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-new_page_replacing.
            call_page( ii_page = li_page iv_replacing = abap_true ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-go_back.
            back( ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-go_back_to_bookmark.
            back( abap_true ).
          WHEN zif_abapgit_definitions=&gt;c_event_state-no_more_act.
            &quot; Do nothing, handling completed
          WHEN OTHERS.
            zcx_abapgit_exception=&gt;raise( |Unknown action: { iv_action }| ).
        ENDCASE.

      CATCH zcx_abapgit_exception INTO lx_exception.
        ROLLBACK WORK.
        MESSAGE lx_exception TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
      CATCH zcx_abapgit_cancel ##NO_HANDLER.
        &quot; Do nothing = gc_event_state-no_more_act
    ENDTRY.

  ENDMETHOD.
  METHOD on_event.

    handle_action(
      iv_action      = action
      iv_frame       = frame
      iv_getdata     = getdata
      it_postdata    = postdata
      it_query_table = query_table ).

  ENDMETHOD.
  METHOD render.

    DATA: lv_url  TYPE w3url,
          lo_html TYPE REF TO zcl_abapgit_html.

    lo_html = mi_cur_page-&gt;render( ).
    lv_url  = cache_html( lo_html-&gt;render( iv_no_indent_jscss = abap_true ) ).

    mo_html_viewer-&gt;show_url( lv_url ).

  ENDMETHOD.
  METHOD startup.

    DATA: lt_events TYPE cntl_simple_events,
          ls_event  LIKE LINE OF lt_events,
          lt_assets TYPE zif_abapgit_gui_asset_manager=&gt;tt_web_assets.

    FIELD-SYMBOLS &lt;ls_asset&gt; LIKE LINE OF lt_assets.

    CREATE OBJECT mo_html_viewer
      EXPORTING
        query_table_disabled = abap_true
        parent               = cl_gui_container=&gt;screen0.

    lt_assets = mi_asset_man-&gt;get_all_assets( ).
    LOOP AT lt_assets ASSIGNING &lt;ls_asset&gt;.
      cache_asset( iv_xdata   = &lt;ls_asset&gt;-content
                   iv_url     = &lt;ls_asset&gt;-url
                   iv_type    = &lt;ls_asset&gt;-type
                   iv_subtype = &lt;ls_asset&gt;-subtype ).
    ENDLOOP.

    ls_event-eventid    = mo_html_viewer-&gt;m_id_sapevent.
    ls_event-appl_event = abap_true.
    APPEND ls_event TO lt_events.

    mo_html_viewer-&gt;set_registered_events( lt_events ).
    SET HANDLER me-&gt;on_event FOR mo_html_viewer.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_DB_EDIT IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_key = is_key.
    ms_control-page_title = &apos;CONFIG EDIT&apos;.
  ENDMETHOD.
  METHOD dbcontent_decode.

    DATA: lt_fields TYPE tihttpnvp,
          lv_string TYPE string.
    CONCATENATE LINES OF it_postdata INTO lv_string.

    lv_string = cl_http_utility=&gt;unescape_url( lv_string ).

    rs_content = zcl_abapgit_html_action_utils=&gt;dbkey_decode( lv_string ).

    lt_fields = zcl_abapgit_html_action_utils=&gt;parse_fields_upper_case_name( lv_string ).

    zcl_abapgit_html_action_utils=&gt;get_field(
      EXPORTING
        iv_name = &apos;XMLDATA&apos;
        it_field = lt_fields
      CHANGING
        cg_field = rs_content-data_str ).

    IF rs_content-data_str(1) &lt;&gt; &apos;&lt;&apos; AND rs_content-data_str+1(1) = &apos;&lt;&apos;. &quot; Hmmm ???
      rs_content-data_str = rs_content-data_str+1.
    ENDIF.

  ENDMETHOD.
  METHOD render_content.

    DATA: lv_data    TYPE zif_abapgit_persistence=&gt;ty_content-data_str,
          lo_toolbar TYPE REF TO zcl_abapgit_html_toolbar.

    TRY.
        lv_data = zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;read(
          iv_type  = ms_key-type
          iv_value = ms_key-value ).
      CATCH zcx_abapgit_not_found ##NO_HANDLER.
    ENDTRY.

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;lock(
      iv_type  = ms_key-type
      iv_value = ms_key-value ).

    lv_data = escape( val    = zcl_abapgit_xml_pretty=&gt;print( lv_data )
                      format = cl_abap_format=&gt;e_html_attr ).

    CREATE OBJECT ro_html.
    CREATE OBJECT lo_toolbar.
    lo_toolbar-&gt;add( iv_act = &apos;submitFormById(&apos;&apos;db_form&apos;&apos;);&apos;
                     iv_txt = &apos;Save&apos;
                     iv_typ = zif_abapgit_definitions=&gt;c_action_type-onclick
                     iv_opt = zif_abapgit_definitions=&gt;c_html_opt-strong ) ##NO_TEXT.

    ro_html-&gt;add( &apos;&lt;div class=&quot;db_entry&quot;&gt;&apos; ).

    &quot; Banners &amp; Toolbar
    ro_html-&gt;add( &apos;&lt;table class=&quot;toolbar&quot;&gt;&lt;tr&gt;&lt;td&gt;&apos; ).
    ro_html-&gt;add( zcl_abapgit_gui_page_db_dis=&gt;render_record_banner( ms_key ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;td&gt;&apos; ).
    ro_html-&gt;add( lo_toolbar-&gt;render( iv_right = abap_true ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&apos; ).

    &quot; Form
    ro_html-&gt;add( |&lt;form id=&quot;db_form&quot; method=&quot;post&quot; action=&quot;sapevent:| &amp;&amp; |{ c_action-update }&quot;&gt;| ).
    ro_html-&gt;add( |&lt;input type=&quot;hidden&quot; name=&quot;type&quot; value=&quot;{ ms_key-type }&quot;&gt;| ).
    ro_html-&gt;add( |&lt;input type=&quot;hidden&quot; name=&quot;value&quot; value=&quot;{ ms_key-value }&quot;&gt;| ).
    ro_html-&gt;add( |&lt;textarea rows=&quot;20&quot; cols=&quot;100&quot; name=&quot;xmldata&quot;&gt;{ lv_data }&lt;/textarea&gt;| ).
    ro_html-&gt;add( &apos;&lt;/form&gt;&apos; ).

    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ). &quot;db_entry

  ENDMETHOD.
  METHOD update.

    ASSERT is_content-type IS NOT INITIAL.

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;update(
      iv_type  = is_content-type
      iv_value = is_content-value
      iv_data  = is_content-data_str ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: ls_db TYPE zif_abapgit_persistence=&gt;ty_content.

    CASE iv_action.
      WHEN c_action-update.
        ls_db = dbcontent_decode( it_postdata ).
        update( ls_db ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-go_back.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_DB_DIS IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_key = is_key.
    ms_control-page_title = &apos;CONFIG DISPLAY&apos;.
  ENDMETHOD.
  METHOD render_content.

    DATA:
      lo_highlighter TYPE REF TO zcl_abapgit_syntax_highlighter,
      lo_toolbar     TYPE REF TO zcl_abapgit_html_toolbar,
      lv_data        TYPE zif_abapgit_persistence=&gt;ty_content-data_str,
      ls_action      TYPE zif_abapgit_persistence=&gt;ty_content,
      lv_action      TYPE string.

    TRY.
        lv_data = zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;read(
          iv_type = ms_key-type
          iv_value = ms_key-value ).
      CATCH zcx_abapgit_not_found ##NO_HANDLER.
    ENDTRY.

    &quot; Create syntax highlighter
    lo_highlighter  = zcl_abapgit_syntax_highlighter=&gt;create( &apos;*.xml&apos; ).

    ls_action-type  = ms_key-type.
    ls_action-value = ms_key-value.
    lv_action       = zcl_abapgit_html_action_utils=&gt;dbkey_encode( ls_action ).
    lv_data         = lo_highlighter-&gt;process_line( zcl_abapgit_xml_pretty=&gt;print( lv_data ) ).

    CREATE OBJECT ro_html.
    CREATE OBJECT lo_toolbar.
    lo_toolbar-&gt;add( iv_act = |{ zif_abapgit_definitions=&gt;c_action-db_edit }?{ lv_action }|
                     iv_txt = &apos;Edit&apos; ) ##NO_TEXT.

    ro_html-&gt;add( &apos;&lt;div class=&quot;db_entry&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;table class=&quot;toolbar&quot;&gt;&lt;tr&gt;&lt;td&gt;&apos; ).
    ro_html-&gt;add( render_record_banner( ms_key ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;td&gt;&apos; ).
    ro_html-&gt;add( lo_toolbar-&gt;render( iv_right = abap_true ) ).
    ro_html-&gt;add( &apos;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&apos; ).

    ro_html-&gt;add( |&lt;pre class=&quot;syntax-hl&quot;&gt;{ lv_data }&lt;/pre&gt;| ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD render_record_banner.
    rv_html = |&lt;table class=&quot;tag&quot;&gt;&lt;tr&gt;&lt;td class=&quot;label&quot;&gt;Type:&lt;/td&gt;|
           &amp;&amp; | &lt;td&gt;{ is_key-type }&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;|
           &amp;&amp; zif_abapgit_definitions=&gt;c_newline
           &amp;&amp; |&lt;table class=&quot;tag&quot;&gt;&lt;tr&gt;&lt;td class=&quot;label&quot;&gt;Key:&lt;/td&gt;|
           &amp;&amp; |  &lt;td&gt;{ is_key-value }&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;|.
  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GUI_PAGE_DB IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    ms_control-page_title = &apos;DATABASE PERSISTENCY&apos;.
  ENDMETHOD.
  METHOD delete.

    DATA: lv_answer TYPE c LENGTH 1.

    ASSERT is_key-type IS NOT INITIAL.

    lv_answer = zcl_abapgit_ui_factory=&gt;get_popups( )-&gt;popup_to_confirm(
      iv_titlebar              = &apos;Warning&apos;
      iv_text_question         = &apos;Delete?&apos;
      iv_text_button_1         = &apos;Ok&apos;
      iv_icon_button_1         = &apos;ICON_DELETE&apos;
      iv_text_button_2         = &apos;Cancel&apos;
      iv_icon_button_2         = &apos;ICON_CANCEL&apos;
      iv_default_button        = &apos;2&apos;
      iv_display_cancel_button = abap_false ).                 &quot;#EC NOTEXT

    IF lv_answer = &apos;2&apos;.
      RAISE EXCEPTION TYPE zcx_abapgit_cancel.
    ENDIF.

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;delete(
      iv_type  = is_key-type
      iv_value = is_key-value ).

    COMMIT WORK.

  ENDMETHOD.
  METHOD explain_content.

    DATA: ls_result TYPE match_result,
          ls_match  TYPE submatch_result,
          lv_cnt    TYPE i.
    CASE is_data-type.
      WHEN &apos;REPO&apos;.
        FIND FIRST OCCURRENCE OF REGEX &apos;&lt;url&gt;(.*)&lt;/url&gt;&apos;
          IN is_data-data_str IGNORING CASE RESULTS ls_result.
        READ TABLE ls_result-submatches INTO ls_match INDEX 1.
        IF sy-subrc IS INITIAL.
          rv_text = is_data-data_str+ls_match-offset(ls_match-length).
        ENDIF.

        FIND FIRST OCCURRENCE OF REGEX &apos;&lt;OFFLINE/&gt;&apos;
          IN is_data-data_str IGNORING CASE MATCH COUNT lv_cnt.
        IF lv_cnt &gt; 0.
          rv_text = |&lt;strong&gt;On-line&lt;/strong&gt;, Name: &lt;strong&gt;{
                    zcl_abapgit_url=&gt;name( rv_text ) }&lt;/strong&gt;|.
        ELSE.
          rv_text = |Off-line, Name: &lt;strong&gt;{ rv_text }&lt;/strong&gt;|.
        ENDIF.

      WHEN &apos;BACKGROUND&apos;.
        FIND FIRST OCCURRENCE OF REGEX &apos;&lt;method&gt;(.*)&lt;/method&gt;&apos;
          IN is_data-data_str IGNORING CASE RESULTS ls_result.
        READ TABLE ls_result-submatches INTO ls_match INDEX 1.
        IF sy-subrc IS NOT INITIAL.
          RETURN.
        ENDIF.
        rv_text = |Method: { is_data-data_str+ls_match-offset(ls_match-length) }, |
               &amp;&amp; |Repository: { zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( is_data-value )-&gt;get_name( ) }|.

      WHEN &apos;USER&apos;.
        rv_text = &apos;-&apos;. &quot; No additional explanation for user
      WHEN &apos;SETTINGS&apos;.
        rv_text = &apos;-&apos;.
      WHEN OTHERS.
        IF strlen( is_data-data_str ) &gt;= 250.
          rv_text = is_data-data_str(250).
        ELSE.
          rv_text = is_data-data_str.
        ENDIF.
        rv_text = escape( val    = rv_text
                          format = cl_abap_format=&gt;e_html_attr ).
        rv_text = |&lt;pre&gt;{ rv_text }&lt;/pre&gt;|.
    ENDCASE.
  ENDMETHOD.
  METHOD render_content.

    DATA: lt_data    TYPE zif_abapgit_persistence=&gt;tt_content,
          lv_action  TYPE string,
          lv_trclass TYPE string,
          lo_toolbar TYPE REF TO zcl_abapgit_html_toolbar.

    FIELD-SYMBOLS: &lt;ls_data&gt; LIKE LINE OF lt_data.
    lt_data = zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;list( ).

    CREATE OBJECT ro_html.

    ro_html-&gt;add( &apos;&lt;div class=&quot;db_list&quot;&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;table class=&quot;db_tab&quot;&gt;&apos; ).

    &quot; Header
    ro_html-&gt;add( &apos;&lt;thead&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;th&gt;Type&lt;/th&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;th&gt;Key&lt;/th&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;th&gt;Data&lt;/th&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;th&gt;&lt;/th&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/thead&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;tbody&gt;&apos; ).

    &quot; Lines
    LOOP AT lt_data ASSIGNING &lt;ls_data&gt;.
      CLEAR lv_trclass.
      IF sy-tabix = 1.
        lv_trclass = &apos; class=&quot;firstrow&quot;&apos; ##NO_TEXT.
      ENDIF.

      lv_action  = zcl_abapgit_html_action_utils=&gt;dbkey_encode( &lt;ls_data&gt; ).

      CREATE OBJECT lo_toolbar.
      lo_toolbar-&gt;add( iv_txt = &apos;Display&apos; iv_act = |{ zif_abapgit_definitions=&gt;c_action-db_display }?{ lv_action }| ).
      lo_toolbar-&gt;add( iv_txt = &apos;Edit&apos;    iv_act = |{ zif_abapgit_definitions=&gt;c_action-db_edit }?{ lv_action }| ).
      lo_toolbar-&gt;add( iv_txt = &apos;Delete&apos;  iv_act = |{ c_action-delete }?{ lv_action }| ).

      ro_html-&gt;add( |&lt;tr{ lv_trclass }&gt;| ).
      ro_html-&gt;add( |&lt;td&gt;{ &lt;ls_data&gt;-type }&lt;/td&gt;| ).
      ro_html-&gt;add( |&lt;td&gt;{ &lt;ls_data&gt;-value }&lt;/td&gt;| ).
      ro_html-&gt;add( |&lt;td class=&quot;data&quot;&gt;{ explain_content( &lt;ls_data&gt; ) }&lt;/td&gt;| ).
      ro_html-&gt;add( &apos;&lt;td&gt;&apos; ).
      ro_html-&gt;add( lo_toolbar-&gt;render( ) ).
      ro_html-&gt;add( &apos;&lt;/td&gt;&apos; ).
      ro_html-&gt;add( &apos;&lt;/tr&gt;&apos; ).
    ENDLOOP.

    ro_html-&gt;add( &apos;&lt;/tbody&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/table&gt;&apos; ).
    ro_html-&gt;add( &apos;&lt;/div&gt;&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_gui_page_hotkey~get_hotkey_actions.

  ENDMETHOD.
  METHOD zif_abapgit_gui_page~on_event.

    DATA: ls_db TYPE zif_abapgit_persistence=&gt;ty_content.

    CASE iv_action.
      WHEN c_action-delete.
        ls_db = zcl_abapgit_html_action_utils=&gt;dbkey_decode( iv_getdata ).
        delete( ls_db ).
        ev_state = zif_abapgit_definitions=&gt;c_event_state-re_render.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_test_serialize IMPLEMENTATION.
  METHOD check.

    DATA: ls_files_item TYPE zcl_abapgit_objects=&gt;ty_serialization.

    ls_files_item = zcl_abapgit_objects=&gt;serialize( is_item     = is_item
                                                    iv_language = zif_abapgit_definitions=&gt;c_english ).

    cl_abap_unit_assert=&gt;assert_not_initial( ls_files_item-files ).
    cl_abap_unit_assert=&gt;assert_equals( act = ls_files_item-item
                                        exp = is_item ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SYNTAX_XML IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( ).

    &quot; Initialize instances of regular expressions

    add_rule( iv_regex    = c_regex-xml_tag
              iv_token    = c_token-xml_tag
              iv_style    = c_css-xml_tag
              iv_submatch = 1 ).

    add_rule( iv_regex = c_regex-attr
              iv_token = c_token-attr
              iv_style = c_css-attr ).

    add_rule( iv_regex = c_regex-attr_val
              iv_token = c_token-attr_val
              iv_style = c_css-attr_val ).

  ENDMETHOD.
  METHOD order_matches.

    DATA:
      lv_index      TYPE sy-tabix,
      lv_prev_token TYPE c,
      lv_state      TYPE c VALUE &apos;O&apos;. &quot; O - for open tag; C - for closed tag;

    FIELD-SYMBOLS:
      &lt;ls_prev&gt;  TYPE ty_match,
      &lt;ls_match&gt; TYPE ty_match.
    SORT ct_matches BY offset.

    LOOP AT ct_matches ASSIGNING &lt;ls_match&gt;.
      lv_index = sy-tabix.

      CASE &lt;ls_match&gt;-token.
        WHEN c_token-xml_tag.
          &lt;ls_match&gt;-text_tag = substring( val = iv_line
                                        off = &lt;ls_match&gt;-offset
                                        len = &lt;ls_match&gt;-length ).

          &quot; No other matches between two tags
          IF &lt;ls_match&gt;-text_tag = &apos;&gt;&apos; AND lv_prev_token = c_token-xml_tag.
            lv_state = &apos;C&apos;.
            &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset + &lt;ls_match&gt;-length.
            DELETE ct_matches INDEX lv_index.
            CONTINUE.

            &quot; Adjust length and offset of closing tag
          ELSEIF &lt;ls_match&gt;-text_tag = &apos;&gt;&apos; AND lv_prev_token &lt;&gt; c_token-xml_tag.
            lv_state = &apos;C&apos;.
            IF &lt;ls_prev&gt; IS ASSIGNED.
              &lt;ls_match&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset - &lt;ls_prev&gt;-length + &lt;ls_match&gt;-length.
              &lt;ls_match&gt;-offset = &lt;ls_prev&gt;-offset + &lt;ls_prev&gt;-length.
            ENDIF.
          ELSE.
            lv_state = &apos;O&apos;.
          ENDIF.

        WHEN OTHERS.
          IF lv_prev_token = c_token-xml_tag.
            &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset. &quot; Extend length of the opening tag
          ENDIF.

          IF lv_state = &apos;C&apos;.  &quot; Delete all matches between tags
            DELETE ct_matches INDEX lv_index.
            CONTINUE.
          ENDIF.

      ENDCASE.

      lv_prev_token = &lt;ls_match&gt;-token.
      ASSIGN &lt;ls_match&gt; TO &lt;ls_prev&gt;.
    ENDLOOP.

    &quot;if the last XML tag is not closed, extend it to the end of the tag
    IF lv_prev_token = c_token-xml_tag
        AND &lt;ls_prev&gt; IS ASSIGNED
        AND &lt;ls_prev&gt;-length  = 1
        AND &lt;ls_prev&gt;-text_tag = &apos;&lt;&apos;.

      FIND REGEX &apos;&lt;\s*[^\s]*&apos; IN iv_line+&lt;ls_prev&gt;-offset MATCH LENGTH &lt;ls_prev&gt;-length.
      IF sy-subrc &lt;&gt; 0.
        &lt;ls_prev&gt;-length = 1.
      ENDIF.

    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SYNTAX_HIGHLIGHTER IMPLEMENTATION.
  METHOD add_rule.

    DATA ls_rule LIKE LINE OF mt_rules.

    CREATE OBJECT ls_rule-regex
      EXPORTING
        pattern     = iv_regex
        ignore_case = abap_true.

    ls_rule-token         = iv_token.
    ls_rule-style         = iv_style.
    ls_rule-relevant_submatch = iv_submatch.
    APPEND ls_rule TO mt_rules.

  ENDMETHOD.
  METHOD apply_style.

    DATA lv_escaped TYPE string.

    lv_escaped = escape( val = iv_line  format = cl_abap_format=&gt;e_html_attr ).
    IF iv_class IS NOT INITIAL.
      rv_line = |&lt;span class=&quot;{ iv_class }&quot;&gt;{ lv_escaped }&lt;/span&gt;|.
    ELSE.
      rv_line = lv_escaped.
    ENDIF.

  ENDMETHOD.
  METHOD create.

    &quot; Create instance of highighter dynamically dependent on syntax type
    IF iv_filename CP &apos;*.abap&apos;.
      CREATE OBJECT ro_instance TYPE zcl_abapgit_syntax_abap.
    ELSEIF iv_filename CP &apos;*.xml&apos;.
      CREATE OBJECT ro_instance TYPE zcl_abapgit_syntax_xml.
    ELSE.
      CLEAR ro_instance.
    ENDIF.

  ENDMETHOD.
  METHOD extend_matches.

    DATA: lv_line_len TYPE i,
          lv_last_pos TYPE i VALUE 0,
          lv_length   TYPE i,
          ls_match    TYPE ty_match.

    FIELD-SYMBOLS &lt;ls_match&gt; TYPE ty_match.

    lv_line_len = strlen( iv_line ).

    SORT ct_matches BY offset.

    &quot; Add entries refering to parts of text that should not be formatted
    LOOP AT ct_matches ASSIGNING &lt;ls_match&gt;.
      IF &lt;ls_match&gt;-offset &gt; lv_last_pos.
        lv_length = &lt;ls_match&gt;-offset - lv_last_pos.
        ls_match-token  = c_token_none.
        ls_match-offset = lv_last_pos.
        ls_match-length = lv_length.
        INSERT ls_match INTO ct_matches INDEX sy-tabix.
      ENDIF.
      lv_last_pos = &lt;ls_match&gt;-offset + &lt;ls_match&gt;-length.
    ENDLOOP.

    &quot; Add remainder of the string
    IF lv_line_len &gt; lv_last_pos.
      lv_length = lv_line_len - lv_last_pos.
      ls_match-token  = c_token_none.
      ls_match-offset = lv_last_pos.
      ls_match-length = lv_length.
      APPEND ls_match TO ct_matches.
    ENDIF.

  ENDMETHOD.
  METHOD format_line.

    DATA:
      lv_chunk TYPE string,
      ls_rule  LIKE LINE OF mt_rules.

    FIELD-SYMBOLS &lt;ls_match&gt; TYPE ty_match.

    LOOP AT it_matches ASSIGNING &lt;ls_match&gt;.
      lv_chunk = substring( val = iv_line off = &lt;ls_match&gt;-offset len = &lt;ls_match&gt;-length ).

      CLEAR ls_rule. &quot; Failed read equals no style
      READ TABLE mt_rules INTO ls_rule WITH KEY token = &lt;ls_match&gt;-token.

      lv_chunk = me-&gt;apply_style( iv_line  = lv_chunk
                                  iv_class = ls_rule-style ).

      rv_line = rv_line &amp;&amp; lv_chunk.
    ENDLOOP.

  ENDMETHOD.
  METHOD parse_line.

    DATA:
      lo_regex   TYPE REF TO cl_abap_regex,
      lo_matcher TYPE REF TO cl_abap_matcher,
      lt_result  TYPE match_result_tab,
      ls_match   TYPE ty_match.

    FIELD-SYMBOLS:
      &lt;ls_regex&gt;    LIKE LINE OF mt_rules,
      &lt;ls_result&gt;   TYPE match_result,
      &lt;ls_submatch&gt; LIKE LINE OF &lt;ls_result&gt;-submatches.
    CLEAR et_matches.

    &quot; Process syntax-dependent regex table and find all matches
    LOOP AT mt_rules ASSIGNING &lt;ls_regex&gt;.
      lo_regex   = &lt;ls_regex&gt;-regex.
      lo_matcher = lo_regex-&gt;create_matcher( text = iv_line ).
      lt_result  = lo_matcher-&gt;find_all( ).

      &quot; Save matches into custom table with predefined tokens
      LOOP AT lt_result ASSIGNING &lt;ls_result&gt;.
        CLEAR: ls_match.
        IF &lt;ls_regex&gt;-relevant_submatch = 0.
          ls_match-token  = &lt;ls_regex&gt;-token.
          ls_match-offset = &lt;ls_result&gt;-offset.
          ls_match-length = &lt;ls_result&gt;-length.
          APPEND ls_match TO et_matches.
        ELSE.
          READ TABLE &lt;ls_result&gt;-submatches ASSIGNING &lt;ls_submatch&gt; INDEX &lt;ls_regex&gt;-relevant_submatch.
          &quot;submatch might be empty if only discarted parts matched
          IF sy-subrc = 0 AND &lt;ls_submatch&gt;-offset &gt;= 0 AND &lt;ls_submatch&gt;-length &gt; 0.
            ls_match-token  = &lt;ls_regex&gt;-token.
            ls_match-offset = &lt;ls_submatch&gt;-offset.
            ls_match-length = &lt;ls_submatch&gt;-length.
            APPEND ls_match TO et_matches.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.
  METHOD process_line.

    DATA: lt_matches TYPE ty_match_tt.

    IF strlen( iv_line ) = 0.
      RETURN.
    ENDIF.

    me-&gt;parse_line( EXPORTING iv_line    = iv_line
                    IMPORTING et_matches = lt_matches ).

    me-&gt;order_matches( EXPORTING iv_line    = iv_line
                       CHANGING  ct_matches = lt_matches ).

    me-&gt;extend_matches( EXPORTING iv_line    = iv_line
                        CHANGING  ct_matches = lt_matches ).

    rv_line = me-&gt;format_line( iv_line    = iv_line
                               it_matches = lt_matches ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_SYNTAX_ABAP IMPLEMENTATION.
  METHOD class_constructor.

    init_keywords( ).

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( ).

    &quot; Initialize instances of regular expression

    add_rule( iv_regex = c_regex-keyword
              iv_token = c_token-keyword
              iv_style = c_css-keyword ).

    add_rule( iv_regex = c_regex-comment
              iv_token = c_token-comment
              iv_style = c_css-comment ).

    add_rule( iv_regex = c_regex-text
              iv_token = c_token-text
              iv_style = c_css-text ).

  ENDMETHOD.
  METHOD init_keywords.

    DATA: lv_keywords TYPE string,
          lt_keywords TYPE STANDARD TABLE OF string.

    lv_keywords =
      &apos;&amp;&amp;|?TO|ABAP-SOURCE|ABBREVIATED|ABS|ABSTRACT|ACCEPT|ACCEPTING|ACCESSPOLICY&apos; &amp;&amp;
      &apos;|ACCORDING|ACOS|ACTIVATION|ACTUAL|ADD|ADD-CORRESPONDING|ADJACENT|AFTER|ALIAS&apos; &amp;&amp;
      &apos;|ALIASES|ALIGN|ALL|ALLOCATE|ALPHA|ANALYSIS|ANALYZER|AND|ANY|APPEND|APPENDAGE&apos; &amp;&amp;
      &apos;|APPENDING|APPLICATION|ARCHIVE|AREA|ARITHMETIC|AS|ASCENDING|ASIN|ASPECT|ASSERT&apos; &amp;&amp;
      &apos;|ASSIGN|ASSIGNED|ASSIGNING|ASSOCIATION|ASYNCHRONOUS|AT|ATAN|ATTRIBUTES|AUTHORITY&apos; &amp;&amp;
      &apos;|AUTHORITY-CHECK|AVG|BACK|BACKGROUND|BACKUP|BACKWARD|BADI|BASE|BEFORE|BEGIN&apos; &amp;&amp;
      &apos;|BETWEEN|BIG|BINARY|BINDING|BIT|BIT-AND|BIT-NOT|BIT-OR|BIT-XOR|BLACK|BLANK&apos; &amp;&amp;
      &apos;|BLANKS|BLOB|BLOCK|BLOCKS|BLUE|BOUND|BOUNDARIES|BOUNDS|BOXED|BREAK-POINT|BT&apos; &amp;&amp;
      &apos;|BUFFER|BY|BYPASSING|BYTE|BYTE-CA|BYTE-CN|BYTE-CO|BYTE-CS|BYTE-NA|BYTE-NS&apos; &amp;&amp;
      &apos;|BYTE-ORDER|C|CA|CALL|CALLING|CASE|CAST|CASTING|CATCH|CEIL|CENTER|CENTERED&apos; &amp;&amp;
      &apos;|CHAIN|CHAIN-INPUT|CHAIN-REQUEST|CHANGE|CHANGING|CHANNELS|CHARACTER|CHARLEN&apos; &amp;&amp;
      &apos;|CHAR-TO-HEX|CHECK|CHECKBOX|CI_|CIRCULAR|CLASS|CLASS-CODING|CLASS-DATA&apos; &amp;&amp;
      &apos;|CLASS-EVENTS|CLASS-METHODS|CLASS-POOL|CLEANUP|CLEAR|CLIENT|CLOB|CLOCK|CLOSE&apos; &amp;&amp;
      &apos;|CN|CNT|CO|COALESCE|CODE|CODING|COL_BACKGROUND|COL_GROUP|COL_HEADING|COL_KEY&apos; &amp;&amp;
      &apos;|COL_NEGATIVE|COL_NORMAL|COL_POSITIVE|COL_TOTAL|COLLECT|COLOR|COLUMN|COLUMNS&apos; &amp;&amp;
      &apos;|COMMENT|COMMENTS|COMMIT|COMMON|COMMUNICATION|COMPARING|COMPONENT|COMPONENTS&apos; &amp;&amp;
      &apos;|COMPRESSION|COMPUTE|CONCAT|CONCATENATE|COND|CONDENSE|CONDITION|CONNECT&apos; &amp;&amp;
      &apos;|CONNECTION|CONSTANTS|CONTEXT|CONTEXTS|CONTINUE|CONTROL|CONTROLS|CONV|CONVERSION&apos; &amp;&amp;
      &apos;|CONVERT|COPIES|COPY|CORRESPONDING|COS|COSH|COUNT|COUNTRY|COVER|CP|CPI|CREATE&apos; &amp;&amp;
      &apos;|CREATING|CRITICAL|CS|CURRENCY|CURRENCY_CONVERSION|CURRENT|CURSOR|CURSOR-SELECTION&apos; &amp;&amp;
      &apos;|CUSTOMER|CUSTOMER-FUNCTION|DANGEROUS|DATA|DATABASE|DATAINFO|DATASET|DATE&apos; &amp;&amp;
      &apos;|DAYLIGHT|DBMAXLEN|DD/MM/YY|DD/MM/YYYY|DDMMYY|DEALLOCATE|DECIMAL_SHIFT|DECIMALS&apos; &amp;&amp;
      &apos;|DECLARATIONS|DEEP|DEFAULT|DEFERRED|DEFINE|DEFINING|DEFINITION|DELETE|DELETING&apos; &amp;&amp;
      &apos;|DEMAND|DEPARTMENT|DESCENDING|DESCRIBE|DESTINATION|DETAIL|DIALOG|DIRECTORY&apos; &amp;&amp;
      &apos;|DISCONNECT|DISPLAY|DISPLAY-MODE|DISTANCE|DISTINCT|DIV|DIVIDE|DIVIDE-CORRESPONDING&apos; &amp;&amp;
      &apos;|DIVISION|DO|DUMMY|DUPLICATE|DUPLICATES|DURATION|DURING|DYNAMIC|DYNPRO|E|EACH&apos; &amp;&amp;
      &apos;|EDIT|EDITOR-CALL|ELSE|ELSEIF|EMPTY|ENABLED|ENABLING|ENCODING|END|ENDAT|ENDCASE&apos; &amp;&amp;
      &apos;|ENDCATCH|ENDCHAIN|ENDCLASS|ENDDO|ENDENHANCEMENT|END-ENHANCEMENT-SECTION&apos; &amp;&amp;
      &apos;|ENDEXEC|ENDFOR|ENDFORM|ENDFUNCTION|ENDIAN|ENDIF|ENDING|ENDINTERFACE&apos; &amp;&amp;
      &apos;|END-LINES|ENDLOOP|ENDMETHOD|ENDMODULE|END-OF-DEFINITION|END-OF-FILE&apos; &amp;&amp;
      &apos;|END-OF-PAGE|END-OF-SELECTION|ENDON|ENDPROVIDE|ENDSELECT|ENDTRY|ENDWHILE&apos; &amp;&amp;
      &apos;|ENGINEERING|ENHANCEMENT|ENHANCEMENT-POINT|ENHANCEMENTS|ENHANCEMENT-SECTION&apos; &amp;&amp;
      &apos;|ENTRIES|ENTRY|ENVIRONMENT|EQ|EQUAL|EQUIV|ERRORMESSAGE|ERRORS|ESCAPE|ESCAPING&apos; &amp;&amp;
      &apos;|EVENT|EVENTS|EXACT|EXCEPT|EXCEPTION|EXCEPTIONS|EXCEPTION-TABLE|EXCLUDE|EXCLUDING&apos; &amp;&amp;
      &apos;|EXEC|EXECUTE|EXISTS|EXIT|EXIT-COMMAND|EXP|EXPAND|EXPANDING|EXPIRATION|EXPLICIT&apos; &amp;&amp;
      &apos;|EXPONENT|EXPORT|EXPORTING|EXTEND|EXTENDED|EXTENSION|EXTRACT|FAIL|FETCH|FIELD&apos; &amp;&amp;
      &apos;|FIELD-GROUPS|FIELDS|FIELD-SYMBOL|FIELD-SYMBOLS|FILE|FILTER|FILTERS|FILTER-TABLE&apos; &amp;&amp;
      &apos;|FINAL|FIND|FIRST|FIRST-LINE|FIXED-POINT|FKEQ|FKGE|FLOOR|FLUSH|FONT|FOR|FORM&apos; &amp;&amp;
      &apos;|FORMAT|FORWARD|FOUND|FRAC|FRAME|FRAMES|FREE|FRIENDS|FROM|FUNCTION|FUNCTIONALITY&apos; &amp;&amp;
      &apos;|FUNCTION-POOL|FURTHER|GAPS|GE|GENERATE|GET|GIVING|GKEQ|GKGE|GLOBAL|GRANT|GREATER&apos; &amp;&amp;
      &apos;|GREEN|GROUP|GROUPS|GT|HANDLE|HANDLER|HARMLESS|HASHED|HAVING|HDB|HEADER|HEADERS&apos; &amp;&amp;
      &apos;|HEADING|HEAD-LINES|HELP-ID|HELP-REQUEST|HIDE|HIGH|HINT|HOLD|HOTSPOT|I|ICON|ID&apos; &amp;&amp;
      &apos;|IDENTIFICATION|IDENTIFIER|IDS|IF|IGNORE|IGNORING|IMMEDIATELY|IMPLEMENTATION&apos; &amp;&amp;
      &apos;|IMPLEMENTATIONS|IMPLEMENTED|IMPLICIT|IMPORT|IMPORTING|IN|INACTIVE|INCL|INCLUDE&apos; &amp;&amp;
      &apos;|INCLUDES|INCLUDING|INCREMENT|INDEX|INDEX-LINE|INFOTYPES|INHERITING|INIT|INITIAL&apos; &amp;&amp;
      &apos;|INITIALIZATION|INNER|INOUT|INPUT|INSERT|INSTANCES|INTENSIFIED|INTERFACE&apos; &amp;&amp;
      &apos;|INTERFACE-POOL|INTERFACES|INTERNAL|INTERVALS|INTO|INVERSE|INVERTED-DATE|IS&apos; &amp;&amp;
      &apos;|ISO|ITERATOR|ITNO|JOB|JOIN|KEEP|KEEPING|KERNEL|KEY|KEYS|KEYWORDS|KIND&apos; &amp;&amp;
      &apos;|LANGUAGE|LAST|LATE|LAYOUT|LE|LEADING|LEAVE|LEFT|LEFT-JUSTIFIED|LEFTPLUS&apos; &amp;&amp;
      &apos;|LEFTSPACE|LEGACY|LENGTH|LESS|LET|LEVEL|LEVELS|LIKE|LINE|LINE-COUNT|LINEFEED&apos; &amp;&amp;
      &apos;|LINES|LINE-SELECTION|LINE-SIZE|LIST|LISTBOX|LIST-PROCESSING|LITTLE|LLANG&apos; &amp;&amp;
      &apos;|LOAD|LOAD-OF-PROGRAM|LOB|LOCAL|LOCALE|LOCATOR|LOG|LOG10|LOGFILE|LOGICAL&apos; &amp;&amp;
      &apos;|LOG-POINT|LONG|LOOP|LOW|LOWER|LPAD|LPI|LT|M|MAIL|MAIN|MAJOR-ID|MAPPING|MARGIN&apos; &amp;&amp;
      &apos;|MARK|MASK|MATCH|MATCHCODE|MAX|MAXIMUM|MEDIUM|MEMBERS|MEMORY|MESH|MESSAGE&apos; &amp;&amp;
      &apos;|MESSAGE-ID|MESSAGES|MESSAGING|METHOD|METHODS|MIN|MINIMUM|MINOR-ID|MM/DD/YY&apos; &amp;&amp;
      &apos;|MM/DD/YYYY|MMDDYY|MOD|MODE|MODIF|MODIFIER|MODIFY|MODULE|MOVE|MOVE-CORRESPONDING&apos; &amp;&amp;
      &apos;|MULTIPLY|MULTIPLY-CORRESPONDING|NA|NAME|NAMETAB|NATIVE|NB|NE|NESTED|NESTING&apos; &amp;&amp;
      &apos;|NEW|NEW-LINE|NEW-PAGE|NEW-SECTION|NEXT|NO|NODE|NODES|NO-DISPLAY&apos; &amp;&amp;
      &apos;|NO-EXTENSION|NO-GAP|NO-GAPS|NO-GROUPING|NO-HEADING|NON-UNICODE|NON-UNIQUE&apos; &amp;&amp;
      &apos;|NO-SCROLLING|NO-SIGN|NOT|NO-TITLE|NO-TOPOFPAGE|NO-ZERO|NP|NS|NULL|NUMBER&apos; &amp;&amp;
      &apos;|NUMOFCHAR|O|OBJECT|OBJECTS|OBLIGATORY|OCCURRENCE|OCCURRENCES|OCCURS|OF|OFF&apos; &amp;&amp;
      &apos;|OFFSET|OLE|ON|ONLY|OPEN|OPTION|OPTIONAL|OPTIONS|OR|ORDER|OTHER|OTHERS|OUT&apos; &amp;&amp;
      &apos;|OUTER|OUTPUT|OUTPUT-LENGTH|OVERFLOW|OVERLAY|PACK|PACKAGE|PAD|PADDING|PAGE&apos; &amp;&amp;
      &apos;|PAGES|PARAMETER|PARAMETERS|PARAMETER-TABLE|PART|PARTIALLY|PATTERN|PERCENTAGE&apos; &amp;&amp;
      &apos;|PERFORM|PERFORMING|PERSON|PF|PF-STATUS|PINK|PLACES|POOL|POS_HIGH|POS_LOW&apos; &amp;&amp;
      &apos;|POSITION|PRAGMAS|PRECOMPILED|PREFERRED|PRESERVING|PRIMARY|PRINT|PRINT-CONTROL&apos; &amp;&amp;
      &apos;|PRIORITY|PRIVATE|PROCEDURE|PROCESS|PROGRAM|PROPERTY|PROTECTED|PROVIDE|PUBLIC&apos; &amp;&amp;
      &apos;|PUSHBUTTON|PUT|QUEUE-ONLY|QUICKINFO|RADIOBUTTON|RAISE|RAISING|RANGE|RANGES&apos; &amp;&amp;
      &apos;|RAW|READ|READER|READ-ONLY|RECEIVE|RECEIVED|RECEIVER|RECEIVING|RED|REDEFINITION&apos; &amp;&amp;
      &apos;|REDUCE|REDUCED|REF|REFERENCE|REFRESH|REGEX|REJECT|REMOTE|RENAMING|REPLACE&apos; &amp;&amp;
      &apos;|REPLACEMENT|REPLACING|REPORT|REQUEST|REQUESTED|RESERVE|RESET|RESOLUTION&apos; &amp;&amp;
      &apos;|RESPECTING|RESPONSIBLE|RESULT|RESULTS|RESUMABLE|RESUME|RETRY|RETURN|RETURNCODE&apos; &amp;&amp;
      &apos;|RETURNING|RIGHT|RIGHT-JUSTIFIED|RIGHTPLUS|RIGHTSPACE|RISK|RMC_COMMUNICATION_FAILURE&apos; &amp;&amp;
      &apos;|RMC_INVALID_STATUS|RMC_SYSTEM_FAILURE|ROLE|ROLLBACK|ROUND|ROWS|RTTI|RUN|SAP&apos; &amp;&amp;
      &apos;|SAP-SPOOL|SAVING|SCALE_PRESERVING|SCALE_PRESERVING_SCIENTIFIC|SCAN|SCIENTIFIC&apos; &amp;&amp;
      &apos;|SCIENTIFIC_WITH_LEADING_ZERO|SCREEN|SCROLL|SCROLL-BOUNDARY|SCROLLING|SEARCH&apos; &amp;&amp;
      &apos;|SECONDARY|SECONDS|SECTION|SELECT|SELECTION|SELECTIONS|SELECTION-SCREEN|SELECTION-SET&apos; &amp;&amp;
      &apos;|SELECTION-SETS|SELECTION-TABLE|SELECT-OPTIONS|SELECTOR|SEND|SEPARATE|SEPARATED|SET&apos; &amp;&amp;
      &apos;|SHARED|SHIFT|SHORT|SHORTDUMP-ID|SIGN|SIGN_AS_POSTFIX|SIMPLE|SIN|SINGLE|SINH|SIZE&apos; &amp;&amp;
      &apos;|SKIP|SKIPPING|SMART|SOME|SORT|SORTABLE|SORTED|SOURCE|SPACE|SPECIFIED|SPLIT|SPOOL&apos; &amp;&amp;
      &apos;|SPOTS|SQL|SQLSCRIPT|SQRT|STABLE|STAMP|STANDARD|STARTING|START-OF-SELECTION|STATE&apos; &amp;&amp;
      &apos;|STATEMENT|STATEMENTS|STATIC|STATICS|STATUSINFO|STEP-LOOP|STOP|STRLEN|STRUCTURE&apos; &amp;&amp;
      &apos;|STRUCTURES|STYLE|SUBKEY|SUBMATCHES|SUBMIT|SUBROUTINE|SUBSCREEN|SUBSTRING|SUBTRACT&apos; &amp;&amp;
      &apos;|SUBTRACT-CORRESPONDING|SUFFIX|SUM|SUMMARY|SUMMING|SUPPLIED|SUPPLY|SUPPRESS|SWITCH&apos; &amp;&amp;
      &apos;|SWITCHSTATES|SYMBOL|SYNCPOINTS|SYNTAX|SYNTAX-CHECK|SYNTAX-TRACE&apos; &amp;&amp;
      &apos;|SYSTEM-CALL|SYSTEM-EXCEPTIONS|SYSTEM-EXIT|TAB|TABBED|TABLE|TABLES|TABLEVIEW|TABSTRIP&apos; &amp;&amp;
      &apos;|TAN|TANH|TARGET|TASK|TASKS|TEST|TESTING|TEXT|TEXTPOOL|THEN|THROW|TIME|TIMES|TIMESTAMP&apos; &amp;&amp;
      &apos;|TIMEZONE|TITLE|TITLEBAR|TITLE-LINES|TO|TOKENIZATION|TOKENS|TOP-LINES|TOP-OF-PAGE&apos; &amp;&amp;
      &apos;|TRACE-FILE|TRACE-TABLE|TRAILING|TRANSACTION|TRANSFER|TRANSFORMATION|TRANSLATE&apos; &amp;&amp;
      &apos;|TRANSPORTING|TRMAC|TRUNC|TRUNCATE|TRUNCATION|TRY|TYPE|TYPE-POOL|TYPE-POOLS|TYPES&apos; &amp;&amp;
      &apos;|ULINE|UNASSIGN|UNDER|UNICODE|UNION|UNIQUE|UNIT|UNIT_CONVERSION|UNIX|UNPACK|UNTIL&apos; &amp;&amp;
      &apos;|UNWIND|UP|UPDATE|UPPER|USER|USER-COMMAND|USING|UTF-8|VALID|VALUE|VALUE-REQUEST|VALUES&apos; &amp;&amp;
      &apos;|VARY|VARYING|VERIFICATION-MESSAGE|VERSION|VIA|VIEW|VISIBLE|WAIT|WARNING|WHEN|WHENEVER&apos; &amp;&amp;
      &apos;|WHERE|WHILE|WIDTH|WINDOW|WINDOWS|WITH|WITH-HEADING|WITHOUT|WITH-TITLE|WORD|WORK&apos; &amp;&amp;
      &apos;|WRITE|WRITER|X|XML|XOR|XSD|XSTRLEN|YELLOW|YES|YYMMDD|Z|ZERO|ZONE&apos;.

    SPLIT lv_keywords AT &apos;|&apos; INTO TABLE lt_keywords.
    gt_keywords = lt_keywords. &quot; Hash table

  ENDMETHOD.
  METHOD is_keyword.

    DATA lv_str TYPE string.

    lv_str = to_upper( iv_chunk ).
    READ TABLE gt_keywords WITH KEY table_line = lv_str TRANSPORTING NO FIELDS.
    rv_yes = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD order_matches.

    DATA:
      lv_index      TYPE sy-tabix,
      lv_line_len   TYPE i,
      lv_prev_token TYPE c.

    FIELD-SYMBOLS:
      &lt;ls_prev&gt;  TYPE ty_match,
      &lt;ls_match&gt; TYPE ty_match.

    SORT ct_matches BY offset.

    lv_line_len = strlen( iv_line ).

    LOOP AT ct_matches ASSIGNING &lt;ls_match&gt;.
      lv_index = sy-tabix.

      &quot; Delete matches after open text match
      IF lv_prev_token = c_token-text AND &lt;ls_match&gt;-token &lt;&gt; c_token-text.
        DELETE ct_matches INDEX lv_index.
        CONTINUE.
      ENDIF.

      CASE &lt;ls_match&gt;-token.
        WHEN c_token-keyword.
          IF &lt;ls_match&gt;-offset &gt; 0
              AND substring( val = iv_line off = ( &lt;ls_match&gt;-offset - 1 ) len = 1 ) CA &apos;-&lt;&apos;.
            &quot; Delete match if keyword is part of structure or field symbol
            DELETE ct_matches INDEX lv_index.
            CONTINUE.
          ENDIF.

        WHEN c_token-comment.
          &lt;ls_match&gt;-length = lv_line_len - &lt;ls_match&gt;-offset.
          DELETE ct_matches FROM lv_index + 1.
          CONTINUE.

        WHEN c_token-text.
          &lt;ls_match&gt;-text_tag = substring( val = iv_line
                                        off = &lt;ls_match&gt;-offset
                                        len = &lt;ls_match&gt;-length ).
          IF lv_prev_token = c_token-text.
            IF &lt;ls_match&gt;-text_tag = &lt;ls_prev&gt;-text_tag.
              &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset + &lt;ls_match&gt;-length - &lt;ls_prev&gt;-offset.
              CLEAR lv_prev_token.
            ELSEIF &lt;ls_prev&gt;-text_tag = &apos;}&apos; AND &lt;ls_match&gt;-text_tag = &apos;{&apos;.
              &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset - 1.  &quot; Shift } out of scope
              &lt;ls_prev&gt;-offset = &lt;ls_prev&gt;-offset + 1.                   &quot; Shift { out of scope
              CLEAR lv_prev_token.
            ELSEIF &lt;ls_match&gt;-text_tag = &apos;{&apos;.
              &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset.
              CLEAR lv_prev_token.
            ELSEIF &lt;ls_prev&gt;-text_tag = &apos;}&apos;.
              &lt;ls_prev&gt;-length = &lt;ls_match&gt;-offset - &lt;ls_prev&gt;-offset.
              &lt;ls_prev&gt;-offset = &lt;ls_prev&gt;-offset + 1.                   &quot; Shift } out of scope
              CLEAR lv_prev_token.
            ENDIF.
            DELETE ct_matches INDEX lv_index.
            CONTINUE.
          ENDIF.

      ENDCASE.

      lv_prev_token = &lt;ls_match&gt;-token.
      ASSIGN &lt;ls_match&gt; TO &lt;ls_prev&gt;.
    ENDLOOP.

  ENDMETHOD.
  METHOD parse_line. &quot;REDEFINITION

    DATA lv_index TYPE i.

    FIELD-SYMBOLS &lt;ls_match&gt; LIKE LINE OF et_matches.

    super-&gt;parse_line( EXPORTING iv_line    = iv_line
                       IMPORTING et_matches = et_matches ).

    &quot; Remove non-keywords
    LOOP AT et_matches ASSIGNING &lt;ls_match&gt; WHERE token = c_token-keyword.
      lv_index = sy-tabix.
      IF abap_false = is_keyword( substring( val = iv_line
                                             off = &lt;ls_match&gt;-offset
                                             len = &lt;ls_match&gt;-length ) ).
        DELETE et_matches INDEX lv_index.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSISTENCE_USER IMPLEMENTATION.
  METHOD constructor.
    mv_user = iv_user.
  ENDMETHOD.
  METHOD from_xml.

    DATA: lv_xml TYPE string.

    lv_xml = iv_xml.

* fix downward compatibility
    REPLACE ALL OCCURRENCES OF &apos;&lt;_--28C_TYPE_USER_--29&gt;&apos; IN lv_xml WITH &apos;&lt;USER&gt;&apos;.
    REPLACE ALL OCCURRENCES OF &apos;&lt;/_--28C_TYPE_USER_--29&gt;&apos; IN lv_xml WITH &apos;&lt;/USER&gt;&apos;.

    CALL TRANSFORMATION id
      OPTIONS value_handling = &apos;accept_data_loss&apos;
      SOURCE XML lv_xml
      RESULT user = rs_user ##NO_TEXT.
  ENDMETHOD.
  METHOD get_instance.

    IF iv_user = sy-uname ##USER_OK.
      IF gi_current_user IS NOT BOUND.
        CREATE OBJECT gi_current_user TYPE zcl_abapgit_persistence_user.
      ENDIF.
      ri_user = gi_current_user.
    ELSE.
      CREATE OBJECT ri_user TYPE zcl_abapgit_persistence_user
        EXPORTING
          iv_user = iv_user.
    ENDIF.

  ENDMETHOD.
  METHOD read.

    DATA: lv_xml TYPE string.

    TRY.
        lv_xml = zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;read(
          iv_type  = zcl_abapgit_persistence_db=&gt;c_type_user
          iv_value = mv_user ).
      CATCH zcx_abapgit_not_found.
        RETURN.
    ENDTRY.

    rs_user = from_xml( lv_xml ).

  ENDMETHOD.
  METHOD read_repo_config.
    DATA: lt_repo_config TYPE ty_repo_config_tt,
          lv_key         TYPE string.

    lv_key         = to_lower( iv_url ).
    lt_repo_config = read( )-repo_config.
    READ TABLE lt_repo_config INTO rs_repo_config WITH KEY url = lv_key.

  ENDMETHOD.
  METHOD to_xml.
    CALL TRANSFORMATION id
      SOURCE user = is_user
      RESULT XML rv_xml.
  ENDMETHOD.
  METHOD update.

    DATA: lv_xml TYPE string.

    lv_xml = to_xml( is_user ).

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;modify(
      iv_type  = zcl_abapgit_persistence_db=&gt;c_type_user
      iv_value = mv_user
      iv_data  = lv_xml ).

  ENDMETHOD.
  METHOD update_repo_config.

    DATA: ls_user TYPE ty_user,
          lv_key  TYPE string.

    FIELD-SYMBOLS &lt;ls_repo_config&gt; TYPE ty_repo_config.
    ls_user = read( ).
    lv_key  = to_lower( iv_url ).

    READ TABLE ls_user-repo_config ASSIGNING &lt;ls_repo_config&gt; WITH KEY url = lv_key.
    IF sy-subrc IS NOT INITIAL.
      APPEND INITIAL LINE TO ls_user-repo_config ASSIGNING &lt;ls_repo_config&gt;.
    ENDIF.
    &lt;ls_repo_config&gt;     = is_repo_config.
    &lt;ls_repo_config&gt;-url = lv_key.

    update( ls_user ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_changes_only.

    rv_changes_only = read( )-changes_only.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_default_git_user_email.

    rv_email = read( )-default_git_user-email.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_default_git_user_name.

    rv_username = read( )-default_git_user-name.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_diff_unified.

    rv_diff_unified = read( )-diff_unified.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_favorites.

    rt_favorites = read( )-favorites.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_hide_files.

    rv_hide = read( )-hide_files.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_repo_git_user_email.

    rv_email = read_repo_config( iv_url )-git_user-email.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_repo_git_user_name.

    rv_username = read_repo_config( iv_url )-git_user-name.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_repo_last_change_seen.

    rv_version = read_repo_config( iv_url )-last_change_seen.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_repo_login.

    rv_login = read_repo_config( iv_url )-login.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_repo_show.

    rv_key = read( )-repo_show.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~get_settings.

    DATA: ls_user TYPE ty_user.

    ls_user = read( ).

    rs_user_settings = ls_user-settings.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~is_favorite_repo.

    DATA: lt_favorites TYPE tt_favorites.

    lt_favorites = zif_abapgit_persist_user~get_favorites( ).

    READ TABLE lt_favorites TRANSPORTING NO FIELDS
      WITH KEY table_line = iv_repo_key.

    rv_yes = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_default_git_user_email.

    DATA: ls_user TYPE ty_user.
    ls_user = read( ).
    ls_user-default_git_user-email = iv_email.
    update( ls_user ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_default_git_user_name.

    DATA: ls_user TYPE ty_user.
    ls_user = read( ).

    ls_user-default_git_user-name = iv_username.

    update( ls_user ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_repo_git_user_email.

    DATA: ls_repo_config TYPE ty_repo_config.

    ls_repo_config                = read_repo_config( iv_url ).
    ls_repo_config-git_user-email = iv_email.
    update_repo_config( iv_url = iv_url is_repo_config = ls_repo_config ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_repo_git_user_name.

    DATA: ls_repo_config TYPE ty_repo_config.

    ls_repo_config               = read_repo_config( iv_url ).
    ls_repo_config-git_user-name = iv_username.
    update_repo_config( iv_url = iv_url is_repo_config = ls_repo_config ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_repo_last_change_seen.

    DATA: ls_repo_config TYPE ty_repo_config.

    ls_repo_config                  = read_repo_config( iv_url ).
    ls_repo_config-last_change_seen = iv_version.
    update_repo_config( iv_url = iv_url is_repo_config = ls_repo_config ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_repo_login.

    DATA: ls_repo_config TYPE ty_repo_config.

    ls_repo_config       = read_repo_config( iv_url ).
    ls_repo_config-login = iv_login.
    update_repo_config( iv_url = iv_url is_repo_config = ls_repo_config ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_repo_show.

    DATA: ls_user TYPE ty_user.
    ls_user = read( ).
    ls_user-repo_show = iv_key.
    update( ls_user ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~set_settings.

    DATA: ls_user TYPE ty_user.

    ls_user = read( ).
    ls_user-settings = is_user_settings.
    update( ls_user ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~toggle_changes_only.

    DATA ls_user TYPE ty_user.

    ls_user = read( ).
    ls_user-changes_only = boolc( ls_user-changes_only = abap_false ).
    update( ls_user ).

    rv_changes_only = ls_user-changes_only.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~toggle_diff_unified.

    DATA ls_user TYPE ty_user.

    ls_user = read( ).
    ls_user-diff_unified = boolc( ls_user-diff_unified = abap_false ).
    update( ls_user ).

    rv_diff_unified = ls_user-diff_unified.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~toggle_favorite.

    DATA: ls_user TYPE ty_user.

    ls_user = read( ).

    READ TABLE ls_user-favorites TRANSPORTING NO FIELDS
      WITH KEY table_line = iv_repo_key.

    IF sy-subrc = 0.
      DELETE ls_user-favorites INDEX sy-tabix.
    ELSE.
      APPEND iv_repo_key TO ls_user-favorites.
    ENDIF.

    update( ls_user ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.
  METHOD zif_abapgit_persist_user~toggle_hide_files.

    DATA ls_user TYPE ty_user.

    ls_user = read( ).
    ls_user-hide_files = boolc( ls_user-hide_files = abap_false ).
    update( ls_user ).

    rv_hide = ls_user-hide_files.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSISTENCE_REPO IMPLEMENTATION.

  METHOD constructor.

    DATA ls_dummy_meta_mask TYPE zif_abapgit_persistence=&gt;ty_repo_meta_mask.
    DATA ls_dummy_meta      TYPE zif_abapgit_persistence=&gt;ty_repo_xml.
    DATA lo_type_meta_mask  TYPE REF TO cl_abap_structdescr.
    DATA lo_type_meta       TYPE REF TO cl_abap_structdescr.
    FIELD-SYMBOLS &lt;ls_comp&gt; LIKE LINE OF lo_type_meta_mask-&gt;components.

    &quot; Collect actual list of fields in repo meta data (used in update_meta)
    lo_type_meta_mask ?= cl_abap_structdescr=&gt;describe_by_data( ls_dummy_meta_mask ).
    lo_type_meta      ?= cl_abap_structdescr=&gt;describe_by_data( ls_dummy_meta ).
    LOOP AT lo_type_meta_mask-&gt;components ASSIGNING &lt;ls_comp&gt;.
      APPEND &lt;ls_comp&gt;-name TO mt_meta_fields.
    ENDLOOP.

    mo_db = zcl_abapgit_persistence_db=&gt;get_instance( ).

  ENDMETHOD.
  METHOD from_xml.

    DATA: lv_xml TYPE string.

    lv_xml = iv_repo_xml_string.

* fix downward compatibility
    REPLACE ALL OCCURRENCES OF &apos;&lt;_--28C_TYPE_REPO_--29&gt;&apos; IN lv_xml WITH &apos;&lt;REPO&gt;&apos;.
    REPLACE ALL OCCURRENCES OF &apos;&lt;/_--28C_TYPE_REPO_--29&gt;&apos; IN lv_xml WITH &apos;&lt;/REPO&gt;&apos;.

    CALL TRANSFORMATION id
      OPTIONS value_handling = &apos;accept_data_loss&apos;
      SOURCE XML lv_xml
      RESULT repo = rs_repo ##NO_TEXT.

* automatic migration of old fields
    FIND FIRST OCCURRENCE OF &apos;&lt;/HEAD_BRANCH&gt;&lt;WRITE_PROTECT&gt;X&lt;/WRITE_PROTECT&gt;&apos; IN lv_xml.
    IF sy-subrc = 0.
      rs_repo-local_settings-write_protected = abap_true.
    ENDIF.
    FIND FIRST OCCURRENCE OF &apos;&lt;IGNORE_SUBPACKAGES&gt;X&lt;/IGNORE_SUBPACKAGES&gt;&lt;/REPO&gt;&apos; IN lv_xml.
    IF sy-subrc = 0.
      rs_repo-local_settings-ignore_subpackages = abap_true.
    ENDIF.

    IF rs_repo IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Inconsistent repo metadata&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD get_next_id.

* todo: Lock the complete persistence in order to prevent concurrent repo-creation
* however the current approach will most likely work in almost all cases

    DATA: lt_content TYPE zif_abapgit_persistence=&gt;tt_content.

    FIELD-SYMBOLS: &lt;ls_content&gt; LIKE LINE OF lt_content.
    rv_next_repo_id = 1.

    lt_content = mo_db-&gt;list_by_type( zcl_abapgit_persistence_db=&gt;c_type_repo ).
    LOOP AT lt_content ASSIGNING &lt;ls_content&gt;.
      IF &lt;ls_content&gt;-value &gt;= rv_next_repo_id.
        rv_next_repo_id = &lt;ls_content&gt;-value + 1.
      ENDIF.
    ENDLOOP.

    CALL FUNCTION &apos;CONVERSION_EXIT_ALPHA_INPUT&apos;
      EXPORTING
        input  = rv_next_repo_id
      IMPORTING
        output = rv_next_repo_id.

  ENDMETHOD.
  METHOD to_xml.

    DATA: ls_xml TYPE zif_abapgit_persistence=&gt;ty_repo_xml.
    MOVE-CORRESPONDING is_repo TO ls_xml.

    CALL TRANSFORMATION id
      SOURCE repo = ls_xml
      RESULT XML rv_repo_xml_string.
  ENDMETHOD.
  METHOD zif_abapgit_persist_repo~add.

    DATA: ls_repo        TYPE zif_abapgit_persistence=&gt;ty_repo,
          lv_repo_as_xml TYPE string.
    ls_repo-url          = iv_url.
    ls_repo-branch_name  = iv_branch_name.
    ls_repo-package      = iv_package.
    ls_repo-offline      = iv_offline.
    ls_repo-created_by   = sy-uname.
    GET TIME STAMP FIELD ls_repo-created_at.
    ls_repo-dot_abapgit  = is_dot_abapgit.

    lv_repo_as_xml = to_xml( ls_repo ).

    rv_key = get_next_id( ).

    mo_db-&gt;add( iv_type  = zcl_abapgit_persistence_db=&gt;c_type_repo
                iv_value = rv_key
                iv_data  = lv_repo_as_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_repo~delete.

    DATA: lo_background TYPE REF TO zcl_abapgit_persist_background.

    CREATE OBJECT lo_background.
    lo_background-&gt;delete( iv_key ).

    mo_db-&gt;delete( iv_type  = zcl_abapgit_persistence_db=&gt;c_type_repo
                   iv_value = iv_key ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_repo~list.

    DATA: lt_content TYPE zif_abapgit_persistence=&gt;tt_content,
          ls_content LIKE LINE OF lt_content,
          ls_repo    LIKE LINE OF rt_repos.
    lt_content = mo_db-&gt;list_by_type( zcl_abapgit_persistence_db=&gt;c_type_repo ).

    LOOP AT lt_content INTO ls_content.
      MOVE-CORRESPONDING from_xml( ls_content-data_str ) TO ls_repo.
      ls_repo-key = ls_content-value.
      INSERT ls_repo INTO TABLE rt_repos.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_persist_repo~lock.

    mo_db-&gt;lock( iv_mode  = iv_mode
                 iv_type  = zcl_abapgit_persistence_db=&gt;c_type_repo
                 iv_value = iv_key ).

  ENDMETHOD.
  METHOD zif_abapgit_persist_repo~read.

    DATA lt_repo TYPE zif_abapgit_persistence=&gt;tt_repo.

    lt_repo = list( ).

    READ TABLE lt_repo INTO rs_repo WITH KEY key = iv_key.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_abapgit_not_found.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_persist_repo~update_metadata.

    DATA:
          lv_blob            TYPE zif_abapgit_persistence=&gt;ty_content-data_str,
          ls_persistent_meta TYPE zif_abapgit_persistence=&gt;ty_repo.

    FIELD-SYMBOLS &lt;lv_field&gt;   LIKE LINE OF mt_meta_fields.
    FIELD-SYMBOLS &lt;lv_dst&gt;     TYPE ANY.
    FIELD-SYMBOLS &lt;lv_src&gt;     TYPE ANY.
    FIELD-SYMBOLS &lt;lv_changed&gt; TYPE abap_bool.

    ASSERT NOT iv_key IS INITIAL.

    IF is_change_mask IS INITIAL.
      RETURN.
    ENDIF.

    &quot; Validations
    IF is_change_mask-url = abap_true AND is_meta-url IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;update, url empty&apos; ).
    ENDIF.

    TRY.
        ls_persistent_meta = read( iv_key ).
      CATCH zcx_abapgit_not_found.
        zcx_abapgit_exception=&gt;raise( &apos;repo key not found&apos; ).
    ENDTRY.

    &quot; Update
    LOOP AT mt_meta_fields ASSIGNING &lt;lv_field&gt;.
      ASSIGN COMPONENT &lt;lv_field&gt; OF STRUCTURE is_change_mask TO &lt;lv_changed&gt;.
      ASSERT sy-subrc = 0.
      CHECK &lt;lv_changed&gt; = abap_true.
      ASSIGN COMPONENT &lt;lv_field&gt; OF STRUCTURE ls_persistent_meta TO &lt;lv_dst&gt;.
      ASSERT sy-subrc = 0.
      ASSIGN COMPONENT &lt;lv_field&gt; OF STRUCTURE is_meta TO &lt;lv_src&gt;.
      ASSERT sy-subrc = 0.
      &lt;lv_dst&gt; = &lt;lv_src&gt;.
    ENDLOOP.

    lv_blob = to_xml( ls_persistent_meta ).

    mo_db-&gt;update( iv_type  = zcl_abapgit_persistence_db=&gt;c_type_repo
                   iv_value = iv_key
                   iv_data  = lv_blob ).

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_PERSISTENCE_DB IMPLEMENTATION.
  METHOD add.

    DATA ls_table TYPE zif_abapgit_persistence=&gt;ty_content.

    ls_table-type  = iv_type.
    ls_table-value = iv_value.
    ls_table-data_str = iv_data.

    INSERT (c_tabname) FROM ls_table.                     &quot;#EC CI_SUBRC
    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD delete.

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    DELETE FROM (c_tabname)
      WHERE type = iv_type
      AND value = iv_value.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;DB Delete failed&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD get_instance.

    IF go_db IS NOT BOUND.
      CREATE OBJECT go_db.
    ENDIF.
    ro_db = go_db.

  ENDMETHOD.
  METHOD get_update_function.
    IF mv_update_function IS INITIAL.
      mv_update_function = &apos;CALL_V1_PING&apos;.
      CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
        EXPORTING
          funcname = mv_update_function
        EXCEPTIONS
          OTHERS   = 2.

      IF sy-subrc &lt;&gt; 0.
        mv_update_function = &apos;BANK_OBJ_WORKL_RELEASE_LOCKS&apos;.
      ENDIF.
    ENDIF.
    rv_funcname = mv_update_function.

  ENDMETHOD.
  METHOD list.
    SELECT * FROM (c_tabname)
      INTO TABLE rt_content.                              &quot;#EC CI_SUBRC
  ENDMETHOD.
  METHOD list_by_type.
    SELECT * FROM (c_tabname)
      INTO TABLE rt_content
      WHERE type = iv_type
      ORDER BY PRIMARY KEY.                               &quot;#EC CI_SUBRC
  ENDMETHOD.
  METHOD lock.
    DATA: lv_dummy_update_function TYPE funcname.

    CALL FUNCTION &apos;ENQUEUE_EZABAPGIT&apos;
      EXPORTING
        mode_zabapgit  = iv_mode
        type           = iv_type
        value          = iv_value
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Could not aquire lock { iv_type } { iv_value }| ).
    ENDIF.

    lv_dummy_update_function = get_update_function( ).

* trigger dummy update task to automatically release locks at commit
    CALL FUNCTION lv_dummy_update_function
      IN UPDATE TASK.

  ENDMETHOD.
  METHOD modify.

    DATA: ls_content TYPE zif_abapgit_persistence=&gt;ty_content.

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    ls_content-type  = iv_type.
    ls_content-value = iv_value.
    ls_content-data_str = iv_data.

    MODIFY (c_tabname) FROM ls_content.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;DB modify failed&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD read.

    SELECT SINGLE data_str FROM (c_tabname) INTO rv_data
      WHERE type = iv_type
      AND value = iv_value.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_abapgit_not_found.
    ENDIF.

  ENDMETHOD.
  METHOD update.

    DATA lv_data LIKE iv_data.

    lv_data = validate_and_unprettify_xml( iv_data ).

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    UPDATE (c_tabname) SET data_str = lv_data
      WHERE type  = iv_type
      AND   value = iv_value.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;DB update failed&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD validate_and_unprettify_xml.

    rv_xml = zcl_abapgit_xml_pretty=&gt;print(
      iv_xml           = iv_xml
      iv_unpretty      = abap_true
      iv_ignore_errors = abap_false ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_persist_settings IMPLEMENTATION.
  METHOD get_instance.

    IF go_persist IS NOT BOUND.
      CREATE OBJECT go_persist.
    ENDIF.
    ro_settings = go_persist.

  ENDMETHOD.
  METHOD modify.

    DATA: lv_settings      TYPE string,
          ls_user_settings TYPE zif_abapgit_definitions=&gt;ty_s_user_settings.
    lv_settings = io_settings-&gt;get_settings_xml( ).

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;modify(
      iv_type       = zcl_abapgit_persistence_db=&gt;c_type_settings
      iv_value      = &apos;&apos;
      iv_data       = lv_settings ).

    ls_user_settings = io_settings-&gt;get_user_settings( ).

    zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_settings( ls_user_settings ).

    &quot; Settings have been modified: Update Buffered Settings
    IF mo_settings IS BOUND.
      mo_settings-&gt;set_xml_settings( lv_settings ).
      mo_settings-&gt;set_user_settings( ls_user_settings ).
    ENDIF.

  ENDMETHOD.
  METHOD read.

    IF mo_settings IS BOUND.
      &quot; Return Buffered Settings
      ro_settings = mo_settings.
      RETURN.
    ENDIF.

    &quot; Settings have changed or have not yet been loaded
    CREATE OBJECT ro_settings.

    TRY.

        ro_settings-&gt;set_xml_settings(
          zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;read(
            iv_type  = zcl_abapgit_persistence_db=&gt;c_type_settings
            iv_value = &apos;&apos; ) ).

        ro_settings-&gt;set_user_settings( zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_settings( ) ).

      CATCH zcx_abapgit_not_found zcx_abapgit_exception.

        ro_settings-&gt;set_defaults( ).

    ENDTRY.

    mo_settings = ro_settings.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSIST_MIGRATE IMPLEMENTATION.
  METHOD distribute_settings_to_users.

    DATA: lt_abapgit_users    TYPE STANDARD TABLE OF char12
                                   WITH NON-UNIQUE DEFAULT KEY,
          ls_user_settings    TYPE zif_abapgit_definitions=&gt;ty_s_user_settings,
          li_user_persistence TYPE REF TO zif_abapgit_persist_user.

    FIELD-SYMBOLS: &lt;lv_user&gt;                     LIKE LINE OF lt_abapgit_users,
                   &lt;ls_setting_to_migrate&gt;       TYPE zcl_abapgit_persist_migrate=&gt;ty_settings_to_migrate,
                   &lt;lg_user_specific_setting_val&gt; TYPE data.

    &quot; distribute settings to all abapGit users
    SELECT value FROM (zcl_abapgit_persistence_db=&gt;c_tabname)
                 INTO TABLE lt_abapgit_users
                 WHERE type = zcl_abapgit_persistence_db=&gt;c_type_user.

    LOOP AT lt_abapgit_users ASSIGNING &lt;lv_user&gt;.

      li_user_persistence = zcl_abapgit_persistence_user=&gt;get_instance( &lt;lv_user&gt; ).

      ls_user_settings = li_user_persistence-&gt;get_settings( ).

      LOOP AT it_settings_to_migrate ASSIGNING &lt;ls_setting_to_migrate&gt;.

        ASSIGN COMPONENT &lt;ls_setting_to_migrate&gt;-name
               OF STRUCTURE ls_user_settings
               TO &lt;lg_user_specific_setting_val&gt;.
        ASSERT sy-subrc = 0.

        &lt;lg_user_specific_setting_val&gt; = &lt;ls_setting_to_migrate&gt;-value.

      ENDLOOP.

      li_user_persistence-&gt;set_settings( ls_user_settings ).

    ENDLOOP.

  ENDMETHOD.
  METHOD get_global_settings_document.

    DATA: lv_global_settings_xml TYPE string.

    lv_global_settings_xml = read_global_settings_xml( ).

    ri_global_settings_dom = cl_ixml_80_20=&gt;parse_to_document( stream_string = lv_global_settings_xml ).

  ENDMETHOD.
  METHOD lock_create.

    DATA: lv_obj_name TYPE tadir-obj_name,
          ls_dd25v    TYPE dd25v,
          lt_dd26e    TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY,
          lt_dd27p    TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.

    FIELD-SYMBOLS: &lt;ls_dd26e&gt; LIKE LINE OF lt_dd26e,
                   &lt;ls_dd27p&gt; LIKE LINE OF lt_dd27p.
    ls_dd25v-viewname   = zcl_abapgit_persistence_db=&gt;c_lock.
    ls_dd25v-aggtype    = &apos;E&apos;.
    ls_dd25v-roottab    = zcl_abapgit_persistence_db=&gt;c_tabname.
    ls_dd25v-ddlanguage = zif_abapgit_definitions=&gt;c_english.
    ls_dd25v-ddtext     = c_text.

    APPEND INITIAL LINE TO lt_dd26e ASSIGNING &lt;ls_dd26e&gt;.
    &lt;ls_dd26e&gt;-viewname   = zcl_abapgit_persistence_db=&gt;c_lock.
    &lt;ls_dd26e&gt;-tabname    = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd26e&gt;-tabpos     = &apos;0001&apos;.
    &lt;ls_dd26e&gt;-fortabname = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd26e&gt;-enqmode    = &apos;E&apos;.

    APPEND INITIAL LINE TO lt_dd27p ASSIGNING &lt;ls_dd27p&gt;.
    &lt;ls_dd27p&gt;-viewname  = zcl_abapgit_persistence_db=&gt;c_lock.
    &lt;ls_dd27p&gt;-objpos    = &apos;0001&apos;.
    &lt;ls_dd27p&gt;-viewfield = &apos;TYPE&apos;.
    &lt;ls_dd27p&gt;-tabname   = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd27p&gt;-fieldname = &apos;TYPE&apos;.
    &lt;ls_dd27p&gt;-keyflag   = abap_true.

    APPEND INITIAL LINE TO lt_dd27p ASSIGNING &lt;ls_dd27p&gt;.
    &lt;ls_dd27p&gt;-viewname  = zcl_abapgit_persistence_db=&gt;c_lock.
    &lt;ls_dd27p&gt;-objpos    = &apos;0002&apos;.
    &lt;ls_dd27p&gt;-viewfield = &apos;VALUE&apos;.
    &lt;ls_dd27p&gt;-tabname   = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd27p&gt;-fieldname = &apos;VALUE&apos;.
    &lt;ls_dd27p&gt;-keyflag   = abap_true.

    CALL FUNCTION &apos;DDIF_ENQU_PUT&apos;
      EXPORTING
        name              = zcl_abapgit_persistence_db=&gt;c_lock
        dd25v_wa          = ls_dd25v
      TABLES
        dd26e_tab         = lt_dd26e
        dd27p_tab         = lt_dd27p
      EXCEPTIONS
        enqu_not_found    = 1
        name_inconsistent = 2
        enqu_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from DDIF_ENQU_PUT&apos; ).
    ENDIF.

    lv_obj_name = zcl_abapgit_persistence_db=&gt;c_lock.
    CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
      EXPORTING
        wi_tadir_pgmid    = &apos;R3TR&apos;
        wi_tadir_object   = &apos;ENQU&apos;
        wi_tadir_obj_name = lv_obj_name
        wi_set_genflag    = abap_true
        wi_test_modus     = abap_false
        wi_tadir_devclass = &apos;$TMP&apos;
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from TR_TADIR_INTERFACE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;DDIF_ENQU_ACTIVATE&apos;
      EXPORTING
        name        = zcl_abapgit_persistence_db=&gt;c_lock
      EXCEPTIONS
        not_found   = 1
        put_failure = 2
        OTHERS      = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from DDIF_ENQU_ACTIVATE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD lock_exists.

    DATA: lv_viewname TYPE dd25l-viewname.
    SELECT SINGLE viewname FROM dd25l INTO lv_viewname
      WHERE viewname = zcl_abapgit_persistence_db=&gt;c_lock.
    rv_exists = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD migrate_setting.

    DATA: li_element            TYPE REF TO if_ixml_element,
          ls_setting_to_migrate LIKE LINE OF ct_settings_to_migrate.

    li_element = ci_document-&gt;find_from_name( iv_name  ).
    IF li_element IS BOUND.

      &quot; The element is present in the global config.
      &quot; Therefore we have to migrate it

      ls_setting_to_migrate-name = iv_name.
      ls_setting_to_migrate-value = li_element-&gt;get_value( ).
      INSERT ls_setting_to_migrate INTO TABLE ct_settings_to_migrate.

      li_element-&gt;remove_node( ).

    ENDIF.

  ENDMETHOD.
  METHOD migrate_settings.

    DATA: li_global_settings_document TYPE REF TO if_ixml_document,
          lt_settings_to_migrate      TYPE tty_settings_to_migrate,
          lx_error                    TYPE REF TO zcx_abapgit_not_found.

    &quot; migrate global settings to user specific settings

    TRY.
        li_global_settings_document = get_global_settings_document( ).

      CATCH zcx_abapgit_not_found INTO lx_error.
        &quot; No global settings available, nothing todo.
        RETURN.
    ENDTRY.

    migrate_setting(
      EXPORTING
        iv_name                = |MAX_LINES|
      CHANGING
        ct_settings_to_migrate = lt_settings_to_migrate
        ci_document            = li_global_settings_document ).

    migrate_setting(
      EXPORTING
        iv_name                = |ADT_JUMP_ENABLED|
      CHANGING
        ct_settings_to_migrate = lt_settings_to_migrate
        ci_document            = li_global_settings_document ).

    IF lines( lt_settings_to_migrate ) &gt; 0.

      distribute_settings_to_users( lt_settings_to_migrate ).

      update_global_settings( li_global_settings_document ).

    ENDIF.

  ENDMETHOD.
  METHOD read_global_settings_xml.

    rv_global_settings_xml = zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;read(
        iv_type  = zcl_abapgit_persistence_db=&gt;c_type_settings
        iv_value = &apos;&apos; ).

  ENDMETHOD.
  METHOD run.

    IF table_exists( ) = abap_false.
      table_create( ).
    ENDIF.

    IF lock_exists( ) = abap_false.
      lock_create( ).
    ENDIF.

    migrate_settings( ).

  ENDMETHOD.
  METHOD table_create.

    DATA: lv_rc       LIKE sy-subrc,
          lv_obj_name TYPE tadir-obj_name,
          ls_dd02v    TYPE dd02v,
          ls_dd09l    TYPE dd09l,
          lt_dd03p    TYPE STANDARD TABLE OF dd03p WITH DEFAULT KEY.

    FIELD-SYMBOLS: &lt;ls_dd03p&gt; LIKE LINE OF lt_dd03p.

    ls_dd02v-tabname    = zcl_abapgit_persistence_db=&gt;c_tabname.
    ls_dd02v-ddlanguage = zif_abapgit_definitions=&gt;c_english.
    ls_dd02v-tabclass   = &apos;TRANSP&apos;.
    ls_dd02v-ddtext     = c_text.
    ls_dd02v-contflag   = &apos;L&apos;.
    ls_dd02v-exclass    = &apos;1&apos;.

    ls_dd09l-tabname  = zcl_abapgit_persistence_db=&gt;c_tabname.
    ls_dd09l-as4local = &apos;A&apos;.
    ls_dd09l-tabkat   = &apos;1&apos;.
    ls_dd09l-tabart   = &apos;APPL1&apos;.
    ls_dd09l-bufallow = &apos;N&apos;.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING &lt;ls_dd03p&gt;.
    &lt;ls_dd03p&gt;-tabname   = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd03p&gt;-fieldname = &apos;TYPE&apos;.
    &lt;ls_dd03p&gt;-position  = &apos;0001&apos;.
    &lt;ls_dd03p&gt;-keyflag   = &apos;X&apos;.
    &lt;ls_dd03p&gt;-datatype  = &apos;CHAR&apos;.
    &lt;ls_dd03p&gt;-leng      = &apos;000012&apos;.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING &lt;ls_dd03p&gt;.
    &lt;ls_dd03p&gt;-tabname   = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd03p&gt;-fieldname = &apos;VALUE&apos;.
    &lt;ls_dd03p&gt;-position  = &apos;0002&apos;.
    &lt;ls_dd03p&gt;-keyflag   = &apos;X&apos;.
    &lt;ls_dd03p&gt;-datatype  = &apos;CHAR&apos;.
    &lt;ls_dd03p&gt;-leng      = &apos;000012&apos;.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING &lt;ls_dd03p&gt;.
    &lt;ls_dd03p&gt;-tabname   = zcl_abapgit_persistence_db=&gt;c_tabname.
    &lt;ls_dd03p&gt;-fieldname = &apos;DATA_STR&apos;.
    &lt;ls_dd03p&gt;-position  = &apos;0003&apos;.
    &lt;ls_dd03p&gt;-datatype  = &apos;STRG&apos;.

    CALL FUNCTION &apos;DDIF_TABL_PUT&apos;
      EXPORTING
        name              = zcl_abapgit_persistence_db=&gt;c_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from DDIF_TABL_PUT&apos; ).
    ENDIF.

    lv_obj_name = zcl_abapgit_persistence_db=&gt;c_tabname.
    CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
      EXPORTING
        wi_tadir_pgmid    = &apos;R3TR&apos;
        wi_tadir_object   = &apos;TABL&apos;
        wi_tadir_obj_name = lv_obj_name
        wi_set_genflag    = abap_true
        wi_test_modus     = abap_false
        wi_tadir_devclass = &apos;$TMP&apos;
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from TR_TADIR_INTERFACE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;DDIF_TABL_ACTIVATE&apos;
      EXPORTING
        name        = zcl_abapgit_persistence_db=&gt;c_tabname
        auth_chk    = abap_false
      IMPORTING
        rc          = lv_rc
      EXCEPTIONS
        not_found   = 1
        put_failure = 2
        OTHERS      = 3.
    IF sy-subrc &lt;&gt; 0 OR lv_rc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;migrate, error from DDIF_TABL_ACTIVATE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD table_exists.

    DATA: lv_tabname TYPE dd02l-tabname.

    SELECT SINGLE tabname FROM dd02l INTO lv_tabname
      WHERE tabname = zcl_abapgit_persistence_db=&gt;c_tabname.
    rv_exists = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD update_global_settings.

    DATA: li_ixml          TYPE REF TO if_ixml,
          lv_settings_xml  TYPE string,
          li_ostream       TYPE REF TO if_ixml_ostream,
          li_renderer      TYPE REF TO if_ixml_renderer,
          li_streamfactory TYPE REF TO if_ixml_stream_factory.

    &quot; finally update global settings
    &quot; migrated elements are already removed from document

    li_ixml = cl_ixml=&gt;create( ).
    li_streamfactory = li_ixml-&gt;create_stream_factory( ).
    li_ostream = li_streamfactory-&gt;create_ostream_cstring( lv_settings_xml ).
    li_renderer = li_ixml-&gt;create_renderer( ostream  = li_ostream
                                            document = ii_document ).
    li_renderer-&gt;render( ).

    zcl_abapgit_persistence_db=&gt;get_instance( )-&gt;update(
      iv_type  = zcl_abapgit_persistence_db=&gt;c_type_settings
      iv_value = &apos;&apos;
      iv_data  = lv_settings_xml ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSIST_INJECTOR IMPLEMENTATION.
  METHOD set_repo.

    zcl_abapgit_persist_factory=&gt;gi_repo = ii_repo.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSIST_FACTORY IMPLEMENTATION.
  METHOD get_repo.

    IF gi_repo IS INITIAL.
      CREATE OBJECT gi_repo TYPE zcl_abapgit_persistence_repo.
    ENDIF.

    ri_repo = gi_repo.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PERSIST_BACKGROUND IMPLEMENTATION.
  METHOD constructor.
    mo_db = zcl_abapgit_persistence_db=&gt;get_instance( ).
  ENDMETHOD.
  METHOD delete.

    TRY.
        mo_db-&gt;read( iv_type  = zcl_abapgit_persistence_db=&gt;c_type_background
                     iv_value = iv_key ).
      CATCH zcx_abapgit_not_found.
        RETURN.
    ENDTRY.

    mo_db-&gt;delete( iv_type  = zcl_abapgit_persistence_db=&gt;c_type_background
                   iv_value = iv_key ).

    DELETE mt_jobs WHERE key = iv_key.

  ENDMETHOD.
  METHOD exists.

    list( ). &quot; Ensure mt_jobs is populated
    READ TABLE mt_jobs WITH KEY key = iv_key TRANSPORTING NO FIELDS.
    rv_yes = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD from_xml.
    CALL TRANSFORMATION id
      OPTIONS value_handling = &apos;accept_data_loss&apos;
      SOURCE XML iv_string
      RESULT data = rs_xml ##NO_TEXT.
  ENDMETHOD.
  METHOD list.

    DATA: lt_list TYPE zif_abapgit_persistence=&gt;tt_content,
          ls_xml  TYPE ty_xml.

    FIELD-SYMBOLS: &lt;ls_list&gt;   LIKE LINE OF lt_list,
                   &lt;ls_output&gt; LIKE LINE OF rt_list.

    IF lines( mt_jobs ) &gt; 0.
      rt_list = mt_jobs.
      RETURN.
    ENDIF.
    lt_list = mo_db-&gt;list_by_type( zcl_abapgit_persistence_db=&gt;c_type_background ).

    LOOP AT lt_list ASSIGNING &lt;ls_list&gt;.
      ls_xml = from_xml( &lt;ls_list&gt;-data_str ).

      APPEND INITIAL LINE TO rt_list ASSIGNING &lt;ls_output&gt;.
      MOVE-CORRESPONDING ls_xml TO &lt;ls_output&gt;.
      &lt;ls_output&gt;-key = &lt;ls_list&gt;-value.
    ENDLOOP.

    mt_jobs = rt_list.

  ENDMETHOD.
  METHOD modify.

    ASSERT NOT is_data-key IS INITIAL.

    mo_db-&gt;modify(
      iv_type  = zcl_abapgit_persistence_db=&gt;c_type_background
      iv_value = is_data-key
      iv_data  = to_xml( is_data ) ).

    DELETE mt_jobs WHERE key = is_data-key.
    APPEND is_data TO mt_jobs.

  ENDMETHOD.
  METHOD to_xml.
    DATA: ls_xml TYPE ty_xml.

    MOVE-CORRESPONDING is_background TO ls_xml.

    CALL TRANSFORMATION id
      SOURCE data = ls_xml
      RESULT XML rv_string.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OO_SERIALIZER IMPLEMENTATION.
  METHOD are_test_classes_skipped.
    rv_return = mv_skip_testclass.
  ENDMETHOD.
  METHOD calculate_skip_testclass.

    DATA: lv_line1 LIKE LINE OF it_source,
          lv_line2 LIKE LINE OF it_source.

* when creating classes in Eclipse it automatically generates the
* testclass include, but it is not needed, so skip to avoid
* creating an extra file in the repository.
* Also remove it if the content is manually removed, but
* the class still thinks it contains tests

    rv_skip_testclass = abap_false.
    IF lines( it_source ) = 2.
      READ TABLE it_source INDEX 1 INTO lv_line1.
      ASSERT sy-subrc = 0.
      READ TABLE it_source INDEX 2 INTO lv_line2.
      ASSERT sy-subrc = 0.
      IF strlen( lv_line1 ) &gt;= 3 AND lv_line1(3) = &apos;*&quot;*&apos; AND lv_line2 IS INITIAL.
        rv_skip_testclass = abap_true.
      ENDIF.
    ELSEIF lines( it_source ) = 1.
      READ TABLE it_source INDEX 1 INTO lv_line1.
      ASSERT sy-subrc = 0.
      IF lv_line1 IS INITIAL
          OR ( strlen( lv_line1 ) &gt;= 3 AND lv_line1(3) = &apos;*&quot;*&apos; )
          OR ( strlen( lv_line1 ) = 1 AND lv_line1(1) = &apos;*&apos; ).
        rv_skip_testclass = abap_true.
      ENDIF.
    ELSEIF lines( it_source ) = 0.
      rv_skip_testclass = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD read_include.

    DATA: ls_include TYPE progstruc.
    ASSERT iv_type = seop_ext_class_locals_def
      OR iv_type = seop_ext_class_locals_imp
      OR iv_type = seop_ext_class_macros
      OR iv_type = seop_ext_class_testclasses.

    ls_include-rootname = is_clskey-clsname.
    TRANSLATE ls_include-rootname USING &apos; =&apos;.
    ls_include-categorya = iv_type(1).
    ls_include-codea = iv_type+1(4).

* it looks like there is an issue in function module SEO_CLASS_GET_INCLUDE_SOURCE
* on 750 kernels, where the READ REPORT without STATE addition does not
* return the active version, this method is a workaround for this issue
    READ REPORT ls_include INTO rt_source STATE &apos;A&apos;.

  ENDMETHOD.
  METHOD reduce.

    DATA: lv_source LIKE LINE OF ct_source,
          lv_found  TYPE sap_bool.
* skip files that only contain the standard comments
    lv_found = abap_false.
    LOOP AT ct_source INTO lv_source.
      IF strlen( lv_source ) &gt;= 3 AND lv_source(3) &lt;&gt; &apos;*&quot;*&apos;.
        lv_found = abap_true.
      ENDIF.
    ENDLOOP.
    IF lv_found = abap_false.
      CLEAR ct_source.
    ENDIF.

  ENDMETHOD.
  METHOD remove_signatures.

* signatures messes up in CL_OO_SOURCE when deserializing and serializing
* within same session

    DATA: lv_begin  TYPE string,
          lv_end    TYPE string,
          lv_remove TYPE sap_bool,
          lv_source LIKE LINE OF ct_source.

    &quot;@TODO: Put under test
    CONCATENATE &apos;* &lt;SIGNATURE&gt;------------------------------------&apos;
      &apos;---------------------------------------------------+&apos;
      INTO lv_begin.

    CONCATENATE &apos;* +------------------------------------------------&apos;
      &apos;--------------------------------------&lt;/SIGNATURE&gt;&apos;
      INTO lv_end.

    lv_remove = abap_false.
    LOOP AT ct_source INTO lv_source.
      IF lv_source = lv_begin.
        lv_remove = abap_true.
      ENDIF.
      IF lv_remove = abap_true.
        DELETE ct_source INDEX sy-tabix.
      ENDIF.
      IF lv_source = lv_end.
        lv_remove = abap_false.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_abap_clif_source.
    TRY.
        rt_source = serialize_abap_new( is_class_key ).
      CATCH cx_sy_dyn_call_error.
        rt_source = serialize_abap_old( is_class_key ).
    ENDTRY.
  ENDMETHOD.
  METHOD serialize_abap_new.

    DATA: lo_source   TYPE REF TO object,
          lo_instance TYPE REF TO object.

* do not call the class/methods statically, as it will
* give syntax errors on old versions
    CALL METHOD (&apos;CL_OO_FACTORY&apos;)=&gt;(&apos;CREATE_INSTANCE&apos;)
      RECEIVING
        result = lo_instance.

    CALL METHOD lo_instance-&gt;(&apos;CREATE_CLIF_SOURCE&apos;)
      EXPORTING
        clif_name = is_clskey-clsname
        version   = &apos;A&apos;
      RECEIVING
        result    = lo_source.

    CALL METHOD lo_source-&gt;(&apos;GET_SOURCE&apos;)
      IMPORTING
        source = rt_source.

  ENDMETHOD.
  METHOD serialize_abap_old.
* for old ABAP AS versions
    DATA: lo_source TYPE REF TO cl_oo_source.

    CREATE OBJECT lo_source
      EXPORTING
        clskey             = is_clskey
      EXCEPTIONS
        class_not_existing = 1
        OTHERS             = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from CL_OO_SOURCE&apos; ).
    ENDIF.

    lo_source-&gt;read( &apos;A&apos; ).
    rt_source = lo_source-&gt;get_old_source( ).
    remove_signatures( CHANGING ct_source = rt_source ).

  ENDMETHOD.
  METHOD serialize_locals_def.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_locals_def ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.
  METHOD serialize_locals_imp.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_locals_imp ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.
  METHOD serialize_macros.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_macros ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.
  METHOD serialize_testclasses.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_testclasses ).

    mv_skip_testclass = calculate_skip_testclass( rt_source ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_oo_interface IMPLEMENTATION.
  METHOD zif_abapgit_oo_object_fnc~create.
    DATA: lt_vseoattrib TYPE seoo_attributes_r.
    FIELD-SYMBOLS: &lt;lv_clsname&gt; TYPE seoclsname.

    ASSIGN COMPONENT &apos;CLSNAME&apos; OF STRUCTURE cg_properties TO &lt;lv_clsname&gt;.
    ASSERT sy-subrc = 0.

    lt_vseoattrib = convert_attrib_to_vseoattrib(
                      iv_clsname    = &lt;lv_clsname&gt;
                      it_attributes = it_attributes ).

    CALL FUNCTION &apos;SEO_INTERFACE_CREATE_COMPLETE&apos;
      EXPORTING
        devclass        = iv_package
        overwrite       = iv_overwrite
      CHANGING
        interface       = cg_properties
        attributes      = lt_vseoattrib
      EXCEPTIONS
        existing        = 1
        is_class        = 2
        db_error        = 3
        component_error = 4
        no_access       = 5
        other           = 6
        OTHERS          = 7.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from SEO_INTERFACE_CREATE_COMPLETE&apos; ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_includes.
    DATA lv_interface_name TYPE seoclsname.
    lv_interface_name = iv_object_name.
    APPEND cl_oo_classname_service=&gt;get_interfacepool_name( lv_interface_name ) TO rt_includes.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_interface_properties.
    CALL FUNCTION &apos;SEO_CLIF_GET&apos;
      EXPORTING
        cifkey       = is_interface_key
        version      = seoc_version_active
      IMPORTING
        interface    = rs_interface_properties
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 1.
      RETURN. &quot; in case only inactive version exists
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from seo_clif_get&apos; ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete.
    CALL FUNCTION &apos;SEO_INTERFACE_DELETE_COMPLETE&apos;
      EXPORTING
        intkey       = is_deletion_key
      EXCEPTIONS
        not_existing = 1
        is_class     = 2
        db_error     = 3
        no_access    = 4
        other        = 5
        OTHERS       = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from SEO_INTERFACE_DELETE_COMPLETE&apos; ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OO_FACTORY IMPLEMENTATION.
  METHOD make.
    IF gi_object_oriented_object IS BOUND.
      ro_object_oriented_object = gi_object_oriented_object.
      RETURN.
    ENDIF.
    IF iv_object_type = &apos;CLAS&apos;.
      CREATE OBJECT ro_object_oriented_object TYPE zcl_abapgit_oo_class.
    ELSEIF iv_object_type = &apos;INTF&apos;.
      CREATE OBJECT ro_object_oriented_object TYPE zcl_abapgit_oo_interface.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_oo_class_new IMPLEMENTATION.
  METHOD create_report.
    INSERT REPORT iv_program FROM it_source EXTENSION TYPE iv_extension STATE iv_version PROGRAM TYPE iv_program_type.
    ASSERT sy-subrc = 0.
  ENDMETHOD.
  METHOD determine_method_include.

    DATA: ls_mtdkey TYPE seocpdkey.
    ls_mtdkey-clsname = iv_name.
    ls_mtdkey-cpdname = iv_method.

    cl_oo_classname_service=&gt;get_method_include(
      EXPORTING
        mtdkey              = ls_mtdkey
      RECEIVING
        result              = rv_program
      EXCEPTIONS
        method_not_existing = 1 ).
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;SEO_METHOD_GENERATE_INCLUDE&apos;
      EXPORTING
        suppress_mtdkey_check          = seox_true
        mtdkey                         = ls_mtdkey
      EXCEPTIONS
        not_existing                   = 1
        model_only                     = 2
        include_existing               = 3
        method_imp_not_generated       = 4
        method_imp_not_initialised     = 5
        _internal_class_not_existing   = 6
        _internal_method_overflow      = 7
        cancelled                      = 8
        method_is_abstract_implemented = 9
        method_is_final_implemented    = 10
        internal_error_insert_report   = 11
        OTHERS                         = 12.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SEO_METHOD_GENERATE_INCLUDE&apos; ).
    ENDIF.

    rv_program = cl_oo_classname_service=&gt;get_method_include( ls_mtdkey ).

  ENDMETHOD.
  METHOD generate_classpool.

    DATA: ls_clskey TYPE seoclskey.

    ls_clskey-clsname = iv_name.

    CALL FUNCTION &apos;SEO_CLASS_GENERATE_CLASSPOOL&apos;
      EXPORTING
        clskey                        = ls_clskey
        suppress_corr                 = seox_true
      EXCEPTIONS
        not_existing                  = 1
        model_only                    = 2
        class_pool_not_generated      = 3
        class_stment_not_generated    = 4
        locals_not_generated          = 5
        macros_not_generated          = 6
        public_sec_not_generated      = 7
        protected_sec_not_generated   = 8
        private_sec_not_generated     = 9
        typeref_not_generated         = 10
        class_pool_not_initialised    = 11
        class_stment_not_initialised  = 12
        locals_not_initialised        = 13
        macros_not_initialised        = 14
        public_sec_not_initialised    = 15
        protected_sec_not_initialised = 16
        private_sec_not_initialised   = 17
        typeref_not_initialised       = 18
        _internal_class_overflow      = 19
        OTHERS                        = 20.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SEO_CLASS_GENERATE_CLASSPOOL&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD init_scanner.

    TRY.
        ro_scanner = cl_oo_source_scanner_class=&gt;create_class_scanner(
          clif_name = iv_name
          source    = it_source ).
        ro_scanner-&gt;scan( ).
      CATCH cx_clif_scan_error.
        zcx_abapgit_exception=&gt;raise( &apos;error initializing CLAS scanner&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD update_cs_number_of_methods.

    &quot; Indirect access to keep downward compatibility
    DATA lr_cache_entry TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_cache_entry&gt; TYPE any,
                   &lt;lg_field&gt;       TYPE any.
    TRY.
        CREATE DATA lr_cache_entry TYPE (&apos;SEO_CS_CACHE&apos;).
      CATCH cx_sy_create_data_error.
* does not exist in some older systems
        RETURN.
    ENDTRY.

    ASSIGN lr_cache_entry-&gt;* TO &lt;lg_cache_entry&gt;.
    ASSERT sy-subrc = 0.

    ASSIGN COMPONENT &apos;CLSNAME&apos; OF STRUCTURE &lt;lg_cache_entry&gt;
           TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    &lt;lg_field&gt; = iv_classname.

    ASSIGN COMPONENT &apos;NO_OF_METHOD_IMPLS&apos; OF STRUCTURE &lt;lg_cache_entry&gt;
           TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    &lt;lg_field&gt; = iv_number_of_impl_methods.

    MODIFY (&apos;SEO_CS_CACHE&apos;) FROM &lt;lg_cache_entry&gt;.

  ENDMETHOD.
  METHOD update_full_class_include.

    CONSTANTS: lc_class_source_extension TYPE sychar02 VALUE &apos;CS&apos;,
               lc_include_program_type   TYPE sychar01 VALUE &apos;I&apos;,
               lc_active_version         TYPE r3state VALUE &apos;A&apos;.
    create_report( iv_program      = cl_oo_classname_service=&gt;get_cs_name( iv_classname )
                   it_source       = it_source
                   iv_extension    = lc_class_source_extension
                   iv_program_type = lc_include_program_type
                   iv_version      = lc_active_version ).

    &quot; Assuming that all methods that were scanned are implemented
    update_cs_number_of_methods( iv_classname              = iv_classname
                                 iv_number_of_impl_methods = lines( it_methods ) ).

  ENDMETHOD.
  METHOD update_meta.

    DATA: lo_update     TYPE REF TO cl_oo_class_section_source,
          ls_clskey     TYPE seoclskey,
          lv_scan_error TYPE seox_boolean.
    ls_clskey-clsname = iv_name.

    TRY.
        CREATE OBJECT lo_update TYPE (&apos;CL_OO_CLASS_SECTION_SOURCE&apos;)
          EXPORTING
            clskey                        = ls_clskey
            exposure                      = iv_exposure
            state                         = &apos;A&apos;
            source                        = it_source
            suppress_constrctr_generation = seox_true
          EXCEPTIONS
            class_not_existing            = 1
            read_source_error             = 2
            OTHERS                        = 3.
      CATCH cx_sy_dyn_call_param_not_found.
* downport to 702, see https://github.com/larshp/abapGit/issues/933
* this will READ REPORT instead of using it_source, which should be okay
        CREATE OBJECT lo_update TYPE cl_oo_class_section_source
          EXPORTING
            clskey             = ls_clskey
            exposure           = iv_exposure
            state              = &apos;A&apos;
          EXCEPTIONS
            class_not_existing = 1
            read_source_error  = 2
            OTHERS             = 3.
    ENDTRY.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error instantiating CL_OO_CLASS_SECTION_SOURCE&apos; ).
    ENDIF.

    lo_update-&gt;set_dark_mode( seox_true ).
    TRY.
        CALL METHOD lo_update-&gt;(&apos;SET_AMDP_SUPPORT&apos;)
          EXPORTING
            enabled = abap_true.
      CATCH cx_sy_dyn_call_illegal_method.
* AMDP not supported in this system, ignore error
    ENDTRY.
    lo_update-&gt;scan_section_source(
      RECEIVING
        scan_error             = lv_scan_error
      EXCEPTIONS
        scan_abap_source_error = 1
        OTHERS                 = 2 ).
    IF sy-subrc &lt;&gt; 0 OR lv_scan_error = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;CLAS, error while scanning source&apos; ).
    ENDIF.

* this will update the SEO* database tables
    lo_update-&gt;revert_scan_result( ).

    IF iv_exposure = seoc_exposure_public.
      generate_classpool( iv_name ).
    ENDIF.

  ENDMETHOD.
  METHOD update_report.

    DATA: lt_old TYPE string_table.

    READ REPORT iv_program INTO lt_old.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Fatal error. Include { iv_program } should have been created previously!| ).
    ENDIF.

    IF lt_old &lt;&gt; it_source.
      INSERT REPORT iv_program FROM it_source.
      ASSERT sy-subrc = 0.
      rv_updated = abap_true.
    ELSE.
      rv_updated = abap_false.
    ENDIF.

  ENDMETHOD.
  METHOD update_source_index.

    CONSTANTS:
      lc_version_active   TYPE r3state VALUE &apos;A&apos;,           &quot;#EC NOTEXT
      lc_version_inactive TYPE r3state VALUE &apos;I&apos;.           &quot;#EC NOTEXT

    &quot;    dynamic invocation, IF_OO_SOURCE_POS_INDEX_HELPER doesn&apos;t exist in 702.
    DATA lo_index_helper TYPE REF TO object.

    TRY.
        CREATE OBJECT lo_index_helper TYPE (&apos;CL_OO_SOURCE_POS_INDEX_HELPER&apos;).

        CALL METHOD lo_index_helper-&gt;(&apos;IF_OO_SOURCE_POS_INDEX_HELPER~CREATE_INDEX_WITH_SCANNER&apos;)
          EXPORTING
            class_name = iv_clsname
            version    = lc_version_active
            scanner    = io_scanner.

        CALL METHOD lo_index_helper-&gt;(&apos;IF_OO_SOURCE_POS_INDEX_HELPER~DELETE_INDEX&apos;)
          EXPORTING
            class_name = iv_clsname
            version    = lc_version_inactive.

      CATCH cx_root.
        &quot; it&apos;s probably okay to no update the index
        RETURN.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~create.
    DATA: lt_vseoattrib TYPE seoo_attributes_r.
    FIELD-SYMBOLS: &lt;lv_clsname&gt; TYPE seoclsname.

* same as in super class, but with &quot;version = seoc_version_active&quot;

    ASSIGN COMPONENT &apos;CLSNAME&apos; OF STRUCTURE cg_properties TO &lt;lv_clsname&gt;.
    ASSERT sy-subrc = 0.

    lt_vseoattrib = convert_attrib_to_vseoattrib(
                      iv_clsname    = &lt;lv_clsname&gt;
                      it_attributes = it_attributes ).

    CALL FUNCTION &apos;SEO_CLASS_CREATE_COMPLETE&apos;
      EXPORTING
        devclass        = iv_package
        overwrite       = iv_overwrite
        version         = seoc_version_active
      CHANGING
        class           = cg_properties
        attributes      = lt_vseoattrib
      EXCEPTIONS
        existing        = 1
        is_interface    = 2
        db_error        = 3
        component_error = 4
        no_access       = 5
        other           = 6
        OTHERS          = 7.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SEO_CLASS_CREATE_COMPLETE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~deserialize_source.

    DATA: lv_updated TYPE abap_bool,
          lv_program TYPE program,
          lo_scanner TYPE REF TO cl_oo_source_scanner_class,
          lt_methods TYPE cl_oo_source_scanner_class=&gt;type_method_implementations,
          lv_method  LIKE LINE OF lt_methods,
          lt_source  TYPE seop_source_string.
    &quot;Buffer needs to be refreshed,
    &quot;otherwise standard SAP CLIF_SOURCE reorder methods alphabetically
    CALL FUNCTION &apos;SEO_BUFFER_INIT&apos;.
    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        cifkey  = is_key
        version = seoc_version_inactive.

    lo_scanner = init_scanner(
      it_source = it_source
      iv_name   = is_key-clsname ).

* public
    lt_source = lo_scanner-&gt;get_public_section_source( ).
    IF lt_source IS NOT INITIAL.
      lv_program = cl_oo_classname_service=&gt;get_pubsec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  it_source  = lt_source ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_public
                     it_source   = lt_source ).
      ENDIF.
    ENDIF.

* protected
    lt_source = lo_scanner-&gt;get_protected_section_source( ).
    IF lt_source IS NOT INITIAL.
      lv_program = cl_oo_classname_service=&gt;get_prosec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  it_source  = lt_source ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_protected
                     it_source   = lt_source ).
      ENDIF.
    ENDIF.

* private
    lt_source = lo_scanner-&gt;get_private_section_source( ).
    IF lt_source IS NOT INITIAL.
      lv_program = cl_oo_classname_service=&gt;get_prisec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  it_source  = lt_source ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_private
                     it_source   = lt_source ).
      ENDIF.
    ENDIF.

* methods
    lt_methods = lo_scanner-&gt;get_method_implementations( ).

    LOOP AT lt_methods INTO lv_method.
      TRY.
          lt_source = lo_scanner-&gt;get_method_impl_source( lv_method ).
        CATCH cx_oo_clif_component.
          zcx_abapgit_exception=&gt;raise( &apos;error from GET_METHOD_IMPL_SOURCE&apos; ).
      ENDTRY.
      lv_program = determine_method_include(
        iv_name   = is_key-clsname
        iv_method = lv_method ).

      update_report(
        iv_program = lv_program
        it_source  = lt_source ).
    ENDLOOP.

* full class include
    update_full_class_include( iv_classname = is_key-clsname
                               it_source    = it_source
                               it_methods   = lt_methods ).

    update_source_index(
      iv_clsname = is_key-clsname
      io_scanner = lo_scanner ).

* TODO, perhaps move this call to somewhere else, to be done while cleaning up the CLAS deserialization
    zcl_abapgit_objects_activation=&gt;add(
      iv_type = &apos;CLAS&apos;
      iv_name = is_key-clsname ).

  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~generate_locals.

    DATA: lv_program TYPE programm.
    IF lines( it_local_definitions ) &gt; 0.
      lv_program = cl_oo_classname_service=&gt;get_ccdef_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     it_source  = it_local_definitions ).
    ENDIF.

    IF lines( it_local_implementations ) &gt; 0.
      lv_program = cl_oo_classname_service=&gt;get_ccimp_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     it_source  = it_local_implementations ).
    ENDIF.

    IF lines( it_local_macros ) &gt; 0.
      lv_program = cl_oo_classname_service=&gt;get_ccmac_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     it_source  = it_local_macros ).
    ENDIF.

    IF lines( it_local_test_classes ) &gt; 0.
      lv_program = cl_oo_classname_service=&gt;get_ccau_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     it_source  = it_local_test_classes ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_oo_class IMPLEMENTATION.
  METHOD zif_abapgit_oo_object_fnc~create.
    DATA: lt_vseoattrib TYPE seoo_attributes_r.
    FIELD-SYMBOLS: &lt;lv_clsname&gt; TYPE seoclsname.

    ASSIGN COMPONENT &apos;CLSNAME&apos; OF STRUCTURE cg_properties TO &lt;lv_clsname&gt;.
    ASSERT sy-subrc = 0.

    lt_vseoattrib = convert_attrib_to_vseoattrib(
                      iv_clsname    = &lt;lv_clsname&gt;
                      it_attributes = it_attributes ).

    CALL FUNCTION &apos;SEO_CLASS_CREATE_COMPLETE&apos;
      EXPORTING
        devclass        = iv_package
        overwrite       = iv_overwrite
      CHANGING
        class           = cg_properties
        attributes      = lt_vseoattrib
      EXCEPTIONS
        existing        = 1
        is_interface    = 2
        db_error        = 3
        component_error = 4
        no_access       = 5
        other           = 6
        OTHERS          = 7.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SEO_CLASS_CREATE_COMPLETE&apos; ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~generate_locals.
    CALL FUNCTION &apos;SEO_CLASS_GENERATE_LOCALS&apos;
      EXPORTING
        clskey                 = is_key
        force                  = iv_force
        locals_def             = it_local_definitions
        locals_imp             = it_local_implementations
        locals_mac             = it_local_macros
        locals_testclasses     = it_local_test_classes
      EXCEPTIONS
        not_existing           = 1
        model_only             = 2
        locals_not_generated   = 3
        locals_not_initialised = 4
        OTHERS                 = 5.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from generate_locals&apos; ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~insert_text_pool.
    DATA: lv_cp TYPE program.

    lv_cp = cl_oo_classname_service=&gt;get_classpool_name( iv_class_name ).

    INSERT TEXTPOOL lv_cp
      FROM it_text_pool
      LANGUAGE iv_language
      STATE &apos;I&apos;.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from INSERT TEXTPOOL&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add( iv_type = &apos;REPT&apos;
                                         iv_name = lv_cp ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create_sotr.
    DATA: lt_sotr    TYPE zif_abapgit_definitions=&gt;ty_sotr_tt,
          lt_objects TYPE sotr_objects,
          ls_paket   TYPE sotr_pack,
          lv_object  LIKE LINE OF lt_objects.

    FIELD-SYMBOLS: &lt;ls_sotr&gt; LIKE LINE OF lt_sotr.

    LOOP AT it_sotr ASSIGNING &lt;ls_sotr&gt;.
      CALL FUNCTION &apos;SOTR_OBJECT_GET_OBJECTS&apos;
        EXPORTING
          object_vector    = &lt;ls_sotr&gt;-header-objid_vec
        IMPORTING
          objects          = lt_objects
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from SOTR_OBJECT_GET_OBJECTS&apos; ).
      ENDIF.

      READ TABLE lt_objects INDEX 1 INTO lv_object.
      ASSERT sy-subrc = 0.

      ls_paket-paket = iv_package.

      CALL FUNCTION &apos;SOTR_CREATE_CONCEPT&apos;
        EXPORTING
          paket                         = ls_paket
          crea_lan                      = &lt;ls_sotr&gt;-header-crea_lan
          alias_name                    = &lt;ls_sotr&gt;-header-alias_name
          object                        = lv_object
          entries                       = &lt;ls_sotr&gt;-entries
          concept_default               = &lt;ls_sotr&gt;-header-concept
        EXCEPTIONS
          package_missing               = 1
          crea_lan_missing              = 2
          object_missing                = 3
          paket_does_not_exist          = 4
          alias_already_exist           = 5
          object_type_not_found         = 6
          langu_missing                 = 7
          identical_context_not_allowed = 8
          text_too_long                 = 9
          error_in_update               = 10
          no_master_langu               = 11
          error_in_concept_id           = 12
          alias_not_allowed             = 13
          tadir_entry_creation_failed   = 14
          internal_error                = 15
          error_in_correction           = 16
          user_cancelled                = 17
          no_entry_found                = 18
          OTHERS                        = 19.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from SOTR_CREATE_CONCEPT&apos; ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_includes.
* note: includes returned might not exist
* method cl_oo_classname_service=&gt;GET_ALL_CLASS_INCLUDES does not exist in 702

    DATA: lv_class_name TYPE seoclsname,
          lt_methods    TYPE seop_methods_w_include.

    FIELD-SYMBOLS: &lt;ls_method&gt; LIKE LINE OF lt_methods.

    lv_class_name = iv_object_name.

    APPEND cl_oo_classname_service=&gt;get_ccdef_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_ccmac_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_ccimp_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_cl_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_ccau_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_pubsec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_prosec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_prisec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_classpool_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=&gt;get_ct_name( lv_class_name ) TO rt_includes.

* skip the CS include, as it is sometimes generated on the fly instead of
* when the methods are changed
*    APPEND cl_oo_classname_service=&gt;get_cs_name( lv_class_name ) TO rt_includes.

    cl_oo_classname_service=&gt;get_all_method_includes(
      EXPORTING
        clsname            = lv_class_name
      RECEIVING
        result             = lt_methods
      EXCEPTIONS
        class_not_existing = 1 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Class { lv_class_name } not existing| ).
    ENDIF.

    LOOP AT lt_methods ASSIGNING &lt;ls_method&gt;.
      APPEND &lt;ls_method&gt;-incname TO rt_includes.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_class_properties.
    CALL FUNCTION &apos;SEO_CLIF_GET&apos;
      EXPORTING
        cifkey       = is_class_key
        version      = seoc_version_active
      IMPORTING
        class        = rs_class_properties
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 1.
      RETURN. &quot; in case only inactive version exists
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from seo_clif_get&apos; ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_text_pool.
    DATA:
     lv_cp TYPE program.

    lv_cp = cl_oo_classname_service=&gt;get_classpool_name( iv_class_name ).
    READ TEXTPOOL lv_cp INTO rt_text_pool LANGUAGE iv_language. &quot;#EC CI_READ_REP
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_sotr.
    DATA: lv_concept    TYPE sotr_head-concept,
          lt_seocompodf TYPE STANDARD TABLE OF seocompodf WITH DEFAULT KEY,
          ls_header     TYPE sotr_head,
          lt_entries    TYPE sotr_text_tt.

    FIELD-SYMBOLS: &lt;ls_sotr&gt;       LIKE LINE OF rt_sotr,
                   &lt;ls_seocompodf&gt; LIKE LINE OF lt_seocompodf,
                   &lt;ls_entry&gt;      LIKE LINE OF lt_entries.
    SELECT * FROM seocompodf
      INTO TABLE lt_seocompodf
      WHERE clsname = iv_object_name
      AND version = &apos;1&apos;
      AND exposure = &apos;2&apos;
      AND attdecltyp = &apos;2&apos;
      AND type = &apos;SOTR_CONC&apos;
      ORDER BY PRIMARY KEY.                               &quot;#EC CI_SUBRC

    LOOP AT lt_seocompodf ASSIGNING &lt;ls_seocompodf&gt;.

      lv_concept = translate( val = &lt;ls_seocompodf&gt;-attvalue from = &apos;&apos;&apos;&apos; to = &apos;&apos; ).

      CALL FUNCTION &apos;SOTR_GET_CONCEPT&apos;
        EXPORTING
          concept        = lv_concept
        IMPORTING
          header         = ls_header
        TABLES
          entries        = lt_entries
        EXCEPTIONS
          no_entry_found = 1
          OTHERS         = 2.
      IF sy-subrc &lt;&gt; 0.
        CONTINUE.
      ENDIF.

      CLEAR: ls_header-paket,
             ls_header-crea_name,
             ls_header-crea_tstut,
             ls_header-chan_name,
             ls_header-chan_tstut.

      LOOP AT lt_entries ASSIGNING &lt;ls_entry&gt;.
        CLEAR: &lt;ls_entry&gt;-version,
               &lt;ls_entry&gt;-crea_name,
               &lt;ls_entry&gt;-crea_tstut,
               &lt;ls_entry&gt;-chan_name,
               &lt;ls_entry&gt;-chan_tstut.
      ENDLOOP.

      APPEND INITIAL LINE TO rt_sotr ASSIGNING &lt;ls_sotr&gt;.
      &lt;ls_sotr&gt;-header = ls_header.
      &lt;ls_sotr&gt;-entries = lt_entries.

    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete.
    CALL FUNCTION &apos;SEO_CLASS_DELETE_COMPLETE&apos;
      EXPORTING
        clskey       = is_deletion_key
      EXCEPTIONS
        not_existing = 1
        is_interface = 2
        db_error     = 3
        no_access    = 4
        other        = 5
        OTHERS       = 6.
    IF sy-subrc = 1.
* ignore deletion of objects that does not exist
* this can happen when the SXCI object is deleted before the implementing CLAS
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from SEO_CLASS_DELETE_COMPLETE: { sy-subrc }| ).
    ENDIF.
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_oo_base IMPLEMENTATION.
  METHOD deserialize_abap_source_new.
    DATA: lo_factory  TYPE REF TO object,
          lo_source   TYPE REF TO object,
          lo_settings TYPE REF TO object,
          lr_settings TYPE REF TO data.

    FIELD-SYMBOLS &lt;lg_settings&gt; TYPE any.
    &quot;Buffer needs to be refreshed,
    &quot;otherwise standard SAP CLIF_SOURCE reorder methods alphabetically
    CALL FUNCTION &apos;SEO_BUFFER_INIT&apos;.
    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        cifkey  = is_clskey
        version = seoc_version_inactive.

    CALL METHOD (&apos;CL_OO_FACTORY&apos;)=&gt;(&apos;CREATE_INSTANCE&apos;)
      RECEIVING
        result = lo_factory.

    &quot;Enable modification mode to avoid exception CX_OO_ACCESS_PERMISSON when
    &quot;dealing with objects in foreign namespaces (namespace role = C)
    CALL METHOD lo_factory-&gt;(&apos;CREATE_SETTINGS&apos;)
      EXPORTING
        modification_mode_enabled = abap_true
      RECEIVING
        result                    = lo_settings.

    CREATE DATA lr_settings TYPE REF TO (&apos;IF_OO_CLIF_SOURCE_SETTINGS&apos;).
    ASSIGN lr_settings-&gt;* TO &lt;lg_settings&gt;.

    &lt;lg_settings&gt; ?= lo_settings.

    CALL METHOD lo_factory-&gt;(&apos;CREATE_CLIF_SOURCE&apos;)
      EXPORTING
        clif_name = is_clskey-clsname
        settings  = &lt;lg_settings&gt;
      RECEIVING
        result    = lo_source.

    TRY.
        CALL METHOD lo_source-&gt;(&apos;IF_OO_CLIF_SOURCE~LOCK&apos;).
      CATCH cx_oo_access_permission.
        zcx_abapgit_exception=&gt;raise( &apos;source_new, access permission exception&apos; ).
    ENDTRY.

    CALL METHOD lo_source-&gt;(&apos;IF_OO_CLIF_SOURCE~SET_SOURCE&apos;)
      EXPORTING
        source = it_source.

    CALL METHOD lo_source-&gt;(&apos;IF_OO_CLIF_SOURCE~SAVE&apos;).

    CALL METHOD lo_source-&gt;(&apos;IF_OO_CLIF_SOURCE~UNLOCK&apos;).

  ENDMETHOD.
  METHOD deserialize_abap_source_old.
    &quot;for backwards compatability down to 702

    DATA: lo_source TYPE REF TO cl_oo_source.

    CREATE OBJECT lo_source
      EXPORTING
        clskey             = is_clskey
      EXCEPTIONS
        class_not_existing = 1
        OTHERS             = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from CL_OO_SOURCE&apos; ).
    ENDIF.

    TRY.
        lo_source-&gt;access_permission( seok_access_modify ).
        lo_source-&gt;set_source( it_source ).
        lo_source-&gt;save( ).
        lo_source-&gt;access_permission( seok_access_free ).
      CATCH cx_oo_access_permission.
        zcx_abapgit_exception=&gt;raise( &apos;permission error&apos; ).
      CATCH cx_oo_source_save_failure.
        zcx_abapgit_exception=&gt;raise( &apos;save failure&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~add_to_activation_list.
    zcl_abapgit_objects_activation=&gt;add_item( is_item ).
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~create.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~create_documentation.
    CALL FUNCTION &apos;DOCU_UPD&apos;
      EXPORTING
        id       = &apos;CL&apos;
        langu    = iv_language
        object   = iv_object_name
      TABLES
        line     = it_lines
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DOCU_UPD&apos; ).
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~create_sotr.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~delete.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~deserialize_source.
    TRY.
        deserialize_abap_source_new(
          is_clskey = is_key
          it_source = it_source ).
      CATCH cx_sy_dyn_call_error.
        deserialize_abap_source_old(
          is_clskey = is_key
          it_source = it_source ).
    ENDTRY.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~exists.
    CALL FUNCTION &apos;SEO_CLASS_EXISTENCE_CHECK&apos;
      EXPORTING
        clskey        = is_object_name
      EXCEPTIONS
        not_specified = 1
        not_existing  = 2
        is_interface  = 3
        no_text       = 4
        inconsistent  = 5
        OTHERS        = 6.
    rv_exists = boolc( sy-subrc &lt;&gt; 2 ).
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~generate_locals.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~get_class_properties.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~get_includes.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~get_interface_properties.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~get_skip_test_classes.
    rv_skip = mv_skip_test_classes.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~insert_text_pool.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~read_descriptions.
    SELECT * FROM seocompotx INTO TABLE rt_descriptions
      WHERE clsname   = iv_obejct_name
        AND descript &lt;&gt; &apos;&apos;
      ORDER BY PRIMARY KEY.                               &quot;#EC CI_SUBRC
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~read_documentation.
    DATA: lv_state  TYPE dokstate,
          lv_object TYPE dokhl-object,
          lt_lines  TYPE tlinetab.

    lv_object = iv_class_name.

    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id                = &apos;CL&apos;
        langu             = iv_language
        object            = lv_object
      IMPORTING
        dokstate          = lv_state
      TABLES
        line              = lt_lines
      EXCEPTIONS
        no_docu_on_screen = 1
        no_docu_self_def  = 2
        no_docu_temp      = 3
        ret_code          = 4
        OTHERS            = 5.
    IF sy-subrc = 0 AND lv_state = &apos;R&apos;.
      rt_lines = lt_lines.
    ELSE.
      CLEAR rt_lines.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~read_sotr.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~read_superclass.
    SELECT SINGLE refclsname FROM vseoextend INTO rv_superclass
      WHERE clsname = iv_classname.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~read_text_pool.
    ASSERT 0 = 1. &quot;Subclass responsibility
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~serialize_abap.
    DATA lo_oo_serializer TYPE REF TO zcl_abapgit_oo_serializer.
    CREATE OBJECT lo_oo_serializer.
    CASE iv_type.
      WHEN seop_ext_class_locals_def.
        rt_source = lo_oo_serializer-&gt;serialize_locals_def( is_class_key ).
      WHEN seop_ext_class_locals_imp.
        rt_source = lo_oo_serializer-&gt;serialize_locals_imp( is_class_key ).
      WHEN seop_ext_class_macros.
        rt_source = lo_oo_serializer-&gt;serialize_macros( is_class_key ).
      WHEN seop_ext_class_testclasses.
        rt_source = lo_oo_serializer-&gt;serialize_testclasses( is_class_key ).
        mv_skip_test_classes = lo_oo_serializer-&gt;are_test_classes_skipped( ).
      WHEN OTHERS.
        rt_source = lo_oo_serializer-&gt;serialize_abap_clif_source( is_class_key ).
    ENDCASE.
  ENDMETHOD.
  METHOD zif_abapgit_oo_object_fnc~update_descriptions.
    DELETE FROM seocompotx WHERE clsname = is_key-clsname. &quot;#EC CI_SUBRC
    INSERT seocompotx FROM TABLE it_descriptions.         &quot;#EC CI_SUBRC
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_attributes.
    SELECT cmpname attbusobj attkeyfld
      FROM seocompodf
      INTO CORRESPONDING FIELDS OF TABLE rt_attributes
      WHERE clsname = iv_object_name
        AND ( attbusobj &lt;&gt; space OR attkeyfld &lt;&gt; space )
        AND version = &apos;1&apos;
      ORDER BY PRIMARY KEY.
  ENDMETHOD.
  METHOD convert_attrib_to_vseoattrib.
    FIELD-SYMBOLS: &lt;ls_attribute&gt;  LIKE LINE OF it_attributes,
                   &lt;ls_vseoattrib&gt; LIKE LINE OF rt_vseoattrib.

    LOOP AT it_attributes ASSIGNING &lt;ls_attribute&gt;.
      INSERT INITIAL LINE INTO TABLE rt_vseoattrib ASSIGNING &lt;ls_vseoattrib&gt;.
      MOVE-CORRESPONDING &lt;ls_attribute&gt; TO &lt;ls_vseoattrib&gt;.
      &lt;ls_vseoattrib&gt;-clsname = iv_clsname.
      UNASSIGN &lt;ls_vseoattrib&gt;.
    ENDLOOP.
    UNASSIGN &lt;ls_attribute&gt;.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_SUPER IMPLEMENTATION.
  METHOD check_timestamp.

    DATA: lv_ts TYPE timestamp.

    IF sy-subrc = 0 AND iv_date IS NOT INITIAL AND iv_time IS NOT INITIAL.
      cl_abap_tstmp=&gt;systemtstmp_syst2utc(
        EXPORTING syst_date = iv_date
                  syst_time = iv_time
        IMPORTING utc_tstmp = lv_ts ).
      IF lv_ts &lt; iv_timestamp.
        rv_changed = abap_false. &quot; Unchanged
      ELSE.
        rv_changed = abap_true.
      ENDIF.
    ELSE. &quot; Not found? =&gt; changed
      rv_changed = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.
    ms_item = is_item.
    ASSERT NOT ms_item IS INITIAL.
    mv_language = iv_language.
    ASSERT NOT mv_language IS INITIAL.
  ENDMETHOD.
  METHOD corr_insert.

    DATA: ls_object TYPE ddenqs.
    ls_object-objtype = ms_item-obj_type.
    ls_object-objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ls_object
        object_class        = &apos;DICT&apos;
        devclass            = iv_package
        master_language     = mv_language
        mode                = &apos;INSERT&apos;
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc = 1.
      zcx_abapgit_exception=&gt;raise( &apos;Cancelled&apos; ).
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD delete_longtexts.

    zcl_abapgit_longtexts=&gt;delete( iv_longtext_id = iv_longtext_id
                                   iv_object_name = ms_item-obj_name ).

  ENDMETHOD.
  METHOD deserialize_longtexts.

    zcl_abapgit_longtexts=&gt;deserialize( io_xml             = io_xml
                                        iv_master_language = mv_language ).

  ENDMETHOD.
  METHOD exists_a_lock_entry_for.

    DATA: lt_lock_entries TYPE STANDARD TABLE OF seqg3.

    CALL FUNCTION &apos;ENQUEUE_READ&apos;
      EXPORTING
        guname                = &apos;*&apos;
        garg                  = iv_argument
      TABLES
        enq                   = lt_lock_entries
      EXCEPTIONS
        communication_failure = 1
        system_failure        = 2
        OTHERS                = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    READ TABLE lt_lock_entries TRANSPORTING NO FIELDS
                               WITH KEY gobj = iv_lock_object.
    IF sy-subrc = 0.
      rv_exists_a_lock_entry = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD get_adt_objects_and_names.

    DATA lv_obj_type       TYPE trobjtype.
    DATA lv_obj_name       TYPE trobj_name.
    DATA lo_object         TYPE REF TO cl_wb_object.
    DATA lo_adt            TYPE REF TO object.
    FIELD-SYMBOLS &lt;lv_uri&gt; TYPE string.

    lv_obj_name = iv_obj_name.
    lv_obj_type = iv_obj_type.

    TRY.
        cl_wb_object=&gt;create_from_transport_key(
          EXPORTING
            p_object    = lv_obj_type
            p_obj_name  = lv_obj_name
          RECEIVING
            p_wb_object = lo_object
          EXCEPTIONS
            OTHERS      = 1 ).
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
        ENDIF.

        CALL METHOD (&apos;CL_ADT_TOOLS_CORE_FACTORY&apos;)=&gt;(&apos;GET_INSTANCE&apos;)
          RECEIVING
            result = lo_adt.

        IF is_adt_jump_possible( io_object = lo_object
                                 io_adt    = lo_adt ) = abap_false.
          zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
        ENDIF.

        CALL METHOD lo_adt-&gt;(&apos;IF_ADT_TOOLS_CORE_FACTORY~GET_URI_MAPPER&apos;)
          RECEIVING
            result = eo_adt_uri_mapper.

        CALL METHOD eo_adt_uri_mapper-&gt;(&apos;IF_ADT_URI_MAPPER~MAP_WB_OBJECT_TO_OBJREF&apos;)
          EXPORTING
            wb_object = lo_object
          RECEIVING
            result    = eo_adt_objectref.

        ASSIGN (&apos;EO_ADT_OBJECTREF-&gt;REF_DATA-URI&apos;) TO &lt;lv_uri&gt;.
        ASSERT sy-subrc = 0.

        CALL METHOD eo_adt_uri_mapper-&gt;(&apos;IF_ADT_URI_MAPPER~MAP_OBJREF_TO_INCLUDE&apos;)
          EXPORTING
            uri     = &lt;lv_uri&gt;
          IMPORTING
            program = ev_program
            include = ev_include.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD get_metadata.

    DATA: lv_class TYPE string.

    lv_class = cl_abap_classdescr=&gt;describe_by_object_ref( me )-&gt;get_relative_name( ).

    REPLACE FIRST OCCURRENCE OF &apos;ZCL_ABAPGIT&apos; IN lv_class WITH &apos;LCL&apos;.

    rs_metadata-class = lv_class.
    rs_metadata-version = &apos;v1.0.0&apos; ##no_text.

  ENDMETHOD.
  METHOD is_active.

    DATA: lt_messages    TYPE STANDARD TABLE OF sprot_u WITH DEFAULT KEY,
          lt_e071_tadirs TYPE STANDARD TABLE OF e071 WITH DEFAULT KEY,
          ls_e071_tadir  LIKE LINE OF lt_e071_tadirs.

    ms_item-inactive = abap_false.

    ls_e071_tadir-object   = ms_item-obj_type.
    ls_e071_tadir-obj_name = ms_item-obj_name.
    INSERT ls_e071_tadir INTO TABLE lt_e071_tadirs.

    CALL FUNCTION &apos;RS_INACTIVE_OBJECTS_WARNING&apos;
      EXPORTING
        suppress_protocol         = abap_false
        with_program_includes     = abap_false
        suppress_dictionary_check = abap_false
        phased_activation         = abap_false
      TABLES
        p_e071                    = lt_e071_tadirs
        p_xmsg                    = lt_messages.

    IF lt_messages IS NOT INITIAL.
      ms_item-inactive = abap_true.
    ENDIF.

    rv_active = boolc( ms_item-inactive = abap_false ).
  ENDMETHOD.
  METHOD is_adt_jump_possible.

    DATA: lo_wb_request         TYPE REF TO cl_wb_request,
          lo_adt_uri_mapper_vit TYPE REF TO object,
          lv_vit_wb_request     TYPE abap_bool.

    cl_wb_request=&gt;create_from_object_ref(
      EXPORTING
        p_wb_object       = io_object
      RECEIVING
        p_wb_request      = lo_wb_request
      EXCEPTIONS
        illegal_operation = 1
        cancelled         = 2
        OTHERS            = 3 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
    ENDIF.

    TRY.
        CALL METHOD io_adt-&gt;(&apos;IF_ADT_TOOLS_CORE_FACTORY~GET_URI_MAPPER_VIT&apos;)
          RECEIVING
            result = lo_adt_uri_mapper_vit.

        CALL METHOD lo_adt_uri_mapper_vit-&gt;(&apos;IF_ADT_URI_MAPPER_VIT~IS_VIT_WB_REQUEST&apos;)
          EXPORTING
            wb_request = lo_wb_request
          RECEIVING
            result     = lv_vit_wb_request.

        IF lv_vit_wb_request = abap_true.
          rv_is_adt_jump_possible = abap_false.
        ELSE.
          rv_is_adt_jump_possible = abap_true.
        ENDIF.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD jump_adt.

    DATA: lv_adt_link       TYPE string.
    DATA: lo_adt_uri_mapper TYPE REF TO object ##needed.
    DATA: lo_adt_objref     TYPE REF TO object ##needed.
    DATA: lo_adt_sub_objref TYPE REF TO object ##needed.
    DATA: lv_program        TYPE progname.
    DATA: lv_include        TYPE progname.
    FIELD-SYMBOLS: &lt;lv_uri&gt; TYPE string.
    get_adt_objects_and_names(
      EXPORTING
        iv_obj_name       = iv_obj_name
        iv_obj_type       = iv_obj_type
      IMPORTING
        eo_adt_uri_mapper = lo_adt_uri_mapper
        eo_adt_objectref  = lo_adt_objref
        ev_program        = lv_program
        ev_include        = lv_include ).

    TRY.
        IF iv_sub_obj_name IS NOT INITIAL.

          IF ( lv_program &lt;&gt; iv_obj_name AND lv_include IS INITIAL ) OR
             ( lv_program = lv_include AND iv_sub_obj_name IS NOT INITIAL ).
            lv_include = iv_sub_obj_name.
          ENDIF.

          CALL METHOD lo_adt_uri_mapper-&gt;(&apos;IF_ADT_URI_MAPPER~MAP_INCLUDE_TO_OBJREF&apos;)
            EXPORTING
              program     = lv_program
              include     = lv_include
              line        = iv_line_number
              line_offset = 0
              end_line    = iv_line_number
              end_offset  = 1
            RECEIVING
              result      = lo_adt_sub_objref.
          IF lo_adt_sub_objref IS NOT INITIAL.
            lo_adt_objref = lo_adt_sub_objref.
          ENDIF.

        ENDIF.

        ASSIGN (&apos;LO_ADT_OBJREF-&gt;REF_DATA-URI&apos;) TO &lt;lv_uri&gt;.
        ASSERT sy-subrc = 0.

        CONCATENATE &apos;adt://&apos; sy-sysid &lt;lv_uri&gt; INTO lv_adt_link.

        cl_gui_frontend_services=&gt;execute( EXPORTING  document = lv_adt_link
                                           EXCEPTIONS OTHERS   = 1 ).

        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
        ENDIF.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;ADT Jump Error&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD jump_se11.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.
    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPLSD_ENTRY&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;1000&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=WB_DISPLAY&apos;.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = iv_radio.
    &lt;ls_bdcdata&gt;-fval = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = iv_field.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode                 = &apos;SE11&apos;
        mode_val              = &apos;E&apos;
      TABLES
        using_tab             = lt_bdcdata
      EXCEPTIONS
        system_failure        = 1
        communication_failure = 2
        resource_failure      = 3
        OTHERS                = 4
        ##fm_subrc_ok.                                                   &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD serialize_longtexts.

    zcl_abapgit_longtexts=&gt;serialize( iv_object_name = ms_item-obj_name
                                      iv_longtext_id = iv_longtext_id
                                      it_dokil       = it_dokil
                                      io_xml         = io_xml ).

  ENDMETHOD.
  METHOD set_default_package.

    &quot; In certain cases we need to set the package package via ABAP memory
    &quot; because we can&apos;t supply it via the APIs.
    &quot;
    &quot; Set default package, see function module RS_CORR_INSERT FORM get_current_devclass.
    &quot;
    &quot; We use ABAP memory instead the SET parameter because it is
    &quot; more reliable. SET parameter doesn&apos;t work when multiple objects
    &quot; are deserialized which uses the ABAP memory mechanism.
    &quot; We don&apos;t need to reset the memory as it is done in above mentioned form routine.

    EXPORT current_devclass FROM iv_package TO MEMORY ID &apos;EUK&apos;.

  ENDMETHOD.
  METHOD tadir_insert.

    CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
      EXPORTING
        wi_test_modus       = abap_false
        wi_tadir_pgmid      = &apos;R3TR&apos;
        wi_tadir_object     = ms_item-obj_type
        wi_tadir_obj_name   = ms_item-obj_name
        wi_tadir_author     = sy-uname
        wi_tadir_devclass   = iv_package
        wi_tadir_masterlang = mv_language
        iv_delflag          = abap_false
      EXCEPTIONS
        OTHERS              = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from TR_TADIR_INTERFACE&apos; ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_SAXX_SUPER IMPLEMENTATION.
  METHOD create_channel_objects.

    get_names( ).

    TRY.
        IF mo_appl_obj_data IS NOT BOUND.
          CREATE OBJECT mo_appl_obj_data TYPE (mv_appl_obj_cls_name).
        ENDIF.

        IF mo_persistence IS NOT BOUND.
          CREATE OBJECT mo_persistence TYPE (mv_persistence_cls_name).
        ENDIF.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_type } not supported| ).
    ENDTRY.

  ENDMETHOD.
  METHOD get_data.

    DATA: lv_object_key TYPE seu_objkey.

    lv_object_key = ms_item-obj_name.

    TRY.
        mo_persistence-&gt;get(
          EXPORTING
            p_object_key  = lv_object_key
            p_version     = &apos;A&apos;
          CHANGING
            p_object_data = mo_appl_obj_data ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_type } not supported| ).
    ENDTRY.

    mo_appl_obj_data-&gt;get_data(
      IMPORTING
        p_data = eg_data ).

  ENDMETHOD.
  METHOD get_names.

    IF mv_data_structure_name IS INITIAL.
      mv_data_structure_name  = get_data_structure_name( ).
    ENDIF.

    IF mv_appl_obj_cls_name IS INITIAL.
      mv_appl_obj_cls_name    = get_data_class_name( ).
    ENDIF.

    IF mv_persistence_cls_name IS INITIAL.
      mv_persistence_cls_name = get_persistence_class_name( ).
    ENDIF.

  ENDMETHOD.
  METHOD lock.

    DATA: lv_objname    TYPE trobj_name,
          lv_object_key TYPE seu_objkey,
          lv_objtype    TYPE trobjtype.
    lv_objname    = ms_item-obj_name.
    lv_object_key = ms_item-obj_name.
    lv_objtype    = ms_item-obj_type.

    mo_persistence-&gt;lock(
      EXPORTING
        p_objname_tr   = lv_objname
        p_object_key   = lv_object_key
        p_objtype_tr   = lv_objtype
      EXCEPTIONS
        foreign_lock   = 1
        error_occurred = 2
        OTHERS         = 3 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error occured while locking { ms_item-obj_type } | &amp;&amp; lv_objname ).
    ENDIF.

  ENDMETHOD.
  METHOD unlock.

    DATA: lv_objname    TYPE trobj_name,
          lv_object_key TYPE seu_objkey,
          lv_objtype    TYPE trobjtype.

    lv_objname    = ms_item-obj_name.
    lv_object_key = ms_item-obj_name.
    lv_objtype    = ms_item-obj_type.

    mo_persistence-&gt;unlock( p_objname_tr = lv_objname
                            p_object_key = lv_object_key
                            p_objtype_tr = lv_objtype ).

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lr_data TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_data&gt;       TYPE any,
                   &lt;lg_header&gt;     TYPE any,
                   &lt;lg_changed_by&gt; TYPE any.

    create_channel_objects( ).

    TRY.
        CREATE DATA lr_data TYPE (mv_data_structure_name).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_name } not supported| ).
    ENDTRY.

    get_data(
      IMPORTING
        eg_data = &lt;lg_data&gt; ).

    ASSIGN COMPONENT &apos;HEADER&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_header&gt;.
    ASSERT sy-subrc = 0.
    ASSIGN COMPONENT &apos;CHANGED_BY&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_changed_by&gt;.
    ASSERT sy-subrc = 0.

    IF &lt;lg_changed_by&gt; IS NOT INITIAL.
      rv_user = &lt;lg_changed_by&gt;.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_object_key TYPE seu_objkey.

    create_channel_objects( ).

    lv_object_key = ms_item-obj_name.

    TRY.
        lock( ).

        mo_persistence-&gt;delete( lv_object_key ).

        unlock( ).

      CATCH cx_swb_exception.
        zcx_abapgit_exception=&gt;raise( |Error occured while deleting { ms_item-obj_type }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lr_data TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_data&gt; TYPE any.

    create_channel_objects( ).

    TRY.
        CREATE DATA lr_data TYPE (mv_data_structure_name).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_type } not supported| ).
    ENDTRY.

    io_xml-&gt;read(
      EXPORTING
        iv_name = ms_item-obj_type
      CHANGING
        cg_data = &lt;lg_data&gt; ).

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    TRY.
        lock( ).

        CALL FUNCTION &apos;RS_CORR_INSERT&apos;
          EXPORTING
            object              = ms_item-obj_name
            object_class        = ms_item-obj_type
            mode                = &apos;I&apos;
            global_lock         = abap_true
            devclass            = iv_package
            master_language     = mv_language
          EXCEPTIONS
            cancelled           = 1
            permission_failure  = 2
            unknown_objectclass = 3
            OTHERS              = 4.

        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( |Error occured while creating { ms_item-obj_type }| ).
        ENDIF.

        mo_appl_obj_data-&gt;set_data( &lt;lg_data&gt; ).

        mo_persistence-&gt;save( mo_appl_obj_data ).

        unlock( ).

      CATCH cx_swb_exception.
        zcx_abapgit_exception=&gt;raise( |Error occured while creating { ms_item-obj_type }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_object_key TYPE seu_objkey.

    create_channel_objects( ).

    lv_object_key = ms_item-obj_name.

    TRY.
        mo_persistence-&gt;get( p_object_key           = lv_object_key
                             p_version              = &apos;A&apos;
                             p_existence_check_only = abap_true  ).

      CATCH cx_swb_object_does_not_exist cx_swb_exception.
        rv_bool = abap_false.
        RETURN.
    ENDTRY.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lr_data             TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_data&gt;   TYPE any,
                   &lt;lg_header&gt; TYPE any,
                   &lt;lg_field&gt;  TYPE any.

    create_channel_objects( ).

    TRY.
        CREATE DATA lr_data TYPE (mv_data_structure_name).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_type } not supported| ).
    ENDTRY.

    get_data(
      IMPORTING
        eg_data = &lt;lg_data&gt; ).

    ASSIGN COMPONENT &apos;HEADER&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_header&gt;.
    ASSERT sy-subrc = 0.

    ASSIGN COMPONENT &apos;CHANGED_ON&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CHANGED_BY&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CHANGED_AT&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CHANGED_CLNT&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CREATED_ON&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CREATED_BY&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CREATED_AT&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    ASSIGN COMPONENT &apos;CREATED_CLNT&apos; OF STRUCTURE &lt;lg_header&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

    io_xml-&gt;add( iv_name = ms_item-obj_type
                 ig_data = &lt;lg_data&gt; ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_PROGRAM IMPLEMENTATION.
  METHOD add_tpool.

    FIELD-SYMBOLS: &lt;ls_tpool_in&gt;  LIKE LINE OF it_tpool,
                   &lt;ls_tpool_out&gt; LIKE LINE OF rt_tpool.
    LOOP AT it_tpool ASSIGNING &lt;ls_tpool_in&gt;.
      APPEND INITIAL LINE TO rt_tpool ASSIGNING &lt;ls_tpool_out&gt;.
      MOVE-CORRESPONDING &lt;ls_tpool_in&gt; TO &lt;ls_tpool_out&gt;.
      IF &lt;ls_tpool_out&gt;-id = &apos;S&apos;.
        &lt;ls_tpool_out&gt;-split = &lt;ls_tpool_out&gt;-entry.
        &lt;ls_tpool_out&gt;-entry = &lt;ls_tpool_out&gt;-entry+8.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD auto_correct_cua_adm.
    &quot; issue #1807 automatic correction of CUA interfaces saved incorrectly in the past (ADM was not saved in the XML)
    FIELD-SYMBOLS:
      &lt;ls_pfk&gt; TYPE rsmpe_pfk,
      &lt;ls_act&gt; TYPE rsmpe_act,
      &lt;ls_men&gt; TYPE rsmpe_men.

    IF cs_adm IS NOT INITIAL.
      RETURN.
    ENDIF.

    LOOP AT is_cua-act ASSIGNING &lt;ls_act&gt;.
      IF &lt;ls_act&gt;-code+6(14) IS INITIAL AND &lt;ls_act&gt;-code(6) CO &apos;0123456789&apos;.
        cs_adm-actcode = &lt;ls_act&gt;-code.
      ENDIF.
    ENDLOOP.

    LOOP AT is_cua-men ASSIGNING &lt;ls_men&gt;.
      IF &lt;ls_men&gt;-code+6(14) IS INITIAL AND &lt;ls_men&gt;-code(6) CO &apos;0123456789&apos;.
        cs_adm-mencode = &lt;ls_men&gt;-code.
      ENDIF.
    ENDLOOP.

    LOOP AT is_cua-pfk ASSIGNING &lt;ls_pfk&gt;.
      IF &lt;ls_pfk&gt;-code+6(14) IS INITIAL AND &lt;ls_pfk&gt;-code(6) CO &apos;0123456789&apos;.
        cs_adm-pfkcode = &lt;ls_pfk&gt;-code.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD check_prog_changed_since.

    DATA: lv_date    TYPE dats,
          lv_time    TYPE tims,
          lt_screens TYPE STANDARD TABLE OF d020s,
          lt_eudb    TYPE STANDARD TABLE OF eudb.

    FIELD-SYMBOLS: &lt;ls_screen&gt; LIKE LINE OF lt_screens,
                   &lt;ls_eudb&gt;   LIKE LINE OF lt_eudb.

    SELECT SINGLE udat utime FROM reposrc &quot; Program
      INTO (lv_date, lv_time)
      WHERE progname = iv_program
      AND   r3state = &apos;A&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).
    IF rv_changed = abap_true.
      RETURN.
    ENDIF.

    SELECT SINGLE udat utime FROM repotext &quot; Program text pool
      INTO (lv_date, lv_time)
      WHERE progname = iv_program
      AND   r3state = &apos;A&apos;.

    IF sy-subrc = 0. &quot; Text not found ? Assuming no changes, see #404
      rv_changed = check_timestamp(
        iv_timestamp = iv_timestamp
        iv_date      = lv_date
        iv_time      = lv_time ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDIF.

    IF iv_skip_gui = abap_true.
      RETURN.
    ENDIF.

    SELECT dgen tgen FROM d020s           &quot; Screens
      INTO CORRESPONDING FIELDS OF TABLE lt_screens
      WHERE prog = iv_program
      ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS.        &quot;#EC CI_SUBRC

    LOOP AT lt_screens ASSIGNING &lt;ls_screen&gt;.
      rv_changed = check_timestamp(
        iv_timestamp = iv_timestamp
        iv_date      = &lt;ls_screen&gt;-dgen
        iv_time      = &lt;ls_screen&gt;-tgen ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

    SELECT vdatum vzeit FROM eudb         &quot; GUI
      INTO CORRESPONDING FIELDS OF TABLE lt_eudb
      WHERE relid = &apos;CU&apos;
      AND   name  = iv_program
      AND   srtf2 = 0
      ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS.        &quot;#EC CI_SUBRC

    LOOP AT lt_eudb ASSIGNING &lt;ls_eudb&gt;.
      rv_changed = check_timestamp(
        iv_timestamp = iv_timestamp
        iv_date      = &lt;ls_eudb&gt;-vdatum
        iv_time      = &lt;ls_eudb&gt;-vzeit ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD condense_flow.

    DATA: lv_spaces LIKE LINE OF et_spaces.

    FIELD-SYMBOLS: &lt;ls_flow&gt; LIKE LINE OF ct_flow.
    CLEAR et_spaces.

    LOOP AT ct_flow ASSIGNING &lt;ls_flow&gt;.
      lv_spaces = 0.

      WHILE NOT &lt;ls_flow&gt;-line IS INITIAL AND &lt;ls_flow&gt;-line(1) = space.
        lv_spaces = lv_spaces + 1.
        &lt;ls_flow&gt;-line = &lt;ls_flow&gt;-line+1.
      ENDWHILE.

      APPEND lv_spaces TO et_spaces.
    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_cua.

    DATA: ls_tr_key TYPE trkey,
          ls_adm    TYPE rsmpe_adm.
    IF lines( is_cua-sta ) = 0
        AND lines( is_cua-fun ) = 0
        AND lines( is_cua-men ) = 0
        AND lines( is_cua-mtx ) = 0
        AND lines( is_cua-act ) = 0
        AND lines( is_cua-but ) = 0
        AND lines( is_cua-pfk ) = 0
        AND lines( is_cua-set ) = 0
        AND lines( is_cua-doc ) = 0
        AND lines( is_cua-tit ) = 0
        AND lines( is_cua-biv ) = 0.
      RETURN.
    ENDIF.

    SELECT SINGLE devclass INTO ls_tr_key-devclass
      FROM tadir
      WHERE pgmid = &apos;R3TR&apos;
      AND object = ms_item-obj_type
      AND obj_name = ms_item-obj_name.                  &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;not found in tadir&apos; ).
    ENDIF.

    ls_tr_key-obj_type = ms_item-obj_type.
    ls_tr_key-obj_name = ms_item-obj_name.
    ls_tr_key-sub_type = &apos;CUAD&apos;.
    ls_tr_key-sub_name = iv_program_name.
    ls_adm = is_cua-adm.
    auto_correct_cua_adm( EXPORTING is_cua = is_cua CHANGING cs_adm = ls_adm ).

    sy-tcode = &apos;SE41&apos; ##write_ok. &quot; evil hack, workaround to handle fixes in note 2159455
    CALL FUNCTION &apos;RS_CUA_INTERNAL_WRITE&apos;
      EXPORTING
        program   = iv_program_name
        language  = mv_language
        tr_key    = ls_tr_key
        adm       = ls_adm
        state     = &apos;I&apos;
      TABLES
        sta       = is_cua-sta
        fun       = is_cua-fun
        men       = is_cua-men
        mtx       = is_cua-mtx
        act       = is_cua-act
        but       = is_cua-but
        pfk       = is_cua-pfk
        set       = is_cua-set
        doc       = is_cua-doc
        tit       = is_cua-tit
        biv       = is_cua-biv
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
* if moving code from SAPlink, see https://github.com/larshp/abapGit/issues/562
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CUA_INTERNAL_WRITE&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add(
      iv_type = &apos;CUAD&apos;
      iv_name = iv_program_name ).

  ENDMETHOD.
  METHOD deserialize_dynpros.

    DATA: lv_name   TYPE dwinactiv-obj_name,
          ls_dynpro LIKE LINE OF it_dynpros.
* ls_dynpro is changed by the function module, a field-symbol will cause
* the program to dump since it_dynpros cannot be changed
    LOOP AT it_dynpros INTO ls_dynpro.

      ls_dynpro-flow_logic = uncondense_flow(
        it_flow = ls_dynpro-flow_logic
        it_spaces = ls_dynpro-spaces ).

      CALL FUNCTION &apos;RPY_DYNPRO_INSERT&apos;
        EXPORTING
          header                 = ls_dynpro-header
          suppress_exist_checks  = abap_true
        TABLES
          containers             = ls_dynpro-containers
          fields_to_containers   = ls_dynpro-fields
          flow_logic             = ls_dynpro-flow_logic
        EXCEPTIONS
          cancelled              = 1
          already_exists         = 2
          program_not_exists     = 3
          not_executed           = 4
          missing_required_field = 5
          illegal_field_value    = 6
          field_not_allowed      = 7
          not_generated          = 8
          illegal_field_position = 9
          OTHERS                 = 10.
      IF sy-subrc &lt;&gt; 2 AND sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |error from RPY_DYNPRO_INSERT: { sy-subrc }| ).
      ENDIF.
* todo, RPY_DYNPRO_UPDATE?

      CONCATENATE ls_dynpro-header-program ls_dynpro-header-screen
        INTO lv_name RESPECTING BLANKS.
      ASSERT NOT lv_name IS INITIAL.

      zcl_abapgit_objects_activation=&gt;add(
        iv_type = &apos;DYNP&apos;
        iv_name = lv_name ).

    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_program.

    DATA: lv_exists      TYPE sap_bool,
          lv_progname    TYPE reposrc-progname,
          ls_tpool       LIKE LINE OF it_tpool,
          lv_title       TYPE rglif-title,
          ls_progdir_new TYPE progdir.

    FIELD-SYMBOLS: &lt;lg_any&gt; TYPE any.
    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = is_progdir-name
        object_class        = &apos;ABAP&apos;
        devclass            = iv_package
        master_language     = mv_language
        mode                = &apos;INSERT&apos;
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc = 1.
      zcx_abapgit_exception=&gt;raise( &apos;Cancelled&apos; ).
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT&apos; ).
    ENDIF.

    READ TABLE it_tpool INTO ls_tpool WITH KEY id = &apos;R&apos;.  &quot;#EC CI_SUBRC
    IF sy-subrc = 0.
* there is a bug in RPY_PROGRAM_UPDATE, the header line of TTAB is not
* cleared, so the title length might be inherited from a different program.
      ASSIGN (&apos;(SAPLSIFP)TTAB&apos;) TO &lt;lg_any&gt;.
      IF sy-subrc = 0.
        CLEAR &lt;lg_any&gt;.
      ENDIF.

      lv_title = ls_tpool-entry.
    ENDIF.

    SELECT SINGLE progname FROM reposrc INTO lv_progname
      WHERE progname = is_progdir-name
      AND r3state = &apos;A&apos;.
    IF sy-subrc = 0.
      lv_exists = abap_true.
    ELSE.
      lv_exists = abap_false.
    ENDIF.

    IF lv_exists = abap_true.
      zcl_abapgit_language=&gt;set_current_language( mv_language ).

      CALL FUNCTION &apos;RPY_PROGRAM_UPDATE&apos;
        EXPORTING
          program_name     = is_progdir-name
          title_string     = lv_title
          save_inactive    = &apos;I&apos;
        TABLES
          source_extended  = it_source
        EXCEPTIONS
          cancelled        = 1
          permission_error = 2
          not_found        = 3
          OTHERS           = 4.

      IF sy-subrc &lt;&gt; 0.
        zcl_abapgit_language=&gt;restore_login_language( ).

        IF sy-msgid = &apos;EU&apos; AND sy-msgno = &apos;510&apos;.
          zcx_abapgit_exception=&gt;raise( &apos;User is currently editing program&apos; ).
        ELSE.
          zcx_abapgit_exception=&gt;raise( &apos;PROG, error updating&apos; ).
        ENDIF.
      ENDIF.

      zcl_abapgit_language=&gt;restore_login_language( ).
    ELSEIF strlen( is_progdir-name ) &gt; 30.
* function module RPY_PROGRAM_INSERT cannot handle function group includes

      &quot; special treatment for extensions
      &quot; if the program name exceeds 30 characters it is not a usual
      &quot; ABAP program but might be some extension, which requires the internal
      &quot; addition EXTENSION TYPE, see
      &quot; http://help.sap.com/abapdocu_751/en/abapinsert_report_internal.htm#!ABAP_ADDITION_1@1@
      &quot; This e.g. occurs in case of transportable Code Inspector variants (ending with ===VC)
      INSERT REPORT is_progdir-name
       FROM it_source
       STATE &apos;I&apos;
       EXTENSION TYPE is_progdir-name+30.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from INSERT REPORT .. EXTENSION TYPE&apos; ).
      ENDIF.
    ELSE.
      INSERT REPORT is_progdir-name
        FROM it_source
        STATE &apos;I&apos;
        PROGRAM TYPE is_progdir-subc.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from INSERT REPORT&apos; ).
      ENDIF.
    ENDIF.

    IF NOT it_tpool[] IS INITIAL.
      INSERT TEXTPOOL is_progdir-name
        FROM it_tpool
        LANGUAGE mv_language
        STATE &apos;I&apos;.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from INSERT TEXTPOOL&apos; ).
      ENDIF.
    ENDIF.

    CALL FUNCTION &apos;READ_PROGDIR&apos;
      EXPORTING
        i_progname = is_progdir-name
        i_state    = &apos;I&apos;
      IMPORTING
        e_progdir  = ls_progdir_new
      EXCEPTIONS
        not_exists = 1
        OTHERS     = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;not found in PROGDIR&apos; ).
    ENDIF.

* todo, package?

    ls_progdir_new-ldbname = is_progdir-ldbname.
    ls_progdir_new-dbna    = is_progdir-dbna.
    ls_progdir_new-dbapl   = is_progdir-dbapl.
    ls_progdir_new-rload   = is_progdir-rload.
    ls_progdir_new-fixpt   = is_progdir-fixpt.
    ls_progdir_new-varcl   = is_progdir-varcl.
    ls_progdir_new-appl    = is_progdir-appl.
    ls_progdir_new-rstat   = is_progdir-rstat.

    CALL FUNCTION &apos;UPDATE_PROGDIR&apos;
      EXPORTING
        i_progdir    = ls_progdir_new
        i_progname   = ls_progdir_new-name
        i_state      = ls_progdir_new-state
      EXCEPTIONS
        not_executed = 1
        OTHERS       = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;PROG, error inserting&apos; ).
    ENDIF.

    SELECT SINGLE * FROM progdir INTO ls_progdir_new
      WHERE name = ls_progdir_new-name
      AND state = ls_progdir_new-state.
    IF sy-subrc = 0 AND is_progdir-varcl = space AND ls_progdir_new-varcl = abap_true.
* function module UPDATE_PROGDIR does not update VARCL
      UPDATE progdir SET varcl = is_progdir-varcl
        WHERE name = ls_progdir_new-name
        AND state = ls_progdir_new-state.                 &quot;#EC CI_SUBRC
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add(
      iv_type = &apos;REPS&apos;
      iv_name = is_progdir-name ).

  ENDMETHOD.
  METHOD deserialize_textpool.

    DATA lv_language TYPE langu.
    DATA lv_state    TYPE c.
    DATA lv_delete   TYPE abap_bool.

    IF iv_language IS INITIAL.
      lv_language = mv_language.
    ELSE.
      lv_language = iv_language.
    ENDIF.

    IF lv_language = mv_language.
      lv_state = &apos;I&apos;. &quot;Textpool in master language needs to be activated
    ELSE.
      lv_state = &apos;A&apos;. &quot;Translations are always active
    ENDIF.

    IF it_tpool IS INITIAL.
      IF iv_is_include = abap_false OR lv_state = &apos;A&apos;.
        DELETE TEXTPOOL iv_program &quot;Remove initial description from textpool if
          LANGUAGE iv_program      &quot;original program does not have a textpool
          STATE lv_state.

        lv_delete = abap_true.
      ELSE.
        INSERT TEXTPOOL iv_program &quot;In case of includes: Deletion of textpool in
          FROM it_tpool            &quot;master language cannot be activated because
          LANGUAGE lv_language     &quot;this woul activate the deletion of the textpool
          STATE lv_state.          &quot;of the mail program -&gt; insert empty textpool
      ENDIF.
    ELSE.
      IF lines( it_tpool ) = 1 AND lv_language = mv_language.
        READ TABLE it_tpool WITH KEY id = &apos;R&apos; TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          RETURN. &quot;No action because description in master language is already there
        ENDIF.
      ENDIF.

      INSERT TEXTPOOL iv_program
        FROM it_tpool
        LANGUAGE lv_language
        STATE lv_state.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from INSERT TEXTPOOL&apos; ).
      ENDIF.
    ENDIF.

    IF lv_state = &apos;I&apos;. &quot;Textpool in master language needs to be activated
      zcl_abapgit_objects_activation=&gt;add(
        iv_type   = &apos;REPT&apos;
        iv_name   = iv_program
        iv_delete = lv_delete ).
    ENDIF.
  ENDMETHOD.
  METHOD is_any_dynpro_locked.

    DATA: lt_dynpros TYPE zcl_abapgit_objects_program=&gt;ty_dynpro_tt,
          lv_object  TYPE seqg3-garg.

    FIELD-SYMBOLS: &lt;ls_dynpro&gt; TYPE zcl_abapgit_objects_program=&gt;ty_dynpro.

    lt_dynpros = serialize_dynpros( iv_program ).

    LOOP AT lt_dynpros ASSIGNING &lt;ls_dynpro&gt;.

      lv_object = |{ &lt;ls_dynpro&gt;-header-screen }{ &lt;ls_dynpro&gt;-header-program }|.

      IF exists_a_lock_entry_for( iv_lock_object = &apos;ESCRP&apos;
                                  iv_argument    = lv_object ) = abap_true.
        rv_is_any_dynpro_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD is_cua_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |CU{ iv_program }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_cua_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESCUAPAINT&apos;
                                                iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD is_text_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |*{ iv_program }|.

    rv_is_text_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EABAPTEXTE&apos;
                                                 iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD read_progdir.

    DATA: ls_sapdir TYPE progdir.
    CALL FUNCTION &apos;READ_PROGDIR&apos;
      EXPORTING
        i_progname = iv_program
        i_state    = &apos;A&apos;
      IMPORTING
        e_progdir  = ls_sapdir.
    MOVE-CORRESPONDING ls_sapdir TO rs_progdir.

    CLEAR: rs_progdir-edtx,
           rs_progdir-cnam,
           rs_progdir-cdat,
           rs_progdir-unam,
           rs_progdir-udat,
           rs_progdir-levl,
           rs_progdir-vern,
           rs_progdir-rmand,
           rs_progdir-sdate,
           rs_progdir-stime,
           rs_progdir-idate,
           rs_progdir-itime.

  ENDMETHOD.
  METHOD read_tpool.

    FIELD-SYMBOLS: &lt;ls_tpool_in&gt;  LIKE LINE OF it_tpool,
                   &lt;ls_tpool_out&gt; LIKE LINE OF rt_tpool.
    LOOP AT it_tpool ASSIGNING &lt;ls_tpool_in&gt;.
      APPEND INITIAL LINE TO rt_tpool ASSIGNING &lt;ls_tpool_out&gt;.
      MOVE-CORRESPONDING &lt;ls_tpool_in&gt; TO &lt;ls_tpool_out&gt;.
      IF &lt;ls_tpool_out&gt;-id = &apos;S&apos;.
        CONCATENATE &lt;ls_tpool_in&gt;-split &lt;ls_tpool_in&gt;-entry
          INTO &lt;ls_tpool_out&gt;-entry
          RESPECTING BLANKS.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_cua.

    CALL FUNCTION &apos;RS_CUA_INTERNAL_FETCH&apos;
      EXPORTING
        program         = iv_program_name
        language        = mv_language
        state           = &apos;A&apos;
      IMPORTING
        adm             = rs_cua-adm
      TABLES
        sta             = rs_cua-sta
        fun             = rs_cua-fun
        men             = rs_cua-men
        mtx             = rs_cua-mtx
        act             = rs_cua-act
        but             = rs_cua-but
        pfk             = rs_cua-pfk
        set             = rs_cua-set
        doc             = rs_cua-doc
        tit             = rs_cua-tit
        biv             = rs_cua-biv
      EXCEPTIONS
        not_found       = 1
        unknown_version = 2
        OTHERS          = 3.
    IF sy-subrc &gt; 1.
      zcx_abapgit_exception=&gt;raise( |error from RS_CUA_INTERNAL_FETCH, { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD serialize_dynpros.

    DATA: ls_header               TYPE rpy_dyhead,
          lt_containers           TYPE dycatt_tab,
          lt_fields_to_containers TYPE dyfatc_tab,
          lt_flow_logic           TYPE swydyflow,
          lt_d020s                TYPE TABLE OF d020s.

    FIELD-SYMBOLS: &lt;ls_d020s&gt;       LIKE LINE OF lt_d020s,
                   &lt;lv_outputstyle&gt; TYPE scrpostyle,
                   &lt;ls_container&gt;   LIKE LINE OF lt_containers,
                   &lt;ls_field&gt;       LIKE LINE OF lt_fields_to_containers,
                   &lt;ls_dynpro&gt;      LIKE LINE OF rt_dynpro.
    CALL FUNCTION &apos;RS_SCREEN_LIST&apos;
      EXPORTING
        dynnr     = &apos;&apos;
        progname  = iv_program_name
      TABLES
        dynpros   = lt_d020s
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc = 2.
      zcx_abapgit_exception=&gt;raise( &apos;error from screen_list&apos; ).
    ENDIF.

    SORT lt_d020s BY dnum ASCENDING.

* loop dynpros and skip generated selection screens
    LOOP AT lt_d020s ASSIGNING &lt;ls_d020s&gt;
        WHERE type &lt;&gt; &apos;S&apos; AND type &lt;&gt; &apos;W&apos; AND type &lt;&gt; &apos;J&apos;
        AND NOT dnum IS INITIAL.

      CALL FUNCTION &apos;RPY_DYNPRO_READ&apos;
        EXPORTING
          progname             = iv_program_name
          dynnr                = &lt;ls_d020s&gt;-dnum
        IMPORTING
          header               = ls_header
        TABLES
          containers           = lt_containers
          fields_to_containers = lt_fields_to_containers
          flow_logic           = lt_flow_logic
        EXCEPTIONS
          cancelled            = 1
          not_found            = 2
          permission_error     = 3
          OTHERS               = 4.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Error while reading dynpro: { sy-subrc }| ).
      ENDIF.

      LOOP AT lt_fields_to_containers ASSIGNING &lt;ls_field&gt;.
* output style is a NUMC field, the XML conversion will fail if it contains invalid value
* field does not exist in all versions
        ASSIGN COMPONENT &apos;OUTPUTSTYLE&apos; OF STRUCTURE &lt;ls_field&gt; TO &lt;lv_outputstyle&gt;.
        IF sy-subrc = 0 AND &lt;lv_outputstyle&gt; = &apos;  &apos;.
          CLEAR &lt;lv_outputstyle&gt;.
        ENDIF.
      ENDLOOP.

      LOOP AT lt_containers ASSIGNING &lt;ls_container&gt;.
        IF &lt;ls_container&gt;-c_resize_v = abap_false.
          CLEAR &lt;ls_container&gt;-c_line_min.
        ENDIF.
        IF &lt;ls_container&gt;-c_resize_h = abap_false.
          CLEAR &lt;ls_container&gt;-c_coln_min.
        ENDIF.
      ENDLOOP.

      APPEND INITIAL LINE TO rt_dynpro ASSIGNING &lt;ls_dynpro&gt;.
      &lt;ls_dynpro&gt;-header     = ls_header.
      &lt;ls_dynpro&gt;-containers = lt_containers.
      &lt;ls_dynpro&gt;-fields     = lt_fields_to_containers.

      condense_flow( IMPORTING et_spaces = &lt;ls_dynpro&gt;-spaces
                     CHANGING ct_flow = lt_flow_logic ).
      &lt;ls_dynpro&gt;-flow_logic = lt_flow_logic.

    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_program.

    DATA: ls_progdir      TYPE ty_progdir,
          lv_program_name TYPE programm,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua,
          lt_source       TYPE TABLE OF abaptxt255,
          lt_tpool        TYPE textpool_table,
          ls_tpool        LIKE LINE OF lt_tpool,
          lo_xml          TYPE REF TO zcl_abapgit_xml_output.

    IF iv_program IS INITIAL.
      lv_program_name = is_item-obj_name.
    ELSE.
      lv_program_name = iv_program.
    ENDIF.

    zcl_abapgit_language=&gt;set_current_language( mv_language ).

    CALL FUNCTION &apos;RPY_PROGRAM_READ&apos;
      EXPORTING
        program_name     = lv_program_name
        with_lowercase   = abap_true
      TABLES
        source_extended  = lt_source
        textelements     = lt_tpool
      EXCEPTIONS
        cancelled        = 1
        not_found        = 2
        permission_error = 3
        OTHERS           = 4.

    IF sy-subrc = 2.
      zcl_abapgit_language=&gt;restore_login_language( ).
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcl_abapgit_language=&gt;restore_login_language( ).
      zcx_abapgit_exception=&gt;raise( &apos;Error reading program&apos; ).
    ENDIF.

    zcl_abapgit_language=&gt;restore_login_language( ).

    ls_progdir = read_progdir( lv_program_name ).

    IF io_xml IS BOUND.
      lo_xml = io_xml.
    ELSE.
      CREATE OBJECT lo_xml.
    ENDIF.

    lo_xml-&gt;add( iv_name = &apos;PROGDIR&apos;
                 ig_data = ls_progdir ).
    IF ls_progdir-subc = &apos;1&apos; OR ls_progdir-subc = &apos;M&apos;.
      lt_dynpros = serialize_dynpros( lv_program_name ).
      lo_xml-&gt;add( iv_name = &apos;DYNPROS&apos;
                   ig_data = lt_dynpros ).

      ls_cua = serialize_cua( lv_program_name ).
      IF NOT ls_cua IS INITIAL.
        lo_xml-&gt;add( iv_name = &apos;CUA&apos;
                     ig_data = ls_cua ).
      ENDIF.
    ENDIF.

    READ TABLE lt_tpool WITH KEY id = &apos;R&apos; INTO ls_tpool.
    IF sy-subrc = 0 AND ls_tpool-key = &apos;&apos; AND ls_tpool-length = 0.
      DELETE lt_tpool INDEX sy-tabix.
    ENDIF.

    lo_xml-&gt;add( iv_name = &apos;TPOOL&apos;
                 ig_data = add_tpool( lt_tpool ) ).

    IF NOT io_xml IS BOUND.
      io_files-&gt;add_xml( iv_extra = iv_extra
                         io_xml   = lo_xml ).
    ENDIF.

    io_files-&gt;add_abap( iv_extra = iv_extra
                        it_abap  = lt_source ).

  ENDMETHOD.
  METHOD uncondense_flow.

    DATA: lv_spaces LIKE LINE OF it_spaces.

    FIELD-SYMBOLS: &lt;ls_flow&gt;   LIKE LINE OF it_flow,
                   &lt;ls_output&gt; LIKE LINE OF rt_flow.
    LOOP AT it_flow ASSIGNING &lt;ls_flow&gt;.
      APPEND INITIAL LINE TO rt_flow ASSIGNING &lt;ls_output&gt;.
      &lt;ls_output&gt;-line = &lt;ls_flow&gt;-line.

      READ TABLE it_spaces INDEX sy-tabix INTO lv_spaces.
      IF sy-subrc = 0.
        SHIFT &lt;ls_output&gt;-line RIGHT BY lv_spaces PLACES IN CHARACTER MODE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_GENERIC IMPLEMENTATION.
  METHOD after_import.

    DATA: lt_cts_object_entry TYPE STANDARD TABLE OF e071 WITH DEFAULT KEY,
          ls_cts_object_entry LIKE LINE OF lt_cts_object_entry,
          lt_cts_key          TYPE STANDARD TABLE OF e071k WITH DEFAULT KEY.

    FIELD-SYMBOLS &lt;ls_object_method&gt; LIKE LINE OF mt_object_method.
    ls_cts_object_entry-pgmid    = seok_pgmid_r3tr.
    ls_cts_object_entry-object   = ms_item-obj_type.
    ls_cts_object_entry-obj_name = ms_item-obj_name.
    INSERT ls_cts_object_entry INTO TABLE lt_cts_object_entry.

    READ TABLE mt_object_method ASSIGNING &lt;ls_object_method&gt;
      WITH KEY
        objectname = ms_item-obj_type
        objecttype = &apos;L&apos;
        method = &apos;AFTER_IMP&apos;.
    IF sy-subrc = 0.
* client is actually optional for most AIM, but let&apos;s supply it and hope
* that those client-independent-ones just ignore it
      CALL FUNCTION &lt;ls_object_method&gt;-methodname
        EXPORTING
          iv_tarclient  = sy-mandt
          iv_is_upgrade = abap_false
        TABLES
          tt_e071       = lt_cts_object_entry
          tt_e071k      = lt_cts_key.
    ENDIF.

  ENDMETHOD.
  METHOD before_export.

    DATA: lt_cts_object_entry TYPE STANDARD TABLE OF e071 WITH DEFAULT KEY,
          ls_cts_object_entry LIKE LINE OF lt_cts_object_entry,
          lt_cts_key          TYPE STANDARD TABLE OF e071k WITH DEFAULT KEY,
          lv_client           TYPE trclient.

    FIELD-SYMBOLS &lt;ls_object_method&gt; LIKE LINE OF mt_object_method.
    READ TABLE mt_object_method ASSIGNING &lt;ls_object_method&gt;
      WITH KEY
        objectname = ms_item-obj_type
        objecttype = &apos;L&apos;
        method     = &apos;BEFORE_EXP&apos; ##no_text.
    IF sy-subrc = 0.
      lv_client = sy-mandt.

      ls_cts_object_entry-pgmid    = seok_pgmid_r3tr.
      ls_cts_object_entry-object   = ms_item-obj_type.
      ls_cts_object_entry-obj_name = ms_item-obj_name.
      INSERT ls_cts_object_entry INTO TABLE lt_cts_object_entry.

      CALL FUNCTION &lt;ls_object_method&gt;-methodname
        EXPORTING
          iv_client = lv_client
        TABLES
          tt_e071   = lt_cts_object_entry
          tt_e071k  = lt_cts_key.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    CONSTANTS lc_logical_transport_object TYPE c LENGTH 1 VALUE &apos;L&apos;.
    SELECT SINGLE * FROM objh INTO ms_object_header
      WHERE objectname = is_item-obj_type
      AND objecttype = lc_logical_transport_object.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Not found in OBJH, or not supported&apos; ).
    ENDIF.

* object tables
    SELECT * FROM objsl INTO CORRESPONDING FIELDS OF TABLE mt_object_table
      WHERE objectname = is_item-obj_type
      AND objecttype = lc_logical_transport_object
      AND tobject = &apos;TABU&apos;.
    IF mt_object_table IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |Obviously corrupted object-type {
        is_item-obj_type }: No tables defined| ).
    ENDIF.

* object methods
    SELECT * FROM objm INTO TABLE mt_object_method
      WHERE objectname = is_item-obj_type
      AND   objecttype = lc_logical_transport_object.

    ms_item = is_item.

  ENDMETHOD.
  METHOD corr_insert.

* this will also insert into TADIR
    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = ms_item-obj_type
        mode                = &apos;I&apos;
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = sy-langu
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT, CMPT&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD delete.

    DATA: lv_where   TYPE string,
          lv_primary TYPE objsl-tobj_name.

    FIELD-SYMBOLS &lt;ls_table&gt; LIKE LINE OF mt_object_table.
    lv_primary = get_primary_table( ).

    LOOP AT mt_object_table ASSIGNING &lt;ls_table&gt;.
      lv_where = get_where_clause( &lt;ls_table&gt;-tobj_name ).
      ASSERT NOT lv_where IS INITIAL.

      DELETE FROM (&lt;ls_table&gt;-tobj_name) WHERE (lv_where).

      IF &lt;ls_table&gt;-tobj_name = lv_primary.
        ASSERT sy-dbcnt &lt;= 1. &quot;Just to be on the very safe side
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize.

    validate( io_xml ).

    delete( ).

    deserialize_data( io_xml ).

    after_import( ).

    corr_insert( iv_package ).

  ENDMETHOD.
  METHOD deserialize_data.

    DATA: lr_ref TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lt_data&gt;  TYPE STANDARD TABLE,
                   &lt;ls_table&gt; LIKE LINE OF mt_object_table.
    LOOP AT mt_object_table ASSIGNING &lt;ls_table&gt;.

      CREATE DATA lr_ref TYPE STANDARD TABLE OF (&lt;ls_table&gt;-tobj_name).
      ASSIGN lr_ref-&gt;* TO &lt;lt_data&gt;.

      io_xml-&gt;read(
        EXPORTING
          iv_name = &lt;ls_table&gt;-tobj_name
        CHANGING
          cg_data = &lt;lt_data&gt; ).

      INSERT (&lt;ls_table&gt;-tobj_name) FROM TABLE &lt;lt_data&gt;.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Error inserting data, {
          &lt;ls_table&gt;-tobj_name }| ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD distribute_name_to_components.

    DATA: lt_key_component_uncovered  LIKE it_key_component,
          ls_key_component_uncovered  LIKE LINE OF lt_key_component_uncovered,
          ls_objkey_sub               LIKE cs_objkey,
          lv_objkey_sub_pos           TYPE i,
          lv_remaining_length         TYPE i,
          lv_count_components_covered LIKE ls_objkey_sub-num.

    DATA lv_len LIKE ls_key_component_uncovered-leng.
    lt_key_component_uncovered = it_key_component.
    ls_objkey_sub-num = cs_objkey-num.
    lv_objkey_sub_pos = 0.

*    we want to fill the atribute values which are not covered by explicit key components yet
    lv_count_components_covered = ls_objkey_sub-num - 1.
    DO lv_count_components_covered TIMES.
      DELETE lt_key_component_uncovered INDEX 1.
    ENDDO.

    LOOP AT lt_key_component_uncovered INTO ls_key_component_uncovered.
      CLEAR ls_objkey_sub-value.

*      Some datatype used in the key might exceed the total remaining characters length (e. g. SICF)
      TRY.
          lv_remaining_length = strlen( |{ substring( val = cs_objkey-value off = lv_objkey_sub_pos ) }| ).
        CATCH cx_sy_range_out_of_bounds.
          lv_remaining_length = 0.
          RETURN. &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
      ENDTRY.
      IF ls_key_component_uncovered-leng &lt;= lv_remaining_length.
        lv_len = ls_key_component_uncovered-leng.
      ELSE.
        lv_len = lv_remaining_length.
      ENDIF.

      ls_objkey_sub-value = |{ substring( val = cs_objkey-value off = lv_objkey_sub_pos len = lv_len ) }|.
      ls_objkey_sub-num = cv_non_value_pos.

      INSERT ls_objkey_sub INTO TABLE ct_objkey.

      lv_objkey_sub_pos = lv_objkey_sub_pos + ls_key_component_uncovered-leng.
      cv_non_value_pos = cv_non_value_pos + 1.
      CLEAR ls_objkey_sub.

      IF lv_objkey_sub_pos = strlen( cs_objkey-value ).
        cs_objkey-num = cv_non_value_pos.
        EXIT. &quot;end splitting - all characters captured
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD exists.

    DATA: lv_where_clause TYPE string,
          lv_primary      TYPE objsl-tobj_name,
          lr_table_line   TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_table_line&gt; TYPE any.
    lv_primary = get_primary_table( ).

    lv_where_clause = get_where_clause( lv_primary ).

    CREATE DATA lr_table_line TYPE (lv_primary).
    ASSIGN lr_table_line-&gt;* TO &lt;lg_table_line&gt;.

    SELECT SINGLE * FROM (lv_primary) INTO &lt;lg_table_line&gt; WHERE (lv_where_clause).
    rv_bool = boolc( sy-dbcnt &gt; 0 ).

  ENDMETHOD.
  METHOD get_key_fields.

    DATA: lv_table TYPE ddobjname.
    lv_table = iv_table.

    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname   = lv_table
      TABLES
        dfies_tab = rt_keys
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    DELETE rt_keys WHERE keyflag = abap_false.

  ENDMETHOD.
  METHOD get_primary_table.

    DATA: ls_object_table LIKE LINE OF mt_object_table.
    READ TABLE mt_object_table INTO ls_object_table WITH KEY prim_table = abap_true.
    IF sy-subrc &lt;&gt; 0.
*    Fallback. For some objects, no primary table is explicitly flagged
*    The, the one with only one key field shall be chosen
      READ TABLE mt_object_table INTO ls_object_table WITH KEY tobjkey = &apos;/&amp;&apos;. &quot;#EC CI_SUBRC
    ENDIF.
    IF ls_object_table IS INITIAL.
      zcx_abapgit_exception=&gt;raise( |Object { ms_item-obj_type } has got no defined primary table| ).
    ENDIF.

    rv_table = ls_object_table-tobj_name.

  ENDMETHOD.
  METHOD get_where_clause.

    DATA: lv_objkey_pos      TYPE i,
          lv_next_objkey_pos TYPE i,
          lv_value_pos       TYPE i,
          lv_objkey_length   TYPE i,
          lt_objkey          TYPE ty_t_objkey,
          ls_objkey          LIKE LINE OF lt_objkey,
          lv_non_value_pos   TYPE numc3,
          lt_key_fields      TYPE ddfields.

    DATA: lv_is_asterix      TYPE abap_bool,
          lv_where_statement TYPE string,
          lv_key_pos         TYPE i,
          lv_value128        TYPE string.

    FIELD-SYMBOLS &lt;ls_object_table&gt; LIKE LINE OF mt_object_table.

    FIELD-SYMBOLS &lt;ls_table_field&gt; LIKE LINE OF lt_key_fields.
    READ TABLE mt_object_table ASSIGNING &lt;ls_object_table&gt; WITH KEY tobj_name = iv_tobj_name.
    ASSERT sy-subrc = 0.

    lt_key_fields = get_key_fields( iv_tobj_name ).

*   analyze the object key and compose the key (table)
    CLEAR lt_objkey.
    CLEAR ls_objkey.
    lv_objkey_pos = 0.
    lv_non_value_pos = 1.
    lv_value_pos = 0.
    lv_objkey_length = strlen( &lt;ls_object_table&gt;-tobjkey ).

    WHILE lv_objkey_pos &lt;= lv_objkey_length.
      ls_objkey-num = lv_non_value_pos.
*     command
      IF &lt;ls_object_table&gt;-tobjkey+lv_objkey_pos(1) = &apos;/&apos;.
        IF NOT ls_objkey-value IS INITIAL.
*        We reached the end of a key-definition.
*        this key part may address multiple fields.
*        E. g. six characters may address one boolean field and a five-digit version field.
*        Thus, we need to analyze the remaining key components which have not been covered yet.
          split_value_to_keys(
            EXPORTING
              it_key_component = lt_key_fields
            CHANGING
              ct_objkey        = lt_objkey
              cs_objkey        = ls_objkey
              cv_non_value_pos = lv_non_value_pos ).
        ENDIF.
        lv_next_objkey_pos = lv_objkey_pos + 1.
*       &apos;*&apos; means all further key values
        IF &lt;ls_object_table&gt;-tobjkey+lv_next_objkey_pos(1) = &apos;*&apos;.
          ls_objkey-value = &apos;*&apos;.
          INSERT ls_objkey INTO TABLE lt_objkey.
          CLEAR ls_objkey.
          lv_non_value_pos = lv_non_value_pos + 1.
          lv_objkey_pos = lv_objkey_pos + 1.
*       object name
        ELSEIF &lt;ls_object_table&gt;-tobjkey+lv_next_objkey_pos(1) = &apos;&amp;&apos;.
          &quot;TODO
          ls_objkey-value = ms_item-obj_name.
*    The object name might comprise multiple key components (e. g. WDCC)
*    This string needs to be split
          distribute_name_to_components(
            EXPORTING
              it_key_component = lt_key_fields
            CHANGING
              ct_objkey        = lt_objkey
              cs_objkey        = ls_objkey
              cv_non_value_pos = lv_non_value_pos ).
          CLEAR ls_objkey.
          lv_objkey_pos = lv_objkey_pos + 1.
*       language
        ELSEIF &lt;ls_object_table&gt;-tobjkey+lv_next_objkey_pos(1) = &apos;L&apos;.
          ls_objkey-value = sy-langu.
          INSERT ls_objkey INTO TABLE lt_objkey.
          CLEAR ls_objkey.
          lv_non_value_pos = lv_non_value_pos + 1.
          lv_objkey_pos = lv_objkey_pos + 1.
*       Client
        ELSEIF &lt;ls_object_table&gt;-tobjkey+lv_next_objkey_pos(1) = &apos;C&apos;.
          ls_objkey-value = sy-mandt.
          INSERT ls_objkey INTO TABLE lt_objkey.
          CLEAR ls_objkey.
          lv_non_value_pos = lv_non_value_pos + 1.
          lv_objkey_pos = lv_objkey_pos + 1.
        ENDIF.
        lv_value_pos = 0.
*     value
      ELSE.
        ls_objkey-value+lv_value_pos(1) = &lt;ls_object_table&gt;-tobjkey+lv_objkey_pos(1).
        lv_value_pos = lv_value_pos + 1.
      ENDIF.

      lv_objkey_pos = lv_objkey_pos + 1.
    ENDWHILE.

*    Similarly to that, fixed values might be supplied in the object key which actually make up key components
    IF NOT ls_objkey-value IS INITIAL.
      split_value_to_keys(
        EXPORTING
          it_key_component = lt_key_fields
        CHANGING
          ct_objkey        = lt_objkey
          cs_objkey        = ls_objkey
          cv_non_value_pos = lv_non_value_pos ).
    ENDIF.

*   compose the where clause
    lv_is_asterix = abap_false.
    lv_key_pos = 1.

    LOOP AT lt_key_fields ASSIGNING &lt;ls_table_field&gt;.
      READ TABLE lt_objkey INTO ls_objkey
        WITH TABLE KEY num = lv_key_pos.
      IF sy-subrc &lt;&gt; 0 OR &lt;ls_table_field&gt;-fieldname = &apos;LANGU&apos;.
        CLEAR ls_objkey.
        lv_key_pos = lv_key_pos + 1.
        CONTINUE.
      ENDIF.
      IF ls_objkey-value = &apos;*&apos;.
        lv_is_asterix = abap_true.
      ENDIF.
      IF lv_is_asterix = abap_true.
        CONTINUE.
      ENDIF.
      IF NOT lv_where_statement IS INITIAL.
        CONCATENATE lv_where_statement &apos;AND&apos; INTO lv_where_statement
          SEPARATED BY space.
      ENDIF.
      lv_value128 = cl_abap_dyn_prg=&gt;quote( ls_objkey-value ).
      CONCATENATE lv_where_statement &lt;ls_table_field&gt;-fieldname &apos;=&apos;
        lv_value128 INTO lv_where_statement SEPARATED BY space.
      lv_key_pos = lv_key_pos + 1.
    ENDLOOP.

    rv_where = condense( lv_where_statement ).

  ENDMETHOD.
  METHOD serialize.

    before_export( ).

    serialize_data( io_xml ).

  ENDMETHOD.
  METHOD serialize_data.

    DATA: lr_ref   TYPE REF TO data,
          lv_where TYPE string.

    FIELD-SYMBOLS: &lt;lt_data&gt;         TYPE STANDARD TABLE,
                   &lt;ls_object_table&gt; LIKE LINE OF mt_object_table.
    LOOP AT mt_object_table ASSIGNING &lt;ls_object_table&gt;.

      CREATE DATA lr_ref TYPE STANDARD TABLE OF (&lt;ls_object_table&gt;-tobj_name).
      ASSIGN lr_ref-&gt;* TO &lt;lt_data&gt;.

      lv_where = get_where_clause( &lt;ls_object_table&gt;-tobj_name ).

      SELECT * FROM (&lt;ls_object_table&gt;-tobj_name)
        INTO TABLE &lt;lt_data&gt;
        WHERE (lv_where).

      io_xml-&gt;add(
        iv_name = &lt;ls_object_table&gt;-tobj_name
        ig_data = &lt;lt_data&gt; ).

    ENDLOOP.

  ENDMETHOD.
  METHOD split_value_to_keys.

    DATA: lt_key_component_uncovered LIKE it_key_component,
          ls_dummy                   LIKE LINE OF ct_objkey,
          ls_key_component_uncovered LIKE LINE OF lt_key_component_uncovered,
          ls_objkey_sub              LIKE cs_objkey,
          lv_objkey_sub_pos          TYPE i.
    lt_key_component_uncovered = it_key_component.

*    we want to fill the atribute values which are not covered by explicit key components yet
    LOOP AT ct_objkey INTO ls_dummy.
      DELETE lt_key_component_uncovered INDEX 1.
    ENDLOOP.

    ls_objkey_sub-num = cs_objkey-num.
    lv_objkey_sub_pos = 0.
    LOOP AT lt_key_component_uncovered INTO ls_key_component_uncovered.
      CLEAR ls_objkey_sub-value.
      ls_objkey_sub-value = cs_objkey-value+lv_objkey_sub_pos(ls_key_component_uncovered-leng).
      ls_objkey_sub-num = cv_non_value_pos.

      INSERT ls_objkey_sub INTO TABLE ct_objkey.

      lv_objkey_sub_pos = lv_objkey_sub_pos + ls_key_component_uncovered-leng.
      cv_non_value_pos = cv_non_value_pos + 1.
      CLEAR ls_objkey_sub.

      IF lv_objkey_sub_pos = strlen( cs_objkey-value ).
        cs_objkey-num = cv_non_value_pos.
        EXIT. &quot;end splitting - all characters captured
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD validate.

    DATA: lv_where   TYPE string,
          lv_primary TYPE objsl-tobj_name,
          lr_ref     TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lt_data&gt; TYPE STANDARD TABLE.
    lv_primary = get_primary_table( ).

    CREATE DATA lr_ref TYPE STANDARD TABLE OF (lv_primary).
    ASSIGN lr_ref-&gt;* TO &lt;lt_data&gt;.

    io_xml-&gt;read(
      EXPORTING
        iv_name = lv_primary
      CHANGING
        cg_data = &lt;lt_data&gt; ).

    IF lines( &lt;lt_data&gt; ) = 0.
      zcx_abapgit_exception=&gt;raise( |Primary table { lv_primary
        } not found in imported container | ).
    ELSEIF lines( &lt;lt_data&gt; ) &lt;&gt; 1.
      zcx_abapgit_exception=&gt;raise( |Primary table { lv_primary
        } contains more than one instance! | ).
    ENDIF.

    lv_where = get_where_clause( lv_primary ).

*  validate that max one local instance was affected by the import
    SELECT COUNT(*) FROM (lv_primary) WHERE (lv_where).
    IF sy-dbcnt &gt; 1.
      zcx_abapgit_exception=&gt;raise( |More than one instance exists locally in primary table {
        lv_primary }| ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_FILES IMPLEMENTATION.
  METHOD add.
    APPEND is_file TO mt_files.
  ENDMETHOD.
  METHOD add_abap.

    DATA: lv_source TYPE string,
          ls_file   TYPE zif_abapgit_definitions=&gt;ty_file.
    CONCATENATE LINES OF it_abap INTO lv_source SEPARATED BY zif_abapgit_definitions=&gt;c_newline.
* when editing files via eg. GitHub web interface it adds a newline at end of file
    lv_source = lv_source &amp;&amp; zif_abapgit_definitions=&gt;c_newline.

    ls_file-path = &apos;/&apos;.
    ls_file-filename = filename( iv_extra = iv_extra
                                 iv_ext   = &apos;abap&apos; ).       &quot;#EC NOTEXT
    ls_file-data = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_source ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.
  METHOD add_raw.

    DATA: ls_file TYPE zif_abapgit_definitions=&gt;ty_file.

    ls_file-path     = &apos;/&apos;.
    ls_file-data     = iv_data.
    ls_file-filename = filename( iv_extra = iv_extra
                                 iv_ext   = iv_ext ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.
  METHOD add_string.

    DATA: ls_file TYPE zif_abapgit_definitions=&gt;ty_file.
    ls_file-path = &apos;/&apos;.
    ls_file-filename = filename( iv_extra = iv_extra
                                 iv_ext   = iv_ext ).       &quot;#EC NOTEXT
    ls_file-data = zcl_abapgit_convert=&gt;string_to_xstring_utf8( iv_string ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.
  METHOD add_xml.

    DATA: lv_xml  TYPE string,
          ls_file TYPE zif_abapgit_definitions=&gt;ty_file.
    lv_xml = io_xml-&gt;render( iv_normalize = iv_normalize
                             is_metadata = is_metadata ).
    ls_file-path = &apos;/&apos;.

    ls_file-filename = filename( iv_extra = iv_extra
                                 iv_ext   = &apos;xml&apos; ).        &quot;#EC NOTEXT

    REPLACE FIRST OCCURRENCE
      OF REGEX &apos;&lt;\?xml version=&quot;1\.0&quot; encoding=&quot;[\w-]+&quot;\?&gt;&apos;
      IN lv_xml
      WITH &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&apos;.
    ASSERT sy-subrc = 0.

    ls_file-data = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_xml ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.
  METHOD add_xml_from_plugin.
*    this method wraps add_xml as in the plugin. This is necessary as the wrapped
*    xml-object in the plugin can only be typed to object.
*    ABAP does not perform implicit type casts (also if compatible) in signatures,
*    therefore this method&apos;s signature is typed ref to object
    DATA lo_xml TYPE REF TO zcl_abapgit_xml_output.

    lo_xml ?= io_xml.

    me-&gt;add_xml(
      iv_extra     = iv_extra
      io_xml       = lo_xml
      iv_normalize = iv_normalize ).

  ENDMETHOD.
  METHOD constructor.
    ms_item = is_item.
    mv_path = iv_path.
  ENDMETHOD.
  METHOD filename.

    DATA: lv_obj_name TYPE string.
    lv_obj_name = ms_item-obj_name.

    IF ms_item-obj_type = &apos;DEVC&apos;.
      &quot; Packages have a fixed filename so that the repository can be installed to a different
      &quot; package(-hierarchy) on the client and not show up as a different package in the repo.
      lv_obj_name = &apos;package&apos;.
    ENDIF.

    IF iv_extra IS INITIAL.
      CONCATENATE lv_obj_name &apos;.&apos; ms_item-obj_type &apos;.&apos; iv_ext
        INTO rv_filename.                                   &quot;#EC NOTEXT
    ELSE.
      CONCATENATE lv_obj_name &apos;.&apos; ms_item-obj_type &apos;.&apos; iv_extra &apos;.&apos; iv_ext
        INTO rv_filename.                                   &quot;#EC NOTEXT
    ENDIF.

* handle namespaces
    REPLACE ALL OCCURRENCES OF &apos;/&apos; IN rv_filename WITH &apos;#&apos;.
    TRANSLATE rv_filename TO LOWER CASE.

  ENDMETHOD.
  METHOD get_accessed_files.
    rt_files = mt_accessed_files.
  ENDMETHOD.
  METHOD get_files.
    rt_files = mt_files.
  ENDMETHOD.
  METHOD read_abap.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring,
          lv_abap     TYPE string.
    lv_filename = filename( iv_extra = iv_extra
                            iv_ext   = &apos;abap&apos; ).            &quot;#EC NOTEXT

    read_file( EXPORTING iv_filename = lv_filename
                         iv_error    = iv_error
               IMPORTING ev_data     = lv_data ).

    IF lv_data IS INITIAL. &quot; Post-handling of iv_error = false
      RETURN.
    ENDIF.

    lv_abap = zcl_abapgit_convert=&gt;xstring_to_string_utf8( lv_data ).

    SPLIT lv_abap AT zif_abapgit_definitions=&gt;c_newline INTO TABLE rt_abap.

  ENDMETHOD.
  METHOD read_file.

    FIELD-SYMBOLS: &lt;ls_file&gt;     LIKE LINE OF mt_files,
                   &lt;ls_accessed&gt; LIKE LINE OF mt_accessed_files.

    CLEAR ev_data.

    IF mv_path IS NOT INITIAL.
      READ TABLE mt_files ASSIGNING &lt;ls_file&gt; WITH KEY path     = mv_path
                                                       filename = iv_filename.
    ELSE.
      READ TABLE mt_files ASSIGNING &lt;ls_file&gt; WITH KEY filename = iv_filename.
    ENDIF.

    IF sy-subrc &lt;&gt; 0.
      IF iv_error = abap_true.
        zcx_abapgit_exception=&gt;raise( |File not found: { iv_filename }| ).
      ELSE.
        RETURN.
      ENDIF.
    ENDIF.

    &quot; Update access table
    READ TABLE mt_accessed_files TRANSPORTING NO FIELDS
      WITH KEY path = &lt;ls_file&gt;-path filename = &lt;ls_file&gt;-filename.
    IF sy-subrc &gt; 0. &quot; Not found ? -&gt; Add
      APPEND INITIAL LINE TO mt_accessed_files ASSIGNING &lt;ls_accessed&gt;.
      MOVE-CORRESPONDING &lt;ls_file&gt; TO &lt;ls_accessed&gt;.
    ENDIF.

    ev_data = &lt;ls_file&gt;-data.

  ENDMETHOD.
  METHOD read_raw.

    DATA: lv_filename TYPE string.

    lv_filename = filename( iv_extra = iv_extra
                            iv_ext   = iv_ext ).

    read_file( EXPORTING iv_filename = lv_filename
               IMPORTING ev_data     = rv_data ).

  ENDMETHOD.
  METHOD read_string.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring.

    lv_filename = filename( iv_extra = iv_extra
                            iv_ext   = iv_ext ).            &quot;#EC NOTEXT

    read_file( EXPORTING iv_filename = lv_filename
               IMPORTING ev_data     = lv_data ).

    rv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( lv_data ).

  ENDMETHOD.
  METHOD read_xml.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring,
          lv_xml      TYPE string.

    lv_filename = filename( iv_extra = iv_extra
                            iv_ext   = &apos;xml&apos; ).             &quot;#EC NOTEXT

    read_file( EXPORTING iv_filename = lv_filename
               IMPORTING ev_data     = lv_data ).

    lv_xml = zcl_abapgit_convert=&gt;xstring_to_string_utf8( lv_data ).

    CREATE OBJECT ro_xml
      EXPORTING
        iv_xml = lv_xml.

  ENDMETHOD.
  METHOD set_files.
    mt_files = it_files.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECTS_ACTIVATION IMPLEMENTATION.
  METHOD activate.

    IF use_new_activation_logic( ) = abap_true.
      activate_new( iv_ddic ).
    ELSE.
      activate_old( iv_ddic ).
    ENDIF.

    update_where_used( ).

  ENDMETHOD.
  METHOD activate_ddic.

    DATA: lt_gentab     TYPE STANDARD TABLE OF dcgentb,
          ls_gentab     LIKE LINE OF lt_gentab,
          lv_rc         TYPE sy-subrc,
          lt_deltab     TYPE STANDARD TABLE OF dcdeltb,
          lt_action_tab TYPE STANDARD TABLE OF dctablres,
          lv_logname    TYPE ddmass-logname,
          lv_errmsg(255) TYPE c.

    FIELD-SYMBOLS: &lt;ls_object&gt; LIKE LINE OF gt_objects.

    LOOP AT gt_objects ASSIGNING &lt;ls_object&gt;.

      ls_gentab-name = &lt;ls_object&gt;-obj_name.
      ls_gentab-type = &lt;ls_object&gt;-object.
      INSERT ls_gentab INTO TABLE lt_gentab.

      CALL FUNCTION &apos;RS_CORR_INSERT&apos;
        EXPORTING
          object              = &lt;ls_object&gt;-obj_name
          object_class        = &lt;ls_object&gt;-object
          global_lock         = abap_true
        EXCEPTIONS
          cancelled           = 1
          permission_failure  = 2
          unknown_objectclass = 3
          OTHERS              = 4.

      IF sy-subrc &lt;&gt; 0.
        CONCATENATE &apos;error from RS_CORR_INSERT for&apos; &lt;ls_object&gt;-object &lt;ls_object&gt;-obj_name
            INTO lv_errmsg SEPARATED BY space.

        zcx_abapgit_exception=&gt;raise( lv_errmsg ).
      ENDIF.

    ENDLOOP.

    IF lt_gentab IS NOT INITIAL.

      lv_logname = |ABAPGIT_{ sy-datum }_{ sy-uzeit }|.

      CALL FUNCTION &apos;DD_MASS_ACT_C3&apos;
        EXPORTING
          ddmode         = &apos;C&apos;
          medium         = &apos;T&apos;
          device         = &apos;T&apos;
          logname        = lv_logname
          write_log      = abap_true
          log_head_tail  = abap_true
          t_on           = space
          prid           = 1
        IMPORTING
          act_rc         = lv_rc
        TABLES
          gentab         = lt_gentab
          deltab         = lt_deltab
          cnvtab         = lt_action_tab
        EXCEPTIONS
          access_failure = 1
          no_objects     = 2
          locked         = 3
          internal_error = 4
          OTHERS         = 5.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from DD_MASS_ACT_C3&apos; ).
      ENDIF.

      IF lv_rc &gt; 0.

        show_activation_errors( lv_logname ).

      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD activate_new.

    DATA: lo_progress TYPE REF TO zcl_abapgit_progress.

    IF gt_objects IS INITIAL.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = 100.

    IF iv_ddic = abap_true.

      lo_progress-&gt;show( iv_current = 98
                         iv_text    = &apos;Activating DDIC&apos; ).

      activate_ddic( ).

    ELSE.

      lo_progress-&gt;show( iv_current = 98
                         iv_text    = &apos;Activating non DDIC&apos; ).

      activate_old( ).

    ENDIF.

  ENDMETHOD.
  METHOD activate_old.

    DATA: lv_popup TYPE abap_bool.

    IF gt_objects IS NOT INITIAL.

      lv_popup = zcl_abapgit_ui_factory=&gt;get_gui_functions( )-&gt;gui_is_available( ).

      CALL FUNCTION &apos;RS_WORKING_OBJECTS_ACTIVATE&apos;
        EXPORTING
          activate_ddic_objects  = iv_ddic
          with_popup             = lv_popup
        TABLES
          objects                = gt_objects
        EXCEPTIONS
          excecution_error       = 1
          cancelled              = 2
          insert_into_corr_error = 3
          OTHERS                 = 4.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from RS_WORKING_OBJECTS_ACTIVATE&apos; ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD add.

* function group SEWORKINGAREA
* function module RS_INSERT_INTO_WORKING_AREA
* class CL_WB_ACTIVATION_WORK_AREA

    DATA: lt_objects  TYPE dwinactiv_tab,
          lv_obj_name TYPE dwinactiv-obj_name.

    FIELD-SYMBOLS: &lt;ls_object&gt; LIKE LINE OF lt_objects.
    lv_obj_name = iv_name.

    CASE iv_type.
      WHEN &apos;CLAS&apos;.
        APPEND iv_name TO gt_classes.
      WHEN &apos;WDYN&apos;.
* todo, move this to the object type include instead
        CALL FUNCTION &apos;RS_INACTIVE_OBJECTS_IN_OBJECT&apos;
          EXPORTING
            obj_name         = lv_obj_name
            object           = iv_type
          TABLES
            inactive_objects = lt_objects
          EXCEPTIONS
            object_not_found = 1
            OTHERS           = 2.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;Error from RS_INACTIVE_OBJECTS_IN_OBJECT&apos; ).
        ENDIF.

*        IF iv_type = &apos;CLAS&apos;.
*          fix_class_methods( EXPORTING iv_obj_name = lv_obj_name
*                             CHANGING ct_objects = lt_objects ).
*        ENDIF.

        LOOP AT lt_objects ASSIGNING &lt;ls_object&gt;.
          &lt;ls_object&gt;-delet_flag = iv_delete.
        ENDLOOP.

        APPEND LINES OF lt_objects TO gt_objects.
      WHEN OTHERS.
        APPEND INITIAL LINE TO gt_objects ASSIGNING &lt;ls_object&gt;.
        &lt;ls_object&gt;-object     = iv_type.
        &lt;ls_object&gt;-obj_name   = lv_obj_name.
        &lt;ls_object&gt;-delet_flag = iv_delete.
    ENDCASE.

  ENDMETHOD.
  METHOD add_item.
    add( iv_type = is_item-obj_type
         iv_name = is_item-obj_name ).
  ENDMETHOD.
  METHOD clear.
    CLEAR gt_objects.
    CLEAR gt_classes.
  ENDMETHOD.
  METHOD fix_class_methods.
* function module RS_WORKING_OBJECTS_ACTIVATE assumes that
* METH lines contains spaces between class and method name
* however, classes named with 30 characters
* eg. ZCL_CLAS_TESTTESTTESTTESTTESTT
* this will not be true, so find all the method includes instead

* TODO, this class is obsolete with new CLAS deserialization logic

    DATA: lt_methods TYPE seop_methods_w_include,
          lv_class   TYPE seoclsname.

    FIELD-SYMBOLS: &lt;ls_method&gt; LIKE LINE OF lt_methods,
                   &lt;ls_object&gt; LIKE LINE OF ct_objects.
    lv_class = iv_obj_name.

    cl_oo_classname_service=&gt;get_all_method_includes(
      EXPORTING
        clsname            = lv_class
      RECEIVING
        result             = lt_methods
      EXCEPTIONS
        class_not_existing = 1
        OTHERS             = 2 ).
    ASSERT sy-subrc = 0.
    DELETE ct_objects WHERE object = &apos;METH&apos;.
    LOOP AT lt_methods ASSIGNING &lt;ls_method&gt;.
      APPEND INITIAL LINE TO ct_objects ASSIGNING &lt;ls_object&gt;.
      &lt;ls_object&gt;-object = &apos;METH&apos;.
      &lt;ls_object&gt;-obj_name = &lt;ls_method&gt;-incname.
    ENDLOOP.

  ENDMETHOD.
  METHOD show_activation_errors.

    DATA: lt_lines      TYPE STANDARD TABLE OF trlog,
          lv_logname_db TYPE ddprh-protname,
          lo_log        TYPE REF TO zcl_abapgit_log.

    FIELD-SYMBOLS: &lt;ls_line&gt; LIKE LINE OF lt_lines.

    lv_logname_db = iv_logname.

    CALL FUNCTION &apos;TR_READ_LOG&apos;
      EXPORTING
        iv_log_type   = &apos;DB&apos;
        iv_logname_db = lv_logname_db
      TABLES
        et_lines      = lt_lines
      EXCEPTIONS
        invalid_input = 1
        access_error  = 2
        OTHERS        = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from TR_READ_LOG&apos; ).
    ENDIF.

    DELETE lt_lines WHERE severity &lt;&gt; &apos;E&apos;.

    CREATE OBJECT lo_log.

    LOOP AT lt_lines ASSIGNING &lt;ls_line&gt;.
      lo_log-&gt;add( &lt;ls_line&gt;-line ).
    ENDLOOP.

    lo_log-&gt;show( ).

  ENDMETHOD.
  METHOD update_where_used.

    DATA: lv_class    LIKE LINE OF gt_classes,
          lo_cross    TYPE REF TO cl_wb_crossreference,
          lv_include  TYPE programm,
          lo_progress TYPE REF TO zcl_abapgit_progress.
    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( gt_classes ).

    LOOP AT gt_classes INTO lv_class.
      IF sy-tabix MOD 20 = 0.
        lo_progress-&gt;show(
          iv_current = sy-tabix
          iv_text    = &apos;Updating where-used lists&apos; ).
      ENDIF.

      lv_include = cl_oo_classname_service=&gt;get_classpool_name( lv_class ).

      CREATE OBJECT lo_cross
        EXPORTING
          p_name    = lv_include
          p_include = lv_include.

      lo_cross-&gt;index_actualize( ).
    ENDLOOP.

  ENDMETHOD.
  METHOD use_new_activation_logic.

    IF zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( )-&gt;get_experimental_features( ) = abap_true.

      CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
        EXPORTING
          funcname           = &apos;DD_MASS_ACT_C3&apos;    &quot; Name of Function Module
        EXCEPTIONS
          function_not_exist = 1
          OTHERS             = 2.

      IF sy-subrc = 0.
        rv_use_new_activation_logic = abap_true.
      ENDIF.

    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_XSLT IMPLEMENTATION.
  METHOD get.

    DATA: lv_name TYPE cxsltdesc.
    lv_name = ms_item-obj_name.

    cl_o2_api_xsltdesc=&gt;load(
      EXPORTING
        p_xslt_desc        = lv_name
      IMPORTING
        p_obj              = ro_xslt
      EXCEPTIONS
        not_existing       = 1
        permission_failure = 2
        OTHERS             = 3 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from cl_o2_api_xsltdesc=&gt;load&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lo_xslt       TYPE REF TO cl_o2_api_xsltdesc,
          ls_attributes TYPE o2xsltattr.

    lo_xslt = get( ).
    lo_xslt-&gt;get_attributes(
      RECEIVING
        p_attributes     = ls_attributes
      EXCEPTIONS
        object_invalid   = 1
        xsltdesc_deleted = 2
        OTHERS           = 3 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    rv_user = ls_attributes-changedby.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_xslt TYPE REF TO cl_o2_api_xsltdesc,
          lv_name TYPE cxsltdesc.
    lv_name = ms_item-obj_name.

    cl_o2_api_xsltdesc=&gt;load(
      EXPORTING
        p_xslt_desc        = lv_name
      IMPORTING
        p_obj              = lo_xslt
      EXCEPTIONS
        error_occured      = 1
        not_existing       = 2
        permission_failure = 3
        version_not_found  = 4
        OTHERS             = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from cl_o2_api_xsltdesc=&gt;load&apos; ).
    ENDIF.

    lo_xslt-&gt;set_changeable( abap_true ).
    lo_xslt-&gt;delete( ).
    lo_xslt-&gt;save( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_source     TYPE string,
          lo_xslt       TYPE REF TO cl_o2_api_xsltdesc,
          lv_len        TYPE i,
          ls_attributes TYPE o2xsltattr.
    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTRIBUTES&apos;
                  CHANGING cg_data = ls_attributes ).

    ls_attributes-devclass = iv_package.

    lv_source = mo_files-&gt;read_string( iv_extra = &apos;source&apos;
                                       iv_ext   = &apos;xml&apos; ) ##NO_TEXT.

* workaround: somewhere additional linefeeds are added
    lv_len = strlen( lv_source ) - 2.
    IF lv_source+lv_len(2) = cl_abap_char_utilities=&gt;cr_lf.
      lv_source = lv_source(lv_len).
    ENDIF.

    cl_o2_api_xsltdesc=&gt;create_new_from_string(
      EXPORTING
        p_source                = lv_source
        p_attr                  = ls_attributes
      IMPORTING
        p_obj                   = lo_xslt
      EXCEPTIONS
        action_cancelled        = 1
        error_occured           = 2
        not_authorized          = 3
        object_already_existing = 4
        undefined_name          = 5
        OTHERS                  = 6 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |error from cl_o2_api_xsltdesc=&gt;create_new_from_string, { sy-subrc }| ).
    ENDIF.

    lo_xslt-&gt;activate( ).

    lo_xslt-&gt;save( ).

    lo_xslt-&gt;set_changeable( abap_false ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE cxsltdesc.

    lv_name = ms_item-obj_name.

    rv_bool = cl_o2_api_xsltdesc=&gt;exists( lv_name ).
    IF rv_bool = &apos;1&apos;.
      rv_bool = abap_true.
    ELSE.
      rv_bool = abap_false.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_xslt       TYPE REF TO cl_o2_api_xsltdesc,
          lv_source     TYPE string,
          ls_attributes TYPE o2xsltattr.
    lo_xslt = get( ).

    ls_attributes = lo_xslt-&gt;get_attributes( ).

    CLEAR: ls_attributes-author,
           ls_attributes-createdon,
           ls_attributes-changedby,
           ls_attributes-changedon,
           ls_attributes-devclass.

    io_xml-&gt;add( iv_name = &apos;ATTRIBUTES&apos;
                 ig_data = ls_attributes ).

    lv_source = lo_xslt-&gt;get_source_string( ).

    mo_files-&gt;add_string( iv_extra  = &apos;source&apos;
                          iv_ext    = &apos;xml&apos;
                          iv_string = lv_source ) ##NO_TEXT.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_XINX IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    cl_wb_object_type=&gt;get_key_components_from_id(
      EXPORTING
        p_key                   = |{ ms_item-obj_name }|
        p_external_id           = swbm_c_type_ddic_db_tabxinx
      IMPORTING
        p_key_component1        = mv_name
        p_key_component2        = mv_id
      EXCEPTIONS
        too_many_key_components = 1
        objecttype_not_existing = 2
        OTHERS                  = 3 ).

    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    &quot; RS_DD_INDX_DELETE calls the GUI. Someday we need a better solution

    CALL FUNCTION &apos;RS_DD_INDX_DELETE&apos;
      EXPORTING
        objname              = mv_name
        indexname            = mv_id
        extension            = abap_true
      EXCEPTIONS
        object_not_found     = 1
        object_not_specified = 2
        permission_failure   = 3
        action_cancelled     = 4
        OTHERS               = 5.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_DD_INDX_DELETE { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_extension_index TYPE ty_extension_index,
          lv_rc              TYPE sy-subrc.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;XINX&apos;
      CHANGING
        cg_data = ls_extension_index ).

    tadir_insert( iv_package ).

    CALL FUNCTION &apos;DDIF_INDX_PUT&apos;
      EXPORTING
        name              = mv_name
        id                = mv_id
        dd12v_wa          = ls_extension_index-dd12v
      TABLES
        dd17v_tab         = ls_extension_index-t_dd17v
      EXCEPTIONS
        indx_not_found    = 1
        name_inconsistent = 2
        indx_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from DDIF_INDX_PUT { sy-subrc }| ).
    ENDIF.

    CALL FUNCTION &apos;DDIF_INDX_ACTIVATE&apos;
      EXPORTING
        name        = mv_name
        id          = mv_id
      IMPORTING
        rc          = lv_rc
      EXCEPTIONS
        not_found   = 1
        put_failure = 2
        OTHERS      = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from DDIF_INDX_ACTIVATE { sy-subrc }| ).
    ENDIF.

    IF lv_rc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Cannot activate extension index { mv_id } of table { mv_name }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_dd12v TYPE dd12v.

    CALL FUNCTION &apos;DDIF_INDX_GET&apos;
      EXPORTING
        name          = mv_name
        id            = mv_id
      IMPORTING
        dd12v_wa      = lv_dd12v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    rv_bool = boolc( lv_dd12v IS NOT INITIAL ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_TOOL_ACCESS { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_extension_index TYPE ty_extension_index.

    CALL FUNCTION &apos;DDIF_INDX_GET&apos;
      EXPORTING
        name          = mv_name
        id            = mv_id
        langu         = sy-langu
      IMPORTING
        dd12v_wa      = ls_extension_index-dd12v
      TABLES
        dd17v_tab     = ls_extension_index-t_dd17v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from DDIF_INDX_GET { sy-subrc }| ).
    ENDIF.

    CLEAR: ls_extension_index-dd12v-as4user,
           ls_extension_index-dd12v-as4date,
           ls_extension_index-dd12v-as4time.

    io_xml-&gt;add( iv_name = &apos;XINX&apos;
                 ig_data = ls_extension_index ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_webi IMPLEMENTATION.
  METHOD handle_endpoint.

    DATA: ls_endpoint LIKE LINE OF is_webi-pvependpoint,
          li_endpoint TYPE REF TO if_ws_md_vif_endpoint_ref.

    FIELD-SYMBOLS: &lt;ls_function&gt; LIKE LINE OF is_webi-pvepfunction.
    READ TABLE is_webi-pvependpoint INDEX 1 INTO ls_endpoint.
    ASSERT sy-subrc = 0.

    IF mi_vi-&gt;has_endpoint_reference( sews_c_vif_version-all ) = abap_true.
      RETURN.
    ENDIF.

    li_endpoint = mi_vi-&gt;create_endpoint_reference(
      endpoint_type          = ls_endpoint-endpointtype
      service_def_startpoint = ls_endpoint-def_start_pt
      auto_generated         = ls_endpoint-auto_generated
      i_is_srvv              = ls_endpoint-is_srvv ).

    IF ls_endpoint-endpointtype = &apos;BAPI&apos;.
* it looks like some special handling is needed when calling
* set_data, and looking at the cluster data LS_ENDPOINT-CLUSTD
      zcx_abapgit_exception=&gt;raise( &apos;todo, WEBI BAPI&apos; ).
    ENDIF.

* field ls_endpoint-endpointname does not exist in 702
    READ TABLE is_webi-pvepfunction INDEX 1 ASSIGNING &lt;ls_function&gt;.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |WEBI { ms_item-obj_name }: couldn&apos;t detect endpoint name| ).
    ENDIF.

    li_endpoint-&gt;set_data(
      data_version = &apos;1&apos;
      data         = &lt;ls_function&gt;-function ).

  ENDMETHOD.
  METHOD handle_function.

    CONSTANTS: BEGIN OF lc_parameter_type,
                 import TYPE vepparamtype VALUE &apos;I&apos;,
                 export TYPE vepparamtype VALUE &apos;O&apos;,
               END OF lc_parameter_type.

    DATA: li_parameter TYPE REF TO if_ws_md_vif_param,
          li_soap      TYPE REF TO if_ws_md_soap_ext_func,
          li_fault     TYPE REF TO if_ws_md_vif_fault,
          li_function  TYPE REF TO if_ws_md_vif_func.

    FIELD-SYMBOLS: &lt;ls_function&gt;  LIKE LINE OF is_webi-pvepfunction,
                   &lt;ls_soap&gt;      LIKE LINE OF is_webi-pvepfuncsoapext,
                   &lt;ls_fault&gt;     LIKE LINE OF is_webi-pvepfault,
                   &lt;ls_parameter&gt; LIKE LINE OF is_webi-pvepparameter.
    LOOP AT is_webi-pvepfunction ASSIGNING &lt;ls_function&gt;.

      IF mi_vi-&gt;has_function( funcname = &lt;ls_function&gt;-function
          version = sews_c_vif_version-active ) = abap_true.
        CONTINUE.
      ENDIF.

      li_function = mi_vi-&gt;create_function(
        funcname    = &lt;ls_function&gt;-function
        mapped_name = &lt;ls_function&gt;-mappedname ).

      li_function-&gt;set_is_exposed( &lt;ls_function&gt;-is_exposed ).

      LOOP AT is_webi-pvepparameter ASSIGNING &lt;ls_parameter&gt;
          WHERE function = &lt;ls_function&gt;-function.

        CASE &lt;ls_parameter&gt;-vepparamtype.
          WHEN lc_parameter_type-import.

            li_parameter = li_function-&gt;create_incoming_parameter(
              &lt;ls_parameter&gt;-vepparam ).

          WHEN lc_parameter_type-export.

            li_parameter = li_function-&gt;create_outgoing_parameter(
              &lt;ls_parameter&gt;-vepparam ).

          WHEN OTHERS.
            ASSERT 0 = 1.
        ENDCASE.

        li_parameter-&gt;set_name_mapped_to( &lt;ls_parameter&gt;-mappedname ).
        li_parameter-&gt;set_is_exposed( &lt;ls_parameter&gt;-is_exposed ).
        li_parameter-&gt;set_is_optional( &lt;ls_parameter&gt;-is_optional ).
        li_parameter-&gt;set_default_value( &lt;ls_parameter&gt;-default_value ).
        li_parameter-&gt;set_initial( &lt;ls_parameter&gt;-is_initial ).
        li_parameter-&gt;set_type( &lt;ls_parameter&gt;-typename ).
      ENDLOOP.

      LOOP AT is_webi-pvepfuncsoapext ASSIGNING &lt;ls_soap&gt;
          WHERE function = &lt;ls_function&gt;-function.
        li_soap = li_function-&gt;create_soap_extension_function( ).
        li_soap-&gt;set_soap_request_name( &lt;ls_soap&gt;-requestname ).
        li_soap-&gt;set_soap_response_name( &lt;ls_soap&gt;-responsename ).
        li_soap-&gt;set_namespace( &lt;ls_soap&gt;-namespace ).
      ENDLOOP.

      LOOP AT is_webi-pvepfault ASSIGNING &lt;ls_fault&gt;
          WHERE function = &lt;ls_function&gt;-function.
        li_fault = li_function-&gt;create_fault( &lt;ls_fault&gt;-fault ).
        li_fault-&gt;set_name_mapped_to( &lt;ls_fault&gt;-mappedname ).
*        li_fault-&gt;set_description( &lt;ls_fault&gt;-description_id ).
        li_fault-&gt;set_detail( &lt;ls_fault&gt;-detail ).
      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.
  METHOD handle_soap.

    DATA: li_soap TYPE REF TO if_ws_md_soap_ext_virtinfc,
          ls_soap LIKE LINE OF is_webi-pvepvisoapext.
    READ TABLE is_webi-pvepvisoapext INDEX 1 INTO ls_soap.
    ASSERT sy-subrc = 0.

    IF mi_vi-&gt;has_soap_extension_virtinfc( sews_c_vif_version-active ) = abap_true.
      RETURN.
    ENDIF.

    li_soap = mi_vi-&gt;create_soap_extension_virtinfc( ls_soap-soap_appl_uri ).
    li_soap-&gt;set_namespace( ls_soap-namespace ).

  ENDMETHOD.
  METHOD handle_types.

    DATA: lv_index TYPE i,
          li_soap  TYPE REF TO if_ws_md_soap_extension_type,
          li_struc TYPE REF TO if_ws_md_vif_struc_type,
          li_field TYPE REF TO if_ws_md_vif_field,
          li_table TYPE REF TO if_ws_md_vif_table_type,
          li_elem  TYPE REF TO if_ws_md_vif_elem_type.

    FIELD-SYMBOLS: &lt;ls_elem&gt;  LIKE LINE OF is_webi-pvepelemtype,
                   &lt;ls_table&gt; LIKE LINE OF is_webi-pveptabletype,
                   &lt;ls_soap&gt;  LIKE LINE OF is_webi-pveptypesoapext,
                   &lt;ls_struc&gt; LIKE LINE OF is_webi-pvepstrutype.
    LOOP AT is_webi-pvepelemtype ASSIGNING &lt;ls_elem&gt;.
      li_elem = mi_vi-&gt;create_type_as_elementary( &lt;ls_elem&gt;-typename ).
      li_elem-&gt;set_built_in_type( &lt;ls_elem&gt;-build_in_type ).
      li_elem-&gt;set_decimals( &lt;ls_elem&gt;-decimals ).
      li_elem-&gt;set_kind( &lt;ls_elem&gt;-kind ).
      li_elem-&gt;set_length( &lt;ls_elem&gt;-length ).
      li_elem-&gt;set_signed( &lt;ls_elem&gt;-signed ).
      li_elem-&gt;set_abaptype( &lt;ls_elem&gt;-abaptype ).

      IF li_elem-&gt;if_ws_md_vif_type~has_soap_extension_type(
          sews_c_vif_version-all ) = abap_false.
        READ TABLE is_webi-pveptypesoapext ASSIGNING &lt;ls_soap&gt;
          WITH KEY typename = &lt;ls_elem&gt;-typename.
        IF sy-subrc = 0.
          li_soap = li_elem-&gt;if_ws_md_vif_type~create_soap_extension_type( ).
          li_soap-&gt;set_namespace( &lt;ls_soap&gt;-namespace ).
        ENDIF.
      ENDIF.
    ENDLOOP.

    LOOP AT is_webi-pvepstrutype ASSIGNING &lt;ls_struc&gt;.
      lv_index = sy-tabix.

      li_struc = mi_vi-&gt;create_type_as_structure( &lt;ls_struc&gt;-typename ).

      IF li_struc-&gt;has_field( field_pos = &lt;ls_struc&gt;-fieldpos
          version = sews_c_vif_version-active ) = abap_true.
        CONTINUE.
      ENDIF.

      li_field = li_struc-&gt;create_field(
        field_name = &lt;ls_struc&gt;-fieldname
        fieldpos = &lt;ls_struc&gt;-fieldpos ).
      li_field-&gt;set_type( mi_vi-&gt;get_type( typename = &lt;ls_struc&gt;-typeref
                                           version  = sews_c_vif_version-inactive ) ).

      IF lv_index = 1
          AND li_struc-&gt;if_ws_md_vif_type~has_soap_extension_type(
          sews_c_vif_version-all ) = abap_false.
        READ TABLE is_webi-pveptypesoapext ASSIGNING &lt;ls_soap&gt;
          WITH KEY typename = &lt;ls_struc&gt;-typename.
        IF sy-subrc = 0.
          li_soap = li_struc-&gt;if_ws_md_vif_type~create_soap_extension_type( ).
          li_soap-&gt;set_namespace( &lt;ls_soap&gt;-namespace ).
        ENDIF.
      ENDIF.
    ENDLOOP.

    LOOP AT is_webi-pveptabletype ASSIGNING &lt;ls_table&gt;.
      li_table = mi_vi-&gt;create_type_as_table( &lt;ls_table&gt;-typename ).
      li_table-&gt;set_line_type( mi_vi-&gt;get_type( typename = &lt;ls_table&gt;-typeref
                                                version  = sews_c_vif_version-inactive ) ).

      IF li_table-&gt;if_ws_md_vif_type~has_soap_extension_type(
          sews_c_vif_version-all ) = abap_false.
        READ TABLE is_webi-pveptypesoapext ASSIGNING &lt;ls_soap&gt;
          WITH KEY typename = &lt;ls_table&gt;-typename.
        IF sy-subrc = 0.
          li_soap = li_table-&gt;if_ws_md_vif_type~create_soap_extension_type( ).
          li_soap-&gt;set_namespace( &lt;ls_soap&gt;-namespace ).
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_name TYPE vepname,
          lo_vif  TYPE REF TO cl_ws_md_vif_root.
    lv_name = ms_item-obj_name.

    CREATE OBJECT lo_vif.
    TRY.
        lo_vif-&gt;if_ws_md_vif_root~delete_virtual_interface( lv_name ).
      CATCH cx_ws_md_exception.
        zcx_abapgit_exception=&gt;raise( &apos;error deleting WEBI&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_webi   TYPE ty_webi,
          lv_name   TYPE vepname,
          ls_header LIKE LINE OF ls_webi-pvepheader,
          lv_text   TYPE string ##needed,
          lx_root   TYPE REF TO cx_root,
          lv_exists TYPE abap_bool,
          li_root   TYPE REF TO if_ws_md_vif_root.
    io_xml-&gt;read( EXPORTING iv_name = &apos;WEBI&apos;
                  CHANGING cg_data = ls_webi ).

    lv_name = ms_item-obj_name.

    READ TABLE ls_webi-pvepheader INDEX 1 INTO ls_header.
    ASSERT sy-subrc = 0.

    lv_exists = cl_ws_md_vif_root=&gt;check_existence_by_vif_name(
      name      = lv_name
      i_version = sews_c_vif_version-all ).

    li_root = cl_ws_md_factory=&gt;get_vif_root( ).
    TRY.
        IF lv_exists = abap_false.
          mi_vi = li_root-&gt;create_virtual_interface(
            name    = lv_name
            nameext = ls_header-vepnameext ).
        ELSE.
          mi_vi = li_root-&gt;get_virtual_interface( lv_name ).
          mi_vi-&gt;if_ws_md_lockable_object~lock( ).
        ENDIF.

        mi_vi-&gt;set_short_text( ls_webi-veptext ).

        handle_endpoint( ls_webi ).
        handle_types( ls_webi ).
        handle_function( ls_webi ).
        handle_soap( ls_webi ).

        tadir_insert( iv_package ).

        mi_vi-&gt;if_ws_md_lockable_object~save( ).
        mi_vi-&gt;if_ws_md_lockable_object~unlock( ).
      CATCH cx_ws_md_exception INTO lx_root.
        TRY.
            mi_vi-&gt;if_ws_md_lockable_object~unlock( ).
          CATCH cx_ws_md_exception ##no_handler.
        ENDTRY.
        lv_text = lx_root-&gt;if_message~get_text( ).
        zcx_abapgit_exception=&gt;raise( &apos;error deserializing WEBI&apos; ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE vepname.
    lv_name = ms_item-obj_name.

    rv_bool = cl_ws_md_vif_root=&gt;check_existence_by_vif_name(
      name      = lv_name
      i_version = sews_c_vif_version-active ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = ms_item-obj_type
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_webi    TYPE ty_webi,
          lt_modilog TYPE STANDARD TABLE OF smodilog WITH DEFAULT KEY,
          li_vi      TYPE REF TO if_ws_md_vif,
          lv_name    TYPE vepname.

    FIELD-SYMBOLS: &lt;ls_header&gt;   LIKE LINE OF ls_webi-pvepheader,
                   &lt;ls_endpoint&gt; LIKE LINE OF ls_webi-pvependpoint.

    CALL FUNCTION &apos;WEBI_GET_OBJECT&apos;
      EXPORTING
        webiname          = ms_item-obj_name
      TABLES
        psmodilog         = lt_modilog
        pvepheader        = ls_webi-pvepheader
        pvepfunction      = ls_webi-pvepfunction
        pvepfault         = ls_webi-pvepfault
        pvepparameter     = ls_webi-pvepparameter
        pveptype          = ls_webi-pveptype
        pvepelemtype      = ls_webi-pvepelemtype
        pveptabletype     = ls_webi-pveptabletype
        pvepstrutype      = ls_webi-pvepstrutype
        pveptypesoapext   = ls_webi-pveptypesoapext
        pvepeletypsoap    = ls_webi-pvepeletypsoap
        pveptabtypsoap    = ls_webi-pveptabtypsoap
        pvepfuncsoapext   = ls_webi-pvepfuncsoapext
        pvepfieldref      = ls_webi-pvepfieldref
        pvependpoint      = ls_webi-pvependpoint
        pvepvisoapext     = ls_webi-pvepvisoapext
        pvepparasoapext   = ls_webi-pvepparasoapext
      EXCEPTIONS
        version_not_found = 1
        webi_not_exist    = 2
        OTHERS            = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from WEBI_GET_OBJECT&apos; ).
    ENDIF.

    SORT ls_webi-pveptype BY
      vepname ASCENDING
      version ASCENDING
      typename ASCENDING.

    lv_name = ms_item-obj_name.
    TRY.
        li_vi = cl_ws_md_factory=&gt;get_vif_root( )-&gt;get_virtual_interface( lv_name ).
        ls_webi-veptext = li_vi-&gt;get_short_text( sews_c_vif_version-active ).
      CATCH cx_ws_md_exception.
        zcx_abapgit_exception=&gt;raise( &apos;error serializing WEBI&apos; ).
    ENDTRY.

    LOOP AT ls_webi-pvepheader ASSIGNING &lt;ls_header&gt;.
      CLEAR &lt;ls_header&gt;-author.
      CLEAR &lt;ls_header&gt;-createdon.
      CLEAR &lt;ls_header&gt;-changedby.
      CLEAR &lt;ls_header&gt;-changedon.
      CLEAR &lt;ls_header&gt;-ctime.
      CLEAR &lt;ls_header&gt;-text_id.
      CLEAR &lt;ls_header&gt;-utime.
      CLEAR &lt;ls_header&gt;-wsint_version.
    ENDLOOP.

    LOOP AT ls_webi-pvependpoint ASSIGNING &lt;ls_endpoint&gt;.
      CLEAR: &lt;ls_endpoint&gt;-clustd.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;WEBI&apos;
                 ig_data = ls_webi ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_wdyn IMPLEMENTATION.
  METHOD add_fm_exception.

    DATA: ls_exception LIKE LINE OF ct_exception.

    ls_exception-name = iv_name.
    ls_exception-value = iv_value.

    INSERT ls_exception INTO TABLE ct_exception.

  ENDMETHOD.
  METHOD add_fm_param_exporting.

    DATA: ls_param LIKE LINE OF ct_param.

    ls_param-kind = abap_func_exporting.
    ls_param-name = iv_name.
    GET REFERENCE OF ig_value INTO ls_param-value.

    INSERT ls_param INTO TABLE ct_param.

  ENDMETHOD.
  METHOD add_fm_param_tables.

    DATA: ls_param LIKE LINE OF ct_param.

    ls_param-kind = abap_func_tables.
    ls_param-name = iv_name.
    GET REFERENCE OF ct_value INTO ls_param-value.

    INSERT ls_param INTO TABLE ct_param.

  ENDMETHOD.
  METHOD delta_controller.

    DATA: li_controller TYPE REF TO if_wdy_md_controller,
          lv_found      TYPE abap_bool,
          ls_key        TYPE wdy_md_controller_key,
          ls_obj_new    TYPE svrs2_versionable_object,
          ls_obj_old    TYPE svrs2_versionable_object.

    FIELD-SYMBOLS: &lt;ls_component&gt;            LIKE LINE OF mt_components,
                   &lt;ls_source&gt;               LIKE LINE OF mt_sources,
                   &lt;lt_ctrl_exceptions&gt;      TYPE ANY TABLE,
                   &lt;lt_ctrl_exception_texts&gt; TYPE ANY TABLE,
                   &lt;lt_excp&gt;                 TYPE ANY TABLE,
                   &lt;lt_excpt&gt;                TYPE ANY TABLE.
    ls_key-component_name = is_controller-definition-component_name.
    ls_key-controller_name = is_controller-definition-controller_name.

    lv_found = cl_wdy_md_controller=&gt;check_existency(
          component_name  = ls_key-component_name
          controller_name = ls_key-controller_name ).
    IF lv_found = abap_false.
      TRY.
          li_controller ?= cl_wdy_md_controller=&gt;create_complete(
                component_name  = ls_key-component_name
                controller_name = ls_key-controller_name
                controller_type = is_controller-definition-controller_type ).
          li_controller-&gt;save_to_database( ).
          li_controller-&gt;unlock( ).
        CATCH cx_wdy_md_exception.
          zcx_abapgit_exception=&gt;raise( &apos;error creating dummy controller&apos; ).
      ENDTRY.
    ENDIF.

    ls_obj_new-objtype = wdyn_limu_component_controller.
    ls_obj_new-objname = ls_key.

    ls_obj_old-objtype = wdyn_limu_component_controller.
    ls_obj_old-objname = ls_key.

    APPEND is_controller-definition TO ls_obj_old-wdyc-defin.

    LOOP AT mt_components ASSIGNING &lt;ls_component&gt;
        WHERE component_name = ls_key-component_name
        AND controller_name = ls_key-controller_name.
      APPEND &lt;ls_component&gt; TO ls_obj_old-wdyc-ccomp.
    ENDLOOP.
    LOOP AT mt_sources ASSIGNING &lt;ls_source&gt;
        WHERE component_name = ls_key-component_name
        AND controller_name = ls_key-controller_name.
      APPEND &lt;ls_source&gt; TO ls_obj_old-wdyc-ccoms.
    ENDLOOP.

    ls_obj_old-wdyc-descr = is_controller-descriptions.
    ls_obj_old-wdyc-cusag = is_controller-controller_usages.
    ls_obj_old-wdyc-ccomt = is_controller-controller_component_texts.
    ls_obj_old-wdyc-cpara = is_controller-controller_parameters.
    ls_obj_old-wdyc-cpart = is_controller-controller_parameter_texts.
    ls_obj_old-wdyc-cnode = is_controller-context_nodes.
    ls_obj_old-wdyc-cattr = is_controller-context_attributes.
    ls_obj_old-wdyc-cmapp = is_controller-context_mappings.
*   Version 702 doesn&apos;t have these two attributes so we
*   use them dynamically for downward compatibility
    ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTIONS&apos; OF STRUCTURE is_controller
      TO &lt;lt_ctrl_exceptions&gt;.
    IF sy-subrc = 0.
      ASSIGN COMPONENT &apos;EXCP&apos; OF STRUCTURE ls_obj_old-wdyc TO &lt;lt_excp&gt;.
      IF sy-subrc = 0.
        &lt;lt_excp&gt; = &lt;lt_ctrl_exceptions&gt;.
      ENDIF.
    ENDIF.
    ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTIONS_TEXTS&apos; OF STRUCTURE is_controller
      TO &lt;lt_ctrl_exception_texts&gt;.
    IF sy-subrc = 0.
      ASSIGN COMPONENT &apos;EXCPT&apos; OF STRUCTURE ls_obj_old-wdyc TO &lt;lt_excpt&gt;.
      IF sy-subrc = 0.
        &lt;lt_excpt&gt; = &lt;lt_ctrl_exception_texts&gt;.
      ENDIF.
    ENDIF.
    ls_obj_old-wdyc-fgrps = is_controller-fieldgroups.

    CALL FUNCTION &apos;SVRS_MAKE_OBJECT_DELTA&apos;
      EXPORTING
        obj_old              = ls_obj_new
        obj_new              = ls_obj_old
      CHANGING
        delta                = rs_delta
      EXCEPTIONS
        inconsistent_objects = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SVRS_MAKE_OBJECT_DELTA&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD delta_definition.

    DATA: ls_key       TYPE wdy_md_component_key,
          lv_found     TYPE abap_bool,
          ls_obj_new   TYPE svrs2_versionable_object,
          li_component TYPE REF TO if_wdy_md_component,
          ls_obj_old   TYPE svrs2_versionable_object.
    ls_key-component_name = is_definition-definition-component_name.

    lv_found = cl_wdy_md_component=&gt;check_existency( ls_key-component_name ).
    IF lv_found = abap_false.
      TRY.
          cl_wdy_md_component=&gt;create_complete(
            EXPORTING
              name      = ls_key-component_name
            IMPORTING
              component = li_component
            CHANGING
              devclass  = iv_package ).
          li_component-&gt;save_to_database( ).
          li_component-&gt;unlock( ).
        CATCH cx_wdy_md_exception.
          zcx_abapgit_exception=&gt;raise( &apos;error creating dummy component&apos; ).
      ENDTRY.
    ENDIF.

    ls_obj_new-objtype = wdyn_limu_component_definition.
    ls_obj_new-objname = ls_key-component_name.

    ls_obj_old-objtype = wdyn_limu_component_definition.
    ls_obj_old-objname = ls_key-component_name.

    APPEND is_definition-definition TO ls_obj_old-wdyd-defin.
    ls_obj_old-wdyd-descr = is_definition-descriptions.
    ls_obj_old-wdyd-cusag = is_definition-component_usages.
    ls_obj_old-wdyd-intrf = is_definition-interface_implementings.
    ls_obj_old-wdyd-libra = is_definition-library_usages.
    ls_obj_old-wdyd-ctuse = is_definition-ext_ctlr_usages.
    ls_obj_old-wdyd-ctmap = is_definition-ext_ctx_mappings.

    CALL FUNCTION &apos;SVRS_MAKE_OBJECT_DELTA&apos;
      EXPORTING
        obj_old              = ls_obj_new
        obj_new              = ls_obj_old
      CHANGING
        delta                = rs_delta
      EXCEPTIONS
        inconsistent_objects = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SVRS_MAKE_OBJECT_DELTA&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD delta_view.

    DATA: ls_key     TYPE wdy_md_view_key,
          ls_obj_new TYPE svrs2_versionable_object,
          ls_obj_old TYPE svrs2_versionable_object,
          lv_found   TYPE abap_bool,
          li_view    TYPE REF TO if_wdy_md_abstract_view.

    FIELD-SYMBOLS: &lt;ls_def&gt; LIKE LINE OF ls_obj_old-wdyv-defin.
    ls_key-component_name = is_view-definition-component_name.
    ls_key-view_name      = is_view-definition-view_name.

    lv_found = cl_wdy_md_abstract_view=&gt;check_existency(
                 component_name = ls_key-component_name
                 name           = ls_key-view_name ).
    IF lv_found = abap_false.
      TRY.
          li_view = cl_wdy_md_abstract_view=&gt;create(
                      component_name = is_view-definition-component_name
                      view_name      = is_view-definition-view_name
                      type           = is_view-definition-type ).
          li_view-&gt;save_to_database( ).
          li_view-&gt;unlock( ).
        CATCH cx_wdy_md_exception.
          zcx_abapgit_exception=&gt;raise( &apos;error creating dummy view&apos; ).
      ENDTRY.
    ENDIF.

    ls_obj_new-objtype = wdyn_limu_component_view.
    ls_obj_new-objname = ls_key.

    ls_obj_old-objtype = wdyn_limu_component_view.
    ls_obj_old-objname = ls_key.

    APPEND INITIAL LINE TO ls_obj_old-wdyv-defin ASSIGNING &lt;ls_def&gt;.
    MOVE-CORRESPONDING is_view-definition TO &lt;ls_def&gt;.

    ls_obj_old-wdyv-descr = is_view-descriptions.
    ls_obj_old-wdyv-vcont = is_view-view_containers.
    ls_obj_old-wdyv-vcntt = is_view-view_container_texts.
    ls_obj_old-wdyv-ibplg = is_view-iobound_plugs.
    ls_obj_old-wdyv-ibplt = is_view-iobound_plug_texts.
    ls_obj_old-wdyv-plpar = is_view-plug_parameters.
    ls_obj_old-wdyv-plprt = is_view-plug_parameter_texts.
    ls_obj_old-wdyv-uiele = is_view-ui_elements.
    ls_obj_old-wdyv-uicon = is_view-ui_context_bindings.
    ls_obj_old-wdyv-uievt = is_view-ui_event_bindings.
    ls_obj_old-wdyv-uiddc = is_view-ui_ddic_bindings.
    ls_obj_old-wdyv-uiprp = is_view-ui_properties.
    ls_obj_old-wdyv-navil = is_view-navigation_links.
    ls_obj_old-wdyv-navit = is_view-navigation_target_refs.
    ls_obj_old-wdyv-vshno = is_view-vsh_nodes.
    ls_obj_old-wdyv-vshpl = is_view-vsh_placeholders.
    ls_obj_old-wdyv-views = is_view-viewset_properties.

    CALL FUNCTION &apos;SVRS_MAKE_OBJECT_DELTA&apos;
      EXPORTING
        obj_old              = ls_obj_new
        obj_new              = ls_obj_old
      CHANGING
        delta                = rs_delta
      EXCEPTIONS
        inconsistent_objects = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SVRS_MAKE_OBJECT_DELTA&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD get_limu_objects.

    DATA: lv_name TYPE wdy_component_name.
    lv_name = ms_item-obj_name.
    CALL FUNCTION &apos;WDYN_GET_LIMU_OBJECTS&apos;
      EXPORTING
        component_name = lv_name
      IMPORTING
        limu_objects   = rt_objects.

  ENDMETHOD.
  METHOD read.

    DATA: lt_objects        TYPE wdy_md_transport_keys,
          ls_controller_key TYPE wdy_md_controller_key,
          ls_component_key  TYPE wdy_md_component_key,
          ls_view_key       TYPE wdy_md_view_key.

    FIELD-SYMBOLS: &lt;ls_object&gt;               LIKE LINE OF lt_objects,
                   &lt;ls_meta&gt;                 LIKE LINE OF rs_component-ctlr_metadata,
                   &lt;lt_ctrl_exceptions&gt;      TYPE ANY TABLE,
                   &lt;lt_ctrl_exception_texts&gt; TYPE ANY TABLE.

    CLEAR mt_components.
    CLEAR mt_sources.

    lt_objects = get_limu_objects( ).

    LOOP AT lt_objects ASSIGNING &lt;ls_object&gt;.
      CASE &lt;ls_object&gt;-sub_type.
        WHEN wdyn_limu_component_controller.
          ls_controller_key = &lt;ls_object&gt;-sub_name.
          APPEND read_controller( ls_controller_key ) TO rs_component-ctlr_metadata.
        WHEN wdyn_limu_component_definition.
          ls_component_key = &lt;ls_object&gt;-sub_name.
          rs_component-comp_metadata = read_definition( ls_component_key ).
        WHEN wdyn_limu_component_view.
          ls_view_key = &lt;ls_object&gt;-sub_name.
          APPEND read_view( ls_view_key ) TO rs_component-view_metadata.
        WHEN OTHERS.
          ASSERT 0 = 1.
      ENDCASE.
    ENDLOOP.

    SORT rs_component-ctlr_metadata BY
      definition-component_name ASCENDING
      definition-controller_name ASCENDING.

    LOOP AT rs_component-ctlr_metadata ASSIGNING &lt;ls_meta&gt;.
      SORT &lt;ls_meta&gt;-descriptions.
      SORT &lt;ls_meta&gt;-controller_usages.
      SORT &lt;ls_meta&gt;-controller_components.
      SORT &lt;ls_meta&gt;-controller_component_texts.
      SORT &lt;ls_meta&gt;-controller_parameters.
      SORT &lt;ls_meta&gt;-controller_parameter_texts.
      SORT &lt;ls_meta&gt;-context_nodes.
      SORT &lt;ls_meta&gt;-context_attributes.
      SORT &lt;ls_meta&gt;-context_mappings.
      SORT &lt;ls_meta&gt;-fieldgroups.
*     Version 702 doesn&apos;t have these two attributes so we
*     use them dynamically for downward compatibility
      ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTIONS&apos; OF STRUCTURE &lt;ls_meta&gt; TO &lt;lt_ctrl_exceptions&gt;.
      IF sy-subrc = 0.
        SORT &lt;lt_ctrl_exceptions&gt;.
      ENDIF.
      ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTION_TEXTS&apos; OF STRUCTURE &lt;ls_meta&gt; TO &lt;lt_ctrl_exception_texts&gt;.
      IF sy-subrc = 0.
        SORT &lt;lt_ctrl_exception_texts&gt;.
      ENDIF.
    ENDLOOP.

    SORT mt_components BY
      component_name ASCENDING
      controller_name ASCENDING
      cmpname ASCENDING.

    SORT mt_sources BY
      component_name ASCENDING
      controller_name ASCENDING
      cmpname ASCENDING
      line_number ASCENDING.

  ENDMETHOD.
  METHOD read_controller.

    DATA: lt_components   TYPE TABLE OF wdy_ctlr_compo_vrs,
          lt_sources      TYPE TABLE OF wdy_ctlr_compo_source_vrs,
          lt_definition   TYPE TABLE OF wdy_controller,
          lt_psmodilog    TYPE TABLE OF smodilog,
          lt_psmodisrc    TYPE TABLE OF smodisrc,
          lt_fm_param     TYPE abap_func_parmbind_tab,
          lt_fm_exception TYPE abap_func_excpbind_tab.

    FIELD-SYMBOLS: &lt;lt_ctrl_exceptions&gt;      TYPE ANY TABLE,
                   &lt;lt_ctrl_exception_texts&gt; TYPE ANY TABLE.

*   Calling FM dynamically because version 702 has less parameters

*   FM parameters
    add_fm_param_exporting( EXPORTING iv_name     = &apos;CONTROLLER_KEY&apos;
                                      ig_value    = is_key
                            CHANGING  ct_param = lt_fm_param ).
    add_fm_param_exporting( EXPORTING iv_name     = &apos;GET_ALL_TRANSLATIONS&apos;
                                      ig_value    = abap_false
                            CHANGING  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;DEFINITION&apos;
                         CHANGING  ct_value = lt_definition
                                   ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;DESCRIPTIONS&apos;
                         CHANGING ct_value = rs_controller-descriptions
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_USAGES&apos;
                         CHANGING ct_value = rs_controller-controller_usages
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_COMPONENTS&apos;
                         CHANGING ct_value = lt_components
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_COMPONENT_SOURCES&apos;
                         CHANGING ct_value = lt_sources
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_COMPONENT_TEXTS&apos;
                         CHANGING ct_value = rs_controller-controller_component_texts
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_PARAMETERS&apos;
                         CHANGING ct_value = rs_controller-controller_parameters
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_PARAMETER_TEXTS&apos;
                         CHANGING ct_value = rs_controller-controller_parameter_texts
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTEXT_NODES&apos;
                         CHANGING ct_value = rs_controller-context_nodes
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTEXT_ATTRIBUTES&apos;
                         CHANGING ct_value = rs_controller-context_attributes
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;CONTEXT_MAPPINGS&apos;
                         CHANGING ct_value = rs_controller-context_mappings
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;FIELDGROUPS&apos;
                         CHANGING ct_value = rs_controller-fieldgroups
                                  ct_param = lt_fm_param ).
*   Version 702 doesn&apos;t have these two attributes so we
*   use them dynamically for downward compatibility
    ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTIONS&apos; OF STRUCTURE rs_controller TO &lt;lt_ctrl_exceptions&gt;.
    IF sy-subrc = 0.
      add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_EXCEPTIONS&apos;
                           CHANGING ct_value = &lt;lt_ctrl_exceptions&gt;
                                    ct_param = lt_fm_param ).
    ENDIF.
    ASSIGN COMPONENT &apos;CONTROLLER_EXCEPTION_TEXTS&apos; OF STRUCTURE rs_controller TO &lt;lt_ctrl_exception_texts&gt;.
    IF sy-subrc = 0.
      add_fm_param_tables( EXPORTING iv_name = &apos;CONTROLLER_EXCEPTION_TEXTS&apos;
                           CHANGING ct_value = &lt;lt_ctrl_exception_texts&gt;
                                    ct_param = lt_fm_param ).
    ENDIF.
    add_fm_param_tables( EXPORTING iv_name = &apos;PSMODILOG&apos;
                         CHANGING ct_value = lt_psmodilog
                                  ct_param = lt_fm_param ).
    add_fm_param_tables( EXPORTING iv_name = &apos;PSMODISRC&apos;
                         CHANGING ct_value = lt_psmodisrc
                                  ct_param = lt_fm_param ).

*   FM exceptions
    add_fm_exception( EXPORTING iv_name = &apos;NOT_EXISTING&apos;
                                iv_value = 1
                      CHANGING ct_exception = lt_fm_exception ).
    add_fm_exception( EXPORTING iv_name = &apos;OTHERS&apos;
                                iv_value = 2
                      CHANGING ct_exception = lt_fm_exception ).

    CALL FUNCTION &apos;WDYC_GET_OBJECT&apos;
      PARAMETER-TABLE
      lt_fm_param
      EXCEPTION-TABLE
      lt_fm_exception.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from WDYC_GET_OBJECT&apos; ).
    ENDIF.

    APPEND LINES OF lt_components TO mt_components.
    APPEND LINES OF lt_sources TO mt_sources.

    READ TABLE lt_definition INDEX 1 INTO rs_controller-definition.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;WDYC, definition not found&apos; ).
    ENDIF.

    CLEAR: rs_controller-definition-author,
           rs_controller-definition-createdon,
           rs_controller-definition-changedby,
           rs_controller-definition-changedon.

  ENDMETHOD.
  METHOD read_definition.

    DATA: lt_definition TYPE TABLE OF wdy_component,
          lt_psmodilog  TYPE TABLE OF smodilog,
          lt_psmodisrc  TYPE TABLE OF smodisrc.
    CALL FUNCTION &apos;WDYD_GET_OBJECT&apos;
      EXPORTING
        component_key           = is_key
        get_all_translations    = abap_false
      TABLES
        definition              = lt_definition
        descriptions            = rs_definition-descriptions
        component_usages        = rs_definition-component_usages
        interface_implementings = rs_definition-interface_implementings
        library_usages          = rs_definition-library_usages
        ext_ctlr_usages         = rs_definition-ext_ctlr_usages
        ext_ctx_mappings        = rs_definition-ext_ctx_mappings
        psmodilog               = lt_psmodilog &quot; not optional in all versions
        psmodisrc               = lt_psmodisrc &quot; not optional in all versions
      EXCEPTIONS
        not_existing            = 1
        OTHERS                  = 2.
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from WDYD_GET_OBJECT&apos; ).
    ENDIF.

    READ TABLE lt_definition INDEX 1 INTO rs_definition-definition.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;WDYD, definition not found&apos; ).
    ENDIF.

    CLEAR: rs_definition-definition-author,
           rs_definition-definition-createdon,
           rs_definition-definition-changedby,
           rs_definition-definition-changedon,
           rs_definition-definition-gendate,
           rs_definition-definition-gentime.

  ENDMETHOD.
  METHOD read_view.

    DATA: lt_definition TYPE TABLE OF wdy_view_vrs,
          lt_psmodilog  TYPE TABLE OF smodilog,
          lt_psmodisrc  TYPE TABLE OF smodisrc.

    FIELD-SYMBOLS: &lt;ls_definition&gt; LIKE LINE OF lt_definition.
    CALL FUNCTION &apos;WDYV_GET_OBJECT&apos;
      EXPORTING
        view_key               = is_key
        get_all_translations   = abap_false
      TABLES
        definition             = lt_definition
        descriptions           = rs_view-descriptions
        view_containers        = rs_view-view_containers
        view_container_texts   = rs_view-view_container_texts
        iobound_plugs          = rs_view-iobound_plugs
        iobound_plug_texts     = rs_view-iobound_plug_texts
        plug_parameters        = rs_view-plug_parameters
        plug_parameter_texts   = rs_view-plug_parameter_texts
        ui_elements            = rs_view-ui_elements
        ui_context_bindings    = rs_view-ui_context_bindings
        ui_event_bindings      = rs_view-ui_event_bindings
        ui_ddic_bindings       = rs_view-ui_ddic_bindings
        ui_properties          = rs_view-ui_properties
        navigation_links       = rs_view-navigation_links
        navigation_target_refs = rs_view-navigation_target_refs
        vsh_nodes              = rs_view-vsh_nodes
        vsh_placeholders       = rs_view-vsh_placeholders
        viewset_properties     = rs_view-viewset_properties
        psmodilog              = lt_psmodilog
        psmodisrc              = lt_psmodisrc
      EXCEPTIONS
        not_existing           = 1
        OTHERS                 = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from WDYV_GET_OBJECT&apos; ).
    ENDIF.

    READ TABLE lt_definition INDEX 1 ASSIGNING &lt;ls_definition&gt;.
    ASSERT sy-subrc = 0.
    MOVE-CORRESPONDING &lt;ls_definition&gt; TO rs_view-definition.

    CLEAR: rs_view-definition-author,
           rs_view-definition-createdon,
           rs_view-definition-changedby,
           rs_view-definition-changedon.

  ENDMETHOD.
  METHOD recover_controller.

    DATA: ls_key    TYPE wdy_controller_key,
          lv_corrnr TYPE trkorr,
          ls_delta  TYPE svrs2_xversionable_object.
    ls_delta = delta_controller( is_controller ).
    ls_key-component_name  = is_controller-definition-component_name.
    ls_key-controller_name = is_controller-definition-controller_name.

    cl_wdy_md_controller=&gt;recover_version(
      EXPORTING
        controller_key = ls_key
        delta          = ls_delta-wdyc
      CHANGING
        corrnr         = lv_corrnr ).

  ENDMETHOD.
  METHOD recover_definition.

    DATA: ls_key    TYPE wdy_md_component_key,
          lv_corrnr TYPE trkorr,
          ls_delta  TYPE svrs2_xversionable_object.
    ls_delta = delta_definition(
      is_definition = is_definition
      iv_package    = iv_package ).

    ls_key-component_name = is_definition-definition-component_name.

    cl_wdy_md_component=&gt;recover_version(
      EXPORTING
        component_key = ls_key
        delta         = ls_delta-wdyd
      CHANGING
        corrnr        = lv_corrnr ).

  ENDMETHOD.
  METHOD recover_view.

    DATA: ls_key    TYPE wdy_md_view_key,
          lv_corrnr TYPE trkorr,
          ls_delta  TYPE svrs2_xversionable_object.
    ls_delta = delta_view( is_view ).
    ls_key-component_name = is_view-definition-component_name.
    ls_key-view_name      = is_view-definition-view_name.

    cl_wdy_md_abstract_view=&gt;recover_version(
      EXPORTING
        view_key = ls_key
        delta    = ls_delta-wdyv
      CHANGING
        corrnr   = lv_corrnr ).

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_component   TYPE REF TO cl_wdy_wb_component,
          lo_request     TYPE REF TO cl_wb_request,
          li_state       TYPE REF TO if_wb_program_state,
          lv_object_name TYPE seu_objkey.
    CREATE OBJECT lo_component.

    lv_object_name = ms_item-obj_name.
    CREATE OBJECT lo_request
      EXPORTING
        p_object_type = &apos;YC&apos;
        p_object_name = lv_object_name
        p_operation   = swbm_c_op_delete_no_dialog.

    lo_component-&gt;if_wb_program~process_wb_request(
      p_wb_request       = lo_request
      p_wb_program_state = li_state ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_component TYPE wdy_component_metadata.

    FIELD-SYMBOLS: &lt;ls_view&gt;       LIKE LINE OF ls_component-view_metadata,
                   &lt;ls_controller&gt; LIKE LINE OF ls_component-ctlr_metadata.
    io_xml-&gt;read( EXPORTING iv_name = &apos;COMPONENT&apos;
                  CHANGING cg_data = ls_component ).
    io_xml-&gt;read( EXPORTING iv_name  = &apos;COMPONENTS&apos;
                  CHANGING cg_data = mt_components ).
    io_xml-&gt;read( EXPORTING iv_name  = &apos;SOURCES&apos;
                  CHANGING cg_data = mt_sources ).

*    tadir_insert( iv_package ).

    ls_component-comp_metadata-definition-author = sy-uname.
    ls_component-comp_metadata-definition-createdon = sy-datum.
    recover_definition( is_definition = ls_component-comp_metadata
                        iv_package    = iv_package ).

    LOOP AT ls_component-ctlr_metadata ASSIGNING &lt;ls_controller&gt;.
      &lt;ls_controller&gt;-definition-author = sy-uname.
      &lt;ls_controller&gt;-definition-createdon = sy-datum.
      recover_controller( &lt;ls_controller&gt; ).
    ENDLOOP.
    LOOP AT ls_component-view_metadata ASSIGNING &lt;ls_view&gt;.
      &lt;ls_view&gt;-definition-author = sy-uname.
      &lt;ls_view&gt;-definition-createdon = sy-datum.
      recover_view( &lt;ls_view&gt; ).
    ENDLOOP.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_component_name TYPE wdy_component-component_name.
    SELECT SINGLE component_name FROM wdy_component
      INTO lv_component_name
      WHERE component_name = ms_item-obj_name
      AND version = &apos;A&apos;.                                &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = ms_item-obj_type
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_component TYPE wdy_component_metadata.
    ls_component = read( ).

    io_xml-&gt;add( iv_name = &apos;COMPONENT&apos;
                 ig_data = ls_component ).
    io_xml-&gt;add( ig_data = mt_components
                 iv_name = &apos;COMPONENTS&apos; ).
    io_xml-&gt;add( ig_data = mt_sources
                 iv_name = &apos;SOURCES&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_wdya IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: li_app  TYPE REF TO if_wdy_md_application,
          ls_app  TYPE wdy_application,
          lv_name TYPE wdy_application_name.
    lv_name = ms_item-obj_name.
    TRY.
        li_app = cl_wdy_md_application=&gt;get_object_by_key(
                   name    = lv_name
                   version = &apos;A&apos; ).

        li_app-&gt;if_wdy_md_object~get_definition( IMPORTING definition = ls_app ).

        IF ls_app-changedby IS INITIAL.
          rv_user = ls_app-author.
        ELSE.
          rv_user = ls_app-changedby.
        ENDIF.
      CATCH cx_root.
        rv_user = c_user_unknown.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE wdy_application_name.
    lv_name = ms_item-obj_name.

    TRY.
        cl_wdy_md_application=&gt;get_object_by_key(
          name    = lv_name
          version = &apos;A&apos; ).
        rv_bool = abap_true.
      CATCH cx_wdy_md_not_existing.
        rv_bool = abap_false.
      CATCH cx_wdy_md_permission_failure.
        zcx_abapgit_exception=&gt;raise( &apos;WDYA, permission failure&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD read.

    DATA: li_app  TYPE REF TO if_wdy_md_application,
          li_map  TYPE REF TO if_object_map,
          lo_prop TYPE REF TO cl_wdy_md_application_property,
          ls_prop LIKE LINE OF et_properties,
          lv_name TYPE wdy_application_name.
    CLEAR es_app.
    CLEAR et_properties.

    lv_name = ms_item-obj_name.
    TRY.
        li_app = cl_wdy_md_application=&gt;get_object_by_key(
                   name    = lv_name
                   version = &apos;A&apos; ).
      CATCH cx_wdy_md_not_existing.
        RETURN.
      CATCH cx_wdy_md_permission_failure.
        zcx_abapgit_exception=&gt;raise( &apos;WDYA, permission failure&apos; ).
    ENDTRY.

    li_app-&gt;if_wdy_md_object~get_definition( IMPORTING definition = es_app ).
    CLEAR: es_app-author,
           es_app-createdon,
           es_app-changedby,
           es_app-changedon.

    li_map = li_app-&gt;get_properties( ).
    DO li_map-&gt;size( ) TIMES.
      lo_prop ?= li_map-&gt;get_by_position( sy-index ).
      lo_prop-&gt;get_definition( IMPORTING definition = ls_prop ).
      APPEND ls_prop TO et_properties.
    ENDDO.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_app        TYPE wdy_application,
          lt_properties TYPE wdy_app_property_table.
    read( IMPORTING es_app        = ls_app
                    et_properties = lt_properties ).

    io_xml-&gt;add( iv_name = &apos;APP&apos;
                 ig_data = ls_app ).
    io_xml-&gt;add( iv_name = &apos;PROPERTIES&apos;
                 ig_data = lt_properties ).

  ENDMETHOD.

  METHOD save.

    DATA: li_prop TYPE REF TO if_wdy_md_application_property,
          lo_app  TYPE REF TO cl_wdy_md_application.

    FIELD-SYMBOLS: &lt;ls_property&gt; LIKE LINE OF it_properties.
    TRY.
        CREATE OBJECT lo_app
          EXPORTING
            name       = is_app-application_name
            definition = is_app
            devclass   = iv_package.

        LOOP AT it_properties ASSIGNING &lt;ls_property&gt;.
          li_prop = lo_app-&gt;if_wdy_md_application~create_property( &lt;ls_property&gt;-name ).
          li_prop-&gt;set_value( &lt;ls_property&gt;-value ).
        ENDLOOP.

        tadir_insert( iv_package ).

        lo_app-&gt;if_wdy_md_lockable_object~save_to_database( ).
      CATCH cx_wdy_md_exception.
        zcx_abapgit_exception=&gt;raise( &apos;error saving WDYA&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_app        TYPE wdy_application,
          lt_properties TYPE wdy_app_property_table.
    io_xml-&gt;read( EXPORTING iv_name = &apos;APP&apos;
                  CHANGING cg_data = ls_app ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PROPERTIES&apos;
                  CHANGING cg_data = lt_properties ).

    save( is_app        = ls_app
          it_properties = lt_properties
          iv_package    = iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_app    TYPE REF TO if_wdy_md_application,
          lv_objkey TYPE wdy_wb_appl_name,
          lv_type   TYPE seu_type,
          lv_name   TYPE wdy_application_name.
    lv_name = ms_item-obj_name.
    TRY.
        li_app = cl_wdy_md_application=&gt;get_object_by_key(
                   name    = lv_name
                   version = &apos;A&apos; ).
        li_app-&gt;if_wdy_md_object~delete( ).
        li_app-&gt;if_wdy_md_lockable_object~save_to_database( ).

* method save_to_database calls function module TR_TADIR_INTERFACE
* with test mode = X, so it does not delete the TADIR entry.
* Instead the standard code uses RS_TREE_OBJECT_PLACEMENT to delete
* the TADIR entry
        lv_objkey = ms_item-obj_name.
        CONCATENATE &apos;O&apos; swbm_c_type_wdy_application INTO lv_type.
        CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
          EXPORTING
            object    = lv_objkey
            type      = lv_type
            operation = &apos;DELETE&apos;.

      CATCH cx_wdy_md_not_existing.
        RETURN.
      CATCH cx_wdy_md_exception.
        zcx_abapgit_exception=&gt;raise( &apos;WDYA, error deleting&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = ms_item-obj_type
        in_new_window = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_wapa IMPLEMENTATION.
  METHOD get_page_content.

    DATA: lt_content TYPE o2pageline_table,
          lv_string  TYPE string.

    io_page-&gt;get_page(
      IMPORTING
        p_content = lt_content
      EXCEPTIONS
        invalid_call = 1
        page_deleted = 2
        OTHERS       = 3 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |WAPA - error from get_page_content| ).
    ENDIF.

    CONCATENATE LINES OF lt_content INTO lv_string SEPARATED BY zif_abapgit_definitions=&gt;c_newline RESPECTING BLANKS.

    rv_content = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

  ENDMETHOD.
  METHOD read_page.

    DATA: lv_name    TYPE o2applname,
          ls_pagekey TYPE o2pagkey,
          lv_content TYPE xstring,
          lv_extra   TYPE string,
          lv_ext     TYPE string,
          lo_page    TYPE REF TO cl_o2_api_pages.
    lv_name = ms_item-obj_name.

    ls_pagekey-applname = lv_name.
    ls_pagekey-pagekey = is_page-pagekey.

    cl_o2_api_pages=&gt;load(
      EXPORTING
        p_pagekey = ls_pagekey
      IMPORTING
        p_page    = lo_page ).

    lo_page-&gt;get_attrs(
      IMPORTING
        p_attrs = rs_page-attributes ).

    IF rs_page-attributes-pagetype &lt;&gt; so2_controller.

      lo_page-&gt;get_event_handlers(
        IMPORTING
          p_ev_handler = rs_page-event_handlers
        EXCEPTIONS
          page_deleted = 1
          invalid_call = 2 ).
      ASSERT sy-subrc = 0.

      lo_page-&gt;get_parameters(
        IMPORTING
          p_parameters = rs_page-parameters
        EXCEPTIONS
          page_deleted = 1
          invalid_call = 2
          OTHERS       = 3 ).
      ASSERT sy-subrc = 0.

      lo_page-&gt;get_type_source(
        IMPORTING
          p_source     = rs_page-types
        EXCEPTIONS
          page_deleted = 1
          invalid_call = 2
          OTHERS       = 3 ).
      ASSERT sy-subrc = 0.

      lv_content = get_page_content( lo_page ).
      SPLIT is_page-pagename AT &apos;.&apos; INTO lv_extra lv_ext.
      REPLACE ALL OCCURRENCES OF &apos;/&apos; IN lv_ext WITH &apos;_-&apos;.
      REPLACE ALL OCCURRENCES OF &apos;/&apos; IN lv_extra WITH &apos;_-&apos;.
      mo_files-&gt;add_raw(
        iv_extra = lv_extra
        iv_ext   = lv_ext
        iv_data  = lv_content ).

      CLEAR: rs_page-attributes-implclass.

    ENDIF.

    CLEAR: rs_page-attributes-author,
           rs_page-attributes-createdon,
           rs_page-attributes-changedby,
           rs_page-attributes-changedon,
           rs_page-attributes-changetime,
           rs_page-attributes-gendate,
           rs_page-attributes-gentime,
           rs_page-attributes-devclass.

  ENDMETHOD.
  METHOD to_page_content.

    DATA: lv_string TYPE string.
    lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_content ).

    SPLIT lv_string AT zif_abapgit_definitions=&gt;c_newline INTO TABLE rt_content.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lv_name   TYPE o2applname,
          lt_pages  TYPE STANDARD TABLE OF o2pagdir WITH DEFAULT KEY,
          ls_latest LIKE LINE OF lt_pages.
    lv_name = ms_item-obj_name.

    SELECT * FROM o2pagdir INTO TABLE lt_pages WHERE applname = lv_name.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
      RETURN.
    ENDIF.

    SORT lt_pages BY changedon DESCENDING changetime DESCENDING.

    READ TABLE lt_pages INDEX 1 INTO ls_latest.
    ASSERT sy-subrc = 0.

    rv_user = ls_latest-changedby.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_name        TYPE o2applname,
          lo_bsp         TYPE REF TO cl_o2_api_application,
          ls_pagekey     TYPE o2pagkey,
          lv_object      TYPE seu_objkey,
          lt_pages       TYPE o2pagelist,
          lt_local_mimes TYPE o2pagename_table.

    FIELD-SYMBOLS: &lt;ls_page&gt;       LIKE LINE OF lt_pages,
                   &lt;ls_local_mime&gt; TYPE o2pagename.

    lv_name = ms_item-obj_name.

    cl_o2_api_application=&gt;load(
      EXPORTING
        p_application_name  = lv_name
      IMPORTING
        p_application       = lo_bsp
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3 ).
    ASSERT sy-subrc = 0.

    lo_bsp-&gt;set_changeable(
      p_changeable           = abap_true
      p_complete_application = abap_true ).

    cl_o2_api_pages=&gt;get_all_pages(
      EXPORTING
        p_applname = lv_name
        p_version  = c_active
      IMPORTING
        p_pages    = lt_pages ).

    LOOP AT lt_pages ASSIGNING &lt;ls_page&gt;.
      CLEAR ls_pagekey.
      ls_pagekey-applname = lv_name.
      ls_pagekey-pagekey  = &lt;ls_page&gt;-pagekey.

      cl_o2_page=&gt;delete_page_for_application(
        EXPORTING
          p_pagekey           = ls_pagekey
        EXCEPTIONS
          object_not_existing = 1
          error_occured       = 2 ).
      ASSERT sy-subrc = 0.
    ENDLOOP.

    lo_bsp-&gt;get_local_mimes(
      IMPORTING
        p_local_mimes  = lt_local_mimes
      EXCEPTIONS
        object_invalid = 1
        object_deleted = 2
        error_occured  = 3
        OTHERS         = 4 ).

    LOOP AT lt_local_mimes ASSIGNING &lt;ls_local_mime&gt;.
      CLEAR ls_pagekey.
      ls_pagekey-applname = &lt;ls_local_mime&gt;-applname.
      ls_pagekey-pagekey  = &lt;ls_local_mime&gt;-pagekey.

      cl_o2_page=&gt;delete_page_for_application(
        EXPORTING
          p_pagekey           = ls_pagekey
        EXCEPTIONS
          object_not_existing = 1
          error_occured       = 2 ).
      ASSERT sy-subrc = 0.
    ENDLOOP.

    lo_bsp-&gt;delete(
      EXCEPTIONS
        object_not_empty      = 1
        object_not_changeable = 2
        object_invalid        = 3
        action_cancelled      = 4
        permission_failure    = 5
        error_occured         = 6
        OTHERS                = 7 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |WAPA - error from delete: { sy-subrc }| ).
    ENDIF.

* release lock
    lv_object = lv_name.
    cl_o2_api_application=&gt;call_access_permission(
      p_mode                 = &apos;FREE&apos;
      p_object               = lv_object
      p_complete_application = abap_true ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lo_bsp            TYPE REF TO cl_o2_api_application,
          ls_attributes     TYPE o2applattr,
          lt_nodes          TYPE o2applnode_table,
          lt_navgraph       TYPE o2applgrap_table,
          lv_obj_name       TYPE string,
          lv_extra          TYPE string,
          lv_ext            TYPE string,
          lo_page           TYPE REF TO cl_o2_api_pages,
          lt_pages_info     TYPE ty_pages_tt,
          ls_pagekey        TYPE o2pagkey,
          ls_local_page     TYPE zcl_abapgit_object_wapa=&gt;ty_page,
          lt_remote_content TYPE o2pageline_table,
          lt_local_content  TYPE o2pageline_table,
          lt_local_pages    TYPE o2pagelist.

    FIELD-SYMBOLS: &lt;ls_remote_page&gt;       LIKE LINE OF lt_pages_info.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTRIBUTES&apos;
                  CHANGING cg_data = ls_attributes ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAVGRAPH&apos;
                  CHANGING cg_data = lt_navgraph ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PAGES&apos;
                  CHANGING cg_data = lt_pages_info ).

    ls_attributes-devclass = iv_package.

    cl_o2_api_application=&gt;load(
      EXPORTING
        p_application_name  = ls_attributes-applname    &quot; Application Name
      IMPORTING
        p_application       = lo_bsp    &quot; Instance Created
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).

    CASE sy-subrc.
      WHEN 0.

        cl_o2_api_pages=&gt;get_all_pages(
          EXPORTING
            p_applname = ls_attributes-applname
            p_version  = c_active
          IMPORTING
            p_pages    = lt_local_pages ).

      WHEN 1.

        lo_bsp = create_new_application( is_attributes = ls_attributes
                                         it_nodes      = lt_nodes
                                         it_navgraph   = lt_navgraph ).

      WHEN OTHERS.

        zcx_abapgit_exception=&gt;raise( |Error { sy-subrc } from CL_O2_API_APPLICATION=&gt;LOAD| ).

    ENDCASE.

    LOOP AT lt_pages_info ASSIGNING &lt;ls_remote_page&gt;.

      ls_pagekey-applname = &lt;ls_remote_page&gt;-attributes-applname.
      ls_pagekey-pagekey = &lt;ls_remote_page&gt;-attributes-pagekey.

      cl_o2_api_pages=&gt;load(
        EXPORTING
          p_pagekey             = ls_pagekey
        IMPORTING
          p_page                = lo_page
        EXCEPTIONS
          object_not_existing   = 1
          version_not_existing  = 2
          OTHERS                = 3 ).

      CASE sy-subrc.
        WHEN 0.

          ls_local_page = read_page( &lt;ls_remote_page&gt;-attributes ).

        WHEN 1.

          lo_page = create_new_page( &lt;ls_remote_page&gt;-attributes ).

        WHEN 2.

          &quot; Do nothing...

        WHEN OTHERS.

          zcx_abapgit_exception=&gt;raise( |Error { sy-subrc } from CL_O2_API_PAGES=&gt;LOAD| ).

      ENDCASE.

      SPLIT &lt;ls_remote_page&gt;-attributes-pagename AT &apos;.&apos; INTO lv_extra lv_ext.
      REPLACE ALL OCCURRENCES OF &apos;/&apos; IN lv_extra WITH &apos;_-&apos;.
      REPLACE ALL OCCURRENCES OF &apos;/&apos; IN lv_ext WITH &apos;_-&apos;.

      lt_remote_content = to_page_content( mo_files-&gt;read_raw( iv_extra = lv_extra
                                                               iv_ext   = lv_ext ) ).
      lt_local_content = to_page_content( get_page_content( lo_page ) ).

      IF ls_local_page = &lt;ls_remote_page&gt;
      AND lt_local_content = lt_remote_content.
        &quot; no changes -&gt; nothing to do
        CONTINUE.
      ENDIF.

      IF &lt;ls_remote_page&gt;-attributes-pagetype &lt;&gt; so2_controller.

        lo_page-&gt;set_page( lt_remote_content ).

        lo_page-&gt;set_event_handlers( &lt;ls_remote_page&gt;-event_handlers ).
        lo_page-&gt;set_parameters( &lt;ls_remote_page&gt;-parameters ).
        lo_page-&gt;set_type_source( &lt;ls_remote_page&gt;-types ).

      ENDIF.

      lo_page-&gt;save( p_with_all_texts = abap_true ).

      lv_obj_name = cl_wb_object_type=&gt;get_concatenated_key_from_id(
        p_key_component1 = &lt;ls_remote_page&gt;-attributes-applname
        p_key_component2 = &lt;ls_remote_page&gt;-attributes-pagekey
        p_external_id    = &apos;WG &apos; ).

      zcl_abapgit_objects_activation=&gt;add( iv_type = &apos;WAPP&apos;
                                           iv_name = lv_obj_name ).

    ENDLOOP.

    delete_superfluous_pages( it_local_pages  = lt_local_pages
                              it_remote_pages = lt_pages_info ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE o2applname.
    lv_name = ms_item-obj_name.

    cl_o2_api_application=&gt;load(
      EXPORTING
        p_application_name  = lv_name
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3 ).
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = ms_item-obj_type
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_name       TYPE o2applname,
          ls_attributes TYPE o2applattr,
          lt_navgraph   TYPE o2applgrap_table,
          lt_pages      TYPE o2pagelist,
          lt_pages_info TYPE ty_pages_tt,
          lo_bsp        TYPE REF TO cl_o2_api_application.

    FIELD-SYMBOLS: &lt;ls_page&gt; LIKE LINE OF lt_pages.
    lv_name = ms_item-obj_name.

    cl_o2_api_application=&gt;load(
      EXPORTING
        p_application_name  = lv_name
      IMPORTING
        p_application       = lo_bsp
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3 ).
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    lo_bsp-&gt;get_attributes(
      EXPORTING
        p_version    = c_active
      IMPORTING
        p_attributes = ls_attributes ).

    CLEAR: ls_attributes-author,
           ls_attributes-createdon,
           ls_attributes-changedby,
           ls_attributes-changedon,
           ls_attributes-devclass.

    io_xml-&gt;add( iv_name = &apos;ATTRIBUTES&apos;
                 ig_data = ls_attributes ).

    lo_bsp-&gt;get_navgraph(
      EXPORTING
        p_version  = c_active
      IMPORTING
        p_navgraph = lt_navgraph ).

    io_xml-&gt;add( iv_name = &apos;NAVGRAPH&apos;
                 ig_data = lt_navgraph ).

    cl_o2_api_pages=&gt;get_all_pages(
      EXPORTING
        p_applname = lv_name
        p_version  = c_active
      IMPORTING
        p_pages    = lt_pages ).

    LOOP AT lt_pages ASSIGNING &lt;ls_page&gt;.
      APPEND read_page( &lt;ls_page&gt; ) TO lt_pages_info.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;PAGES&apos;
                 ig_data = lt_pages_info ).

  ENDMETHOD.

  METHOD create_new_application.

    DATA: ls_item   LIKE ms_item,
          lv_objkey TYPE seu_objkey.

    cl_o2_api_application=&gt;create_new(
      EXPORTING
        p_application_data      = is_attributes
        p_nodes                 = it_nodes
        p_navgraph              = it_navgraph
      IMPORTING
        p_application           = ro_bsp
      EXCEPTIONS
        object_already_existing = 1
        object_just_created     = 2
        not_authorized          = 3
        undefined_name          = 4
        author_not_existing     = 5
        action_cancelled        = 6
        error_occured           = 7
        invalid_parameter       = 8 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |WAPA - error from create_new: { sy-subrc }| ).
    ENDIF.

    ro_bsp-&gt;save( ).

    ro_bsp-&gt;set_changeable(
      p_changeable           = abap_false
      p_complete_application = abap_true ).

    ls_item-obj_type = &apos;WAPD&apos;.
    ls_item-obj_name = ms_item-obj_name.
    zcl_abapgit_objects_activation=&gt;add_item( ls_item ).

    lv_objkey = ls_item-obj_name.
* todo, hmm, the WAPD is not added to the worklist during activation
    cl_o2_api_application=&gt;activate( lv_objkey ).
  ENDMETHOD.
  METHOD create_new_page.

    cl_o2_api_pages=&gt;create_new_page(
      EXPORTING
        p_pageattrs = is_page_attributes
      IMPORTING
        p_page      = ro_page
      EXCEPTIONS
        object_already_exists = 1
        invalid_name          = 2
        error_occured         = 3
        o2appl_not_existing   = 4
        OTHERS                = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error { sy-subrc } from CL_O2_API_PAGES=&gt;CREATE_NEW_PAGE| ).
    ENDIF.

  ENDMETHOD.
  METHOD delete_superfluous_pages.

    DATA: ls_pagekey TYPE o2pagkey.
    FIELD-SYMBOLS: &lt;ls_local_page&gt; LIKE LINE OF it_local_pages.

    &quot; delete local pages which doesn&apos;t exists remotely
    LOOP AT it_local_pages ASSIGNING &lt;ls_local_page&gt;.

      READ TABLE it_remote_pages WITH KEY attributes-pagekey = &lt;ls_local_page&gt;-pagekey
                               TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        &quot; page exists locally but not remotely -&gt; delete

        ls_pagekey-applname = &lt;ls_local_page&gt;-applname.
        ls_pagekey-pagekey = &lt;ls_local_page&gt;-pagekey.

        cl_o2_page=&gt;delete_page_for_application(
          EXPORTING
            p_pagekey           = ls_pagekey
          EXCEPTIONS
            object_not_existing = 1
            error_occured       = 2 ).

        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( |Error { sy-subrc } from CL_O2_PAGE=&gt;DELETE_PAGE_FOR_APPLICATION| ).
        ENDIF.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_w3super IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( is_item = is_item iv_language = iv_language ).
    ms_key-relid = ms_item-obj_type+2(2).
    ms_key-objid = ms_item-obj_name.
  ENDMETHOD.
  METHOD find_param.

    FIELD-SYMBOLS &lt;ls_param&gt; LIKE LINE OF it_params.
    READ TABLE it_params ASSIGNING &lt;ls_param&gt; WITH KEY name = iv_name.
    IF sy-subrc &gt; 0.
      zcx_abapgit_exception=&gt;raise( |W3xx: Cannot find { iv_name } for { ms_key-objid }| ).
    ENDIF.

    rv_value = &lt;ls_param&gt;-value.

  ENDMETHOD.
  METHOD get_ext.

    rv_ext = find_param( it_params = it_params iv_name = c_param_names-fileext ).
    SHIFT rv_ext LEFT DELETING LEADING &apos;.&apos;.

  ENDMETHOD.
  METHOD get_metadata. &quot;Redefinition
    rs_metadata         = super-&gt;get_metadata( ).
    rs_metadata-version = &apos;v2.0.0&apos;. &quot; Seriazation v2, separate data file
  ENDMETHOD.
  METHOD normalize_params.

    FIELD-SYMBOLS &lt;ls_param&gt; LIKE LINE OF ct_params.

    &quot; Ensure filesize param exists
    READ TABLE ct_params ASSIGNING &lt;ls_param&gt; WITH KEY name = c_param_names-filesize.
    IF sy-subrc &lt;&gt; 0.
      APPEND INITIAL LINE TO ct_params ASSIGNING &lt;ls_param&gt;.
      &lt;ls_param&gt;-name  = c_param_names-filesize.
    ENDIF.

    LOOP AT ct_params ASSIGNING &lt;ls_param&gt;.
      &lt;ls_param&gt;-relid = ms_key-relid. &quot; Ensure param key = object key
      &lt;ls_param&gt;-objid = ms_key-objid.
      IF &lt;ls_param&gt;-name = c_param_names-filesize. &quot; Patch filesize = real file size
        &lt;ls_param&gt;-value = iv_size.
        CONDENSE &lt;ls_param&gt;-value.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD strip_params.

    FIELD-SYMBOLS &lt;ls_param&gt; LIKE LINE OF ct_params.

    &quot; Remove path from filename
    find_param( it_params = ct_params iv_name = c_param_names-filename ). &quot; Check exists
    READ TABLE ct_params ASSIGNING &lt;ls_param&gt; WITH KEY name = c_param_names-filename.
    &lt;ls_param&gt;-value = zcl_abapgit_path=&gt;get_filename_from_syspath( |{ &lt;ls_param&gt;-value }| ).

    &quot; Clear version &amp; filesize
    DELETE ct_params WHERE name = c_param_names-version.
    DELETE ct_params WHERE name = c_param_names-filesize.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE chname INTO rv_user
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND   objid = ms_key-objid
      AND   srtf2 = 0.

    IF sy-subrc IS NOT INITIAL OR rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CALL FUNCTION &apos;WWWDATA_DELETE&apos;
      EXPORTING
        key               = ms_key
      EXCEPTIONS
        wrong_object_type = 1
        delete_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot delete W3xx data&apos; ).
    ENDIF.

    CALL FUNCTION &apos;WWWPARAMS_DELETE_ALL&apos;
      EXPORTING
        key          = ms_key
      EXCEPTIONS
        delete_error = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot delete W3xx params&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA lv_base64str TYPE string.
    DATA lt_w3params  TYPE STANDARD TABLE OF wwwparams.
    DATA lv_xstring   TYPE xstring.
    DATA lt_w3mime    TYPE STANDARD TABLE OF w3mime.
    DATA lt_w3html    TYPE STANDARD TABLE OF w3html.
    DATA lv_size      TYPE int4.
    DATA lv_tadir_obj TYPE tadir-object.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TEXT&apos;
                  CHANGING  cg_data = ms_key-text ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;PARAMS&apos;
                  CHANGING  cg_data = lt_w3params ).

    CASE io_xml-&gt;get_metadata( )-version.
      WHEN &apos;v1.0.0&apos;.
        io_xml-&gt;read( EXPORTING iv_name = &apos;DATA&apos;
                      CHANGING  cg_data = lv_base64str ).
        lv_xstring = cl_http_utility=&gt;decode_x_base64( lv_base64str ).
      WHEN &apos;v2.0.0&apos;.
        lv_xstring = zif_abapgit_object~mo_files-&gt;read_raw( iv_extra = &apos;data&apos;
                                                    iv_ext   = get_ext( lt_w3params ) ).
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;W3xx: Unknown serializer version&apos; ).
    ENDCASE.

    CASE ms_key-relid.
      WHEN &apos;MI&apos;.
        CALL FUNCTION &apos;SCMS_XSTRING_TO_BINARY&apos;
          EXPORTING
            buffer        = lv_xstring
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime.
      WHEN &apos;HT&apos;.
        CALL FUNCTION &apos;SCMS_XSTRING_TO_BINARY&apos;
          EXPORTING
            buffer        = lv_xstring
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime.

        CALL FUNCTION &apos;SCMS_BINARY_TO_TEXT&apos;
          EXPORTING
            input_length  = lv_size
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime
            text_tab      = lt_w3html
          EXCEPTIONS
            failed        = 1.
        IF sy-subrc IS NOT INITIAL.
          zcx_abapgit_exception=&gt;raise( &apos;Cannot update W3xx params&apos; ).
        ENDIF.

        CLEAR lt_w3mime.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;Wrong W3xx type&apos; ).
    ENDCASE.

    &quot; Update size of file based on actual data file size, prove param object name
    normalize_params( EXPORTING iv_size   = lv_size
                      CHANGING  ct_params = lt_w3params ).

    CALL FUNCTION &apos;WWWPARAMS_UPDATE&apos;
      TABLES
        params       = lt_w3params
      EXCEPTIONS
        update_error = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot update W3xx params&apos; ).
    ENDIF.

    ms_key-tdate    = sy-datum.
    ms_key-ttime    = sy-uzeit.
    ms_key-chname   = sy-uname.
    ms_key-devclass = iv_package.

    CALL FUNCTION &apos;WWWDATA_EXPORT&apos;
      EXPORTING
        key               = ms_key
      TABLES
        mime              = lt_w3mime
        html              = lt_w3html
      EXCEPTIONS
        wrong_object_type = 1
        export_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot upload W3xx data&apos; ).
    ENDIF.

    CONCATENATE &apos;W3&apos; ms_key-relid INTO lv_tadir_obj.

    CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
      EXPORTING
        wi_tadir_pgmid                 = &apos;R3TR&apos;
        wi_tadir_object                = lv_tadir_obj
        wi_tadir_devclass              = iv_package
        wi_tadir_obj_name              = ms_key-objid
        wi_test_modus                  = space
      EXCEPTIONS
        tadir_entry_not_existing       = 1
        tadir_entry_ill_type           = 2
        no_systemname                  = 3
        no_systemtype                  = 4
        original_system_conflict       = 5
        object_reserved_for_devclass   = 6
        object_exists_global           = 7
        object_exists_local            = 8
        object_is_distributed          = 9
        obj_specification_not_unique   = 10
        no_authorization_to_delete     = 11
        devclass_not_existing          = 12
        simultanious_set_remove_repair = 13
        order_missing                  = 14
        no_modification_of_head_syst   = 15
        pgmid_object_not_allowed       = 16
        masterlanguage_not_specified   = 17
        devclass_not_specified         = 18
        specify_owner_unique           = 19
        loc_priv_objs_no_repair        = 20
        gtadir_not_reached             = 21
        object_locked_for_order        = 22
        change_of_class_not_allowed    = 23
        no_change_from_sap_to_tmp      = 24
        OTHERS                         = 99.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot update TADIR for W3xx&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    SELECT SINGLE objid INTO ms_key-objid
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND   objid = ms_key-objid
      AND   srtf2 = 0.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: ls_bdcdata TYPE bdcdata,
          lt_bdcdata TYPE tty_bdcdata.

    ls_bdcdata-program  = &apos;SAPMWWW0&apos;.
    ls_bdcdata-dynpro   = &apos;0100&apos;.
    ls_bdcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bdcdata TO lt_bdcdata.

    change_bdc_jump_data(
      CHANGING
        ct_bdcdata = lt_bdcdata ).

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bdcdata-fval = &apos;=CRO1&apos;.
    APPEND ls_bdcdata TO lt_bdcdata.

    ls_bdcdata-program  = &apos;RSWWWSHW&apos;.
    ls_bdcdata-dynpro   = &apos;1000&apos;.
    ls_bdcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bdcdata TO lt_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam     = &apos;SO_OBJID-LOW&apos;.
    ls_bdcdata-fval     = ms_item-obj_name.
    APPEND ls_bdcdata TO lt_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bdcdata-fval = &apos;=ONLI&apos;.
    APPEND ls_bdcdata TO lt_bdcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SMW0&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bdcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SE35&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA lt_w3mime    TYPE STANDARD TABLE OF w3mime.
    DATA lt_w3html    TYPE STANDARD TABLE OF w3html.
    DATA lt_w3params  TYPE STANDARD TABLE OF wwwparams.
    DATA lv_xstring   TYPE xstring.
    DATA lv_size      TYPE int4.

    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ms_key
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND   objid = ms_key-objid
      AND   srtf2 = 0.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;WWWDATA_IMPORT&apos;
      EXPORTING
        key               = ms_key
      TABLES
        mime              = lt_w3mime
        html              = lt_w3html
      EXCEPTIONS
        wrong_object_type = 1
        import_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot read W3xx data&apos; ).
    ENDIF.

    CALL FUNCTION &apos;WWWPARAMS_READ_ALL&apos;
      EXPORTING
        type             = ms_key-relid
        objid            = ms_key-objid
      TABLES
        params           = lt_w3params
      EXCEPTIONS
        entry_not_exists = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot read W3xx data&apos; ).
    ENDIF.

    lv_size = find_param( it_params = lt_w3params iv_name = c_param_names-filesize ).
    &quot; Clean params (remove version, filesize &amp; clear filename from path)
    strip_params( CHANGING  ct_params = lt_w3params ).

    CASE ms_key-relid.
      WHEN &apos;MI&apos;.
        CALL FUNCTION &apos;SCMS_BINARY_TO_XSTRING&apos;
          EXPORTING
            input_length = lv_size
          IMPORTING
            buffer       = lv_xstring
          TABLES
            binary_tab   = lt_w3mime
          EXCEPTIONS
            failed       = 1.
      WHEN &apos;HT&apos;.
        CALL FUNCTION &apos;SCMS_TEXT_TO_XSTRING&apos;
          IMPORTING
            buffer   = lv_xstring
          TABLES
            text_tab = lt_w3html
          EXCEPTIONS
            failed   = 1.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;Wrong W3xx type&apos; ).
    ENDCASE.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Cannot convert W3xx to xstring&apos; ).
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;NAME&apos;
                 ig_data = ms_key-objid ).

    io_xml-&gt;add( iv_name = &apos;TEXT&apos;
                 ig_data = ms_key-text ).

    io_xml-&gt;add( iv_name = &apos;PARAMS&apos;
                 ig_data = lt_w3params ).

    &quot; Seriazation v2, separate data file. &apos;extra&apos; added to prevent conflict with .xml
    zif_abapgit_object~mo_files-&gt;add_raw( iv_data  = lv_xstring
                                  iv_extra = &apos;data&apos;
                                  iv_ext   = get_ext( lt_w3params ) ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |{ ms_item-obj_type+2(2) }{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;E_WWW_HTML&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_w3mi IMPLEMENTATION.

  METHOD change_bdc_jump_data.

    DATA: ls_bdcdata LIKE LINE OF ct_bdcdata.

    ls_bdcdata-fnam = &apos;RADIO_HT&apos;.
    ls_bdcdata-fval = &apos; &apos;.
    APPEND ls_bdcdata TO ct_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = &apos;RADIO_MI&apos;.
    ls_bdcdata-fval = &apos;X&apos;.
    APPEND ls_bdcdata TO ct_bdcdata.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_w3ht IMPLEMENTATION.

  METHOD change_bdc_jump_data.

    DATA: ls_bdcdata LIKE LINE OF ct_bdcdata.

    ls_bdcdata-fnam = &apos;RADIO_HT&apos;.
    ls_bdcdata-fval = &apos;X&apos;.
    APPEND ls_bdcdata TO ct_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = &apos;RADIO_MI&apos;.
    ls_bdcdata-fval = &apos; &apos;.
    APPEND ls_bdcdata TO ct_bdcdata.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_view IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd25l INTO rv_user
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;V&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, VIEW&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd25v TYPE dd25v,
          ls_dd09l TYPE dd09l,
          lt_dd26v TYPE TABLE OF dd26v,
          lt_dd27p TYPE TABLE OF dd27p,
          lt_dd28j TYPE TABLE OF dd28j,
          lt_dd28v TYPE TABLE OF dd28v.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD25V&apos;
                  CHANGING cg_data = ls_dd25v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD09L&apos;
                  CHANGING cg_data = ls_dd09l ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD26V_TABLE&apos;
                  CHANGING cg_data = lt_dd26v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD27P_TABLE&apos;
                  CHANGING cg_data = lt_dd27p ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD28J_TABLE&apos;
                  CHANGING cg_data = lt_dd28j ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD28V_TABLE&apos;
                  CHANGING cg_data = lt_dd28v ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name. &quot; type conversion

    CALL FUNCTION &apos;DDIF_VIEW_PUT&apos;
      EXPORTING
        name              = lv_name
        dd25v_wa          = ls_dd25v
        dd09l_wa          = ls_dd09l
      TABLES
        dd26v_tab         = lt_dd26v
        dd27p_tab         = lt_dd27p
        dd28j_tab         = lt_dd28j
        dd28v_tab         = lt_dd28v
      EXCEPTIONS
        view_not_found    = 1
        name_inconsistent = 2
        view_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_VIEW_PUT&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_viewname TYPE dd25l-viewname,
          lv_ddl_view TYPE abap_bool.
    SELECT SINGLE viewname FROM dd25l INTO lv_viewname
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

    IF rv_bool = abap_true.
      TRY.
          CALL METHOD (&apos;CL_DD_DDL_UTILITIES&apos;)=&gt;(&apos;CHECK_FOR_DDL_VIEW&apos;)
            EXPORTING
              objname     = lv_viewname
            RECEIVING
              is_ddl_view = lv_ddl_view.

          IF lv_ddl_view = abap_true.
            rv_bool = abap_false.
          ENDIF.
        CATCH cx_root ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd25l
      INTO (lv_date, lv_time)
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).
    IF rv_changed = abap_true.
      RETURN.
    ENDIF.

    SELECT SINGLE as4date as4time FROM dd09l
      INTO (lv_date, lv_time)
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-VIMA&apos;
               iv_field = &apos;RSRD1-VIMA_VAL&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd25v TYPE dd25v,
          ls_dd09l TYPE dd09l,
          lt_dd26v TYPE TABLE OF dd26v,
          lt_dd27p TYPE TABLE OF dd27p,
          lt_dd28j TYPE TABLE OF dd28j,
          lt_dd28v TYPE TABLE OF dd28v.

    FIELD-SYMBOLS: &lt;ls_dd27p&gt; LIKE LINE OF lt_dd27p.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
      EXPORTING
        name          = lv_name
        state         = &apos;A&apos;
        langu         = mv_language
      IMPORTING
        dd25v_wa      = ls_dd25v
        dd09l_wa      = ls_dd09l
      TABLES
        dd26v_tab     = lt_dd26v
        dd27p_tab     = lt_dd27p
        dd28j_tab     = lt_dd28j
        dd28v_tab     = lt_dd28v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_VIEW_GET&apos; ).
    ENDIF.
    IF ls_dd25v IS INITIAL.
      RETURN. &quot; does not exist in system
    ENDIF.

    CLEAR: ls_dd25v-as4user,
           ls_dd25v-as4date,
           ls_dd25v-as4time.

    CLEAR: ls_dd09l-as4user,
           ls_dd09l-as4date,
           ls_dd09l-as4time.

    LOOP AT lt_dd27p ASSIGNING &lt;ls_dd27p&gt;.
      CLEAR: &lt;ls_dd27p&gt;-ddtext,
             &lt;ls_dd27p&gt;-reptext,
             &lt;ls_dd27p&gt;-scrtext_s,
             &lt;ls_dd27p&gt;-scrtext_m,
             &lt;ls_dd27p&gt;-scrtext_l,
             &lt;ls_dd27p&gt;-outputlen,
             &lt;ls_dd27p&gt;-decimals,
             &lt;ls_dd27p&gt;-lowercase,
             &lt;ls_dd27p&gt;-convexit,
             &lt;ls_dd27p&gt;-signflag,
             &lt;ls_dd27p&gt;-flength,
             &lt;ls_dd27p&gt;-domname,
             &lt;ls_dd27p&gt;-datatype,
             &lt;ls_dd27p&gt;-entitytab,
             &lt;ls_dd27p&gt;-inttype,
             &lt;ls_dd27p&gt;-intlen,
             &lt;ls_dd27p&gt;-headlen,
             &lt;ls_dd27p&gt;-scrlen1,
             &lt;ls_dd27p&gt;-scrlen2,
             &lt;ls_dd27p&gt;-scrlen3,
             &lt;ls_dd27p&gt;-memoryid.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;DD25V&apos;
                 ig_data = ls_dd25v ).
    io_xml-&gt;add( iv_name = &apos;DD09L&apos;
                 ig_data = ls_dd09l ).
    io_xml-&gt;add( ig_data = lt_dd26v
                 iv_name = &apos;DD26V_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd27p
                 iv_name = &apos;DD27P_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd28j
                 iv_name = &apos;DD28J_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd28v
                 iv_name = &apos;DD28V_TABLE&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_vcls IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
* Do the same as in VIEWCLUSTER_SAVE_DEFINITION
    DATA: lv_vclname TYPE vcl_name.
    lv_vclname = ms_item-obj_name.

    DELETE FROM vcldir WHERE vclname = lv_vclname.        &quot;#EC CI_SUBRC
    DELETE FROM vcldirt WHERE vclname = lv_vclname. &quot;#EC CI_NOFIRST &quot;#EC CI_SUBRC
    DELETE FROM vclstruc WHERE vclname = lv_vclname.      &quot;#EC CI_SUBRC
    DELETE FROM vclstruct WHERE vclname = lv_vclname. &quot;#EC CI_NOFIRST &quot;#EC CI_SUBRC
    DELETE FROM vclstrudep WHERE vclname = lv_vclname.    &quot;#EC CI_SUBRC
    DELETE FROM vclmf WHERE vclname = lv_vclname.         &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_vcldir_entry TYPE v_vcldir,
          lt_vclstruc     TYPE TABLE OF v_vclstruc,
          lt_vclstrudep   TYPE TABLE OF v_vclstdep,
          lt_vclmf        TYPE TABLE OF v_vclmf,
          lv_objectname   TYPE ob_object.
    io_xml-&gt;read( EXPORTING iv_name = &apos;VCLDIR&apos;
                  CHANGING cg_data = ls_vcldir_entry ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;VLCSTRUC_TAB&apos;
                  CHANGING cg_data = lt_vclstruc ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;VCLSTRUDEP_TAB&apos;
                  CHANGING cg_data = lt_vclstrudep ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;lt_vclstrudep&apos;
                  CHANGING cg_data = lt_vclmf ).

    ls_vcldir_entry-author = sy-uname.

    CALL FUNCTION &apos;VIEWCLUSTER_SAVE_DEFINITION&apos;
      EXPORTING
        vcldir_entry   = ls_vcldir_entry
      TABLES
        vclstruc_tab   = lt_vclstruc
        vclstrudep_tab = lt_vclstrudep
        vclmf_tab      = lt_vclmf.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = ms_item-obj_type
        devclass            = iv_package
        master_language     = mv_language
        mode                = &apos;INSERT&apos;
        global_lock         = abap_true
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc = 1.
      zcx_abapgit_exception=&gt;raise( &apos;Cancelled&apos; ).
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT&apos; ).
    ENDIF.

    lv_objectname = ls_vcldir_entry-vclname.
    CALL FUNCTION &apos;OBJ_GENERATE&apos;
      EXPORTING
        iv_objectname         = lv_objectname
        iv_objecttype         = c_cluster_type
        iv_maint_mode         = c_mode_insert
        iv_devclass           = iv_package
      EXCEPTIONS
        illegal_call          = 1
        object_not_found      = 2
        generate_error        = 3
        transport_error       = 4
        object_enqueue_failed = 5
        OTHERS                = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error in OBJ_GENERATE for VCLS&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA lv_changedate TYPE vcldir-changedate.

    SELECT SINGLE changedate INTO lv_changedate FROM vcldir
      WHERE vclname = ms_item-obj_name.

    rv_bool = boolc( sy-subrc = 0 ).

    IF lv_changedate IS INITIAL.
* same logic as in function module VIEWCLUSTER_GET_DEFINITION
      rv_bool = abap_false.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSVIM&apos;.
    ls_bcdata-dynpro   = &apos;0050&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;VIMDYNFLDS-VIEWNAME&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;VIMDYNFLDS-STRUCT_MNT&apos;.
    ls_bcdata-fval     = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=CLUS&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-program  = &apos;SAPMSVIM&apos;.
    ls_bcdata-dynpro   = &apos;0052 &apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;VIMDYNFLDS-VCLNAME&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=CLSH&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SE54&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SE35&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_vclname      TYPE vcl_name,
          ls_vcldir_entry TYPE v_vcldir,
          lt_vclstruc     TYPE TABLE OF v_vclstruc,
          lt_vclstrudep   TYPE TABLE OF v_vclstdep,
          lt_vclmf        TYPE TABLE OF v_vclmf.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lv_vclname = ms_item-obj_name.

    CALL FUNCTION &apos;VIEWCLUSTER_GET_DEFINITION&apos;
      EXPORTING
        vclname                = lv_vclname
      IMPORTING
        vcldir_entry           = ls_vcldir_entry
      TABLES
        vclstruc_tab           = lt_vclstruc
        vclstrudep_tab         = lt_vclstrudep
        vclmf_tab              = lt_vclmf
      EXCEPTIONS
        viewcluster_not_found  = 1
        incomplete_viewcluster = 2
        OTHERS                 = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error in VIEWCLUSTER_GET_DEFINITION&apos; ).
    ENDIF.

    CLEAR ls_vcldir_entry-author.

    io_xml-&gt;add( iv_name = &apos;VCLDIR&apos;
                 ig_data = ls_vcldir_entry ).
    io_xml-&gt;add( iv_name = &apos;VLCSTRUC_TAB&apos;
                 ig_data = lt_vclstruc ).
    io_xml-&gt;add( iv_name = &apos;VCLSTRUDEP_TAB&apos;
                 ig_data = lt_vclstrudep ).
    io_xml-&gt;add( iv_name = &apos;VCLMF_TAB&apos;
                 ig_data = lt_vclmf ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_UDMO IMPLEMENTATION.
  METHOD access_free.

    &quot; Release the lock on the object.

    CALL FUNCTION &apos;RS_ACCESS_PERMISSION&apos;
      EXPORTING
        mode                     = &apos;FREE&apos;
        object                   = me-&gt;ms_object_type
        object_class             = me-&gt;c_transport_object_class
      EXCEPTIONS
        canceled_in_corr         = 1
        enqueued_by_user         = 2
        enqueue_system_failure   = 3
        illegal_parameter_values = 4
        locked_by_author         = 5
        no_modify_permission     = 6
        no_show_permission       = 7
        permission_failure       = 8
        request_language_denied  = 9
        OTHERS                   = 10.

    IF sy-subrc NE 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ELSE.
      rv_result = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD access_modify.

* You are reminded that mode modify is the same as insert, with one important difference:

* Mode INSERT is intended for newly created objects, for which a TADIR entry does not yet
* exist. In that case, the system shows a pop-up for the entry of the package, which isn&apos;t
* desirable when the SAPGUI is not available.

* In the context of abapGit, the package is known.

    CALL FUNCTION &apos;RS_ACCESS_PERMISSION&apos;
      EXPORTING
        authority_check          = abap_true
        global_lock              = abap_true
        mode                     = &apos;MODIFY&apos;
        object                   = me-&gt;ms_object_type
        object_class             = me-&gt;c_transport_object_class
      EXCEPTIONS
        canceled_in_corr         = 1
        enqueued_by_user         = 2
        enqueue_system_failure   = 3
        illegal_parameter_values = 4
        locked_by_author         = 5
        no_modify_permission     = 6
        no_show_permission       = 7
        permission_failure       = 8
        request_language_denied  = 9
        OTHERS                   = 10.

    IF sy-subrc NE 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ELSE.
      rv_result = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( is_item  =  is_item  iv_language = iv_language ).
    &quot; Conversion to Data model
    me-&gt;mv_data_model = is_item-obj_name.
    &quot; Default activation state is active
    me-&gt;mv_activation_state = c_active_state.
    &quot; Derive the data model&apos;s text object
    mv_text_object = &apos;UDMD&apos; &amp;&amp; is_item-obj_name.
    &quot; And set the text object to active
    mv_text_object+30(1) = mv_activation_state.
    mv_lxe_text_name = mv_text_object.

    &quot; Correction and Transport System object
    me-&gt;ms_object_type-objtype = c_correction_object_type.
    me-&gt;ms_object_type-objname = is_item-obj_name.
  ENDMETHOD.
  METHOD corr_insert.

    &quot; You are reminded that SUDM - Data Model has no part objects e.g. no LIMU
    &quot; Therefore global lock is always appropriate

    &quot; You are reminded that the master language (in TADIR) is taken from MV_LANGUAGE.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = me-&gt;ms_object_type
        object_class        = me-&gt;c_transport_object_class
        devclass            = iv_package
        master_language     = mv_language
        mode                = &apos;INSERT&apos;
        global_lock         = abap_true
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc = 1.
      zcx_abapgit_exception=&gt;raise( &apos;Cancelled&apos; ).
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RS_CORR_INSERT&apos; ).
    ENDIF.
  ENDMETHOD.
  METHOD deserialize_entities.

    DATA lt_udmo_entities TYPE STANDARD TABLE OF dm41s WITH DEFAULT KEY.
    DATA ls_udmo_entity LIKE LINE OF lt_udmo_entities.
    io_xml-&gt;read( EXPORTING iv_name = &apos;UDMO_ENTITIES&apos;
                  CHANGING  cg_data = lt_udmo_entities ).

    LOOP AT lt_udmo_entities INTO ls_udmo_entity.

      CALL FUNCTION &apos;SDU_DMO_ENT_PUT&apos;
        EXPORTING
          object   = ls_udmo_entity
        EXCEPTIONS
          ret_code = 0
          OTHERS   = 0.

    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_long_texts.

    TYPES BEGIN OF language_type.
    TYPES language TYPE dm40t-sprache.
    TYPES END OF language_type.

    DATA BEGIN OF ls_udmo_long_text.
    DATA language TYPE dm40t-sprache.
    DATA header   TYPE thead.
    DATA content TYPE xstring.
    DATA END OF ls_udmo_long_text.

    DATA lt_udmo_long_texts LIKE STANDARD TABLE OF ls_udmo_long_text.
    DATA ls_header TYPE thead.

    io_xml-&gt;read( EXPORTING iv_name = &apos;UDMO_LONG_TEXTS&apos;
                  CHANGING  cg_data = lt_udmo_long_texts ).

    LOOP AT lt_udmo_long_texts INTO ls_udmo_long_text.

      ls_udmo_long_text-header-tdfuser = sy-uname.
      ls_udmo_long_text-header-tdfdate = sy-datum.
      ls_udmo_long_text-header-tdftime = sy-uzeit.

      &quot; You are reminded that the target system may already have some texts in
      &quot; existence. So we determine the highest existent version.

      CLEAR ls_header-tdversion.

      SELECT MAX( dokversion )
      INTO ls_header-tdversion
      FROM dokhl
      WHERE id = me-&gt;c_lxe_text_type
      AND   object = me-&gt;mv_text_object
      AND   langu = ls_udmo_long_text-language.

      &quot; Increment the version
      ls_header-tdversion = ls_header-tdversion + 1.
      ls_udmo_long_text-header-tdversion = ls_header-tdversion.

      &quot; This function module takes care of the variation in text processing between various objects.
      CALL FUNCTION &apos;LXE_OBJ_DOKU_PUT_XSTRING&apos;
        EXPORTING
          slang   = me-&gt;mv_language
          tlang   = ls_udmo_long_text-language
          objtype = me-&gt;c_lxe_text_type
          objname = me-&gt;mv_lxe_text_name
          header  = ls_udmo_long_text-header
          content = ls_udmo_long_text-content.
    ENDLOOP.
  ENDMETHOD.
  METHOD deserialize_model.

    DATA ls_dm40l TYPE dm40l.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DM40L&apos;
                  CHANGING cg_data = ls_dm40l ).
    &quot; See SDU_MODEL_PUT
    GET TIME.

    ls_dm40l-flg_frame = abap_true.
    ls_dm40l-fstdate   = sy-datum.
    ls_dm40l-fsttime   = sy-uzeit.
    ls_dm40l-fstuser   = sy-uname.
    ls_dm40l-lstdate   = sy-datum.
    ls_dm40l-lsttime   = sy-uzeit.
    ls_dm40l-lstuser   = sy-uname.

    MODIFY dm40l FROM ls_dm40l.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SDU_MODEL_PUT&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD deserialize_short_texts.

    DATA lt_udmo_texts TYPE STANDARD TABLE OF ty_udmo_text_type WITH DEFAULT KEY.
    DATA ls_udmo_text  TYPE ty_udmo_text_type.
    DATA ls_dm40t TYPE dm40t.
    &quot; Deserialize the XML
    io_xml-&gt;read( EXPORTING iv_name = &apos;UDMO_TEXTS&apos;
                  CHANGING  cg_data = lt_udmo_texts ).

    &quot; For every text provided
    LOOP AT lt_udmo_texts INTO ls_udmo_text.

      &quot; Does the text already exist? This is the same logic as used
      &quot; in the FM SDU_MODEL_PUT
      SELECT SINGLE *
        FROM dm40t
        INTO ls_dm40t
        WHERE sprache  EQ ls_udmo_text-sprache
        AND   dmoid    EQ ls_udmo_text-dmoid
        AND   as4local EQ me-&gt;mv_activation_state.

      IF sy-subrc EQ 0.
        &quot; There is already an active description for this language
        &quot; but the provided description differs
        IF ls_dm40t-langbez NE ls_udmo_text-langbez.

          ls_dm40t-langbez = ls_udmo_text-langbez.
          ls_dm40t-lstdate = sy-datum.
          ls_dm40t-lsttime = sy-uzeit.
          ls_dm40t-lstuser = sy-uname.

          MODIFY dm40t FROM ls_dm40t.

        ENDIF.
      ELSE.

        &quot; There is no EXISTING active description in this language

        ls_dm40t-as4local = ls_udmo_text-as4local.
        ls_dm40t-dmoid    = ls_udmo_text-dmoid.
        ls_dm40t-langbez  = ls_udmo_text-langbez.
        ls_dm40t-lstdate  = sy-datum.
        ls_dm40t-lsttime  = sy-uzeit.
        ls_dm40t-lstuser  = sy-uname.
        ls_dm40t-sprache  = ls_udmo_text-sprache.
        INSERT dm40t FROM ls_dm40t.

      ENDIF.

    ENDLOOP.
  ENDMETHOD.
  METHOD is_name_permitted.

    &quot; It is unlikely that a serialised data model will have a name that is not permitted. However
    &quot; there may be reservations in TRESE which could prohibit the data model name.
    &quot; So to be safe, we check. Tx SD11 does this check.
    CALL FUNCTION &apos;SDU_SAA_CHECK&apos;
      EXPORTING
        obj_name   = me-&gt;ms_object_type-objname
        obj_type   = me-&gt;ms_object_type-objtype
      EXCEPTIONS
        wrong_type = 01.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD serialize_entities.

    DATA lt_udmo_entities TYPE STANDARD TABLE OF dm41s WITH DEFAULT KEY.
    FIELD-SYMBOLS &lt;ls_udmo_entity&gt; TYPE dm41s.

    SELECT * FROM dm41s
      INTO TABLE lt_udmo_entities
      WHERE dmoid EQ me-&gt;mv_data_model
      AND as4local EQ me-&gt;mv_activation_state.
    LOOP AT lt_udmo_entities ASSIGNING &lt;ls_udmo_entity&gt;.

      &quot; You are reminded that administrative information, such as last changed by user, date, time is not serialised.
      CLEAR &lt;ls_udmo_entity&gt;-lstuser.
      CLEAR &lt;ls_udmo_entity&gt;-lstdate.
      CLEAR &lt;ls_udmo_entity&gt;-lsttime.
      CLEAR &lt;ls_udmo_entity&gt;-fstuser.
      CLEAR &lt;ls_udmo_entity&gt;-fstdate.
      CLEAR &lt;ls_udmo_entity&gt;-fsttime.

    ENDLOOP.

    &quot; You are reminded that descriptions in other languages do not have to be in existence, although they may.
    IF lines( lt_udmo_entities ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;UDMO_ENTITIES&apos;
                   ig_data = lt_udmo_entities ).
    ENDIF.

  ENDMETHOD.
  METHOD serialize_long_texts.

    &quot; The model has short texts in multiple languages. These are held in DM40T.

    &quot; The model has a long description also in a master language, with other long descriptions
    &quot; maintained as translations using SE63 Translation Editor. All of these long texts are held in DOK*

    TYPES BEGIN OF ls_language_type.
    TYPES language TYPE dm40t-sprache.
    TYPES END OF ls_language_type.

    DATA BEGIN OF ls_udmo_long_text.
    DATA language TYPE dm40t-sprache.
    DATA header   TYPE thead.
    DATA content TYPE xstring.
    DATA END OF ls_udmo_long_text.

    DATA lt_udmo_long_texts LIKE STANDARD TABLE OF ls_udmo_long_text.
    DATA lt_udmo_languages TYPE STANDARD TABLE OF ls_language_type.
    DATA ls_udmo_language  LIKE LINE OF lt_udmo_languages.
    DATA: lv_error_status  TYPE lxestatprc.
    &quot; In which languages are the short texts are maintained.
    SELECT sprache AS language
      FROM dm40t
      INTO TABLE lt_udmo_languages
      WHERE dmoid    EQ me-&gt;mv_data_model
      AND   as4local EQ me-&gt;mv_activation_state
      ORDER BY sprache ASCENDING.                       &quot;#EC CI_NOFIRST

    &quot; For every language for which a short text is maintained,
    LOOP AT lt_udmo_languages INTO ls_udmo_language.

      CLEAR ls_udmo_long_text.
      CLEAR lv_error_status.

      ls_udmo_long_text-language = ls_udmo_language-language.

      &quot; You are reminded that this function gets the most recent version of the texts.
      CALL FUNCTION &apos;LXE_OBJ_DOKU_GET_XSTRING&apos;
        EXPORTING
          lang    = ls_udmo_language-language
          objtype = me-&gt;c_lxe_text_type
          objname = me-&gt;mv_lxe_text_name
        IMPORTING
          header  = ls_udmo_long_text-header
          content = ls_udmo_long_text-content
          pstatus = lv_error_status.

      CHECK lv_error_status EQ &apos;S&apos;. &quot;Success

      &quot; Administrative information is not serialised
      CLEAR ls_udmo_long_text-header-tdfuser.
      CLEAR ls_udmo_long_text-header-tdfdate.
      CLEAR ls_udmo_long_text-header-tdftime.

      CLEAR ls_udmo_long_text-header-tdluser.
      CLEAR ls_udmo_long_text-header-tdldate.
      CLEAR ls_udmo_long_text-header-tdltime.

      APPEND ls_udmo_long_text TO lt_udmo_long_texts.

    ENDLOOP.

    &quot; You are reminded that long texts do not have to be in existence
    IF lines( lt_udmo_long_texts ) GT 0.
      io_xml-&gt;add( iv_name = &apos;UDMO_LONG_TEXTS&apos;
                   ig_data = lt_udmo_long_texts ).
    ENDIF.
  ENDMETHOD.
  METHOD serialize_model.

    DATA ls_dm40l TYPE dm40l.

    &quot; See SDU_MODEL_GET.
    SELECT SINGLE *
    FROM dm40l
    INTO ls_dm40l
    WHERE dmoid    EQ me-&gt;mv_data_model
    AND   as4local EQ me-&gt;mv_activation_state.
    IF sy-subrc NE 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from UDMO - model serialisation&apos; ).
    ENDIF.

    &quot; You are reminded that administrative data is not serialised.
    CLEAR ls_dm40l-lstdate.
    CLEAR ls_dm40l-lsttime.
    CLEAR ls_dm40l-lstuser.
    CLEAR ls_dm40l-fstdate.
    CLEAR ls_dm40l-fsttime.
    CLEAR ls_dm40l-fstuser.

    io_xml-&gt;add( iv_name = &apos;DM40L&apos;
                 ig_data = ls_dm40l ).

  ENDMETHOD.
  METHOD serialize_short_texts.

    DATA lt_udmo_texts TYPE STANDARD TABLE OF ty_udmo_text_type WITH DEFAULT KEY.
    &quot; You are reminded that administrative information, such as last changed by user, date, time is not serialised.

    &quot; You are reminded that active short texts of all (existent) languages are serialised.

    SELECT sprache dmoid as4local langbez
      FROM dm40t
      INTO CORRESPONDING FIELDS OF TABLE lt_udmo_texts
      WHERE dmoid    EQ me-&gt;mv_data_model
      AND   as4local EQ me-&gt;mv_activation_state
      ORDER BY sprache ASCENDING.                       &quot;#EC CI_NOFIRST

    &quot; You are reminded that descriptions in other languages do not have to be in existence.
    IF lines( lt_udmo_texts ) GT 0.
      io_xml-&gt;add( iv_name = &apos;UDMO_TEXTS&apos;
                   ig_data = lt_udmo_texts ).
    ENDIF.
  ENDMETHOD.
  METHOD update_tree.

    CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
      EXPORTING
        object    = me-&gt;mv_data_model
        operation = &apos;INSERT&apos;
        type      = me-&gt;c_correction_object_type.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lstuser INTO rv_user
      FROM  dm40l
      WHERE  dmoid    = me-&gt;mv_data_model
      AND    as4local = me-&gt;mv_activation_state.

    IF sy-subrc NE 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

* You are reminded that this function model checks for
*  - permissions
*  - locks
*  - connection to transport and correction system
*  - deletion of data model, model relations and all documentation
*  - update of object tree
*  - releasing of lock

    CALL FUNCTION &apos;RPY_DATAMODEL_DELETE&apos;
      EXPORTING
        model_name       = me-&gt;mv_data_model
      EXCEPTIONS
        cancelled        = 1
        permission_error = 2
        not_found        = 3
        is_used          = 4
        OTHERS           = 5.

    IF sy-subrc NE 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

* You are reminded that this method checks for
*  - validity of data model name with regard to naming conventions
*  - permissions and locks
*  - connection to transport and correction system
*  - insert of data model, model relations and all documentation
*  - update of object tree
*  - releasing of lock
* Is the data model name compliant with naming conventions?
    is_name_permitted( ).

* Access Permission granted?
    access_modify( ).

* Connection to transport and correction system
    corr_insert( iv_package ).

* Insert the data model, relations and documentation
    TRY.
        deserialize_model( io_xml ).
        deserialize_entities( io_xml ).
        deserialize_short_texts( io_xml ).
        deserialize_long_texts( io_xml ).
        update_tree( ).
        access_free( ).

      CATCH zcx_abapgit_exception.

        me-&gt;access_free( ).

        zcx_abapgit_exception=&gt;raise( &apos;Error in deserialisation of UDMO&apos; ).
    ENDTRY.

    &quot; You are reminded that data models are not relevant for activation.
  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    &quot;  See Function Module SDU_MODEL_EXISTS

    SELECT COUNT( * ) FROM  dm40l
           WHERE  dmoid     = me-&gt;mv_data_model
           AND    as4local  = me-&gt;mv_activation_state.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA lv_date TYPE dats.
    DATA lv_time TYPE tims.
    SELECT SINGLE lstdate lsttime FROM dm40l
      INTO (lv_date, lv_time)
           WHERE  dmoid     = me-&gt;mv_data_model
           AND    as4local  = me-&gt;mv_activation_state.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for(
      iv_lock_object = &apos;ESDUM&apos;
      iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    &quot; The function module listed below do not open a new window - so we revert to BDC.
    &quot;    CALL FUNCTION &apos;SDU_MODEL_SHOW&apos;
    &quot;    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;

    DATA lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPMUD00&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0100&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=SHOW&apos;.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;RSUD3-DATM&apos;.
    &lt;ls_bdcdata&gt;-fval = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;RSUD3-OBJ_KEY&apos;.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode                 = &apos;SD11&apos;
        mode_val              = &apos;E&apos;
      TABLES
        using_tab             = lt_bdcdata
      EXCEPTIONS
        system_failure        = 1
        communication_failure = 2
        resource_failure      = 3
        OTHERS                = 4
        ##fm_subrc_ok.                                                   &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    serialize_model( io_xml ).
    me-&gt;serialize_entities( io_xml  ).
    me-&gt;serialize_short_texts( io_xml ).
    me-&gt;serialize_long_texts( io_xml ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_ucsa IMPLEMENTATION.
  METHOD clear_dynamic_fields.

    FIELD-SYMBOLS: &lt;lg_header&gt; TYPE any.
    ASSIGN COMPONENT &apos;HEADER&apos; OF STRUCTURE cg_complete_comm_assembly
           TO &lt;lg_header&gt;.
    ASSERT sy-subrc = 0.

    clear_field(
      EXPORTING iv_fieldname = &apos;CREATEDBY&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

    clear_field(
      EXPORTING iv_fieldname = &apos;CREATEDON&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

    clear_field(
      EXPORTING iv_fieldname = &apos;CREATEDAT&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

    clear_field(
      EXPORTING iv_fieldname = &apos;CHANGEDBY&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

    clear_field(
      EXPORTING iv_fieldname = &apos;CHANGEDON&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

    clear_field(
      EXPORTING iv_fieldname = &apos;CHANGEDAT&apos;
      CHANGING  cg_header    = &lt;lg_header&gt; ).

  ENDMETHOD.
  METHOD clear_field.

    FIELD-SYMBOLS: &lt;lg_field&gt; TYPE any.

    ASSIGN COMPONENT iv_fieldname OF STRUCTURE cg_header
           TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    CLEAR &lt;lg_field&gt;.

  ENDMETHOD.
  METHOD get_persistence.

    CALL METHOD (&apos;CL_UCON_SA_DB_PERSIST&apos;)=&gt;(&apos;IF_UCON_SA_PERSIST~GET_INSTANCE&apos;)
      EXPORTING
        id       = iv_id
      RECEIVING
        instance = ro_persistence.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_id          TYPE ty_id,
          lx_root        TYPE REF TO cx_root,
          lv_text        TYPE string,
          lo_persistence TYPE REF TO object.

    TRY.
        lv_id = ms_item-obj_name.

        lo_persistence = get_persistence( lv_id ).

        CALL METHOD lo_persistence-&gt;(&apos;IF_UCON_SA_PERSIST~DELETE&apos;)
          EXPORTING
            version = zif_abapgit_definitions=&gt;c_version-active.

      CATCH cx_root INTO lx_root.
        lv_text = lx_root-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_id                     TYPE ty_id,
          lx_root                   TYPE REF TO cx_root,
          lv_text                   TYPE string,
          lo_persistence            TYPE REF TO object,
          lr_complete_comm_assembly TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_complete_comm_assembly&gt; TYPE any.

    TRY.
        CREATE DATA lr_complete_comm_assembly TYPE (&apos;UCONSERVASCOMPLETE&apos;).
        ASSIGN lr_complete_comm_assembly-&gt;* TO &lt;lg_complete_comm_assembly&gt;.
        ASSERT sy-subrc = 0.

        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;UCSA&apos;
          CHANGING
            cg_data = &lt;lg_complete_comm_assembly&gt; ).

        lv_id = ms_item-obj_name.

        lo_persistence = get_persistence( lv_id ).

        CALL METHOD lo_persistence-&gt;(&apos;IF_UCON_SA_PERSIST~CREATE&apos;).

        CALL METHOD lo_persistence-&gt;(&apos;IF_UCON_SA_PERSIST~SAVE&apos;)
          EXPORTING
            sa      = &lt;lg_complete_comm_assembly&gt;
            version = zif_abapgit_definitions=&gt;c_version-active.

        tadir_insert( iv_package ).

      CATCH cx_root INTO lx_root.
        lv_text = lx_root-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_id          TYPE ty_id,
          lo_persistence TYPE REF TO object.

    lv_id = ms_item-obj_name.

    TRY.
        lo_persistence = get_persistence( lv_id ).

        &quot; Interface IF_UCON_SA_PERSIST and other objects are not present
        &quot; in lower Netweaver realeses. Therefore we have to call them
        &quot; dynamically to be downward comapatible.

        CALL METHOD lo_persistence-&gt;(&apos;IF_UCON_SA_PERSIST~LOAD&apos;)
          EXPORTING
            version  = zif_abapgit_definitions=&gt;c_version-active
            language = sy-langu.

      CATCH cx_root.
        rv_bool = abap_false.
        RETURN.
    ENDTRY.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_TOOL_ACCESS&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_id                     TYPE ty_id,
          lx_root                   TYPE REF TO cx_root,
          lv_text                   TYPE string,
          lo_persistence            TYPE REF TO object,
          lr_complete_comm_assembly TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_complete_comm_assembly&gt; TYPE any.
    lv_id = ms_item-obj_name.

    TRY.
        CREATE DATA lr_complete_comm_assembly TYPE (&apos;UCONSERVASCOMPLETE&apos;).
        ASSIGN lr_complete_comm_assembly-&gt;* TO &lt;lg_complete_comm_assembly&gt;.
        ASSERT sy-subrc = 0.

        lo_persistence = get_persistence( lv_id ).

        CALL METHOD lo_persistence-&gt;(&apos;IF_UCON_SA_PERSIST~LOAD&apos;)
          EXPORTING
            version  = zif_abapgit_definitions=&gt;c_version-active
            language = sy-langu
          IMPORTING
            sa       = &lt;lg_complete_comm_assembly&gt;.

        clear_dynamic_fields( CHANGING cg_complete_comm_assembly = &lt;lg_complete_comm_assembly&gt; ).

        io_xml-&gt;add( iv_name = &apos;UCSA&apos;
                     ig_data = &lt;lg_complete_comm_assembly&gt; ).

      CATCH cx_root INTO lx_root.
        lv_text = lx_root-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_type IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    TRY.
        read( ).
        rv_bool = abap_true.
      CATCH zcx_abapgit_not_found zcx_abapgit_exception.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.

  METHOD read.

    DATA: lv_typdname  TYPE rsedd0-typegroup,
          lt_psmodisrc TYPE TABLE OF smodisrc,
          lt_psmodilog TYPE TABLE OF smodilog,
          lt_ptrdir    TYPE TABLE OF trdir.
    SELECT SINGLE ddtext FROM ddtypet
      INTO ev_ddtext
      WHERE typegroup = ms_item-obj_name
      AND ddlanguage = mv_language.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_abapgit_not_found.
    ENDIF.

    lv_typdname = ms_item-obj_name.
    CALL FUNCTION &apos;TYPD_GET_OBJECT&apos;
      EXPORTING
        typdname          = lv_typdname
      TABLES
        psmodisrc         = lt_psmodisrc
        psmodilog         = lt_psmodilog
        psource           = et_source
        ptrdir            = lt_ptrdir
      EXCEPTIONS
        version_not_found = 1
        reps_not_exist    = 2
        OTHERS            = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from TYPD_GET_OBJECT&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_ddtext TYPE ddtypet-ddtext,
          lt_source TYPE abaptxt255_tab.
    TRY.
        read( IMPORTING
                ev_ddtext = lv_ddtext
                et_source = lt_source ).
      CATCH zcx_abapgit_not_found.
        RETURN.
    ENDTRY.

    io_xml-&gt;add( iv_name = &apos;DDTEXT&apos;
                 ig_data = lv_ddtext ).

    mo_files-&gt;add_abap( lt_source ).

  ENDMETHOD.

  METHOD create.

    DATA: lv_progname  TYPE reposrc-progname,
          lv_typegroup TYPE rsedd0-typegroup.
    lv_typegroup = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_TYGR_INSERT_SOURCES&apos;
      EXPORTING
        typegroupname        = lv_typegroup
        ddtext               = iv_ddtext
        corrnum              = &apos;&apos;
        devclass             = iv_devclass
      TABLES
        source               = it_source
      EXCEPTIONS
        already_exists       = 1
        not_executed         = 2
        permission_failure   = 3
        object_not_specified = 4
        illegal_name         = 5
        OTHERS               = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_TYGR_INSERT_SOURCES&apos; ).
    ENDIF.

    CONCATENATE c_prefix lv_typegroup INTO lv_progname.
    UPDATE progdir SET uccheck = abap_true
      WHERE name = lv_progname.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error setting uccheck&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_ddtext    TYPE ddtypet-ddtext,
          lt_source    TYPE abaptxt255_tab,
          lv_progname  TYPE reposrc-progname,
          lv_typegroup TYPE rsedd0-typegroup.
    lv_typegroup = ms_item-obj_name.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DDTEXT&apos;
                  CHANGING cg_data = lv_ddtext ).

    lt_source = mo_files-&gt;read_abap( ).

    IF zif_abapgit_object~exists( ) = abap_false.
      create( iv_ddtext   = lv_ddtext
              it_source   = lt_source
              iv_devclass = iv_package ).
    ELSE.
      CONCATENATE c_prefix lv_typegroup INTO lv_progname.
      INSERT REPORT lv_progname FROM lt_source STATE &apos;I&apos;.
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;G&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4
        dialog_needed        = 5
        OTHERS               = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error deleting TYPE&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    jump_se11( iv_radio = &apos;RSRD1-TYMA&apos;
               iv_field = &apos;RSRD1-TYMA_VAL&apos; ).
  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_ttyp IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd40l
      INTO (lv_date, lv_time)
      WHERE typename = ms_item-obj_name
      AND as4local = &apos;A&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd40l INTO rv_user
      WHERE typename = ms_item-obj_name
      AND as4local = &apos;A&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_typename TYPE dd40l-typename.
    SELECT SINGLE typename FROM dd40l INTO lv_typename
      WHERE typename = ms_item-obj_name
      AND as4local = &apos;A&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-DDTYPE&apos;
               iv_field = &apos;RSRD1-DDTYPE_VAL&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;A&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, TTYP&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          lt_dd42v TYPE dd42v_tab,
          lt_dd43v TYPE dd43v_tab,
          ls_dd40v TYPE dd40v.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
      EXPORTING
        name          = lv_name
        state         = &apos;A&apos;
        langu         = mv_language
      IMPORTING
        dd40v_wa      = ls_dd40v
      TABLES
        dd42v_tab     = lt_dd42v
        dd43v_tab     = lt_dd43v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_TTYP_GET&apos; ).
    ENDIF.
    IF ls_dd40v IS INITIAL.
      RETURN. &quot; does not exist in system
    ENDIF.

    CLEAR: ls_dd40v-as4user,
           ls_dd40v-as4date,
           ls_dd40v-as4time.

    IF NOT ls_dd40v-rowkind IS INITIAL.
      CLEAR ls_dd40v-typelen.
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;DD40V&apos;
                 ig_data = ls_dd40v ).
    io_xml-&gt;add( iv_name = &apos;DD42V&apos;
                 ig_data = lt_dd42v ).
    io_xml-&gt;add( iv_name = &apos;DD43V&apos;
                 ig_data = lt_dd43v ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          lt_dd42v TYPE dd42v_tab,
          lt_dd43v TYPE dd43v_tab,
          ls_dd40v TYPE dd40v.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD40V&apos;
                  CHANGING cg_data = ls_dd40v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD42V&apos;
                  CHANGING cg_data = lt_dd42v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD43V&apos;
                  CHANGING cg_data = lt_dd43v ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name. &quot; type conversion

    CALL FUNCTION &apos;DDIF_TTYP_PUT&apos;
      EXPORTING
        name              = lv_name
        dd40v_wa          = ls_dd40v
      TABLES
        dd42v_tab         = lt_dd42v
        dd43v_tab         = lt_dd43v
      EXCEPTIONS
        ttyp_not_found    = 1
        name_inconsistent = 2
        ttyp_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_TTYP_PUT&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_TRAN IMPLEMENTATION.
  METHOD add_data.

    DATA: ls_bcdata LIKE LINE OF mt_bcdata.

    ls_bcdata-fnam = iv_fnam.
    ls_bcdata-fval = iv_fval.
    APPEND ls_bcdata TO mt_bcdata.

  ENDMETHOD.
  METHOD call_se93.

    DATA: lt_message TYPE STANDARD TABLE OF bdcmsgcoll.

    FIELD-SYMBOLS: &lt;ls_message&gt; TYPE bdcmsgcoll.
    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      EXPORTING
        tcode     = &apos;SE93&apos;
        mode_val  = &apos;N&apos;
      TABLES
        using_tab = mt_bcdata
        mess_tab  = lt_message
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error deserializing { ms_item-obj_type } { ms_item-obj_name }| ).
    ENDIF.

    LOOP AT lt_message ASSIGNING &lt;ls_message&gt;
                       WHERE msgtyp CA &apos;EAX&apos;.

      MESSAGE ID     &lt;ls_message&gt;-msgid
              TYPE   &lt;ls_message&gt;-msgtyp
              NUMBER &lt;ls_message&gt;-msgnr
              WITH   &lt;ls_message&gt;-msgv1 &lt;ls_message&gt;-msgv2 &lt;ls_message&gt;-msgv3 &lt;ls_message&gt;-msgv4
              INTO sy-msgli.
      zcx_abapgit_exception=&gt;raise_t100( ).

    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_oo_transaction.

    &quot; You should remember that we don&apos;t use batch input just for fun,
    &quot; but because FM RPY_TRANSACTION_INSERT doesn&apos;t support OO transactions.

    DATA: ls_bcdata  TYPE bdcdata.
    CLEAR mt_bcdata.

    ls_bcdata-program  = &apos;SAPLSEUK&apos;.
    ls_bcdata-dynpro   = &apos;0390&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = &apos;TSTC-TCODE&apos;
              iv_fval = is_tstc-tcode ).

    IF zif_abapgit_object~exists( ) = abap_true.

      add_data( iv_fnam = &apos;BDC_OKCODE&apos;
                iv_fval = &apos;=CHNG&apos; ).

    ELSE.

      add_data( iv_fnam = &apos;BDC_OKCODE&apos;
                iv_fval = &apos;=ADD&apos; ).

    ENDIF.

    ls_bcdata-program  = &apos;SAPLSEUK&apos;.
    ls_bcdata-dynpro   = &apos;0300&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = &apos;TSTCT-TTEXT&apos;
              iv_fval     = is_tstct-ttext ).

    add_data( iv_fnam     = &apos;RSSTCD-S_CLASS&apos;
              iv_fval     = &apos;X&apos; ).

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=ENTR&apos; ).

    ls_bcdata-program  = &apos;SAPLSEUK&apos;.
    ls_bcdata-dynpro   = &apos;0360&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = &apos;RSSTCD-S_TRFRAME&apos;
              iv_fval     = is_rsstcd-s_trframe ).

    add_data( iv_fnam     = &apos;RSSTCD-S_UPDTASK&apos;
              iv_fval     = is_rsstcd-s_updtask ).

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=TR_FRAMEWORK&apos; ).

    ls_bcdata-program  = &apos;SAPLSEUK&apos;.
    ls_bcdata-dynpro   = &apos;0360&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = &apos;RSSTCD-CLASSNAME&apos;
              iv_fval     = is_rsstcd-classname ).

    add_data( iv_fnam     = &apos;RSSTCD-METHOD&apos;
              iv_fval     = is_rsstcd-method ).

    IF is_rsstcd-s_local IS NOT INITIAL.
      add_data( iv_fnam     = &apos;RSSTCD-S_LOCAL&apos;
                iv_fval     = is_rsstcd-s_local ).
    ENDIF.

    IF is_rsstcd-s_updlok IS NOT INITIAL.
      add_data( iv_fnam     = &apos;RSSTCD-S_UPDLOK&apos;
                iv_fval     = is_rsstcd-s_updlok ).
    ENDIF.

    add_data( iv_fnam     = &apos;TSTC-PGMNA&apos;
              iv_fval     = is_tstc-pgmna ).

    IF is_tstcc-s_webgui = &apos;2&apos;.

      add_data( iv_fnam     = &apos;G_IAC_EWT&apos;
                iv_fval     = abap_true ).

      add_data( iv_fnam = &apos;BDC_OKCODE&apos;
                iv_fval = &apos;MAKE_PROFI&apos; ).

      ls_bcdata-program  = &apos;SAPLSEUK&apos;.
      ls_bcdata-dynpro   = &apos;0360&apos;.
      ls_bcdata-dynbegin = &apos;X&apos;.
      APPEND ls_bcdata TO mt_bcdata.

    ELSEIF is_tstcc-s_webgui IS NOT INITIAL.

      add_data( iv_fnam     = &apos;TSTCC-S_WEBGUI&apos;
                iv_fval     = is_tstcc-s_webgui ).

    ENDIF.

    IF is_tstcc-s_pervas IS NOT INITIAL.
      add_data( iv_fnam     = &apos;TSTCC-S_PERVAS&apos;
                iv_fval     = is_tstcc-s_pervas ).
    ENDIF.

    IF is_tstcc-s_service IS NOT INITIAL.
      add_data( iv_fnam     = &apos;TSTCC-S_SERVICE&apos;
                iv_fval     = is_tstcc-s_service ).
    ENDIF.

    IF is_tstcc-s_platin IS NOT INITIAL.
      add_data( iv_fnam     = &apos;TSTCC-S_PLATIN&apos;
                iv_fval     = is_tstcc-s_platin ).
    ENDIF.

    IF is_tstcc-s_win32 IS NOT INITIAL.
      add_data( iv_fnam     = &apos;TSTCC-S_WIN32&apos;
                iv_fval     = is_tstcc-s_win32 ).
    ENDIF.

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=WB_SAVE&apos; ).

    ls_bcdata-program  = &apos;SAPLSTRD&apos;.
    ls_bcdata-dynpro   = &apos;0100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = &apos;KO007-L_DEVCLASS&apos;
              iv_fval     = iv_package ).

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=ADD&apos; ).

    ls_bcdata-program  = &apos;BDC_OKCODE&apos;.
    ls_bcdata-dynpro   = &apos;0360&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=WB_BACK&apos; ).

    ls_bcdata-program  = &apos;BDC_OKCODE&apos;.
    ls_bcdata-dynpro   = &apos;0360&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = &apos;BDC_OKCODE&apos;
              iv_fval = &apos;=WB_BACK&apos; ).

    call_se93( ).

  ENDMETHOD.
  METHOD deserialize_texts.

    DATA lt_tpool_i18n TYPE TABLE OF tstct.

    FIELD-SYMBOLS &lt;ls_tpool&gt; LIKE LINE OF lt_tpool_i18n.
    &quot; Read XML-files data
    io_xml-&gt;read( EXPORTING iv_name = &apos;I18N_TPOOL&apos;
                  CHANGING  cg_data = lt_tpool_i18n ).

    &quot; Force t-code name (security reasons)
    LOOP AT lt_tpool_i18n ASSIGNING &lt;ls_tpool&gt;.
      &lt;ls_tpool&gt;-tcode = ms_item-obj_name.
    ENDLOOP.

    IF lines( lt_tpool_i18n ) &gt; 0.
      MODIFY tstct FROM TABLE lt_tpool_i18n.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Update of t-code translations failed&apos; ).
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD serialize_texts.

    DATA lt_tpool_i18n TYPE TABLE OF tstct.

    &quot; Skip master language - it was already serialized
    &quot; Don&apos;t serialize t-code itself
    SELECT sprsl ttext
      INTO CORRESPONDING FIELDS OF TABLE lt_tpool_i18n
      FROM tstct
      WHERE sprsl &lt;&gt; mv_language
      AND   tcode = ms_item-obj_name.                   &quot;#EC CI_GENBUFF

    IF lines( lt_tpool_i18n ) &gt; 0.
      SORT lt_tpool_i18n BY sprsl ASCENDING.
      io_xml-&gt;add( iv_name = &apos;I18N_TPOOL&apos;
                   ig_data = lt_tpool_i18n ).
    ENDIF.

  ENDMETHOD.
  METHOD set_oo_parameters.

    DATA: ls_param LIKE LINE OF it_rsparam.

    IF cs_rsstcd-call_tcode = c_oo_tcode.
      cs_rsstcd-s_trframe = c_true.
      LOOP AT it_rsparam INTO ls_param.
        CASE ls_param-field.
          WHEN c_oo_frclass.
            cs_rsstcd-classname = ls_param-value.
          WHEN c_oo_frmethod.
            cs_rsstcd-method   = ls_param-value.
          WHEN c_oo_frupdtask.
            IF ls_param-value = c_oo_synchron.
              cs_rsstcd-s_upddir  = c_true.
              cs_rsstcd-s_updtask = c_false.
              cs_rsstcd-s_updlok  = c_false.
            ELSEIF ls_param-value = c_oo_asynchron.
              cs_rsstcd-s_upddir  = c_false.
              cs_rsstcd-s_updtask = c_true.
              cs_rsstcd-s_updlok  = c_false.
            ELSE.
              cs_rsstcd-s_upddir  = c_false.
              cs_rsstcd-s_updtask = c_false.
              cs_rsstcd-s_updlok  = c_true.
            ENDIF.
        ENDCASE.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD split_parameters.
* see subroutine split_parameters in include LSEUKF01

    DATA: lv_off       TYPE i,
          lv_param_beg TYPE i,
          lv_length    TYPE i,
          ls_param     LIKE LINE OF ct_rsparam.

    FIELD-SYMBOLS &lt;lg_f&gt; TYPE any.
    CLEAR cs_rsstcd-s_vari.

    IF cs_tstcp-param(1) = &apos;\&apos;.             &quot; OO-Transaktion ohne FR
      split_parameters_comp( EXPORTING ig_type = c_oo_program
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_tstc-pgmna ).
      split_parameters_comp( EXPORTING ig_type = c_oo_class
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_rsstcd-classname ).
      split_parameters_comp( EXPORTING ig_type = c_oo_method
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_rsstcd-method ).

      IF NOT cs_tstc-pgmna IS INITIAL.
        cs_rsstcd-s_local = c_true.
      ENDIF.
      RETURN.
    ELSEIF cs_tstcp-param(1) = &apos;@&apos;.         &quot; Transaktionsvariante
      cs_rsstcd-s_vari = c_true.
      IF cs_tstcp-param(2) = &apos;@@&apos;.
        cs_rsstcd-s_ind_vari = c_true.
        lv_off = 2.
      ELSE.
        CLEAR cs_rsstcd-s_ind_vari.
        lv_off = 1.
      ENDIF.
      IF cs_tstcp-param CA &apos; &apos;.
      ENDIF.
      sy-fdpos = sy-fdpos - lv_off.
      IF sy-fdpos &gt; 0.
        cs_rsstcd-call_tcode = cs_tstcp-param+lv_off(sy-fdpos).
        sy-fdpos = sy-fdpos + 1 + lv_off.
        cs_rsstcd-variant = cs_tstcp-param+sy-fdpos.
      ENDIF.
    ELSEIF cs_tstcp-param(1) = &apos;/&apos;.
      cs_rsstcd-st_tcode = c_true.
      cs_rsstcd-st_prog  = space.
      IF cs_tstcp-param+1(1) = &apos;*&apos;.
        cs_rsstcd-st_skip_1 = c_true.
      ELSE.
        CLEAR cs_rsstcd-st_skip_1.
      ENDIF.
      IF cs_tstcp-param CA &apos; &apos;.
      ENDIF.
      lv_param_beg = sy-fdpos + 1.
      sy-fdpos = sy-fdpos - 2.
      IF sy-fdpos &gt; 0.
        cs_rsstcd-call_tcode = cs_tstcp-param+2(sy-fdpos).
      ENDIF.
      SHIFT cs_tstcp-param BY lv_param_beg PLACES.
    ELSE.
      cs_rsstcd-st_tcode = space.
      cs_rsstcd-st_prog  = c_true.
    ENDIF.

    DO 254 TIMES.
      IF cs_tstcp-param = space.
        EXIT.
      ENDIF.
      CLEAR ls_param.
      IF cs_tstcp-param CA &apos;=&apos;.
        CHECK sy-fdpos &lt;&gt; 0.
        ASSIGN cs_tstcp-param(sy-fdpos) TO &lt;lg_f&gt;.
        ls_param-field = &lt;lg_f&gt;.
        IF ls_param-field(1) = space.
          SHIFT ls_param-field.
        ENDIF.
        sy-fdpos = sy-fdpos + 1.
        SHIFT cs_tstcp-param BY sy-fdpos PLACES.
        IF cs_tstcp-param CA &apos;;&apos;.
          IF sy-fdpos &lt;&gt; 0.
            ASSIGN cs_tstcp-param(sy-fdpos) TO &lt;lg_f&gt;.
            ls_param-value = &lt;lg_f&gt;.
            IF ls_param-value(1) = space.
              SHIFT ls_param-value.
            ENDIF.
          ENDIF.
          sy-fdpos = sy-fdpos + 1.
          SHIFT cs_tstcp-param BY sy-fdpos PLACES.
          APPEND ls_param TO ct_rsparam.
        ELSE.
          lv_length = strlen( cs_tstcp-param ).
          CHECK lv_length &gt; 0.
          ASSIGN cs_tstcp-param(lv_length) TO &lt;lg_f&gt;.
          ls_param-value = &lt;lg_f&gt;.
          IF ls_param-value(1) = space.
            SHIFT ls_param-value.
          ENDIF.
          lv_length = lv_length + 1.
          SHIFT cs_tstcp-param BY lv_length PLACES.
          APPEND ls_param TO ct_rsparam.
        ENDIF.
      ENDIF.
    ENDDO.

    set_oo_parameters(
      EXPORTING it_rsparam = ct_rsparam
      CHANGING cs_rsstcd = cs_rsstcd ).

  ENDMETHOD.
  METHOD split_parameters_comp.
    DATA: lv_off TYPE i.

    IF ig_param CS ig_type.
      lv_off = sy-fdpos + strlen( ig_type ).
      cg_value = ig_param+lv_off.
      IF cg_value CA &apos;\&apos;.
        CLEAR cg_value+sy-fdpos.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_transaction TYPE tstc-tcode.
    lv_transaction = ms_item-obj_name.

    CALL FUNCTION &apos;RPY_TRANSACTION_DELETE&apos;
      EXPORTING
        transaction      = lv_transaction
      EXCEPTIONS
        not_excecuted    = 1
        object_not_found = 0
        OTHERS           = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RPY_TRANSACTION_DELETE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    CONSTANTS: lc_hex_tra TYPE x VALUE &apos;00&apos;,
*               c_hex_men TYPE x VALUE &apos;01&apos;,
               lc_hex_par TYPE x VALUE &apos;02&apos;,
               lc_hex_rep TYPE x VALUE &apos;80&apos;,
*               c_hex_rpv TYPE x VALUE &apos;10&apos;,
               lc_hex_obj TYPE x VALUE &apos;08&apos;.

    DATA: lv_dynpro       TYPE d020s-dnum,
          ls_tstc         TYPE tstc,
          lv_type         TYPE rglif-docutype,
          ls_tstct        TYPE tstct,
          ls_tstcc        TYPE tstcc,
          ls_tstcp        TYPE tstcp,
          lt_param_values TYPE tty_param_values,
          ls_rsstcd       TYPE rsstcd.
    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TSTC&apos;
                  CHANGING cg_data = ls_tstc ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSTCC&apos;
                  CHANGING cg_data = ls_tstcc ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSTCT&apos;
                  CHANGING cg_data = ls_tstct ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSTCP&apos;
                  CHANGING cg_data = ls_tstcp ).

    lv_dynpro = ls_tstc-dypno.

    CASE ls_tstc-cinfo.
      WHEN lc_hex_tra.
        lv_type = ststc_c_type_dialog.
      WHEN lc_hex_rep.
        lv_type = ststc_c_type_report.
      WHEN lc_hex_par.
        lv_type = ststc_c_type_parameters.
      WHEN lc_hex_obj.
        lv_type = ststc_c_type_object.
* todo, or ststc_c_type_variant?
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;Transaction, unknown CINFO&apos; ).
    ENDCASE.

    IF ls_tstcp IS NOT INITIAL.
      split_parameters(
        CHANGING
          ct_rsparam = lt_param_values
          cs_rsstcd  = ls_rsstcd
          cs_tstcp   = ls_tstcp
          cs_tstc    = ls_tstc ).
    ENDIF.

    CASE lv_type.
      WHEN ststc_c_type_object.

        deserialize_oo_transaction( iv_package      = iv_package
                                    is_tstc         = ls_tstc
                                    is_tstcc        = ls_tstcc
                                    is_tstct        = ls_tstct
                                    is_tstcp        = ls_tstcp
                                    it_param_values = lt_param_values
                                    is_rsstcd       = ls_rsstcd ).

      WHEN OTHERS.

        CALL FUNCTION &apos;RPY_TRANSACTION_INSERT&apos;
          EXPORTING
            transaction             = ls_tstc-tcode
            program                 = ls_tstc-pgmna
            dynpro                  = lv_dynpro
            language                = mv_language
            development_class       = iv_package
            transaction_type        = lv_type
            shorttext               = ls_tstct-ttext
            called_transaction      = ls_rsstcd-call_tcode
            called_transaction_skip = ls_rsstcd-st_skip_1
            variant                 = ls_rsstcd-variant
            cl_independend          = ls_rsstcd-s_ind_vari
            html_enabled            = ls_tstcc-s_webgui
            java_enabled            = ls_tstcc-s_platin
            wingui_enabled          = ls_tstcc-s_win32
          TABLES
            param_values            = lt_param_values
          EXCEPTIONS
            cancelled               = 1
            already_exist           = 2
            permission_error        = 3
            name_not_allowed        = 4
            name_conflict           = 5
            illegal_type            = 6
            object_inconsistent     = 7
            db_access_error         = 8
            OTHERS                  = 9.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;Error from RPY_TRANSACTION_INSERT&apos; ).
        ENDIF.

    ENDCASE.

    &quot; Texts deserializing (translations)
    deserialize_texts( io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_tcode TYPE tstc-tcode.
    SELECT SINGLE tcode FROM tstc INTO lv_tcode
      WHERE tcode = ms_item-obj_name.                   &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |TN{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EEUDB&apos;
                                            iv_argument    = lv_object ).
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.
    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPLSEUK&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0390&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=SHOW&apos;.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;TSTC-TCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode                 = &apos;SE93&apos;
        mode_val              = &apos;E&apos;
      TABLES
        using_tab             = lt_bdcdata
      EXCEPTIONS
        system_failure        = 1
        communication_failure = 2
        resource_failure      = 3
        OTHERS                = 4
        ##fm_subrc_ok.    &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_transaction TYPE tstc-tcode,
          lt_tcodes      TYPE TABLE OF tstc,
          ls_tcode       LIKE LINE OF lt_tcodes,
          ls_tstct       TYPE tstct,
          ls_tstcp       TYPE tstcp,
          lt_gui_attr    TYPE TABLE OF tstcc,
          ls_gui_attr    LIKE LINE OF lt_gui_attr.
    lv_transaction = ms_item-obj_name.

    CALL FUNCTION &apos;RPY_TRANSACTION_READ&apos;
      EXPORTING
        transaction      = lv_transaction
      TABLES
        tcodes           = lt_tcodes
        gui_attributes   = lt_gui_attr
      EXCEPTIONS
        permission_error = 1
        cancelled        = 2
        not_found        = 3
        object_not_found = 4
        OTHERS           = 5.
    IF sy-subrc = 4 OR sy-subrc = 3.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RPY_TRANSACTION_READ&apos; ).
    ENDIF.

    SELECT SINGLE * FROM tstct INTO ls_tstct
      WHERE sprsl = mv_language
      AND tcode = lv_transaction.         &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    SELECT SINGLE * FROM tstcp INTO ls_tstcp
      WHERE tcode = lv_transaction.       &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    READ TABLE lt_tcodes INDEX 1 INTO ls_tcode.
    ASSERT sy-subrc = 0.
    READ TABLE lt_gui_attr INDEX 1 INTO ls_gui_attr.
    ASSERT sy-subrc = 0.

    io_xml-&gt;add( iv_name = &apos;TSTC&apos;
                 ig_data = ls_tcode ).
    io_xml-&gt;add( iv_name = &apos;TSTCC&apos;
                 ig_data = ls_gui_attr ).
    io_xml-&gt;add( iv_name = &apos;TSTCT&apos;
                 ig_data = ls_tstct ).
    IF ls_tstcp IS NOT INITIAL.
      io_xml-&gt;add( iv_name = &apos;TSTCP&apos;
                   ig_data = ls_tstcp ).
    ENDIF.

    &quot; Texts serializing (translations)
    serialize_texts( io_xml ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_tobj IMPLEMENTATION.

  METHOD read_extra.

    SELECT SINGLE * FROM tddat INTO rs_tobj-tddat WHERE tabname = iv_tabname.

    SELECT SINGLE * FROM tvdir INTO rs_tobj-tvdir WHERE tabname = iv_tabname.
    CLEAR: rs_tobj-tvdir-gendate, rs_tobj-tvdir-gentime.

    SELECT * FROM tvimf INTO TABLE rs_tobj-tvimf WHERE tabname = iv_tabname.

  ENDMETHOD.

  METHOD update_extra.

    MODIFY tddat FROM is_tobj-tddat.
    MODIFY tvdir FROM is_tobj-tvdir.
    MODIFY tvimf FROM TABLE is_tobj-tvimf.

  ENDMETHOD.

  METHOD delete_extra.

    DELETE FROM tddat WHERE tabname = iv_tabname.
    DELETE FROM tvdir WHERE tabname = iv_tabname.
    DELETE FROM tvimf WHERE tabname = iv_tabname.

  ENDMETHOD.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    SELECT SINGLE luser FROM objh INTO rv_user
      WHERE objectname = ms_item-obj_name(lv_type_pos)
      AND objecttype = ms_item-obj_name+lv_type_pos.    &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-late_deser = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_objectname TYPE objh-objectname,
          lv_type_pos   TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    SELECT SINGLE objectname FROM objh INTO lv_objectname
      WHERE objectname = ms_item-obj_name(lv_type_pos)
      AND objecttype = ms_item-obj_name+lv_type_pos.    &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_objh     TYPE objh,
          ls_objt     TYPE objt,
          lt_objs     TYPE tt_objs,
          lt_objsl    TYPE tt_objsl,
          lt_objm     TYPE tt_objm,
          ls_tobj     TYPE ty_tobj,
          lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    ls_objh-objectname = ms_item-obj_name(lv_type_pos).
    ls_objh-objecttype = ms_item-obj_name+lv_type_pos.

    CALL FUNCTION &apos;CTO_OBJECT_GET&apos;
      EXPORTING
        iv_objectname      = ls_objh-objectname
        iv_objecttype      = ls_objh-objecttype
        iv_language        = mv_language
        iv_sel_objt        = abap_true
        iv_sel_objs        = abap_true
        iv_sel_objsl       = abap_true
        iv_sel_objm        = abap_true
      IMPORTING
        es_objh            = ls_objh
        es_objt            = ls_objt
      TABLES
        tt_objs            = lt_objs
        tt_objsl           = lt_objsl
        tt_objm            = lt_objm
      EXCEPTIONS
        object_not_defined = 1
        OTHERS             = 2.
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from CTO_OBJECT_GET&apos; ).
    ENDIF.

    CLEAR: ls_objh-luser,
           ls_objh-ldate.

    io_xml-&gt;add( iv_name = &apos;OBJH&apos;
                 ig_data = ls_objh ).
    io_xml-&gt;add( iv_name = &apos;OBJT&apos;
                 ig_data = ls_objt ).
    io_xml-&gt;add( iv_name = &apos;OBJS&apos;
                 ig_data = lt_objs ).
    io_xml-&gt;add( iv_name = &apos;OBJSL&apos;
                 ig_data = lt_objsl ).
    io_xml-&gt;add( iv_name = &apos;OBJM&apos;
                 ig_data = lt_objm ).

    ls_tobj = read_extra( ls_objh-objectname ).

    io_xml-&gt;add( iv_name = &apos;TOBJ&apos;
                 ig_data = ls_tobj ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_objh  TYPE objh,
          ls_objt  TYPE objt,
          lt_objs  TYPE tt_objs,
          lt_objsl TYPE tt_objsl,
          lt_objm  TYPE tt_objm,
          ls_tobj  TYPE ty_tobj.
    io_xml-&gt;read( EXPORTING iv_name = &apos;OBJH&apos;
                  CHANGING cg_data = ls_objh ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;OBJT&apos;
                  CHANGING cg_data = ls_objt ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;OBJS&apos;
                  CHANGING cg_data = lt_objs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;OBJSL&apos;
                  CHANGING cg_data = lt_objsl ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;OBJM&apos;
                  CHANGING cg_data = lt_objm ).

    CALL FUNCTION &apos;OBJ_GENERATE&apos;
      EXPORTING
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_maint_mode         = &apos;I&apos;
        iv_objecttext         = ls_objt-ddtext
        iv_objcateg           = ls_objh-objcateg
        iv_objtransp          = ls_objh-objtransp
        iv_devclass           = iv_package
      TABLES
        tt_v_obj_s            = lt_objs
        tt_objm               = lt_objm
      EXCEPTIONS
        illegal_call          = 1
        object_not_found      = 2
        generate_error        = 3
        transport_error       = 4
        object_enqueue_failed = 5
        OTHERS                = 6.
    IF sy-subrc &lt;&gt; 0.
* TOBJ has to be saved/generated after the DDIC tables have been
* activated - fixed with late deserialization
      zcx_abapgit_exception=&gt;raise( &apos;error from OBJ_GENERATE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;OBJ_SET_IMPORTABLE&apos;
      EXPORTING
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_importable         = ls_objh-importable
      EXCEPTIONS
        object_not_defined    = 1
        invalid               = 2
        transport_error       = 3
        object_enqueue_failed = 4
        OTHERS                = 5.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from OBJ_SET_IMPORTABLE&apos; ).
    ENDIF.

* fm OBJ_GENERATE takes the defaults from the DDIC object
* set OBJTRANSP directly, should be okay looking at the code in OBJ_SET_IMPORTABLE
* locking has been done in OBJ_SET_IMPORTABLE plus recording of transport
    UPDATE objh SET objtransp = ls_objh-objtransp
      WHERE objectname = ls_objh-objectname
      AND objecttype = ls_objh-objecttype.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJ&apos;
                  CHANGING cg_data = ls_tobj ).
    ls_tobj-tvdir-gendate = sy-datum.
    ls_tobj-tvdir-gentime = sy-uzeit.

    update_extra( ls_tobj ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: ls_objh     TYPE objh,
          lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    ls_objh-objectname = ms_item-obj_name(lv_type_pos).
    ls_objh-objecttype = ms_item-obj_name+lv_type_pos.

    CALL FUNCTION &apos;OBJ_GENERATE&apos;
      EXPORTING
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_maint_mode         = &apos;D&apos;
      EXCEPTIONS
        illegal_call          = 1
        object_not_found      = 2
        generate_error        = 3
        transport_error       = 4
        object_enqueue_failed = 5
        OTHERS                = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from OBJ_GENERATE&apos; ).
    ENDIF.

    delete_extra( ls_objh-objectname ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSVIM&apos;.
    ls_bcdata-dynpro   = &apos;0050&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;VIMDYNFLDS-VIEWNAME&apos;.
    ls_bcdata-fval = substring( val = ms_item-obj_name
                                len = strlen( ms_item-obj_name ) - 1 ).
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;VIMDYNFLDS-ELEM_GEN&apos;.
    ls_bcdata-fval = abap_true.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=SHOW&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SE54&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, TOBJ&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_tabl_valid IMPLEMENTATION.
  METHOD get_where_used_recursive.

    DATA: lt_findstrings TYPE stringtab,
          lt_founds      TYPE STANDARD TABLE OF rsfindlst,
          lt_scope       TYPE tty_seu_obj,
          lv_findstring  LIKE LINE OF lt_findstrings.

    FIELD-SYMBOLS: &lt;ls_found&gt; TYPE rsfindlst.

    lt_scope = it_scope.

    lv_findstring = iv_object_name.
    INSERT lv_findstring INTO TABLE lt_findstrings.

    DO iv_depth TIMES.

      CLEAR: lt_founds.

      CALL FUNCTION &apos;RS_EU_CROSSREF&apos;
        EXPORTING
          i_find_obj_cls           = iv_object_type
          no_dialog                = &apos;X&apos;
        TABLES
          i_findstrings            = lt_findstrings
          o_founds                 = lt_founds
          i_scope_object_cls       = lt_scope
        EXCEPTIONS
          not_executed             = 1
          not_found                = 2
          illegal_object           = 3
          no_cross_for_this_object = 4
          batch                    = 5
          batchjob_error           = 6
          wrong_type               = 7
          object_not_exist         = 8
          OTHERS                   = 9.

      IF sy-subrc = 1
      OR sy-subrc = 2
      OR lines( lt_founds ) = 0.
        EXIT.
      ELSEIF sy-subrc &gt; 2.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

      INSERT LINES OF lt_founds INTO TABLE rt_founds_all.

      CLEAR: lt_findstrings.

      LOOP AT lt_founds ASSIGNING &lt;ls_found&gt;.

        lv_findstring = &lt;ls_found&gt;-object.
        INSERT lv_findstring INTO TABLE lt_findstrings.

      ENDLOOP.

    ENDDO.

  ENDMETHOD.
  METHOD validate.

    DATA: lt_previous_table_fields TYPE TABLE OF dd03p,
          ls_previous_table_field  LIKE LINE OF lt_previous_table_fields,
          lt_current_table_fields  TYPE TABLE OF dd03p,
          ls_current_table_field   LIKE LINE OF lt_current_table_fields,
          ls_dd02v                 TYPE dd02v.

    io_remote_version-&gt;read(
      EXPORTING
        iv_name = &apos;DD02V&apos;
      CHANGING
        cg_data = ls_dd02v ).

    &quot; We only want to compare transparent tables, or structures used in transparent tables
    IF ls_dd02v-tabclass &lt;&gt; &apos;TRANSP&apos; AND is_structure_used_in_db_table( ls_dd02v-tabname ) = abap_false.
      RETURN.
    ENDIF.

    io_remote_version-&gt;read(
      EXPORTING
        iv_name       = &apos;DD03P_TABLE&apos;
      CHANGING
        cg_data       = lt_previous_table_fields ).

    io_local_version-&gt;read(
      EXPORTING
        iv_name       = &apos;DD03P_TABLE&apos;
      CHANGING
        cg_data       = lt_current_table_fields ).

    LOOP AT lt_previous_table_fields INTO ls_previous_table_field.
      READ TABLE lt_current_table_fields WITH KEY fieldname = ls_previous_table_field-fieldname
        INTO ls_current_table_field.
      IF sy-subrc = 0.
        IF ls_current_table_field-rollname &lt;&gt; ls_previous_table_field-rollname.
          rv_message = &apos;Fields were changed. This may lead to inconsistencies.&apos;.
        ENDIF.
      ELSE.
        rv_message = &apos;Fields were changed. This may lead to inconsistencies.&apos;.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD is_structure_used_in_db_table.

    DATA: lt_scope  TYPE tty_seu_obj,
          lt_founds TYPE tty_founds.

    APPEND &apos;TABL&apos; TO lt_scope.
    APPEND &apos;STRU&apos; TO lt_scope.

    lt_founds = get_where_used_recursive( iv_object_name = iv_object_name
                                          iv_object_type = &apos;STRU&apos;
                                          it_scope       = lt_scope
                                          iv_depth       = 5 ).

    DELETE lt_founds WHERE object_cls &lt;&gt; &apos;DT&apos;.

    rv_is_structure_used_in_db_tab = boolc( lines( lt_founds ) &gt; 0 ).

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_tabl_dialog IMPLEMENTATION.
  METHOD constructor.
    mv_message = iv_message.
  ENDMETHOD.
  METHOD zif_abapgit_comparison_result~is_result_complete_halt.
    rv_response = mv_halt.
  ENDMETHOD.
  METHOD zif_abapgit_comparison_result~show_confirmation_dialog.

    DATA lv_answer TYPE string.

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        titlebar              = &apos;Warning&apos;
        text_question         = mv_message
        text_button_1         = &apos;Abort&apos;
        icon_button_1         = &apos;ICON_CANCEL&apos;
        text_button_2         = &apos;Pull anyway&apos;
        icon_button_2         = &apos;ICON_OKAY&apos;
        default_button        = &apos;2&apos;
        display_cancel_button = abap_false
      IMPORTING
        answer                = lv_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.                        &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0 OR lv_answer = 1.
      mv_halt = abap_true.
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_TABL IMPLEMENTATION.
  METHOD clear_dd03p_fields.

    DATA: lv_masklen TYPE c LENGTH 4.

    FIELD-SYMBOLS: &lt;ls_dd03p&gt; LIKE LINE OF ct_dd03p.
* remove nested structures
    DELETE ct_dd03p WHERE depth &lt;&gt; &apos;00&apos;.
* remove fields from .INCLUDEs
    DELETE ct_dd03p WHERE adminfield &lt;&gt; &apos;0&apos;.

    LOOP AT ct_dd03p ASSIGNING &lt;ls_dd03p&gt; WHERE NOT rollname IS INITIAL.
      CLEAR: &lt;ls_dd03p&gt;-ddlanguage,
        &lt;ls_dd03p&gt;-dtelmaster,
        &lt;ls_dd03p&gt;-logflag,
        &lt;ls_dd03p&gt;-ddtext,
        &lt;ls_dd03p&gt;-reservedte,
        &lt;ls_dd03p&gt;-reptext,
        &lt;ls_dd03p&gt;-scrtext_s,
        &lt;ls_dd03p&gt;-scrtext_m,
        &lt;ls_dd03p&gt;-scrtext_l.

      lv_masklen = &lt;ls_dd03p&gt;-masklen.
      IF lv_masklen = &apos;&apos; OR NOT lv_masklen CO &apos;0123456789&apos;.
* make sure the field contains valid data, or the XML will dump
        CLEAR &lt;ls_dd03p&gt;-masklen.
      ENDIF.

      IF &lt;ls_dd03p&gt;-comptype = &apos;E&apos;.
* type specified via data element
        CLEAR: &lt;ls_dd03p&gt;-domname,
          &lt;ls_dd03p&gt;-inttype,
          &lt;ls_dd03p&gt;-intlen,
          &lt;ls_dd03p&gt;-mask,
          &lt;ls_dd03p&gt;-memoryid,
          &lt;ls_dd03p&gt;-headlen,
          &lt;ls_dd03p&gt;-scrlen1,
          &lt;ls_dd03p&gt;-scrlen2,
          &lt;ls_dd03p&gt;-scrlen3,
          &lt;ls_dd03p&gt;-datatype,
          &lt;ls_dd03p&gt;-leng,
          &lt;ls_dd03p&gt;-outputlen,
          &lt;ls_dd03p&gt;-deffdname,
          &lt;ls_dd03p&gt;-convexit,
          &lt;ls_dd03p&gt;-entitytab,
          &lt;ls_dd03p&gt;-dommaster,
          &lt;ls_dd03p&gt;-domname3l,
          &lt;ls_dd03p&gt;-decimals,
          &lt;ls_dd03p&gt;-lowercase,
          &lt;ls_dd03p&gt;-signflag.
      ENDIF.

      IF &lt;ls_dd03p&gt;-shlporigin = &apos;D&apos;.
* search help from domain
        CLEAR: &lt;ls_dd03p&gt;-shlpfield,
          &lt;ls_dd03p&gt;-shlpname.
      ENDIF.

* XML output assumes correct field content
      IF &lt;ls_dd03p&gt;-routputlen = &apos;      &apos;.
        CLEAR &lt;ls_dd03p&gt;-routputlen.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_data,
             as4user TYPE as4user,
             as4date TYPE as4date,
             as4time TYPE as4time,
           END OF ty_data.

    DATA: lt_data TYPE STANDARD TABLE OF ty_data WITH DEFAULT KEY,
          ls_data LIKE LINE OF lt_data.
    SELECT as4user as4date as4time
      FROM dd02l INTO TABLE lt_data
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.

    SELECT as4user as4date as4time
      APPENDING TABLE lt_data
      FROM dd09l
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.

    SELECT as4user as4date as4time
      APPENDING TABLE lt_data
      FROM dd12l
      WHERE sqltab = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.

    SORT lt_data BY as4date DESCENDING as4time DESCENDING.

    READ TABLE lt_data INDEX 1 INTO ls_data.
    IF sy-subrc = 0.
      rv_user = ls_data-as4user.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    DATA: lo_table_validation     TYPE REF TO zcl_abapgit_object_tabl_valid,
          lo_local_version_output TYPE REF TO zcl_abapgit_xml_output,
          lo_local_version_input  TYPE REF TO zcl_abapgit_xml_input,
          lv_validation_text      TYPE string.

    CREATE OBJECT lo_local_version_output.
    me-&gt;zif_abapgit_object~serialize( lo_local_version_output ).

    CREATE OBJECT lo_local_version_input
      EXPORTING
        iv_xml = lo_local_version_output-&gt;render( ).

    CREATE OBJECT lo_table_validation.

    lv_validation_text = lo_table_validation-&gt;validate(
      io_remote_version = io_remote_version_xml
      io_local_version  = lo_local_version_input ).
    IF lv_validation_text IS NOT INITIAL.
      lv_validation_text = |Database Table { ms_item-obj_name }: { lv_validation_text }|.
      CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_object_tabl_dialog
        EXPORTING
          iv_message = lv_validation_text.
    ELSE.
      CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_objname  TYPE rsedd0-ddobjname,
          lv_tabclass TYPE dd02l-tabclass,
          lv_no_ask   TYPE abap_bool,
          lv_subrc    TYPE sy-subrc,
          lr_data     TYPE REF TO data.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any.
    lv_objname = ms_item-obj_name.

    lv_no_ask = abap_true.
    SELECT SINGLE tabclass FROM dd02l INTO lv_tabclass
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    IF sy-subrc = 0 AND lv_tabclass = &apos;TRANSP&apos;.

* Avoid dump in dynamic SELECT in case the table does not exist on database
      CALL FUNCTION &apos;DB_EXISTS_TABLE&apos;
        EXPORTING
          tabname = lv_objname
        IMPORTING
          subrc   = lv_subrc.
      IF lv_subrc = 0.
* it cannot delete table with table wihtout asking
        CREATE DATA lr_data TYPE (lv_objname).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.
        SELECT SINGLE * FROM (lv_objname) INTO &lt;lg_data&gt;.
        IF sy-subrc = 0.
          lv_no_ask = abap_false.
        ENDIF.
      ENDIF.
    ENDIF.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = lv_no_ask
        objname              = lv_objname
        objtype              = &apos;T&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, TABL&apos; ).
    ENDIF.

    delete_longtexts( c_longtext_id_tabl ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name      TYPE ddobjname,
          lv_tname     TYPE trobj_name,
          ls_dd02v     TYPE dd02v,
          ls_dd09l     TYPE dd09l,
          lt_dd03p     TYPE TABLE OF dd03p,
          lt_dd05m     TYPE TABLE OF dd05m,
          lt_dd08v     TYPE TABLE OF dd08v,
          lt_dd12v     TYPE dd12vtab,
          lt_dd17v     TYPE dd17vtab,
          ls_dd17v     LIKE LINE OF lt_dd17v,
          lt_secondary LIKE lt_dd17v,
          lt_dd35v     TYPE TABLE OF dd35v,
          lt_dd36m     TYPE dd36mttyp,
          ls_dd12v     LIKE LINE OF lt_dd12v.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD02V&apos;
                  CHANGING cg_data = ls_dd02v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD09L&apos;
                  CHANGING cg_data = ls_dd09l ).
    io_xml-&gt;read( EXPORTING iv_name  = &apos;DD03P_TABLE&apos;
                  CHANGING cg_data = lt_dd03p ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD05M_TABLE&apos;
                  CHANGING cg_data = lt_dd05m ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD08V_TABLE&apos;
                  CHANGING cg_data = lt_dd08v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD12V&apos;
                  CHANGING cg_data = lt_dd12v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD17V&apos;
                  CHANGING cg_data = lt_dd17v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD35V_TALE&apos;
                  CHANGING cg_data = lt_dd35v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD36M&apos;
                  CHANGING cg_data = lt_dd36m ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name. &quot; type conversion

    CALL FUNCTION &apos;DDIF_TABL_PUT&apos;
      EXPORTING
        name              = lv_name
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_TABL_PUT&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

* handle indexes
    LOOP AT lt_dd12v INTO ls_dd12v.

* todo, call corr_insert?

      CLEAR lt_secondary.
      LOOP AT lt_dd17v INTO ls_dd17v
          WHERE sqltab = ls_dd12v-sqltab AND indexname = ls_dd12v-indexname.
        APPEND ls_dd17v TO lt_secondary.
      ENDLOOP.

      CALL FUNCTION &apos;DDIF_INDX_PUT&apos;
        EXPORTING
          name              = ls_dd12v-sqltab
          id                = ls_dd12v-indexname
          dd12v_wa          = ls_dd12v
        TABLES
          dd17v_tab         = lt_secondary
        EXCEPTIONS
          indx_not_found    = 1
          name_inconsistent = 2
          indx_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_INDX_PUT&apos; ).
      ENDIF.

      CALL FUNCTION &apos;DD_DD_TO_E071&apos;
        EXPORTING
          type     = &apos;INDX&apos;
          name     = ls_dd12v-sqltab
          id       = ls_dd12v-indexname
        IMPORTING
          obj_name = lv_tname.

      zcl_abapgit_objects_activation=&gt;add( iv_type = &apos;INDX&apos;
                                           iv_name = lv_tname ).

    ENDLOOP.

    deserialize_longtexts( io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_tabname TYPE dd02l-tabname.
    SELECT SINGLE tabname FROM dd02l INTO lv_tabname
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date    TYPE dats,
          lv_time    TYPE tims,
          lt_indexes TYPE STANDARD TABLE OF dd09l.

    FIELD-SYMBOLS &lt;ls_index&gt; LIKE LINE OF lt_indexes.

    SELECT SINGLE as4date as4time FROM dd02l &quot; Table
      INTO (lv_date, lv_time)
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).
    IF rv_changed = abap_true.
      RETURN.
    ENDIF.

    SELECT SINGLE as4date as4time FROM dd09l &quot; Table tech settings
      INTO (lv_date, lv_time)
      WHERE tabname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).
    IF rv_changed = abap_true.
      RETURN.
    ENDIF.

    SELECT as4date as4time FROM dd12l &quot; Table tech settings
      INTO CORRESPONDING FIELDS OF TABLE lt_indexes
      WHERE sqltab = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;
      ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS.

    LOOP AT lt_indexes ASSIGNING &lt;ls_index&gt;.
      rv_changed = check_timestamp(
        iv_timestamp = iv_timestamp
        iv_date      = &lt;ls_index&gt;-as4date
        iv_time      = &lt;ls_index&gt;-as4time ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-DDTYPE&apos;
               iv_field = &apos;RSRD1-DDTYPE_VAL&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd02v TYPE dd02v,
          ls_dd09l TYPE dd09l,
          lt_dd03p TYPE ty_dd03p_tt,
          lt_dd05m TYPE TABLE OF dd05m,
          lt_dd08v TYPE TABLE OF dd08v,
          lt_dd12v TYPE dd12vtab,
          lt_dd17v TYPE dd17vtab,
          lt_dd35v TYPE TABLE OF dd35v,
          lv_index LIKE sy-index,
          lt_dd36m TYPE dd36mttyp.

    FIELD-SYMBOLS: &lt;ls_dd12v&gt;      LIKE LINE OF lt_dd12v,
                   &lt;ls_dd05m&gt;      LIKE LINE OF lt_dd05m,
                   &lt;ls_dd36m&gt;      LIKE LINE OF lt_dd36m,
                   &lt;lg_roworcolst&gt; TYPE any.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name          = lv_name
        langu         = mv_language
      IMPORTING
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_TABL_GET&apos; ).
    ENDIF.
    IF ls_dd02v IS INITIAL.
      RETURN. &quot; object does not exits
    ENDIF.

    CLEAR: ls_dd02v-as4user,
           ls_dd02v-as4date,
           ls_dd02v-as4time.

* reset numeric field, so XML does not crash
    IF ls_dd02v-prozpuff = &apos;&apos;.
      CLEAR ls_dd02v-prozpuff.
    ENDIF.
    IF ls_dd02v-datmin = &apos;&apos;.
      CLEAR ls_dd02v-datmin.
    ENDIF.
    IF ls_dd02v-datmax = &apos;&apos;.
      CLEAR ls_dd02v-datmax.
    ENDIF.
    IF ls_dd02v-datavg = &apos;&apos;.
      CLEAR ls_dd02v-datavg.
    ENDIF.

    CLEAR: ls_dd09l-as4user,
           ls_dd09l-as4date,
           ls_dd09l-as4time.

    ASSIGN COMPONENT &apos;ROWORCOLST&apos; OF STRUCTURE ls_dd09l TO &lt;lg_roworcolst&gt;.
    IF sy-subrc = 0 AND &lt;lg_roworcolst&gt; = &apos;C&apos;.
      CLEAR &lt;lg_roworcolst&gt;. &quot;To avoid diff errors. This field doesn&apos;t exists in all releases
    ENDIF.
    LOOP AT lt_dd12v ASSIGNING &lt;ls_dd12v&gt;.
      CLEAR: &lt;ls_dd12v&gt;-as4user,
             &lt;ls_dd12v&gt;-as4date,
             &lt;ls_dd12v&gt;-as4time.
    ENDLOOP.

    clear_dd03p_fields( CHANGING ct_dd03p = lt_dd03p ).

* remove foreign keys inherited from .INCLUDEs
    DELETE lt_dd08v WHERE noinherit = &apos;N&apos;.
    LOOP AT lt_dd05m ASSIGNING &lt;ls_dd05m&gt;.
      lv_index = sy-tabix.
      READ TABLE lt_dd08v WITH KEY fieldname = &lt;ls_dd05m&gt;-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        DELETE lt_dd05m INDEX lv_index.
      ENDIF.
    ENDLOOP.

* remove inherited search helps
    DELETE lt_dd35v WHERE shlpinher = abap_true.
    LOOP AT lt_dd36m ASSIGNING &lt;ls_dd36m&gt;.
      lv_index = sy-tabix.
      READ TABLE lt_dd35v WITH KEY fieldname = &lt;ls_dd36m&gt;-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        DELETE lt_dd36m INDEX lv_index.
      ENDIF.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;DD02V&apos;
                 ig_data = ls_dd02v ).
    IF NOT ls_dd09l IS INITIAL.
      io_xml-&gt;add( iv_name = &apos;DD09L&apos;
                   ig_data = ls_dd09l ).
    ENDIF.
    io_xml-&gt;add( ig_data = lt_dd03p
                 iv_name = &apos;DD03P_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd05m
                 iv_name = &apos;DD05M_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd08v
                 iv_name = &apos;DD08V_TABLE&apos; ).
    io_xml-&gt;add( iv_name = &apos;DD12V&apos;
                 ig_data = lt_dd12v ).
    io_xml-&gt;add( iv_name = &apos;DD17V&apos;
                 ig_data = lt_dd17v ).
    io_xml-&gt;add( ig_data = lt_dd35v
                 iv_name = &apos;DD35V_TALE&apos; ).
    io_xml-&gt;add( iv_name = &apos;DD36M&apos;
                 ig_data = lt_dd36m ).

    serialize_longtexts( io_xml         = io_xml
                         iv_longtext_id = c_longtext_id_tabl ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sxci IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_implementation_name TYPE rsexscrn-imp_name.

    lv_implementation_name = ms_item-obj_name.

    CALL FUNCTION &apos;SXO_IMPL_DELETE&apos;
      EXPORTING
        imp_name           = lv_implementation_name
        no_dialog          = abap_true
      EXCEPTIONS
        imp_not_existing   = 1
        action_canceled    = 2
        access_failure     = 3
        data_inconsistency = 4
        OTHERS             = 5.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_IMPL_DELETE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_badi_definition             TYPE badi_data,
          lo_filter_object               TYPE REF TO cl_badi_flt_struct,
          lo_filter_values_object        TYPE REF TO cl_badi_flt_values_alv,
          lv_korrnum                     TYPE trkorr,
          lv_filter_type_enhanceability  TYPE rsexscrn-flt_ext,
          lv_package                     TYPE devclass,
          ls_classic_badi_implementation TYPE ty_classic_badi_implementation.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;SXCI&apos;
      CHANGING
        cg_data = ls_classic_badi_implementation ).

    CALL FUNCTION &apos;SXO_BADI_READ&apos;
      EXPORTING
        exit_name    = ls_classic_badi_implementation-implementation_data-exit_name
      IMPORTING
        badi         = ls_badi_definition
        filter_obj   = lo_filter_object
      EXCEPTIONS
        read_failure = 1
        OTHERS       = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_BADI_READ&apos; ).
    ENDIF.

    lv_package = iv_package.

    CREATE OBJECT lo_filter_values_object
      EXPORTING
        filter_object = lo_filter_object
        filter_values = ls_classic_badi_implementation-filters.

    CALL FUNCTION &apos;SXO_IMPL_SAVE&apos;
      EXPORTING
        impl             = ls_classic_badi_implementation-implementation_data
        flt_ext          = lv_filter_type_enhanceability
        filter_val_obj   = lo_filter_values_object
        genflag          = abap_true
        no_dialog        = abap_true
      TABLES
        fcodes_to_insert = ls_classic_badi_implementation-function_codes
        cocos_to_insert  = ls_classic_badi_implementation-control_composites
        intas_to_insert  = ls_classic_badi_implementation-customer_includes
        sscrs_to_insert  = ls_classic_badi_implementation-screens
      CHANGING
        korrnum          = lv_korrnum
        devclass         = lv_package
      EXCEPTIONS
        save_failure     = 1
        action_canceled  = 2
        OTHERS           = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_IMPL_SAVE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;SXO_IMPL_ACTIVE&apos;
      EXPORTING
        imp_name                  = ls_classic_badi_implementation-implementation_data-imp_name
        no_dialog                 = abap_true
      EXCEPTIONS
        badi_not_existing         = 1
        imp_not_existing          = 2
        already_active            = 3
        data_inconsistency        = 4
        activation_not_admissable = 5
        action_canceled           = 6
        access_failure            = 7
        OTHERS                    = 8.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_IMPL_ACTIVE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_implementation_name TYPE rsexscrn-imp_name.

    lv_implementation_name = ms_item-obj_name.

    CALL FUNCTION &apos;SXV_IMP_EXISTS&apos;
      EXPORTING
        imp_name           = lv_implementation_name
      EXCEPTIONS
        not_existing       = 1
        data_inconsistency = 2
        OTHERS             = 3.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_TOOL_ACCESS&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_implementation_name         TYPE rsexscrn-imp_name,
          lv_exit_name                   TYPE rsexscrn-exit_name,
          lo_filter_object               TYPE REF TO cl_badi_flt_struct,
          ls_badi_definition             TYPE badi_data,
          lo_filter_values_object        TYPE REF TO cl_badi_flt_values_alv,
          lt_methods                     TYPE seex_mtd_table,
          ls_classic_badi_implementation TYPE ty_classic_badi_implementation.

    lv_implementation_name = ms_item-obj_name.

    CALL FUNCTION &apos;SXV_EXIT_FOR_IMP&apos;
      EXPORTING
        imp_name           = lv_implementation_name
      IMPORTING
        exit_name          = lv_exit_name
      TABLES
        filters            = ls_classic_badi_implementation-filters
      EXCEPTIONS
        data_inconsistency = 1
        OTHERS             = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXV_EXIT_FOR_IMP&apos; ).
    ENDIF.

    CALL FUNCTION &apos;SXO_BADI_READ&apos;
      EXPORTING
        exit_name    = lv_exit_name
      IMPORTING
        badi         = ls_badi_definition
        filter_obj   = lo_filter_object
      TABLES
        fcodes       = ls_classic_badi_implementation-function_codes
        cocos        = ls_classic_badi_implementation-control_composites
        intas        = ls_classic_badi_implementation-customer_includes
        scrns        = ls_classic_badi_implementation-screens
        methods      = lt_methods
      EXCEPTIONS
        read_failure = 1
        OTHERS       = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_BADI_READ&apos; ).
    ENDIF.

    CALL FUNCTION &apos;SXO_IMPL_FOR_BADI_READ&apos;
      EXPORTING
        imp_name                    = lv_implementation_name
        exit_name                   = lv_exit_name
        inter_name                  = ls_badi_definition-inter_name
        filter_obj                  = lo_filter_object
        no_create_filter_values_obj = abap_true
      IMPORTING
        impl                        = ls_classic_badi_implementation-implementation_data
        filter_values_obj           = lo_filter_values_object
      TABLES
        fcodes                      = ls_classic_badi_implementation-function_codes
        cocos                       = ls_classic_badi_implementation-control_composites
        intas                       = ls_classic_badi_implementation-customer_includes
        scrns                       = ls_classic_badi_implementation-screens
      CHANGING
        methods                     = lt_methods
      EXCEPTIONS
        read_failure                = 1
        OTHERS                      = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SXO_IMPL_FOR_BADI_READ&apos; ).
    ENDIF.

    CLEAR: ls_classic_badi_implementation-implementation_data-aname,
           ls_classic_badi_implementation-implementation_data-adate,
           ls_classic_badi_implementation-implementation_data-atime,
           ls_classic_badi_implementation-implementation_data-uname,
           ls_classic_badi_implementation-implementation_data-udate,
           ls_classic_badi_implementation-implementation_data-utime,
           ls_classic_badi_implementation-implementation_data-active.

    io_xml-&gt;add( iv_name = &apos;SXCI&apos;
                 ig_data = ls_classic_badi_implementation ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SUSO IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_objectname = ms_item-obj_name.

  ENDMETHOD.
  METHOD delete_documentation.

    DATA:
      lv_docu_obj TYPE dokhl-object,
      lv_dummy    TYPE sy-langu.

    lv_docu_obj  = mv_objectname.

    SELECT SINGLE langu
           FROM dokil INTO lv_dummy
           WHERE id   = &apos;UO&apos;                            &quot;#EC CI_GENBUFF
           AND object = lv_docu_obj.

    IF sy-subrc = 0.

      CALL FUNCTION &apos;DOKU_DELETE_ALL&apos;
        EXPORTING
          doku_id                        = &apos;UO&apos;
          doku_object                    = lv_docu_obj
          suppress_transport             = space
        EXCEPTIONS
          header_without_text            = 1
          index_without_header           = 2
          no_authority_for_devclass_xxxx = 3
          no_docu_found                  = 4
          object_is_already_enqueued     = 5
          object_is_enqueued_by_corr     = 6
          techn_enqueue_problem          = 7
          user_break                     = 8
          OTHERS                         = 9.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD pre_check.

    CONSTANTS:
      lc_act_delete TYPE activ_auth VALUE &apos;06&apos;.

    DATA:
      lv_act_head            TYPE activ_auth,
      lv_dummy               TYPE string,
      lo_suso                TYPE REF TO object,
      lv_failed              TYPE abap_bool,
      lv_suso_collect_in_cts TYPE i,
      lv_clskey              TYPE seoclskey.

    &quot; Downport: CL_SUSO_GEN doesn&apos;t exist in 702
    lv_clskey-clsname = |CL_SUSO_GEN|.

    CALL FUNCTION &apos;SEO_CLASS_EXISTENCE_CHECK&apos;
      EXPORTING
        clskey        = lv_clskey
      EXCEPTIONS
        not_specified = 1
        not_existing  = 2
        is_interface  = 3
        no_text       = 4
        inconsistent  = 5
        OTHERS        = 6.

    IF sy-subrc = 0.

      &quot; so these check are not executed in 702

      CREATE OBJECT lo_suso
        TYPE
          (&apos;CL_SUSO_GEN&apos;).

      CALL METHOD lo_suso-&gt;(&apos;SUSO_LOAD_FROM_DB&apos;)
        EXPORTING
          id_object = mv_objectname
        RECEIVING
          ed_failed = lv_failed.

      IF lv_failed = abap_true.
        &quot; Object &amp; does not exist; choose an existing object
        MESSAGE s111(01) WITH mv_objectname INTO lv_dummy.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

      CALL METHOD lo_suso-&gt;(&apos;GET_SUSO_EDIT_MODE&apos;)
        EXPORTING
          id_object     = mv_objectname
          id_planed_act = lc_act_delete
        IMPORTING
          ed_mode_head  = lv_act_head.

      IF lv_act_head &lt;&gt; lc_act_delete.
        zcx_abapgit_exception=&gt;raise( |AUTH { mv_objectname }: Delete not allowed| ).
      ENDIF.

      CALL METHOD lo_suso-&gt;(&apos;SUSO_COLLECT_IN_CTS&apos;)
        EXPORTING
          id_object = mv_objectname
        RECEIVING
          ed_result = lv_suso_collect_in_cts.

      IF lv_suso_collect_in_cts IS NOT INITIAL.
        zcx_abapgit_exception=&gt;raise( |AUTH { mv_objectname }: Cannot delete| ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    &quot; FM SUSR_DELETE_OBJECT calls the UI. Therefore we reimplement it here.
    &quot; As the class CL_SUSO_GEN isn&apos;t present in 702, we call dynamically and
    &quot; skip the pre checks on 702 system. That seems ok.

    pre_check( ).

    delete_documentation( ).

    DELETE FROM tobj  WHERE objct  = mv_objectname.
    DELETE FROM tobjt WHERE object = mv_objectname.
    DELETE FROM tactz WHERE brobj  = mv_objectname.

    CALL FUNCTION &apos;SUPV_DELETE_OBJECT_ASSIGNMENTS&apos;
      EXPORTING
        object_name  = mv_objectname
        all_releases = abap_true.

    CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
      EXPORTING
        object    = mv_objectname
        type      = &apos;SUSO&apos;
        operation = &apos;DELETE&apos;.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* see function group SUSA

    DATA: lv_objectname TYPE trobj_name,
          ls_tobj       TYPE tobj,
          ls_tobjt      TYPE tobjt,
          ls_tobjvorflg TYPE tobjvorflg,
          lt_tactz      TYPE TABLE OF tactz,
          lt_tobjvordat TYPE TABLE OF tobjvordat,
          lt_tobjvor    TYPE TABLE OF tobjvor.
    ASSERT NOT ms_item-obj_name IS INITIAL.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJ&apos;
                  CHANGING cg_data = ls_tobj ).
    ls_tobj-bname = sy-uname.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJT&apos;
                  CHANGING cg_data = ls_tobjt ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJVORFLG&apos;
                  CHANGING cg_data = ls_tobjvorflg ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TACTZ&apos;
                  CHANGING  cg_data = lt_tactz ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJVORDAT&apos;
                  CHANGING  cg_data = lt_tobjvordat ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBJVOR&apos;
                  CHANGING  cg_data = lt_tobjvor ).

    tadir_insert( iv_package ).

    lv_objectname = mv_objectname.

    CALL FUNCTION &apos;SUSR_COMMEDITCHECK&apos;
      EXPORTING
        objectname      = lv_objectname
        transobjecttype = &apos;O&apos;.

    MODIFY tobj FROM ls_tobj.                             &quot;#EC CI_SUBRC
    MODIFY tobjt FROM ls_tobjt.                           &quot;#EC CI_SUBRC
    MODIFY tobjvorflg FROM ls_tobjvorflg.                 &quot;#EC CI_SUBRC
    DELETE FROM tactz WHERE brobj = ms_item-obj_name.     &quot;#EC CI_SUBRC
    INSERT tactz FROM TABLE lt_tactz.                     &quot;#EC CI_SUBRC
    DELETE FROM tobjvordat WHERE objct = ms_item-obj_name. &quot;#EC CI_SUBRC
    INSERT tobjvordat FROM TABLE lt_tobjvordat.           &quot;#EC CI_SUBRC
    DELETE FROM tobjvor WHERE objct = ms_item-obj_name.   &quot;#EC CI_SUBRC
    INSERT tobjvor FROM TABLE lt_tobjvor.                 &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_objct TYPE tobj-objct.
    SELECT SINGLE objct FROM tobj INTO lv_objct
      WHERE objct = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;SUSR_SHOW_OBJECT&apos;
      EXPORTING
        object = mv_objectname.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_tobj       TYPE tobj,
          ls_tobjt      TYPE tobjt,
          ls_tobjvorflg TYPE tobjvorflg,
          lt_tactz      TYPE TABLE OF tactz,
          lt_tobjvordat TYPE TABLE OF tobjvordat,
          lt_tobjvor    TYPE TABLE OF tobjvor.
    SELECT SINGLE * FROM tobj INTO ls_tobj
      WHERE objct = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.
    CLEAR ls_tobj-bname.

    SELECT SINGLE * FROM tobjt INTO ls_tobjt
      WHERE object = ms_item-obj_name
      AND langu = mv_language.                          &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;TOBJT no english description&apos;
        &amp;&amp; &apos; for object (&apos; &amp;&amp; ms_item-obj_name &amp;&amp; &apos;)&apos; ).
    ENDIF.

    SELECT SINGLE * FROM tobjvorflg INTO ls_tobjvorflg
      WHERE objct = ms_item-obj_name.                     &quot;#EC CI_SUBRC

    SELECT * FROM tactz INTO TABLE lt_tactz
      WHERE brobj = ms_item-obj_name
      ORDER BY PRIMARY KEY.               &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    SELECT * FROM tobjvordat INTO TABLE lt_tobjvordat
      WHERE objct = ms_item-obj_name
      ORDER BY PRIMARY KEY.               &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    SELECT * FROM tobjvor INTO TABLE lt_tobjvor
      WHERE objct = ms_item-obj_name
      ORDER BY PRIMARY KEY.                               &quot;#EC CI_SUBRC

    io_xml-&gt;add( iv_name = &apos;TOBJ&apos;
                 ig_data = ls_tobj ).
    io_xml-&gt;add( iv_name = &apos;TOBJT&apos;
                 ig_data = ls_tobjt ).
    io_xml-&gt;add( iv_name = &apos;TOBJVORFLG&apos;
                 ig_data = ls_tobjvorflg ).
    io_xml-&gt;add( ig_data = lt_tactz
                 iv_name = &apos;TACTZ&apos; ).
    io_xml-&gt;add( ig_data = lt_tobjvordat
                 iv_name = &apos;TOBJVORDAT&apos; ).
    io_xml-&gt;add( ig_data = lt_tobjvor
                 iv_name = &apos;TOBJVOR&apos; ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SUSC IMPLEMENTATION.
  METHOD delete_class.

    DELETE FROM tobc  WHERE oclss = iv_auth_object_class.
    DELETE FROM tobct WHERE oclss = iv_auth_object_class.

  ENDMETHOD.
  METHOD has_authorization.

    AUTHORITY-CHECK OBJECT &apos;S_DEVELOP&apos;
           ID &apos;DEVCLASS&apos; DUMMY
           ID &apos;OBJTYPE&apos; FIELD iv_object_type
           ID &apos;OBJNAME&apos; FIELD iv_class
           ID &apos;P_GROUP&apos; DUMMY
           ID &apos;ACTVT&apos;   FIELD iv_activity.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( iv_msgid = &apos;01&apos;
                                         iv_msgno = &apos;467&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD is_used.

    DATA: lv_used_auth_object_class TYPE tobc-oclss.

    SELECT SINGLE oclss
      FROM tobj
      INTO lv_used_auth_object_class
      WHERE oclss = iv_auth_object_class ##WARN_OK.
    IF sy-subrc = 0.
      zcx_abapgit_exception=&gt;raise_t100( iv_msgid = &apos;01&apos;
                                         iv_msgno = &apos;212&apos;
                                         iv_msgv1 = |{ iv_auth_object_class }| ).
    ENDIF.

  ENDMETHOD.
  METHOD put_delete_to_transport.

    DATA: lv_tr_object_name TYPE e071-obj_name,
          lv_tr_return      TYPE char1,
          ls_package_info   TYPE tdevc,
          lv_tadir_object   TYPE tadir-object,
          lv_tadir_obj_name TYPE tadir-obj_name.

    lv_tr_object_name = iv_auth_object_class.
    CALL FUNCTION &apos;SUSR_COMMEDITCHECK&apos;
      EXPORTING
        objectname       = lv_tr_object_name
        transobjecttype  = zcl_abapgit_object_susc=&gt;transobjecttype_class
      IMPORTING
        return_from_korr = lv_tr_return.

    IF lv_tr_return &lt;&gt; &apos;M&apos;.
      zcx_abapgit_exception=&gt;raise( |error in SUSC delete at SUSR_COMMEDITCHECK| ).
    ENDIF.

    CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
      EXPORTING
        iv_devclass = ms_item-devclass
      IMPORTING
        es_tdevc    = ls_package_info
      EXCEPTIONS
        OTHERS      = 1.
    IF sy-subrc = 0 AND ls_package_info-korrflag IS INITIAL.
      lv_tadir_object   = iv_object_type.
      lv_tadir_obj_name = lv_tr_object_name.
      CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
        EXPORTING
          wi_delete_tadir_entry = abap_true
          wi_test_modus         = space
          wi_tadir_pgmid        = &apos;R3TR&apos;
          wi_tadir_object       = lv_tadir_object
          wi_tadir_obj_name     = lv_tadir_obj_name
        EXCEPTIONS
          OTHERS                = 0.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    CONSTANTS lc_activity_delete_06 TYPE activ_auth VALUE &apos;06&apos;.

    DATA: lv_auth_object_class TYPE tobc-oclss.
    DATA: lv_object_type       TYPE seu_objid.
    DATA: lv_tr_object_name    TYPE e071-obj_name.
    DATA: lv_tr_return         TYPE char1.

    lv_auth_object_class = ms_item-obj_name.
    lv_object_type = ms_item-obj_type.

    TRY.
        me-&gt;zif_abapgit_object~exists( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    has_authorization( iv_object_type = lv_object_type
                       iv_class       = lv_auth_object_class
                       iv_activity    = lc_activity_delete_06 ).

    is_used( lv_auth_object_class ).

    delete_class( lv_auth_object_class ).

    put_delete_to_transport( iv_auth_object_class = lv_auth_object_class
                             iv_object_type       = lv_object_type ).
  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* see function group SUSA

    DATA: ls_tobc       TYPE tobc,
          lv_objectname TYPE e071-obj_name,
          ls_tobct      TYPE tobct.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBC&apos;
                  CHANGING cg_data = ls_tobc ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TOBCT&apos;
                  CHANGING cg_data = ls_tobct ).

    tadir_insert( iv_package ).

    lv_objectname = ms_item-obj_name.
    CALL FUNCTION &apos;SUSR_COMMEDITCHECK&apos;
      EXPORTING
        objectname      = lv_objectname
        transobjecttype = zcl_abapgit_object_susc=&gt;transobjecttype_class.

    INSERT tobc FROM ls_tobc.                             &quot;#EC CI_SUBRC
* ignore sy-subrc as all fields are key fields

    MODIFY tobct FROM ls_tobct.                           &quot;#EC CI_SUBRC
    ASSERT sy-subrc = 0.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_oclss TYPE tobc-oclss.
    SELECT SINGLE oclss FROM tobc INTO lv_oclss
      WHERE oclss = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lv_objclass TYPE tobc-oclss.

    lv_objclass = ms_item-obj_name.
    CALL FUNCTION &apos;SUSR_SHOW_OBJECT_CLASS&apos;
      EXPORTING
        objclass = lv_objclass.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_tobc  TYPE tobc,
          ls_tobct TYPE tobct.
    SELECT SINGLE * FROM tobc INTO ls_tobc
      WHERE oclss = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tobct INTO ls_tobct
      WHERE oclss = ms_item-obj_name
      AND langu = mv_language.

    io_xml-&gt;add( iv_name = &apos;TOBC&apos;
                 ig_data = ls_tobc ).
    io_xml-&gt;add( iv_name = &apos;TOBCT&apos;
                 ig_data = ls_tobct ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SUCU IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.
    rv_user = zcl_abapgit_objects_super=&gt;c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;delete( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;deserialize(
      iv_package = iv_package
      io_xml     = io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    rv_bool = lo_generic-&gt;exists( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |TODO: Jump| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;serialize( io_xml ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_styl IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: ls_style TYPE ty_style,
          lv_name  TYPE itcda-tdstyle.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;READ_STYLE&apos;
      EXPORTING
        style        = lv_name
      IMPORTING
        style_header = ls_style-header
      TABLES
        paragraphs   = ls_style-paragraphs
        strings      = ls_style-strings
        tabs         = ls_style-tabs.

    rv_user = ls_style-header-tdluser.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_style TYPE ty_style,
          lv_name  TYPE itcda-tdstyle,
          lv_found TYPE abap_bool.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;READ_STYLE&apos;
      EXPORTING
        style      = lv_name
      IMPORTING
        found      = lv_found
      TABLES
        paragraphs = ls_style-paragraphs
        strings    = ls_style-strings
        tabs       = ls_style-tabs.

    rv_bool = boolc( lv_found = abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSSCS&apos;.
    ls_bcdata-dynpro   = &apos;1100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;RSSCS-TDSTYLE&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;RSSCS-TDSPRAS&apos;.
    ls_bcdata-fval     = sy-langu.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;RSSCS-TDHEADEROB&apos;.
    ls_bcdata-fval     = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=SHOW&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SE72&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, STYL&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_style TYPE itcda-tdstyle.
    lv_style = ms_item-obj_name.

    CALL FUNCTION &apos;DELETE_STYLE&apos;
      EXPORTING
        style    = lv_style
        language = &apos;*&apos;.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_style TYPE ty_style.
    io_xml-&gt;read( EXPORTING iv_name = &apos;STYLE&apos;
                  CHANGING cg_data = ls_style ).

    CALL FUNCTION &apos;SAVE_STYLE&apos;
      EXPORTING
        style_header = ls_style-header
      TABLES
        paragraphs   = ls_style-paragraphs
        strings      = ls_style-strings
        tabs         = ls_style-tabs.

    tadir_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_style TYPE ty_style,
          lv_name  TYPE itcda-tdstyle.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;READ_STYLE&apos;
      EXPORTING
        style        = lv_name
      IMPORTING
        style_header = ls_style-header
      TABLES
        paragraphs   = ls_style-paragraphs
        strings      = ls_style-strings
        tabs         = ls_style-tabs.

    CLEAR: ls_style-header-tdfuser,
           ls_style-header-tdfdate,
           ls_style-header-tdftime,
           ls_style-header-tdfreles,
           ls_style-header-tdluser,
           ls_style-header-tdldate,
           ls_style-header-tdltime,
           ls_style-header-tdlreles.

    io_xml-&gt;add( iv_name = &apos;STYLE&apos;
                 ig_data = ls_style ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_ssst IMPLEMENTATION.
  METHOD validate_font.

    DATA: lv_tdfamily TYPE tfo01-tdfamily.
    SELECT SINGLE tdfamily FROM tfo01 INTO lv_tdfamily
      WHERE tdfamily = iv_tdfamily.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Font family not found&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM stxsadm INTO rv_user
      WHERE stylename = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_stylename TYPE tdssname.
    lv_stylename = ms_item-obj_name.

    CALL FUNCTION &apos;SSF_DELETE_STYLE&apos;
      EXPORTING
        i_stylename           = lv_stylename
        i_with_dialog         = abap_false
        i_with_confirm_dialog = abap_false
      EXCEPTIONS
        no_name               = 1
        no_style              = 2
        style_locked          = 3
        cancelled             = 4
        no_access_permission  = 5
        illegal_language      = 6
        OTHERS                = 7.
    IF sy-subrc &lt;&gt; 0 AND sy-subrc &lt;&gt; 2.
      zcx_abapgit_exception=&gt;raise( &apos;error from SSF_DELETE_STYLE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* see fm SSF_UPLOAD_STYLE

    DATA: ls_header     TYPE ssfcats,
          ls_new_header TYPE ssfcats,
          lt_paragraphs TYPE TABLE OF ssfparas,
          lt_strings    TYPE TABLE OF ssfstrings,
          lt_tabstops   TYPE TABLE OF stxstab.

    FIELD-SYMBOLS: &lt;lv_spras&gt; TYPE spras.
    io_xml-&gt;read( EXPORTING iv_name = &apos;HEADER&apos;
                  CHANGING cg_data = ls_header ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;SSFPARAS&apos;
                  CHANGING cg_data = lt_paragraphs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;SSFSTRINGS&apos;
                  CHANGING cg_data = lt_strings ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;STXSTAB&apos;
                  CHANGING cg_data = lt_tabstops ).

    validate_font( ls_header-tdfamily ).

    CALL FUNCTION &apos;SSF_READ_STYLE&apos; &quot;Just load FG
      EXPORTING
        i_style_name        = ls_header-stylename
        i_style_active_flag = &apos;A&apos;
      EXCEPTIONS
        OTHERS              = 0.

    set_default_package( iv_package ).
    ASSIGN (&apos;(SAPLSTXBS)MASTER_LANGUAGE&apos;) TO &lt;lv_spras&gt;.
    IF sy-subrc = 0.
      &lt;lv_spras&gt; = ls_header-masterlang.
    ENDIF.

    tadir_insert( iv_package ).

    CALL FUNCTION &apos;SSF_SAVE_STYLE&apos;
      EXPORTING
        i_header     = ls_header
      IMPORTING
        e_header     = ls_new_header
      TABLES
        i_paragraphs = lt_paragraphs
        i_strings    = lt_strings
        i_tabstops   = lt_tabstops.

    IF ls_new_header IS NOT INITIAL.

      CALL FUNCTION &apos;SSF_ACTIVATE_STYLE&apos;
        EXPORTING
          i_stylename          = ls_header-stylename
        EXCEPTIONS
          no_name              = 1
          no_style             = 2
          cancelled            = 3
          no_access_permission = 4
          illegal_language     = 5
          OTHERS               = 6.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from SSF_ACTIVATE_STYLE&apos; ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_stylename TYPE stxsadm-stylename.

    SELECT SINGLE stylename
      FROM stxshead INTO lv_stylename
      WHERE active    = c_style_active
        AND stylename = ms_item-obj_name
        AND vari      = &apos;&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSSFS&apos;.
    ls_bcdata-dynpro   = &apos;0100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;SSFSCREENS-SNAME&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=DISPLAY&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SMARTSTYLES&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SSST&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.
* see fm SSF_DOWNLOAD_STYLE

    DATA: lv_style_name TYPE tdssname,
          ls_header     TYPE ssfcats,
          lt_paragraphs TYPE TABLE OF ssfparas,
          lt_strings    TYPE TABLE OF ssfstrings,
          lt_tabstops   TYPE TABLE OF stxstab.
    lv_style_name = ms_item-obj_name.

    CALL FUNCTION &apos;SSF_READ_STYLE&apos;
      EXPORTING
        i_style_name             = lv_style_name
        i_style_active_flag      = c_style_active
        i_style_variant          = &apos;%MAIN&apos;
        i_style_language         = mv_language
      IMPORTING
        e_header                 = ls_header
      TABLES
        e_paragraphs             = lt_paragraphs
        e_strings                = lt_strings
        e_tabstops               = lt_tabstops
      EXCEPTIONS
        no_name                  = 1
        no_style                 = 2
        active_style_not_found   = 3
        inactive_style_not_found = 4
        no_variant               = 5
        no_main_variant          = 6
        cancelled                = 7
        no_access_permission     = 8
        OTHERS                   = 9.
    IF sy-subrc = 2.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from SSF_READ_STYLE&apos; ).
    ENDIF.

    CLEAR ls_header-version.
    CLEAR ls_header-firstuser.
    CLEAR ls_header-firstdate.
    CLEAR ls_header-firsttime.
    CLEAR ls_header-lastuser.
    CLEAR ls_header-lastdate.
    CLEAR ls_header-lasttime.

    io_xml-&gt;add( iv_name = &apos;HEADER&apos;
                 ig_data = ls_header ).
    io_xml-&gt;add( ig_data = lt_paragraphs
                 iv_name = &apos;SSFPARAS&apos; ).
    io_xml-&gt;add( ig_data = lt_strings
                 iv_name = &apos;SSFSTRINGS&apos; ).
    io_xml-&gt;add( ig_data = lt_tabstops
                 iv_name = &apos;STXSTAB&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;E_SMSTYLE&apos;
                                            iv_argument    = |{ ms_item-obj_name }| ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SSFO IMPLEMENTATION.
  METHOD code_item_section_handling.
    CONSTANTS: lc_node_item TYPE string VALUE &apos;item&apos; ##NO_TEXT.
    CONSTANTS: lc_node_text TYPE string VALUE &apos;#text&apos; ##NO_TEXT.

    IF iv_name IN get_range_node_codes( ).
      cv_within_code_section = abap_true.
    ENDIF.

    IF cv_within_code_section = abap_true.
      IF iv_name = lc_node_item.
        TRY.
            ei_code_item_element ?= ii_node.
            RETURN.
          CATCH cx_sy_move_cast_error ##no_handler.
        ENDTRY.

      ELSEIF iv_name NOT IN get_range_node_codes( ) AND
             iv_name &lt;&gt; lc_node_text.
        cv_within_code_section = abap_false.
      ENDIF.
    ENDIF.

    RAISE EXCEPTION TYPE zcx_abapgit_exception.

  ENDMETHOD.
  METHOD fix_ids.

    &quot; makes sure ID and IDREF values are the same values for each serialization run
    &quot; the standard code has a counter that keeps increasing values.
    &quot;
    &quot; It is important that IDs and IDREFs which are the same before the fix
    &quot; are also the same after the fix.

    TYPES:
      BEGIN OF ty_id_mapping,
        old TYPE string,
        new TYPE string,
      END OF ty_id_mapping,
      tty_id_mapping TYPE HASHED TABLE OF ty_id_mapping
                          WITH UNIQUE KEY old.

    DATA: lv_name       TYPE string,
          li_idref      TYPE REF TO if_ixml_node,
          li_node       TYPE REF TO if_ixml_node,
          li_attr       TYPE REF TO if_ixml_named_node_map,
          li_iterator   TYPE REF TO if_ixml_node_iterator,
          lt_id_mapping TYPE tty_id_mapping,
          ls_id_mapping LIKE LINE OF lt_id_mapping.

    li_iterator = ii_xml_doc-&gt;create_iterator( ).
    li_node = li_iterator-&gt;get_next( ).
    WHILE NOT li_node IS INITIAL.
      lv_name = li_node-&gt;get_name( ).
      IF lv_name = &apos;NODE&apos; OR lv_name = &apos;WINDOW&apos;.
        li_idref = li_node-&gt;get_attributes( )-&gt;get_named_item( &apos;IDREF&apos; ).
        IF li_idref IS BOUND.

          ls_id_mapping-old = li_idref-&gt;get_value( ).
          READ TABLE lt_id_mapping WITH KEY old = ls_id_mapping-old
                                   INTO ls_id_mapping.
          IF sy-subrc &lt;&gt; 0.
            lv_name = lines( lt_id_mapping ) + 1.
            ls_id_mapping-new = condense( lv_name ).
            INSERT ls_id_mapping INTO TABLE lt_id_mapping.
          ENDIF.

          li_idref-&gt;set_value( |{ ls_id_mapping-new }| ).
        ENDIF.
      ENDIF.
      li_node = li_iterator-&gt;get_next( ).
    ENDWHILE.

    li_iterator = ii_xml_doc-&gt;create_iterator( ).
    li_node = li_iterator-&gt;get_next( ).
    WHILE NOT li_node IS INITIAL.
      lv_name = li_node-&gt;get_name( ).
      IF lv_name = &apos;NODE&apos; OR lv_name = &apos;WINDOW&apos;.
        li_idref = li_node-&gt;get_attributes( )-&gt;get_named_item( &apos;ID&apos; ).
        IF li_idref IS BOUND.

          ls_id_mapping-old = li_idref-&gt;get_value( ).
          READ TABLE lt_id_mapping WITH KEY old = ls_id_mapping-old
                                   INTO ls_id_mapping.
          IF sy-subrc = 0.
            li_idref-&gt;set_value( |{ ls_id_mapping-new }| ).
          ELSE.
            li_attr = li_node-&gt;get_attributes( ).
            li_attr-&gt;remove_named_item( &apos;ID&apos; ).
          ENDIF.

        ENDIF.
      ENDIF.
      li_node = li_iterator-&gt;get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD get_range_node_codes.

    DATA: ls_range_node_code TYPE LINE OF ty_string_range.

    IF me-&gt;gt_range_node_codes IS INITIAL.
      ls_range_node_code-sign   = &apos;I&apos;.
      ls_range_node_code-option = &apos;EQ&apos;.
      ls_range_node_code-low    = &apos;CODE&apos;.
      INSERT ls_range_node_code INTO TABLE me-&gt;gt_range_node_codes.
      ls_range_node_code-low    = &apos;GTYPES&apos;.
      INSERT ls_range_node_code INTO TABLE me-&gt;gt_range_node_codes.
      ls_range_node_code-low    = &apos;GCODING&apos;.
      INSERT ls_range_node_code INTO TABLE me-&gt;gt_range_node_codes.
      ls_range_node_code-low    = &apos;FCODING&apos;.
      INSERT ls_range_node_code INTO TABLE me-&gt;gt_range_node_codes.
    ENDIF.

    rt_range_node_codes = me-&gt;gt_range_node_codes.

  ENDMETHOD.
  METHOD handle_attrib_leading_spaces.

    DATA li_element        TYPE REF TO if_ixml_element.
    DATA lv_leading_spaces TYPE string.
    DATA lv_coding_line    TYPE string.

    TRY.
        code_item_section_handling( EXPORTING iv_name                = iv_name
                                              ii_node                = ii_node
                                    IMPORTING ei_code_item_element   = li_element
                                    CHANGING  cv_within_code_section = cv_within_code_section ).

        lv_leading_spaces = li_element-&gt;get_attribute_ns(
          name = zcl_abapgit_object_ssfo=&gt;attrib_abapgit_leadig_spaces ).

        lv_coding_line = li_element-&gt;get_value( ).
        SHIFT lv_coding_line RIGHT BY lv_leading_spaces PLACES.
        li_element-&gt;set_value( lv_coding_line ).
      CATCH zcx_abapgit_exception ##no_handler.
    ENDTRY.

  ENDMETHOD.
  METHOD set_attribute_leading_spaces.

    DATA: li_element             TYPE REF TO if_ixml_element.
    DATA: lv_code_line           TYPE string.
    DATA: lv_offset              TYPE i.

    TRY.
        code_item_section_handling( EXPORTING iv_name                = iv_name
                                              ii_node                = ii_node
                                    IMPORTING ei_code_item_element   = li_element
                                    CHANGING  cv_within_code_section = cv_within_code_section ).

        lv_code_line = ii_node-&gt;get_value( ).
        &quot;find 1st non space char
        FIND FIRST OCCURRENCE OF REGEX &apos;\S&apos; IN lv_code_line MATCH OFFSET lv_offset.
        IF sy-subrc = 0 AND lv_offset &gt; 0.
          TRY.
              li_element ?= ii_node.
              li_element-&gt;set_attribute( name  = zcl_abapgit_object_ssfo=&gt;attrib_abapgit_leadig_spaces
                                      value = |{ lv_offset }| ).

            CATCH cx_sy_move_cast_error ##no_handler.
          ENDTRY.
        ENDIF.
      CATCH zcx_abapgit_exception ##no_handler.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM stxfadm INTO rv_user
      WHERE formname = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_formname TYPE tdsfname.

    lv_formname = ms_item-obj_name.

    CALL FUNCTION &apos;FB_DELETE_FORM&apos;
      EXPORTING
        i_formname            = lv_formname
        i_with_dialog         = abap_false
        i_with_confirm_dialog = abap_false
      EXCEPTIONS
        no_form               = 1
        OTHERS                = 2.
    IF sy-subrc &lt;&gt; 0 AND sy-subrc &lt;&gt; 1.
      zcx_abapgit_exception=&gt;raise( &apos;Error from FB_DELETE_FORM&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* see function module FB_UPLOAD_FORM

    DATA: li_node                TYPE REF TO if_ixml_node,
          lv_formname            TYPE tdsfname,
          lv_name                TYPE string,
          li_iterator            TYPE REF TO if_ixml_node_iterator,
          lo_sf                  TYPE REF TO cl_ssf_fb_smart_form,
          lo_res                 TYPE REF TO cl_ssf_fb_smart_form,
          lx_error               TYPE REF TO cx_ssf_fb,
          lv_text                TYPE string,
          lv_within_code_section TYPE abap_bool.

    CREATE OBJECT lo_sf.

* set &quot;created by&quot; and &quot;changed by&quot; to current user
    li_iterator = io_xml-&gt;get_raw( )-&gt;get_root_element( )-&gt;create_iterator( ).
    li_node = li_iterator-&gt;get_next( ).
    WHILE NOT li_node IS INITIAL.
      lv_name = li_node-&gt;get_name( ).
      CASE lv_name.
        WHEN &apos;LASTDATE&apos;.
          li_node-&gt;set_value(
            sy-datum(4) &amp;&amp; &apos;-&apos; &amp;&amp; sy-datum+4(2) &amp;&amp; &apos;-&apos; &amp;&amp; sy-datum+6(2) ).
        WHEN &apos;LASTTIME&apos;.
          li_node-&gt;set_value(
            sy-uzeit(2) &amp;&amp; &apos;:&apos; &amp;&amp; sy-uzeit+2(2) &amp;&amp; &apos;:&apos; &amp;&amp; sy-uzeit+4(2) ).
        WHEN &apos;FIRSTUSER&apos; OR &apos;LASTUSER&apos;.
          li_node-&gt;set_value( sy-uname &amp;&amp; &apos;&apos; ).

      ENDCASE.

      handle_attrib_leading_spaces( EXPORTING iv_name                = lv_name
                                              ii_node                = li_node
                                    CHANGING  cv_within_code_section = lv_within_code_section ).

      li_node = li_iterator-&gt;get_next( ).
    ENDWHILE.

    tadir_insert( iv_package ).

    lv_formname = ms_item-obj_name.

    TRY.
        lo_sf-&gt;enqueue( suppress_corr_check = space
                        master_language     = mv_language
                        mode                = &apos;INSERT&apos;
                        formname            = lv_formname ).

        lo_sf-&gt;xml_upload( EXPORTING dom      = io_xml-&gt;get_raw( )-&gt;get_root_element( )
                                     formname = lv_formname
                                     language = mv_language
                           CHANGING  sform    = lo_res ).

        lo_res-&gt;store( im_formname = lo_res-&gt;header-formname
                       im_language = mv_language
                       im_active   = abap_true ).

        lo_sf-&gt;dequeue( lv_formname ).

      CATCH cx_ssf_fb INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( |{ ms_item-obj_type } { ms_item-obj_name }: { lv_text } | ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_formname TYPE stxfadm-formname.

    SELECT SINGLE formname FROM stxfadm INTO lv_formname
      WHERE formname = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.

    DATA: lv_ssfo_formname TYPE tdsfname.

    lv_ssfo_formname = ms_item-obj_name.

    CALL FUNCTION &apos;SSF_STATUS_INFO&apos;
      EXPORTING
        i_formname = lv_ssfo_formname
      IMPORTING
        o_inactive = ms_item-inactive.

    rv_active = boolc( ms_item-inactive = abap_false ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;E_SMFORM&apos;
                                            iv_argument    = |{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata  TYPE TABLE OF bdcdata,
          lv_formtype TYPE stxfadm-formtype.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPMSSFO&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0100&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    SELECT SINGLE formtype FROM stxfadm INTO lv_formtype
           WHERE formname = ms_item-obj_name.

    IF lv_formtype = cssf_formtype_text.

      APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
      &lt;ls_bdcdata&gt;-fnam = &apos;RB_TX&apos;.
      &lt;ls_bdcdata&gt;-fval = abap_true.

      APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
      &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
      &lt;ls_bdcdata&gt;-fval = &apos;=RB&apos;.

      APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
      &lt;ls_bdcdata&gt;-program  = &apos;SAPMSSFO&apos;.
      &lt;ls_bdcdata&gt;-dynpro   = &apos;0100&apos;.
      &lt;ls_bdcdata&gt;-dynbegin = abap_true.

      APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
      &lt;ls_bdcdata&gt;-fnam = &apos;SSFSCREEN-TNAME&apos;.
      &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    ELSE.

      APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
      &lt;ls_bdcdata&gt;-fnam = &apos;SSFSCREEN-FNAME&apos;.
      &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    ENDIF.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=DISPLAY&apos;.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SMARTFORMS&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bdcdata
      EXCEPTIONS
        OTHERS    = 1
        ##fm_subrc_ok.                                                   &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.
* see function module FB_DOWNLOAD_FORM

    DATA: lo_sf                  TYPE REF TO cl_ssf_fb_smart_form,
          lv_name                TYPE string,
          li_node                TYPE REF TO if_ixml_node,
          li_element             TYPE REF TO if_ixml_element,
          li_iterator            TYPE REF TO if_ixml_node_iterator,
          lv_formname            TYPE tdsfname,
          li_ixml                TYPE REF TO if_ixml,
          li_xml_doc             TYPE REF TO if_ixml_document,
          lv_within_code_section TYPE abap_bool.

    li_ixml = cl_ixml=&gt;create( ).
    li_xml_doc = li_ixml-&gt;create_document( ).

    CREATE OBJECT lo_sf.
    lv_formname = ms_item-obj_name. &quot; convert type
    TRY.
        lo_sf-&gt;load( im_formname = lv_formname
                     im_language = &apos;&apos; ).
      CATCH cx_ssf_fb.
* the smartform is not present in system, or other error occured
        RETURN.
    ENDTRY.

    lo_sf-&gt;xml_download( EXPORTING parent   = li_xml_doc
                         CHANGING  document = li_xml_doc ).

    li_iterator = li_xml_doc-&gt;create_iterator( ).
    li_node = li_iterator-&gt;get_next( ).
    WHILE NOT li_node IS INITIAL.

      lv_name = li_node-&gt;get_name( ).
      IF lv_name = &apos;DEVCLASS&apos;
          OR lv_name = &apos;LASTDATE&apos;
          OR lv_name = &apos;LASTTIME&apos;.
        li_node-&gt;set_value( &apos;&apos; ).
      ENDIF.
      IF lv_name = &apos;FIRSTUSER&apos;
          OR lv_name = &apos;LASTUSER&apos;.
        li_node-&gt;set_value( &apos;DUMMY&apos; ).
      ENDIF.
      set_attribute_leading_spaces( EXPORTING iv_name                = lv_name
                                              ii_node                = li_node
                                    CHANGING  cv_within_code_section = lv_within_code_section ).

      li_node = li_iterator-&gt;get_next( ).
    ENDWHILE.

    fix_ids( li_xml_doc ).

    li_element = li_xml_doc-&gt;get_root_element( ).
    li_element-&gt;set_attribute(
      name      = &apos;sf&apos;
      namespace = &apos;xmlns&apos;
      value     = &apos;urn:sap-com:SmartForms:2000:internal-structure&apos; ). &quot;#EC NOTEXT
    li_element-&gt;set_attribute(
      name  = &apos;xmlns&apos;
      value = &apos;urn:sap-com:sdixml-ifr:2000&apos; ).              &quot;#EC NOTEXT

    io_xml-&gt;set_raw( li_xml_doc-&gt;get_root_element( ) ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_srfc IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: li_srfc_persist TYPE REF TO if_wb_object_persist,
          lx_error        TYPE REF TO cx_root,
          lv_text         TYPE string.

    TRY.
        CREATE OBJECT li_srfc_persist TYPE (&apos;CL_UCONRFC_OBJECT_PERSIST&apos;).

        li_srfc_persist-&gt;delete( p_object_key = |{ ms_item-obj_name }|
                                 p_version    = &apos;A&apos; ).

      CATCH cx_root INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: li_srfc_persist TYPE REF TO if_wb_object_persist,
          li_object_data  TYPE REF TO if_wb_object_data_model,
          lv_text         TYPE string,
          lr_srfc_data    TYPE REF TO data,
          lx_error        TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_srfc_data&gt; TYPE any.
    TRY.
        CREATE DATA lr_srfc_data TYPE (&apos;UCONRFCSERV_COMPLETE&apos;).
        ASSIGN lr_srfc_data-&gt;* TO &lt;lg_srfc_data&gt;.
        ASSERT sy-subrc = 0.

        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;SRFC&apos;
          CHANGING
            cg_data = &lt;lg_srfc_data&gt; ).

        CREATE OBJECT li_srfc_persist TYPE (&apos;CL_UCONRFC_OBJECT_PERSIST&apos;).
        CREATE OBJECT li_object_data TYPE (&apos;CL_UCONRFC_OBJECT_DATA&apos;).

        li_object_data-&gt;set_data( &lt;lg_srfc_data&gt; ).

        li_srfc_persist-&gt;save( li_object_data ).

        tadir_insert( iv_package ).

      CATCH cx_root INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: li_object_data  TYPE REF TO if_wb_object_data_model,
          li_srfc_persist TYPE REF TO if_wb_object_persist.

    TRY.
        CREATE OBJECT li_srfc_persist TYPE (&apos;CL_UCONRFC_OBJECT_PERSIST&apos;).

        li_srfc_persist-&gt;get(
          EXPORTING
            p_object_key  = |{ ms_item-obj_name }|
            p_version     = &apos;A&apos;
          CHANGING
            p_object_data = li_object_data ).

      CATCH cx_root.
        rv_bool = abap_false.
        RETURN.
    ENDTRY.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name    &quot; Object Name
        object_type         = ms_item-obj_type    &quot; Object Type
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_TOOL_ACCESS&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: li_object_data  TYPE REF TO if_wb_object_data_model,
          li_srfc_persist TYPE REF TO if_wb_object_persist,
          lr_srfc_data    TYPE REF TO data,
          lx_error        TYPE REF TO cx_root,
          lv_text         TYPE string.

    FIELD-SYMBOLS: &lt;lg_srfc_data&gt; TYPE any.
    TRY.
        CREATE DATA lr_srfc_data TYPE (&apos;UCONRFCSERV_COMPLETE&apos;).
        ASSIGN lr_srfc_data-&gt;* TO &lt;lg_srfc_data&gt;.
        ASSERT sy-subrc = 0.

        CREATE OBJECT li_srfc_persist TYPE (&apos;CL_UCONRFC_OBJECT_PERSIST&apos;).

        li_srfc_persist-&gt;get(
          EXPORTING
            p_object_key  = |{ ms_item-obj_name }|
            p_version     = &apos;A&apos;
          CHANGING
            p_object_data = li_object_data ).

        li_object_data-&gt;get_data(
          IMPORTING
            p_data = &lt;lg_srfc_data&gt; ).

      CATCH cx_root INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

    io_xml-&gt;add( iv_name = &apos;SRFC&apos;
                 ig_data = &lt;lg_srfc_data&gt; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_splo IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE chgname1 FROM tsp1d INTO rv_user
      WHERE papart = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0 OR rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_tsp1t TYPE tsp1t,
          ls_tsp1d TYPE tsp1d,
          ls_tsp0p TYPE tsp0p.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tsp1t INTO ls_tsp1t
      WHERE papart = ms_item-obj_name
      AND spras = mv_language.            &quot;#EC CI_GENBUFF &quot;#EC CI_SUBRC
    SELECT SINGLE * FROM tsp1d INTO ls_tsp1d
      WHERE papart = ms_item-obj_name.                    &quot;#EC CI_SUBRC
    SELECT SINGLE * FROM tsp0p INTO ls_tsp0p
      WHERE pdpaper = ms_item-obj_name.                   &quot;#EC CI_SUBRC

    CLEAR: ls_tsp1d-chgname1,
           ls_tsp1d-chgtstmp1,
           ls_tsp1d-chgsaprel1,
           ls_tsp1d-chgsapsys1.

    io_xml-&gt;add( iv_name = &apos;TSPLT&apos;
                 ig_data = ls_tsp1t ).
    io_xml-&gt;add( iv_name = &apos;TSPLD&apos;
                 ig_data = ls_tsp1d ).
    io_xml-&gt;add( iv_name = &apos;TSP0P&apos;
                 ig_data = ls_tsp0p ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_tsp1t TYPE tsp1t,
          ls_tsp1d TYPE tsp1d,
          ls_tsp0p TYPE tsp0p.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSPLT&apos;
                  CHANGING cg_data = ls_tsp1t ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSPLD&apos;
                  CHANGING cg_data = ls_tsp1d ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TSP0P&apos;
                  CHANGING cg_data = ls_tsp0p ).

    MODIFY tsp1t FROM ls_tsp1t.                           &quot;#EC CI_SUBRC
    MODIFY tsp1d FROM ls_tsp1d.                           &quot;#EC CI_SUBRC
    MODIFY tsp0p FROM ls_tsp0p.                           &quot;#EC CI_SUBRC

    tadir_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DELETE FROM tsp1t WHERE papart = ms_item-obj_name. &quot;#EC CI_NOFIRST &quot;#EC CI_SUBRC
    DELETE FROM tsp1d WHERE papart = ms_item-obj_name.    &quot;#EC CI_SUBRC
    DELETE FROM tsp0p WHERE pdpaper = ms_item-obj_name.   &quot;#EC CI_SUBRC

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_papart TYPE tsp1d-papart.
    SELECT SINGLE papart INTO lv_papart FROM tsp1d
      WHERE papart = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    zcx_abapgit_exception=&gt;raise( &apos;todo, jump, SPLO&apos; ).
  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_smim IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_loio TYPE sdok_docid.
    lv_loio = ms_item-obj_name.

    SELECT SINGLE chng_user FROM smimloio INTO rv_user
      WHERE loio_id = lv_loio.                          &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0 OR rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_loio TYPE sdok_docid.
    lv_loio = ms_item-obj_name.

    SELECT SINGLE loio_id FROM smimloio INTO lv_loio
      WHERE loio_id = lv_loio.                          &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD get_url_for_io.

    DATA: ls_io       TYPE skwf_io,
          lv_url      TYPE skwf_url,
          ls_smimloio TYPE smimloio,
          lv_loio     TYPE sdok_docid.
    lv_loio = ms_item-obj_name.

    CLEAR ev_url.
    CLEAR ev_is_folder.

    SELECT SINGLE * FROM smimloio INTO ls_smimloio
      WHERE loio_id = lv_loio.                          &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_abapgit_not_found.
    ENDIF.

    IF ls_smimloio-lo_class = wbmr_c_skwf_folder_class.
      ev_is_folder = abap_true.
      ls_io-objtype = skwfc_obtype_folder.
    ELSE.
      ls_io-objtype = skwfc_obtype_loio.
    ENDIF.
    ls_io-class = ls_smimloio-lo_class.
    ls_io-objid = ls_smimloio-loio_id.

    CALL FUNCTION &apos;SKWF_NMSPC_IO_ADDRESS_GET&apos;
      EXPORTING
        io  = ls_io
      IMPORTING
        url = lv_url.

    ev_url = lv_url.

  ENDMETHOD.

  METHOD build_filename.

    CONCATENATE ms_item-obj_name ms_item-obj_type iv_filename
      INTO rv_filename SEPARATED BY &apos;.&apos;.
    TRANSLATE rv_filename TO LOWER CASE.

  ENDMETHOD.

  METHOD find_content.

    DATA: lv_filename TYPE string,
          lt_files    TYPE zif_abapgit_definitions=&gt;ty_files_tt.

    FIELD-SYMBOLS: &lt;ls_file&gt; LIKE LINE OF lt_files.
    lv_filename = get_filename( iv_url ).

    lv_filename = build_filename( lv_filename ).

    lt_files = mo_files-&gt;get_files( ).

    READ TABLE lt_files ASSIGNING &lt;ls_file&gt; WITH KEY filename = lv_filename.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;SMIM, file not found&apos; ).
    ENDIF.

    rv_content = &lt;ls_file&gt;-data.

  ENDMETHOD.

  METHOD get_filename.

    DATA: lv_lines   TYPE i,
          lt_strings TYPE TABLE OF string.
    SPLIT iv_url AT &apos;/&apos; INTO TABLE lt_strings.
    lv_lines = lines( lt_strings ).
    ASSERT lv_lines &gt; 0.
    READ TABLE lt_strings INDEX lv_lines INTO rv_filename.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_url      TYPE string,
          lv_folder   TYPE abap_bool,
          lv_filename TYPE string,
          lv_class    TYPE smimloio-lo_class,
          ls_file     TYPE zif_abapgit_definitions=&gt;ty_file,
          lv_content  TYPE xstring,
          li_api      TYPE REF TO if_mr_api,
          lv_loio     TYPE sdok_docid.
    lv_loio = ms_item-obj_name.

    TRY.
        get_url_for_io(
          IMPORTING
            ev_url       = lv_url
            ev_is_folder = lv_folder ).
      CATCH zcx_abapgit_not_found.
        RETURN.
    ENDTRY.

    IF lv_folder = abap_false.
      li_api = cl_mime_repository_api=&gt;if_mr_api~get_api( ).
      li_api-&gt;get(
        EXPORTING
          i_url              = lv_url
        IMPORTING
          e_content          = lv_content
        EXCEPTIONS
          parameter_missing  = 1
          error_occured      = 2
          not_found          = 3
          permission_failure = 4
          OTHERS             = 5 ).
      IF sy-subrc &lt;&gt; 0 AND sy-subrc &lt;&gt; 2 AND sy-subrc &lt;&gt; 3.
        zcx_abapgit_exception=&gt;raise( &apos;error from mime api-&gt;get:&apos; &amp;&amp; sy-msgv1 ).
      ENDIF.

      lv_filename = get_filename( lv_url ).
      CLEAR ls_file.
      ls_file-filename = build_filename( lv_filename ).
      ls_file-path     = &apos;/&apos;.
      ls_file-data     = lv_content.
      mo_files-&gt;add( ls_file ).

      SELECT SINGLE lo_class FROM smimloio INTO lv_class
        WHERE loio_id = lv_loio.                        &quot;#EC CI_GENBUFF
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;URL&apos;
                 ig_data = lv_url ).
    io_xml-&gt;add( iv_name = &apos;FOLDER&apos;
                 ig_data = lv_folder ).
    io_xml-&gt;add( iv_name = &apos;CLASS&apos;
                 ig_data = lv_class ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_url      TYPE string,
          lv_folder   TYPE abap_bool,
          lv_content  TYPE xstring,
          lv_filename TYPE skwf_filnm,
          lv_io       TYPE sdok_docid,
          lv_class    TYPE smimloio-lo_class,
          ls_skwf_io  TYPE skwf_io,
          li_api      TYPE REF TO if_mr_api.
    li_api = cl_mime_repository_api=&gt;if_mr_api~get_api( ).
    lv_io = ms_item-obj_name.

    io_xml-&gt;read( EXPORTING iv_name = &apos;URL&apos;
                  CHANGING cg_data = lv_url ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;FOLDER&apos;
                  CHANGING cg_data = lv_folder ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CLASS&apos;
                  CHANGING cg_data = lv_class ).

    ls_skwf_io-objid = lv_io.

    IF lv_folder = abap_true.
      li_api-&gt;create_folder(
        EXPORTING
          i_url              = lv_url
          i_language         = sy-langu
          i_dev_package      = iv_package
          i_folder_loio      = ls_skwf_io
        EXCEPTIONS
          parameter_missing  = 1
          error_occured      = 2
          cancelled          = 3
          permission_failure = 4
          folder_exists      = 5
          OTHERS             = 6 ).
      IF sy-subrc &lt;&gt; 5 AND sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error frrom SMIM create_folder&apos; ).
      ENDIF.
    ELSE.
      lv_filename = get_filename( lv_url ).
      ls_skwf_io-class = lv_class.
      IF ls_skwf_io-class IS INITIAL.
        cl_wb_mime_repository=&gt;determine_io_class(
          EXPORTING
            filename = lv_filename
          IMPORTING
            io_class = ls_skwf_io-class ).
        CONCATENATE ls_skwf_io-class &apos;_L&apos; INTO ls_skwf_io-class.
      ENDIF.

      lv_content = find_content( lv_url ).

      li_api-&gt;put(
        EXPORTING
          i_url                   = lv_url
          i_content               = lv_content
          i_dev_package           = iv_package
          i_new_loio              = ls_skwf_io
        EXCEPTIONS
          parameter_missing       = 1
          error_occured           = 2
          cancelled               = 3
          permission_failure      = 4
          data_inconsistency      = 5
          new_loio_already_exists = 6
          is_folder               = 7
          OTHERS                  = 8 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from SMIM put&apos; ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_api TYPE REF TO if_mr_api,
          lv_url TYPE string.
    TRY.
        get_url_for_io(
          IMPORTING
            ev_url  = lv_url ).
      CATCH zcx_abapgit_not_found.
        RETURN.
    ENDTRY.

    li_api = cl_mime_repository_api=&gt;if_mr_api~get_api( ).
    li_api-&gt;delete(
      EXPORTING
        i_url              = lv_url
        i_delete_children  = abap_true
      EXCEPTIONS
        parameter_missing  = 1
        error_occured      = 2
        cancelled          = 3
        permission_failure = 4
        not_found          = 5
        OTHERS             = 6 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from delete&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sicf IMPLEMENTATION.
  METHOD change_sicf.

    DATA: lt_icfhndlist TYPE icfhndlist,
          lt_existing   TYPE TABLE OF icfhandler,
          ls_icfserdesc TYPE icfserdesc.

    FIELD-SYMBOLS: &lt;ls_existing&gt; LIKE LINE OF lt_existing.
    lt_icfhndlist = to_icfhndlist( it_icfhandler ).

* Do not add handlers if they already exist, it will make the below
* call to SAP standard code raise an exception
    SELECT * FROM icfhandler INTO TABLE lt_existing
      WHERE icf_name = is_icfservice-icf_name.
    LOOP AT lt_existing ASSIGNING &lt;ls_existing&gt;.
      DELETE TABLE lt_icfhndlist FROM &lt;ls_existing&gt;-icfhandler.
    ENDLOOP.

    MOVE-CORRESPONDING is_icfservice TO ls_icfserdesc.

    cl_icf_tree=&gt;if_icf_tree~change_node(
      EXPORTING
        icf_name                  = is_icfservice-orig_name
        icfparguid                = iv_parent
        icfdocu                   = is_icfdocu
        doculang                  = mv_language
        icfhandlst                = lt_icfhndlist
        package                   = iv_package
        application               = space
        icfserdesc                = ls_icfserdesc
        icfactive                 = abap_true
      EXCEPTIONS
        empty_icf_name            = 1
        no_new_virtual_host       = 2
        special_service_error     = 3
        parent_not_existing       = 4
        enqueue_error             = 5
        node_already_existing     = 6
        empty_docu                = 7
        doculang_not_installed    = 8
        security_info_error       = 9
        user_password_error       = 10
        password_encryption_error = 11
        invalid_url               = 12
        invalid_otr_concept       = 13
        formflg401_error          = 14
        handler_error             = 15
        transport_error           = 16
        tadir_error               = 17
        package_not_found         = 18
        wrong_application         = 19
        not_allow_application     = 20
        no_application            = 21
        invalid_icfparguid        = 22
        alt_name_invalid          = 23
        alternate_name_exist      = 24
        wrong_icf_name            = 25
        no_authority              = 26
        OTHERS                    = 27 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SICF - error from change_node. Subrc = { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD find_parent.

    cl_icf_tree=&gt;if_icf_tree~service_from_url(
      EXPORTING
        url                   = iv_url
        hostnumber            = 0
      IMPORTING
        icfnodguid            = rv_parent
      EXCEPTIONS
        wrong_application     = 1
        no_application        = 2
        not_allow_application = 3
        wrong_url             = 4
        no_authority          = 5
        OTHERS                = 6 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SICF - error from service_from_url. Subrc = { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD insert_sicf.

    DATA: lt_icfhndlist TYPE icfhndlist,
          ls_icfserdesc TYPE icfserdesc,
          ls_icfdocu    TYPE icfdocu,
          lv_parent     TYPE icfparguid.
    lt_icfhndlist = to_icfhndlist( it_icfhandler ).
    lv_parent = find_parent( iv_url ).

* nice, it seems that the structure should be mistreated
    ls_icfdocu = is_icfdocu-icf_docu.

    MOVE-CORRESPONDING is_icfservice TO ls_icfserdesc.

    cl_icf_tree=&gt;if_icf_tree~insert_node(
      EXPORTING
        icf_name                  = is_icfservice-orig_name
        icfparguid                = lv_parent
        icfdocu                   = ls_icfdocu
        doculang                  = mv_language
        icfhandlst                = lt_icfhndlist
        package                   = iv_package
        application               = space
        icfserdesc                = ls_icfserdesc
        icfactive                 = abap_true
      EXCEPTIONS
        empty_icf_name            = 1
        no_new_virtual_host       = 2
        special_service_error     = 3
        parent_not_existing       = 4
        enqueue_error             = 5
        node_already_existing     = 6
        empty_docu                = 7
        doculang_not_installed    = 8
        security_info_error       = 9
        user_password_error       = 10
        password_encryption_error = 11
        invalid_url               = 12
        invalid_otr_concept       = 13
        formflg401_error          = 14
        handler_error             = 15
        transport_error           = 16
        tadir_error               = 17
        package_not_found         = 18
        wrong_application         = 19
        not_allow_application     = 20
        no_application            = 21
        invalid_icfparguid        = 22
        alt_name_invalid          = 23
        alternate_name_exist      = 24
        wrong_icf_name            = 25
        no_authority              = 26
        OTHERS                    = 27 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SICF - error from insert_node: { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD read.

    DATA: lt_serv_info TYPE icfservtbl,
          ls_serv_info LIKE LINE OF lt_serv_info,
          ls_key       TYPE ty_sicf_key.

    FIELD-SYMBOLS: &lt;ls_icfhandler&gt; LIKE LINE OF et_icfhandler.
    CLEAR es_icfservice.
    CLEAR es_icfdocu.
    CLEAR et_icfhandler.
    CLEAR ev_url.

    ls_key = read_tadir_sicf( ms_item-obj_name )-obj_name.

    cl_icf_tree=&gt;if_icf_tree~get_info_from_serv(
      EXPORTING
        icf_name          = ls_key-icf_name
        icfparguid        = ls_key-icfparguid
        icf_langu         = mv_language
      IMPORTING
        serv_info         = lt_serv_info
        icfdocu           = es_icfdocu
        url               = ev_url
      EXCEPTIONS
        wrong_name        = 1
        wrong_parguid     = 2
        incorrect_service = 3
        no_authority      = 4
        OTHERS            = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SICF - error from get_info_from_serv. Subrc = { sy-subrc }| ).
    ENDIF.

    ASSERT lines( lt_serv_info ) = 1.
    READ TABLE lt_serv_info INDEX 1 INTO ls_serv_info.
    ASSERT sy-subrc = 0.

    MOVE-CORRESPONDING ls_serv_info-service TO es_icfservice.
    IF iv_clear = abap_true.
      CLEAR es_icfservice-icf_cuser.
      CLEAR es_icfservice-icf_cdate.
      CLEAR es_icfservice-icf_muser.
      CLEAR es_icfservice-icf_mdate.
    ENDIF.

    CLEAR es_icfdocu-icfparguid.

    APPEND LINES OF ls_serv_info-handlertbl TO et_icfhandler.
    LOOP AT et_icfhandler ASSIGNING &lt;ls_icfhandler&gt;.
      CLEAR &lt;ls_icfhandler&gt;-icfparguid.
    ENDLOOP.

  ENDMETHOD.
  METHOD read_sicf_url.

* note: this method is called dynamically from some places

    DATA: lv_name    TYPE icfname,
          lv_url     TYPE string,
          lv_parguid TYPE icfparguid.
    lv_name    = iv_obj_name.
    lv_parguid = iv_obj_name+15.

    cl_icf_tree=&gt;if_icf_tree~get_info_from_serv(
      EXPORTING
        icf_name          = lv_name
        icfparguid        = lv_parguid
      IMPORTING
        url               = lv_url
      EXCEPTIONS
        wrong_name        = 1
        wrong_parguid     = 2
        incorrect_service = 3
        no_authority      = 4
        OTHERS            = 5 ).
    IF sy-subrc = 0.
      rv_hash = zcl_abapgit_hash=&gt;sha1_raw( zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_url ) ).
    ENDIF.

  ENDMETHOD.
  METHOD read_tadir_sicf.

* note: this method is called dynamically from some places

    DATA: lt_tadir    TYPE zif_abapgit_definitions=&gt;ty_tadir_tt,
          lv_hash     TYPE text25,
          lv_obj_name TYPE tadir-obj_name.

    FIELD-SYMBOLS: &lt;ls_tadir&gt; LIKE LINE OF lt_tadir.
    lv_hash = iv_obj_name+15.
    CONCATENATE iv_obj_name(15) &apos;%&apos; INTO lv_obj_name.

    SELECT * FROM tadir INTO CORRESPONDING FIELDS OF TABLE lt_tadir
      WHERE pgmid = iv_pgmid
      AND object = &apos;SICF&apos;
      AND obj_name LIKE lv_obj_name
      ORDER BY PRIMARY KEY.                             &quot;#EC CI_GENBUFF

    LOOP AT lt_tadir ASSIGNING &lt;ls_tadir&gt;.
      IF read_sicf_url( &lt;ls_tadir&gt;-obj_name ) = lv_hash.
        rs_tadir = &lt;ls_tadir&gt;.
        RETURN.
      ENDIF.
    ENDLOOP.

    IF lines( lt_tadir ) = 1.
      READ TABLE lt_tadir INDEX 1 ASSIGNING &lt;ls_tadir&gt;.
      ASSERT sy-subrc = 0.
      rs_tadir = &lt;ls_tadir&gt;.
    ENDIF.

  ENDMETHOD.
  METHOD to_icfhndlist.

    FIELD-SYMBOLS: &lt;ls_list&gt; LIKE LINE OF it_list.
* convert to sorted table
    LOOP AT it_list ASSIGNING &lt;ls_list&gt;.
      INSERT &lt;ls_list&gt;-icfhandler INTO TABLE rt_list.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_icfservice TYPE icfservice.
    read( EXPORTING iv_clear = abap_false
          IMPORTING es_icfservice = ls_icfservice ).

    rv_user = ls_icfservice-icf_muser.

    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: ls_icfservice TYPE icfservice.

    read( IMPORTING es_icfservice = ls_icfservice ).

    IF ls_icfservice IS INITIAL.
      &quot; It seems that the ICF service doesn&apos;t exist anymore.
      &quot; But that&apos;s ok, because some objects like SAPC manage
      &quot; the lifecycle of its ICF service by itself and already
      &quot; deleted the service.
      RETURN.
    ENDIF.

    IF ls_icfservice-icfparguid CO &apos;0&apos;.
      &quot; not supported by the SAP standard API
      zcx_abapgit_exception=&gt;raise( &apos;SICF - cannot delete root node, delete node manually&apos; ).
    ENDIF.

    &quot; Delete Application Customizing Data the hard way, as it isn&apos;t done by the API.
    &quot; If we wouldn&apos;t we would get errors from the API if entrys exist.
    &quot; Transaction SICF does the same.
    DELETE FROM icfapplcust
           WHERE icf_name = ls_icfservice-icf_name
           AND icfparguid = ls_icfservice-icfparguid.

    cl_icf_tree=&gt;if_icf_tree~delete_node(
      EXPORTING
        icfparguid                  = ls_icfservice-icfparguid
      CHANGING
        icf_name                    = ls_icfservice-icf_name
      EXCEPTIONS
        no_virtual_host_delete      = 1
        special_service_error       = 2
        enqueue_error               = 3
        node_not_existing           = 4
        node_has_childs             = 5
        node_is_aliased             = 6
        node_not_in_original_system = 7
        transport_error             = 8
        tadir_error                 = 9
        db_error                    = 10
        no_authority                = 11
        OTHERS                      = 12 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SICF - error from delete_node. Subrc = { sy-subrc }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_icfservice TYPE icfservice,
          ls_read       TYPE icfservice,
          ls_icfdocu    TYPE icfdocu,
          lv_url        TYPE string,
          lv_exists     TYPE abap_bool,
          lt_icfhandler TYPE TABLE OF icfhandler.
    io_xml-&gt;read( EXPORTING iv_name = &apos;URL&apos;
                  CHANGING cg_data = lv_url ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ICFSERVICE&apos;
                  CHANGING cg_data = ls_icfservice ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ICFDOCU&apos;
                  CHANGING cg_data = ls_icfdocu ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ICFHANDLER_TABLE&apos;
                  CHANGING cg_data = lt_icfhandler ).
    lv_exists = zif_abapgit_object~exists( ).
    IF lv_exists = abap_false.
      insert_sicf( is_icfservice = ls_icfservice
                   is_icfdocu    = ls_icfdocu
                   it_icfhandler = lt_icfhandler
                   iv_package    = iv_package
                   iv_url        = lv_url ).
    ELSE.
      read( IMPORTING es_icfservice = ls_read ).
      change_sicf( is_icfservice = ls_icfservice
                   is_icfdocu    = ls_icfdocu
                   it_icfhandler = lt_icfhandler
                   iv_package    = iv_package
                   iv_parent     = ls_read-icfparguid ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_tadir TYPE zif_abapgit_definitions=&gt;ty_tadir,
          ls_key   TYPE ty_sicf_key.

    ls_tadir = read_tadir_sicf( ms_item-obj_name ).

    rv_bool = boolc( NOT ls_tadir IS INITIAL ).

    IF rv_bool = abap_true.
      ls_key = ls_tadir-obj_name.
      SELECT SINGLE icfaltnme FROM icfservice INTO ls_key-icf_name
        WHERE icf_name = ls_key-icf_name
        AND icfparguid = ls_key-icfparguid.
      rv_bool = boolc( sy-subrc = 0 ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = ms_item-obj_name(15).
    lv_argument+15(1) = &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESICFSER&apos;
                                            iv_argument    = lv_argument ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;RSICFTREE&apos;.
    ls_bcdata-dynpro   = &apos;1000&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    ls_bcdata-dynpro   = space.
    ls_bcdata-dynbegin = space.
    ls_bcdata-fnam     = &apos;ICF_SERV&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=ONLI&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SICF&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SICF&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_icfservice TYPE icfservice,
          ls_icfdocu    TYPE icfdocu,
          lv_url        TYPE string,
          lt_icfhandler TYPE TABLE OF icfhandler.
    read( IMPORTING es_icfservice = ls_icfservice
                    es_icfdocu    = ls_icfdocu
                    et_icfhandler = lt_icfhandler
                    ev_url        = lv_url ).
    IF ls_icfservice IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR ls_icfservice-icf_mandt.
    CLEAR ls_icfservice-icfnodguid.
    CLEAR ls_icfservice-icfparguid.
    CLEAR ls_icfservice-icf_user.
    CLEAR ls_icfservice-icf_cclnt.
    CLEAR ls_icfservice-icf_mclnt.

    io_xml-&gt;add( iv_name = &apos;URL&apos;
                 ig_data = lv_url ).
    io_xml-&gt;add( iv_name = &apos;ICFSERVICE&apos;
                 ig_data = ls_icfservice ).
    io_xml-&gt;add( iv_name = &apos;ICFDOCU&apos;
                 ig_data = ls_icfdocu ).
    io_xml-&gt;add( iv_name = &apos;ICFHANDLER_TABLE&apos;
                 ig_data = lt_icfhandler ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_shma IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_area_name TYPE shm_area_name.

    SELECT SINGLE area_name
           FROM shma_attributes
           INTO lv_area_name
           WHERE area_name = ms_item-obj_name.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_area_name       TYPE shm_area_name,
          ls_area_attributes TYPE shma_attributes.

    lv_area_name = ms_item-obj_name.

    TRY.
        CALL METHOD (&apos;\PROGRAM=SAPLSHMA\CLASS=LCL_SHMA_HELPER&apos;)=&gt;(&apos;READ_AREA_ATTRIBUTES_ALL&apos;)
          EXPORTING
            area_name       = lv_area_name
          IMPORTING
            area_attributes = ls_area_attributes.

        CLEAR: ls_area_attributes-chg_user,
               ls_area_attributes-chg_date,
               ls_area_attributes-chg_time,
               ls_area_attributes-cls_gen_user,
               ls_area_attributes-cls_gen_date,
               ls_area_attributes-cls_gen_time.

        io_xml-&gt;add( iv_name = &apos;AREA_ATTRIBUTES&apos;
                     ig_data = ls_area_attributes ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error serializing SHMA { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_area_name       TYPE shm_area_name,
          ls_area_attributes TYPE shma_attributes.

    lv_area_name = ms_item-obj_name.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;AREA_ATTRIBUTES&apos;
      CHANGING
        cg_data = ls_area_attributes ).

    tadir_insert( iv_package ).

    TRY.
        CALL METHOD (&apos;\PROGRAM=SAPLSHMA\CLASS=LCL_SHMA_HELPER&apos;)=&gt;(&apos;INSERT_AREA&apos;)
          EXPORTING
            area_name           = lv_area_name
            attributes          = ls_area_attributes
            force_overwrite     = abap_true
            no_class_generation = abap_true
            silent_mode         = abap_true.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error serializing SHMA { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    &quot; We can&apos;t use FM SHMA_DELETE_AREA because it depends
    &quot; on the corresponding class, but in abapGit it has its own
    &quot; lifecycle. Therefore we have to reimplement most of the
    &quot; FMs logic

    CONSTANTS: lc_request_delete TYPE i VALUE 4.

    DATA: lv_request   TYPE i,
          lv_area_name TYPE shm_area_name,
          lv_order     TYPE e070-trkorr,
          lv_korrnum   TYPE tadir-korrnum,
          lv_objname   TYPE tadir-obj_name,
          lv_task      TYPE e070-trkorr,
          lv_append    TYPE abap_bool,
          ls_tadir     TYPE tadir,
          ls_tdevc     TYPE tdevc,
          lo_cts_if    TYPE REF TO object.

    lv_area_name = ms_item-obj_name.

    TRY.
        CALL FUNCTION &apos;ENQUEUE_E_SHM_AREA&apos;
          EXPORTING
            mode_shma_attributes = &apos;E&apos;
            area_name            = lv_area_name
            x_area_name          = &apos; &apos;
            _scope               = &apos;2&apos;
            _wait                = &apos; &apos;
            _collect             = &apos; &apos;
          EXCEPTIONS
            foreign_lock         = 1
            system_failure       = 2
            OTHERS               = 3.

        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( |Error deleting SHMA { ms_item-obj_name }| ).
        ENDIF.

        CALL METHOD (&apos;\PROGRAM=SAPMSHM_MONITOR\CLASS=LCL_SHMM&apos;)=&gt;(&apos;FREE_AREA_BY_NAME&apos;)
          EXPORTING
            area_name     = lv_area_name
            affect_server = cl_shm_area=&gt;affect_all_servers.

        CREATE OBJECT lo_cts_if TYPE (&apos;\FUNCTION-POOL=SHMA\CLASS=LCL_CTS_INTERFACE&apos;)
          EXPORTING
            area = lv_area_name.

        CALL METHOD lo_cts_if-&gt;(&apos;CHECK_AREA&apos;)
          EXPORTING
            request     = lc_request_delete
          IMPORTING
            access_mode = lv_request
            appendable  = lv_append.

        IF lv_request &lt;&gt; lc_request_delete.
          zcx_abapgit_exception=&gt;raise( |Error deleting SHMA { ms_item-obj_name }| ).
        ENDIF.

        CALL METHOD lo_cts_if-&gt;(&apos;INSERT_AREA&apos;)
          EXPORTING
            request = lc_request_delete
          IMPORTING
            order   = lv_order
            task    = lv_task.

        DELETE FROM shma_attributes  WHERE area_name = lv_area_name.
        DELETE FROM shma_start       WHERE area_name = lv_area_name.

        lv_korrnum = lv_order.
        lv_objname = lv_area_name.

        CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
          EXPORTING
            wi_read_only      = abap_true
            wi_tadir_pgmid    = &apos;R3TR&apos;
            wi_tadir_object   = &apos;SHMA&apos;
            wi_tadir_obj_name = lv_objname
          IMPORTING
            new_tadir_entry   = ls_tadir
          EXCEPTIONS
            OTHERS            = 0.

        CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
          EXPORTING
            iv_devclass = ls_tadir-devclass
          IMPORTING
            es_tdevc    = ls_tdevc
          EXCEPTIONS
            OTHERS      = 1.

        IF sy-subrc = 0 AND ls_tdevc-korrflag IS INITIAL.

          &quot; TADIR entries for local objects must be deleted &apos;by hand&apos;

          CALL FUNCTION &apos;TR_TADIR_INTERFACE&apos;
            EXPORTING
              wi_test_modus         = abap_false
              wi_delete_tadir_entry = abap_true
              wi_tadir_pgmid        = &apos;R3TR&apos;
              wi_tadir_object       = &apos;SHMA&apos;
              wi_tadir_obj_name     = lv_objname
              wi_tadir_korrnum      = lv_korrnum
            EXCEPTIONS
              OTHERS                = 0.

        ENDIF.

        CALL METHOD (&apos;\PROGRAM=SAPLSHMA\CLASS=LCL_SHMA_HELPER&apos;)=&gt;(&apos;DELETE_RUNTIME_SETTINGS&apos;)
          EXPORTING
            area_name = lv_area_name.

        CALL FUNCTION &apos;DEQUEUE_E_SHM_AREA&apos;
          EXPORTING
            mode_shma_attributes = &apos;E&apos;
            area_name            = lv_area_name
            x_area_name          = &apos; &apos;
            _scope               = &apos;3&apos;
            _synchron            = &apos; &apos;
            _collect             = &apos; &apos;.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error deleting SHMA { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPLSHMA&apos;.
    ls_bcdata-dynpro   = &apos;0100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;SHMA_ATTRIBUTES-AREA_NAME&apos;.
    ls_bcdata-fval = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=SHOW&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SHMA&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SHMA&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_shlp IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd30l
       INTO (lv_date, lv_time)
       WHERE shlpname = ms_item-obj_name
       AND as4local = &apos;A&apos;.                              &quot;#EC CI_GENBUFF

    rv_changed = check_timestamp(
     iv_timestamp = iv_timestamp
     iv_date      = lv_date
     iv_time      = lv_time ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd30l INTO rv_user
      WHERE shlpname = ms_item-obj_name
      AND as4local = &apos;A&apos;.                               &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_shlpname TYPE dd30l-shlpname.
    SELECT SINGLE shlpname FROM dd30l INTO lv_shlpname
      WHERE shlpname = ms_item-obj_name
      AND as4local = &apos;A&apos;.                               &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-SHMA&apos;
               iv_field = &apos;RSRD1-SHMA_VAL&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;H&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, SHLP&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd30v TYPE dd30v,
          lt_dd31v TYPE TABLE OF dd31v,
          lt_dd32p TYPE TABLE OF dd32p,
          lt_dd33v TYPE TABLE OF dd33v.

    FIELD-SYMBOLS: &lt;ls_dd32p&gt; LIKE LINE OF lt_dd32p.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
      EXPORTING
        name          = lv_name
        state         = &apos;A&apos;
        langu         = mv_language
      IMPORTING
        dd30v_wa      = ls_dd30v
      TABLES
        dd31v_tab     = lt_dd31v
        dd32p_tab     = lt_dd32p
        dd33v_tab     = lt_dd33v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_SHLP_GET&apos; ).
    ENDIF.
    IF ls_dd30v IS INITIAL.
      RETURN. &quot; does not exist in system
    ENDIF.

    CLEAR: ls_dd30v-as4user,
           ls_dd30v-as4date,
           ls_dd30v-as4time.

    LOOP AT lt_dd32p ASSIGNING &lt;ls_dd32p&gt;.
* clear information inherited from domain
      CLEAR: &lt;ls_dd32p&gt;-domname,
        &lt;ls_dd32p&gt;-headlen,
        &lt;ls_dd32p&gt;-scrlen1,
        &lt;ls_dd32p&gt;-scrlen2,
        &lt;ls_dd32p&gt;-datatype,
        &lt;ls_dd32p&gt;-leng,
        &lt;ls_dd32p&gt;-outputlen,
        &lt;ls_dd32p&gt;-decimals,
        &lt;ls_dd32p&gt;-lowercase,
        &lt;ls_dd32p&gt;-signflag,
        &lt;ls_dd32p&gt;-convexit.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;DD30V&apos;
                 ig_data = ls_dd30v ).
    io_xml-&gt;add( ig_data = lt_dd31v
                 iv_name = &apos;DD31V_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd32p
                 iv_name = &apos;DD32P_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd33v
                 iv_name = &apos;DD33V_TABLE&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd30v TYPE dd30v,
          lt_dd31v TYPE TABLE OF dd31v,
          lt_dd32p TYPE TABLE OF dd32p,
          lt_dd33v TYPE TABLE OF dd33v.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD30V&apos;
                  CHANGING cg_data = ls_dd30v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD31V_TABLE&apos;
                  CHANGING cg_data = lt_dd31v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD32P_TABLE&apos;
                  CHANGING cg_data = lt_dd32p ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD33V_TABLE&apos;
                  CHANGING cg_data = lt_dd33v ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_SHLP_PUT&apos;
      EXPORTING
        name              = lv_name
        dd30v_wa          = ls_dd30v
      TABLES
        dd31v_tab         = lt_dd31v
        dd32p_tab         = lt_dd32p
        dd33v_tab         = lt_dd33v
      EXCEPTIONS
        shlp_not_found    = 1
        name_inconsistent = 2
        shlp_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_SHLP_PUT&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_shi8 IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_assignment_id = ms_item-obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    zcx_abapgit_exception=&gt;raise( |TODO: Jump SHI8| ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;STREE_SFW_ASSIGNMENT_ID_EXISTS&apos;
      EXPORTING
        assignment_id = mv_assignment_id
      IMPORTING
        exists        = rv_bool.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_deleted TYPE xfeld,
          ls_message TYPE hier_mess.

    CALL FUNCTION &apos;STREE_SFW_ASSIGNMENT_DELETE&apos;
      EXPORTING
        assignment_id = mv_assignment_id
      IMPORTING
        id_deleted    = lv_deleted
        message       = ls_message.

    IF lv_deleted = abap_false.
      zcx_abapgit_exception=&gt;raise( |{ ls_message-msgtxt }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lt_assignments     TYPE STANDARD TABLE OF hier_sfw_assignment_id,
          ls_assignment      LIKE LINE OF lt_assignments,
          lt_assignment_data TYPE STANDARD TABLE OF ttree_sfw_nodes,
          ls_assignment_data LIKE LINE OF lt_assignment_data.

    ls_assignment-sfw_ass_id = mv_assignment_id.
    INSERT ls_assignment INTO TABLE lt_assignments.

    CALL FUNCTION &apos;STREE_SFW_ASSIGNMENT_READ&apos;
      TABLES
        it_assignments     = lt_assignments
        et_assignment_data = lt_assignment_data.

    READ TABLE lt_assignment_data INTO ls_assignment_data
                                  INDEX 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error serializing { ms_item-obj_type } { ms_item-obj_name  }| ).
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;SHI8&apos;
                 ig_data = ls_assignment_data ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_assignment_data TYPE ttree_sfw_nodes,
          ls_node_data       TYPE hier_iface,
          lv_saved           TYPE xfeld,
          ls_message         TYPE hier_mess.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;SHI8&apos;
      CHANGING
        cg_data = ls_assignment_data ).

    ls_node_data-tree_id = ls_assignment_data-tree_id.
    ls_node_data-node_id = ls_assignment_data-node_id.

    CALL FUNCTION &apos;STREE_SFW_ASSIGNMENT_SAVE&apos;
      EXPORTING
        assignment_id = ls_assignment_data-sfw_ass_id
        switch_id     = ls_assignment_data-switch_id
        reaction      = ls_assignment_data-reaction
        node_data     = ls_node_data
      IMPORTING
        data_saved    = lv_saved
        message       = ls_message.

    IF lv_saved = abap_false.
      zcx_abapgit_exception=&gt;raise( |{ ls_message-msgtxt }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_shi5 IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_extension = ms_item-obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    zcx_abapgit_exception=&gt;raise( |TODO: Jump { ms_item-obj_type }| ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_extension_header TYPE ttree_ext.

    CALL FUNCTION &apos;STREE_EXTENSION_EXISTS&apos;
      EXPORTING
        extension        = mv_extension
      IMPORTING
        extension_header = ls_extension_header.

    rv_bool = boolc( ls_extension_header IS NOT INITIAL ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: ls_message             TYPE hier_mess,
          lv_deletion_successful TYPE hier_yesno.

    CALL FUNCTION &apos;STREE_EXTENSION_DELETE&apos;
      EXPORTING
        extension           = mv_extension
      IMPORTING
        message             = ls_message
        deletion_successful = lv_deletion_successful.

    IF lv_deletion_successful = abap_false.
      zcx_abapgit_exception=&gt;raise( ls_message-msgtxt ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_extension TYPE ty_extension.

    CALL FUNCTION &apos;STREE_EXTENSION_EXISTS&apos;
      EXPORTING
        extension        = mv_extension
      IMPORTING
        extension_header = ls_extension-header.

    SELECT * FROM ttree_extt
             INTO TABLE ls_extension-texts
             WHERE extension = mv_extension.

    io_xml-&gt;add( iv_name = &apos;SHI5&apos;
                 ig_data = ls_extension ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    &quot; We cannot use STREE_EXTENSION_NAME_CREATE
    &quot; the create logic is directly tied to the UI
    &quot;
    &quot; Do it like here LSHI20F01 -&gt; SAVE_DATA

    DATA: ls_extension TYPE ty_extension.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;SHI5&apos;
      CHANGING
        cg_data = ls_extension ).

    INSERT ttree_ext  FROM ls_extension-header.
    MODIFY ttree_extt FROM TABLE ls_extension-texts.

    tadir_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SHI3 IMPLEMENTATION.
  METHOD clear_fields.

    FIELD-SYMBOLS &lt;ls_node&gt; LIKE LINE OF ct_nodes.

    CLEAR: cs_head-luser, cs_head-ldate, cs_head-ltime.
    CLEAR: cs_head-fuser, cs_head-fdate, cs_head-ftime.
    CLEAR: cs_head-frelease, cs_head-lrelease.
    CLEAR: cs_head-responsibl.

    LOOP AT ct_nodes ASSIGNING &lt;ls_node&gt;.
      CLEAR: &lt;ls_node&gt;-luser, &lt;ls_node&gt;-ldate, &lt;ls_node&gt;-ltime.
      CLEAR: &lt;ls_node&gt;-fuser, &lt;ls_node&gt;-fdate, &lt;ls_node&gt;-ftime.
      CLEAR: &lt;ls_node&gt;-frelease, &lt;ls_node&gt;-lrelease.
    ENDLOOP.

  ENDMETHOD.
  METHOD constructor.
    super-&gt;constructor( is_item = is_item iv_language = iv_language ).
    mv_tree_id = ms_item-obj_name.
  ENDMETHOD.
  METHOD delete_tree_structure.
    CALL FUNCTION &apos;STREE_EXTERNAL_DELETE&apos;
      EXPORTING
        structure_id          = iv_structure_id
        no_confirmation_popup = abap_true.
  ENDMETHOD.
  METHOD has_authorization.

    AUTHORITY-CHECK OBJECT &apos;S_DEVELOP&apos;
      ID &apos;DEVCLASS&apos;  FIELD iv_devclass
      ID &apos;OBJTYPE&apos;   FIELD &apos;MENU&apos;
      ID &apos;OBJNAME&apos;   FIELD iv_structure_id
      ID &apos;P_GROUP&apos;  DUMMY
      ID &apos;ACTVT&apos;    FIELD iv_activity.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( iv_msgid = &apos;s#&apos;
                                         iv_msgno = &apos;203&apos; ).
    ENDIF.
  ENDMETHOD.
  METHOD is_used.

    DATA: lt_used_in_structures TYPE STANDARD TABLE OF ttree WITH DEFAULT KEY.

    CALL FUNCTION &apos;STREE_GET_STRUCTURE_USAGE&apos;
      EXPORTING
        structure_id       = iv_structure_id
      TABLES
        used_in_structures = lt_used_in_structures.

    IF lt_used_in_structures IS NOT INITIAL.
      zcx_abapgit_exception=&gt;raise( |IMG structure ID { iv_structure_id } is still used| ).
    ENDIF.

  ENDMETHOD.
  METHOD jump_se43.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPLBMEN&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0200&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=SHOW&apos;.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BMENUNAME-ID&apos;.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode                 = &apos;SE43&apos;
        mode_val              = &apos;E&apos;
      TABLES
        using_tab             = lt_bdcdata
      EXCEPTIONS
        system_failure        = 1
        communication_failure = 2
        resource_failure      = 3
        OTHERS                = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SHI3&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_head TYPE ttree.

    CALL FUNCTION &apos;STREE_STRUCTURE_READ&apos;
      EXPORTING
        structure_id     = mv_tree_id
      IMPORTING
        structure_header = ls_head.

    rv_user = ls_head-luser.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CONSTANTS lc_activity_delete_06 TYPE activ_auth VALUE &apos;06&apos;.

    DATA: lv_object_type    TYPE seu_objid.
    DATA: lv_tr_object_name TYPE e071-obj_name.
    DATA: lv_tr_return      TYPE char1.

    lv_object_type = ms_item-obj_type.

    TRY.
        me-&gt;zif_abapgit_object~exists( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    has_authorization( iv_object_type  = lv_object_type
                       iv_structure_id = mv_tree_id
                       iv_devclass     = ms_item-devclass
                       iv_activity     = lc_activity_delete_06 ).

    is_used( mv_tree_id ).

    delete_tree_structure( mv_tree_id ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_msg    TYPE hier_mess,
          ls_head   TYPE ttree,
          lt_titles TYPE TABLE OF ttreet,
          lt_nodes  TYPE TABLE OF hier_iface,
          lt_texts  TYPE TABLE OF hier_texts,
          lt_refs   TYPE TABLE OF hier_ref.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TREE_HEAD&apos;
                  CHANGING  cg_data = ls_head ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TREE_TITLES&apos;
                  CHANGING  cg_data = lt_titles ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TREE_NODES&apos;
                  CHANGING  cg_data = lt_nodes ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TREE_REFS&apos;
                  CHANGING  cg_data = lt_refs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TREE_TEXTS&apos;
                  CHANGING  cg_data = lt_texts ).

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    CALL FUNCTION &apos;STREE_HIERARCHY_SAVE&apos;
      EXPORTING
        structure_id             = mv_tree_id
        structure_type           = ls_head-type
        structure_description    = space
        structure_masterlanguage = mv_language
        structure_responsible    = sy-uname
        development_class        = iv_package
      IMPORTING
        message                  = ls_msg
      TABLES
        list_of_nodes            = lt_nodes
        list_of_references       = lt_refs
        list_of_texts            = lt_texts
        structure_descriptions   = lt_titles
      EXCEPTIONS
        no_nodes_given           = 1
        OTHERS                   = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from STREE_HIERARCHY_SAVE, SHI3&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_msg    TYPE hier_mess,
          ls_header TYPE ttree,
          ls_tadir  TYPE tadir.

    CALL FUNCTION &apos;STREE_STRUCTURE_EXIST&apos;
      EXPORTING
        structure_id         = mv_tree_id
        do_not_read_devclass = &apos;&apos;
      IMPORTING
        message              = ls_msg
        structure_header     = ls_header
        structure_tadir      = ls_tadir.

    rv_bool = boolc( ls_header-id IS NOT INITIAL ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: ls_head TYPE ttree.

    CALL FUNCTION &apos;STREE_STRUCTURE_READ&apos;
      EXPORTING
        structure_id     = mv_tree_id
      IMPORTING
        structure_header = ls_head.

    CASE ls_head-type.
      WHEN &apos;BMENU&apos;.
        jump_se43( ).
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |Jump for type { ls_head-type } not implemented| ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_msg    TYPE hier_mess,
          ls_head   TYPE ttree,
          lt_titles TYPE TABLE OF ttreet,
          lt_nodes  TYPE TABLE OF hier_iface,
          lt_texts  TYPE TABLE OF hier_texts,
          lt_refs   TYPE TABLE OF hier_ref.
    CALL FUNCTION &apos;STREE_STRUCTURE_READ&apos;
      EXPORTING
        structure_id     = mv_tree_id
      IMPORTING
        message          = ls_msg
        structure_header = ls_head
      TABLES
        description      = lt_titles.

    CALL FUNCTION &apos;STREE_HIERARCHY_READ&apos;
      EXPORTING
        structure_id       = mv_tree_id
        read_also_texts    = &apos;X&apos;
        all_languages      = &apos;X&apos;
      IMPORTING
        message            = ls_msg
      TABLES
        list_of_nodes      = lt_nodes
        list_of_references = lt_refs
        list_of_texts      = lt_texts.

    clear_fields( CHANGING cs_head  = ls_head
                           ct_nodes = lt_nodes ).

    io_xml-&gt;add( iv_name = &apos;TREE_HEAD&apos;
                 ig_data = ls_head ).
    io_xml-&gt;add( iv_name = &apos;TREE_TITLES&apos;
                 ig_data = lt_titles ).
    io_xml-&gt;add( iv_name = &apos;TREE_NODES&apos;
                 ig_data = lt_nodes ).
    io_xml-&gt;add( iv_name = &apos;TREE_REFS&apos;
                 ig_data = lt_refs ).
    io_xml-&gt;add( iv_name = &apos;TREE_TEXTS&apos;
                 ig_data = lt_texts ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sfsw IMPLEMENTATION.
  METHOD get.

    DATA: lv_switch_id TYPE sfw_switch_id.

    lv_switch_id = ms_item-obj_name.

    TRY.
        ro_switch = cl_sfw_sw=&gt;get_switch_from_db( lv_switch_id ).
      CATCH cx_pak_invalid_data cx_pak_invalid_state cx_pak_not_authorized.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_SFW_SW=&gt;GET_SWITCH&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_data TYPE sfw_switch.
    ls_data = get( )-&gt;get_header_data( ).

    rv_user = ls_data-changedby.
    IF rv_user IS INITIAL.
      rv_user = ls_data-author.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_switch_id TYPE sfw_switch_id,
          lo_switch    TYPE REF TO cl_sfw_sw.
    lv_switch_id = ms_item-obj_name.
    TRY.
        lo_switch = cl_sfw_sw=&gt;get_switch( lv_switch_id ).
        lo_switch-&gt;set_delete_flag( lv_switch_id ).
        lo_switch-&gt;save_all( ).

        &quot; deletion via background job. Wait until the job is finished...
        wait_for_background_job( ).

        &quot; ... the object is deleted
        wait_for_deletion( ).

      CATCH cx_pak_invalid_data cx_pak_invalid_state cx_pak_not_authorized.
        zcx_abapgit_exception=&gt;raise( &apos;Error deleting Switch&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lo_switch    TYPE REF TO cl_sfw_sw,
          lv_switch_id TYPE sfw_switch_id,
          ls_header    TYPE sfw_switch,
          lv_name_32   TYPE sfw_name32,
          lv_name_80   TYPE sfw_name80,
          lt_parent_bf TYPE sfw_bf_sw_outtab,
          lt_conflicts TYPE sfw_confl_outtab.
    io_xml-&gt;read( EXPORTING iv_name = &apos;HEADER&apos;
                  CHANGING cg_data = ls_header ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME32&apos;
                  CHANGING cg_data = lv_name_32 ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME80&apos;
                  CHANGING cg_data = lv_name_80 ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;PARENT_BF&apos;
                  CHANGING cg_data = lt_parent_bf ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CONFLICTS&apos;
                  CHANGING cg_data = lt_conflicts ).

    lv_switch_id = ms_item-obj_name.
    TRY.
        lo_switch = cl_sfw_sw=&gt;create_switch( lv_switch_id ).
      CATCH cx_pak_not_authorized cx_pak_invalid_state cx_pak_invalid_data.
        zcx_abapgit_exception=&gt;raise( &apos;error in CL_SFW_SW=&gt;CREATE_SWITCH&apos; ).
    ENDTRY.

    ls_header-author = sy-uname.
    ls_header-createdon = sy-datum.
    lo_switch-&gt;set_header_data( ls_header ).

    lo_switch-&gt;set_texts( p_32 = lv_name_32
                          p_80 = lv_name_80 ).

    lo_switch-&gt;set_parent_bf( lt_parent_bf ).
    lo_switch-&gt;set_conflicts( lt_conflicts ).

    set_default_package( iv_package ).
    tadir_insert( iv_package ).

    lo_switch-&gt;save_all(
      EXCEPTIONS
        not_saved = 1
        OTHERS    = 2 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error in CL_SFW_SW-&gt;SAVE_ALL&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_tadir     TYPE tadir,
          lv_switch_id TYPE sfw_switch_id.
    lv_switch_id = ms_item-obj_name.
    IF cl_sfw_sw=&gt;check_existence( lv_switch_id ) = abap_false.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tadir INTO ls_tadir
      WHERE pgmid = &apos;R3TR&apos;
      AND object = ms_item-obj_type
      AND obj_name = ms_item-obj_name.
    IF ls_tadir IS INITIAL.
      RETURN.
    ENDIF.

    rv_bool = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;SFSW&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_switch    TYPE REF TO cl_sfw_sw,
          ls_header    TYPE sfw_switch,
          lv_name_32   TYPE sfw_name32,
          lv_name_80   TYPE sfw_name80,
          lt_parent_bf TYPE sfw_bf_sw_outtab,
          lt_conflicts TYPE sfw_confl_outtab.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_switch = get( ).

    ls_header = lo_switch-&gt;get_header_data( ).
    CLEAR: ls_header-author,
           ls_header-createdon,
           ls_header-changedby,
           ls_header-changedon,
           ls_header-timestamp.

    lo_switch-&gt;get_texts(
      IMPORTING
        p_32 = lv_name_32
        p_80 = lv_name_80 ).

    lt_parent_bf = lo_switch-&gt;get_parent_bf( ).
    lt_conflicts = lo_switch-&gt;get_conflicts( ).

    io_xml-&gt;add( ig_data = ls_header
                 iv_name = &apos;HEADER&apos; ).
    io_xml-&gt;add( ig_data = lv_name_32
                 iv_name = &apos;NAME32&apos; ).
    io_xml-&gt;add( ig_data = lv_name_80
                 iv_name = &apos;NAME80&apos; ).

    io_xml-&gt;add( ig_data = lt_parent_bf
                 iv_name = &apos;PARENT_BF&apos; ).
    io_xml-&gt;add( ig_data = lt_conflicts
                 iv_name = &apos;CONFLICTS&apos; ).

  ENDMETHOD.

  METHOD wait_for_background_job.

    DATA: lv_job_count TYPE tbtco-jobcount.

    &quot; We wait for at most 5 seconds. If it takes
    &quot; more than that it probably doesn&apos;t matter,
    &quot; because we have other problems

    DO 5 TIMES.

      SELECT SINGLE jobcount
             FROM tbtco
             INTO lv_job_count
             WHERE jobname = &apos;SFW_DELETE_SWITCH&apos;
             AND   status  = &apos;R&apos;
             AND   sdluname = sy-uname.

      IF sy-subrc = 0.
        WAIT UP TO 1 SECONDS.
      ELSE.
        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.
  METHOD wait_for_deletion.

    DO 5 TIMES.

      IF zif_abapgit_object~exists( ) = abap_true.
        WAIT UP TO 1 SECONDS.
      ELSE.
        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_sfpi IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM fpinterface
      INTO rv_user
      WHERE name = ms_item-obj_name
      AND state = &apos;A&apos;.
    IF rv_user IS INITIAL.
      SELECT SINGLE firstuser FROM fpinterface
        INTO rv_user
        WHERE name = ms_item-obj_name
        AND state = &apos;A&apos;.
    ENDIF.
    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE fpinterface-name.

    SELECT SINGLE name FROM fpinterface
      INTO lv_name
      WHERE name = ms_item-obj_name
      AND state = &apos;A&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_name         TYPE fpname,
          lo_wb_interface TYPE REF TO cl_fp_wb_interface.
    lo_wb_interface ?= load( ).

    lv_name = ms_item-obj_name.

    TRY.
        lo_wb_interface-&gt;delete( lv_name ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPI error, delete&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD load.

    DATA: lv_name TYPE fpname.
    lv_name = ms_item-obj_name.

    TRY.
        ri_wb_interface = cl_fp_wb_interface=&gt;load( lv_name ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPI error, load&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD interface_to_xstring.

    DATA: li_fp_interface TYPE REF TO if_fp_interface,
          li_wb_interface TYPE REF TO if_fp_wb_interface.
    TRY.
        li_wb_interface = load( ).
        li_fp_interface ?= li_wb_interface-&gt;get_object( ).
        rv_xstr = cl_fp_helper=&gt;convert_interface_to_xstring( li_fp_interface ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPI error, interface_to_xstring&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_xstr     TYPE xstring,
          li_document TYPE REF TO if_ixml_document.
    lv_xstr = interface_to_xstring( ).
    li_document = cl_ixml_80_20=&gt;parse_to_document( stream_xstring = lv_xstr ).
    zcl_abapgit_object_sfpf=&gt;fix_oref( li_document ).
    io_xml-&gt;set_raw( li_document-&gt;get_root_element( ) ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_xstr      TYPE xstring,
          lv_name      TYPE fpname,
          li_wb_object TYPE REF TO if_fp_wb_interface,
          li_interface TYPE REF TO if_fp_interface.
    lv_name = ms_item-obj_name.
    lv_xstr = cl_ixml_80_20=&gt;render_to_xstring( io_xml-&gt;get_raw( ) ).

    TRY.
        li_interface = cl_fp_helper=&gt;convert_xstring_to_interface( lv_xstr ).
        tadir_insert( iv_package ).
        li_wb_object = cl_fp_wb_interface=&gt;create( i_name      = lv_name
                                                   i_interface = li_interface ).
        li_wb_object-&gt;save( ).
        li_wb_object-&gt;free( ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPI error, deserialize&apos; ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    lv_object = |{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                              &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EFPINTERFACE&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sfpf IMPLEMENTATION.
  METHOD fix_oref.

    DATA: li_iterator TYPE REF TO if_ixml_node_iterator,
          lv_new      TYPE n LENGTH 3,
          lv_old      TYPE string,
          lt_map      TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
          li_attr_map TYPE REF TO if_ixml_named_node_map,
          li_attr     TYPE REF TO if_ixml_node,
          li_node     TYPE REF TO if_ixml_node.

    DEFINE _lookup.
      READ TABLE lt_map FROM &amp;1 TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        APPEND &amp;1 TO lt_map.
        READ TABLE lt_map FROM &amp;1 TRANSPORTING NO FIELDS.
      ENDIF.
      lv_new = sy-tabix + 100.
    END-OF-DEFINITION.
    li_iterator = ii_document-&gt;create_iterator( ).
    li_node = li_iterator-&gt;get_next( ).
    WHILE NOT li_node IS INITIAL.
      li_attr_map = li_node-&gt;get_attributes( ).

      IF li_attr_map IS BOUND.
        li_attr = li_attr_map-&gt;get_named_item_ns( &apos;href&apos; ).
        IF li_attr IS BOUND.
          lv_old = li_attr-&gt;get_value( ).
          IF lv_old(2) = &apos;#o&apos;.
            _lookup lv_old+1.
            li_attr-&gt;set_value( &apos;#o&apos; &amp;&amp; lv_new ).
          ENDIF.
        ENDIF.

        li_attr = li_attr_map-&gt;get_named_item_ns( &apos;id&apos; ).
        IF li_attr IS BOUND.
          lv_old = li_attr-&gt;get_value( ).
          IF lv_old(1) = &apos;o&apos;.
            _lookup lv_old.
            li_attr-&gt;set_value( &apos;o&apos; &amp;&amp; lv_new ).
          ENDIF.
        ENDIF.
      ENDIF.

      li_node = li_iterator-&gt;get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD form_to_xstring.

    DATA: li_fp_form TYPE REF TO if_fp_form,
          li_wb_form TYPE REF TO if_fp_wb_form.
    TRY.
        li_wb_form = load( ).
        li_fp_form ?= li_wb_form-&gt;get_object( ).
        rv_xstr = cl_fp_helper=&gt;convert_form_to_xstring( li_fp_form ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPF error, form_to_xstring&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD load.

    DATA: lv_name TYPE fpname.
    lv_name = ms_item-obj_name.

    TRY.
        ri_wb_form = cl_fp_wb_form=&gt;load( lv_name ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPF error, load&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM fplayout
      INTO rv_user
      WHERE name = ms_item-obj_name
      AND state = &apos;A&apos;.
    IF rv_user IS INITIAL.
      SELECT SINGLE firstuser FROM fplayout
        INTO rv_user
        WHERE name = ms_item-obj_name
        AND state = &apos;A&apos;.
    ENDIF.
    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_name    TYPE fpname,
          lo_wb_form TYPE REF TO cl_fp_wb_form.
    lo_wb_form ?= load( ).

    lv_name = ms_item-obj_name.

    TRY.
        lo_wb_form-&gt;delete( lv_name ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPI error, delete&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_xstr      TYPE xstring,
          lv_name      TYPE fpname,
          li_wb_object TYPE REF TO if_fp_wb_form,
          li_form      TYPE REF TO if_fp_form.
    lv_name = ms_item-obj_name.
    lv_xstr = cl_ixml_80_20=&gt;render_to_xstring( io_xml-&gt;get_raw( ) ).

    TRY.
        li_form = cl_fp_helper=&gt;convert_xstring_to_form( lv_xstr ).
        tadir_insert( iv_package ).
        li_wb_object = cl_fp_wb_form=&gt;create( i_name = lv_name
                                              i_form = li_form ).
        li_wb_object-&gt;save( ).
        li_wb_object-&gt;free( ).
      CATCH cx_fp_api.
        zcx_abapgit_exception=&gt;raise( &apos;SFPF error, deserialize&apos; ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE fpname.

    SELECT SINGLE name FROM fplayout
      INTO lv_name
      WHERE name = ms_item-obj_name
      AND state = &apos;A&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_xstr     TYPE xstring,
          li_document TYPE REF TO if_ixml_document.
    lv_xstr = form_to_xstring( ).
    li_document = cl_ixml_80_20=&gt;parse_to_document( stream_xstring = lv_xstr ).
    fix_oref( li_document ).
    io_xml-&gt;set_raw( li_document-&gt;get_root_element( ) ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    lv_object = |{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                              &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EFPFORM&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sfbs IMPLEMENTATION.
  METHOD get.

    DATA: lv_bfset TYPE sfw_bset.
    lv_bfset = ms_item-obj_name.

    TRY.
        ro_bfs = cl_sfw_bfs=&gt;get_bfs( lv_bfset ).
        ro_bfs-&gt;free( ).
        ro_bfs = cl_sfw_bfs=&gt;get_bfs( lv_bfset ).
      CATCH cx_pak_invalid_data cx_pak_invalid_state cx_pak_not_authorized.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_SFW_BFS=&gt;GET_BFS&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_data TYPE sfw_bs.

    ls_data = get( )-&gt;get_header_data( ).

    rv_user = ls_data-changedby.

    IF rv_user IS INITIAL.
      rv_user = ls_data-author.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_bfset  TYPE sfw_bset,
          lt_delete TYPE sfw_bstab,
          lt_msgtab TYPE sprot_u_tab.
    lv_bfset = ms_item-obj_name.
    APPEND lv_bfset TO lt_delete.

    cl_sfw_activate=&gt;delete_sfbs( EXPORTING p_bsets = lt_delete
                                  IMPORTING p_msgtab = lt_msgtab ).

    READ TABLE lt_msgtab WITH KEY severity = &apos;E&apos; TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error deleting SFBS&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_bfset       TYPE sfw_bset,
          lo_bfs         TYPE REF TO cl_sfw_bfs,
          ls_header      TYPE sfw_bs,
          lv_name_32     TYPE sfw_name32,
          lv_name_80     TYPE sfw_name80,
          lt_assigned_bf TYPE sfw_bfbs_outtab,
          lt_nested_bfs  TYPE sfw_bsbs_outtab,
          lt_parent_bfs  TYPE sfw_bs_bs_parent_outtab.
    io_xml-&gt;read( EXPORTING iv_name = &apos;HEADER&apos;
                  CHANGING cg_data = ls_header ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME32&apos;
                  CHANGING cg_data = lv_name_32 ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME80&apos;
                  CHANGING cg_data = lv_name_80 ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;ASSIGNED_BF&apos;
                  CHANGING cg_data = lt_assigned_bf ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NESTED_BFS&apos;
                  CHANGING cg_data = lt_nested_bfs ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PARENT_BFS&apos;
                  CHANGING cg_data = lt_parent_bfs ).

    lv_bfset = ms_item-obj_name.
    TRY.
        lo_bfs = cl_sfw_bfs=&gt;create_bfs( lv_bfset ).
      CATCH cx_pak_not_authorized cx_pak_invalid_state cx_pak_invalid_data.
        zcx_abapgit_exception=&gt;raise( &apos;error in CL_SFW_BFS=&gt;CREATE_BFS&apos; ).
    ENDTRY.

    ls_header-author = sy-uname.
    ls_header-createdon = sy-datum.
    lo_bfs-&gt;set_header_data( ls_header ).

    lo_bfs-&gt;set_texts( p_32 = lv_name_32
                       p_80 = lv_name_80 ).

    lo_bfs-&gt;set_assigned_bf( lt_assigned_bf ).
    lo_bfs-&gt;set_assigned_bfs( lt_nested_bfs ).
    lo_bfs-&gt;set_nested_parent( lt_parent_bfs ).

    set_default_package( iv_package ).
    tadir_insert( iv_package ).

    lo_bfs-&gt;save_all( ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_tadir TYPE tadir,
          lv_bfset TYPE sfw_bset.
    lv_bfset = ms_item-obj_name.
    IF cl_sfw_bfs=&gt;check_existence( lv_bfset ) = abap_false.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tadir INTO ls_tadir
      WHERE pgmid = &apos;R3TR&apos;
      AND object = ms_item-obj_type
      AND obj_name = ms_item-obj_name.
    IF ls_tadir IS INITIAL.
      RETURN.
    ENDIF.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;SFBS&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_bfs         TYPE REF TO cl_sfw_bfs,
          ls_header      TYPE sfw_bs,
          lv_name_32     TYPE sfw_name32,
          lv_name_80     TYPE sfw_name80,
          lt_assigned_bf TYPE sfw_bfbs_outtab,
          lt_nested_bfs  TYPE sfw_bsbs_outtab,
          lt_parent_bfs  TYPE sfw_bs_bs_parent_outtab.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_bfs = get( ).

    ls_header = lo_bfs-&gt;get_header_data( ).
    CLEAR: ls_header-author,
           ls_header-createdon,
           ls_header-changedby,
           ls_header-changedon,
           ls_header-timestamp.

    lo_bfs-&gt;get_texts(
      IMPORTING
        p_32 = lv_name_32
        p_80 = lv_name_80 ).

    lt_assigned_bf = lo_bfs-&gt;get_assigned_bf( ).
    lt_nested_bfs = lo_bfs-&gt;get_nested_bfs( ).
    lt_parent_bfs = lo_bfs-&gt;get_nested_parent( ).

    io_xml-&gt;add( ig_data = ls_header
                 iv_name = &apos;HEADER&apos; ).
    io_xml-&gt;add( ig_data = lv_name_32
                 iv_name = &apos;NAME32&apos; ).
    io_xml-&gt;add( ig_data = lv_name_80
                 iv_name = &apos;NAME80&apos; ).

    io_xml-&gt;add( ig_data = lt_assigned_bf
                 iv_name = &apos;ASSIGNED_BF&apos; ).
    io_xml-&gt;add( ig_data = lt_nested_bfs
                 iv_name = &apos;NESTED_BFS&apos; ).
    io_xml-&gt;add( ig_data = lt_parent_bfs
                 iv_name = &apos;PARENT_BFS&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_sfbf IMPLEMENTATION.
  METHOD get.

    DATA: lv_bf TYPE sfw_bfunction.
    lv_bf = ms_item-obj_name.

    TRY.
* make sure to clear cache, method GET_BF_FROM_DB does not exist in 702
        ro_bf = cl_sfw_bf=&gt;get_bf( lv_bf ).
        ro_bf-&gt;free( ).
        ro_bf = cl_sfw_bf=&gt;get_bf( lv_bf ).
      CATCH cx_pak_invalid_data cx_pak_invalid_state cx_pak_not_authorized.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_SFW_BF=&gt;GET_BF&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_data TYPE sfw_bf.

    ls_data = get( )-&gt;get_header_data( ).

    rv_user = ls_data-changedby.

    IF rv_user IS INITIAL.
      rv_user = ls_data-author.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_bf     TYPE sfw_bfunction,
          lt_delete TYPE sfw_bftab,
          lt_msgtab TYPE sprot_u_tab.
    lv_bf = ms_item-obj_name.
    APPEND lv_bf TO lt_delete.

    cl_sfw_activate=&gt;delete_sfbf( EXPORTING p_bfuncts = lt_delete
                                  IMPORTING p_msgtab = lt_msgtab ).

    READ TABLE lt_msgtab WITH KEY severity = &apos;E&apos; TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error deleting SFBF&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_bf                TYPE sfw_bfunction,
          lo_bf                TYPE REF TO cl_sfw_bf,
          ls_header            TYPE sfw_bf,
          lv_name_32           TYPE sfw_name32,
          lv_name_80           TYPE sfw_name80,
          lt_assigned_switches TYPE sfw_swbf_outtab,
          lt_dependancies      TYPE sfw_depend_outtab,
          ls_sfw_bfc_kw        TYPE sfw_bfc_kw,
          ls_sfw_bfc_tc        TYPE sfw_bfc_tc,
          ls_sfw_bfc_rn        TYPE sfw_bfc_rn,
          lt_parent_bfs        TYPE sfw_bs_bf_outtab.
    io_xml-&gt;read( EXPORTING iv_name = &apos;HEADER&apos;
                  CHANGING cg_data = ls_header ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME32&apos;
                  CHANGING cg_data = lv_name_32 ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;NAME80&apos;
                  CHANGING cg_data = lv_name_80 ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;ASSIGNED_SWITCHES&apos;
                  CHANGING cg_data = lt_assigned_switches ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DEPENDANCIES&apos;
                  CHANGING cg_data = lt_dependancies ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CONTENT_KW&apos;
                  CHANGING cg_data = ls_sfw_bfc_kw ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CONTENT_TC&apos;
                  CHANGING cg_data = ls_sfw_bfc_tc ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CONTENT_RN&apos;
                  CHANGING cg_data = ls_sfw_bfc_rn ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PARENT_BFS&apos;
                  CHANGING cg_data = lt_parent_bfs ).

    lv_bf = ms_item-obj_name.
    TRY.
        lo_bf = cl_sfw_bf=&gt;create_bf( lv_bf ).
      CATCH cx_pak_not_authorized cx_pak_invalid_state cx_pak_invalid_data.
        zcx_abapgit_exception=&gt;raise( &apos;error in CL_SFW_BF=&gt;CREATE_BF&apos; ).
    ENDTRY.

    ls_header-author = sy-uname.
    ls_header-createdon = sy-datum.
    lo_bf-&gt;set_header_data( ls_header ).

    lo_bf-&gt;set_texts( p_32 = lv_name_32
                      p_80 = lv_name_80 ).

    lo_bf-&gt;set_assigned_switches( lt_assigned_switches ).
    lo_bf-&gt;set_excluded_bf( lt_dependancies ).
    lo_bf-&gt;set_content_data(
        im_sfw_bfc_kw = ls_sfw_bfc_kw
        im_sfw_bfc_rn = ls_sfw_bfc_rn
        im_sfw_bfc_tc = ls_sfw_bfc_tc ).
    lo_bf-&gt;set_parent_bfs( lt_parent_bfs ).

    set_default_package( iv_package ).
    tadir_insert( iv_package ).

    lo_bf-&gt;save_all( ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_tadir TYPE tadir,
          lv_bf    TYPE sfw_bfunction.

    lv_bf = ms_item-obj_name.
    IF cl_sfw_bf=&gt;check_existence( lv_bf ) = abap_false.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tadir INTO ls_tadir
      WHERE pgmid = &apos;R3TR&apos;
      AND object = ms_item-obj_type
      AND obj_name = ms_item-obj_name.
    IF ls_tadir IS INITIAL.
      RETURN.
    ENDIF.

    rv_bool = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;SFBF&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_bf                TYPE REF TO cl_sfw_bf,
          ls_header            TYPE sfw_bf,
          lv_name_32           TYPE sfw_name32,
          lv_name_80           TYPE sfw_name80,
          lt_assigned_switches TYPE sfw_swbf_outtab,
          lt_dependancies      TYPE sfw_depend_outtab,
          ls_sfw_bfc_kw        TYPE sfw_bfc_kw,
          ls_sfw_bfc_tc        TYPE sfw_bfc_tc,
          ls_sfw_bfc_rn        TYPE sfw_bfc_rn,
          lt_parent_bfs        TYPE sfw_bs_bf_outtab.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_bf = get( ).

    ls_header = lo_bf-&gt;get_header_data( ).
    CLEAR: ls_header-author,
           ls_header-createdon,
           ls_header-changedby,
           ls_header-changedon,
           ls_header-timestamp.

    lo_bf-&gt;get_texts(
      IMPORTING
        p_32 = lv_name_32
        p_80 = lv_name_80 ).

    lt_assigned_switches = lo_bf-&gt;get_assigned_switches( ).
    lt_dependancies = lo_bf-&gt;get_excluded_bf( ).
    lo_bf-&gt;get_content_data(
      IMPORTING
        ex_sfw_bfc_kw = ls_sfw_bfc_kw
        ex_sfw_bfc_tc = ls_sfw_bfc_tc
        ex_sfw_bfc_rn = ls_sfw_bfc_rn ).
    lt_parent_bfs = lo_bf-&gt;get_parent_bfs( ).

    io_xml-&gt;add( ig_data = ls_header
                 iv_name = &apos;HEADER&apos; ).
    io_xml-&gt;add( ig_data = lv_name_32
                 iv_name = &apos;NAME32&apos; ).
    io_xml-&gt;add( ig_data = lv_name_80
                 iv_name = &apos;NAME80&apos; ).

    io_xml-&gt;add( ig_data = lt_assigned_switches
                 iv_name = &apos;ASSIGNED_SWITCHES&apos; ).
    io_xml-&gt;add( ig_data = lt_dependancies
                 iv_name = &apos;DEPENDANCIES&apos; ).
    io_xml-&gt;add( ig_data = ls_sfw_bfc_kw
                 iv_name = &apos;CONTENT_KW&apos; ).
    io_xml-&gt;add( ig_data = ls_sfw_bfc_tc
                 iv_name = &apos;CONTENT_TC&apos; ).
    io_xml-&gt;add( ig_data = ls_sfw_bfc_rn
                 iv_name = &apos;CONTENT_RN&apos; ).
    io_xml-&gt;add( ig_data = lt_parent_bfs
                 iv_name = &apos;PARENT_BFS&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SCP1 IMPLEMENTATION.
  METHOD adjust_inbound.

    FIELD-SYMBOLS: &lt;ls_scprvals&gt; TYPE scprvals,
                   &lt;ls_scprreca&gt; TYPE scprreca.

* back to internal format
    LOOP AT cs_scp1-scprvals ASSIGNING &lt;ls_scprvals&gt;.
      SHIFT &lt;ls_scprvals&gt;-recnumber RIGHT DELETING TRAILING space.
    ENDLOOP.
    LOOP AT cs_scp1-scprreca ASSIGNING &lt;ls_scprreca&gt;.
      SHIFT &lt;ls_scprreca&gt;-recnumber RIGHT DELETING TRAILING space.
    ENDLOOP.

  ENDMETHOD.
  METHOD adjust_outbound.

    FIELD-SYMBOLS: &lt;ls_scprvals&gt; TYPE scprvals,
                   &lt;ls_scprreca&gt; TYPE scprreca.

* normalize the XML
    LOOP AT cs_scp1-scprvals ASSIGNING &lt;ls_scprvals&gt;.
      CONDENSE &lt;ls_scprvals&gt;-recnumber.
    ENDLOOP.
    LOOP AT cs_scp1-scprreca ASSIGNING &lt;ls_scprreca&gt;.
      CONDENSE &lt;ls_scprreca&gt;-recnumber.
    ENDLOOP.

  ENDMETHOD.
  METHOD call_delete_fms.

    CONSTANTS lc_version_new      TYPE c VALUE &apos;N&apos; ##NO_TEXT. &quot;Include SCPRINTCONST version_new
    CONSTANTS lc_operation_delete TYPE c VALUE &apos;D&apos; ##NO_TEXT.
    DATA lv_profile_type          TYPE scprattr-type.
    DATA lt_fatherprofiles        TYPE STANDARD TABLE OF scproprof WITH DEFAULT KEY.
    DATA ls_fatherprofile         TYPE scproprof.

    CALL FUNCTION &apos;SCPR_DB_ATTR_GET_DETAIL&apos;
      EXPORTING
        profid   = iv_profile_id
        version  = lc_version_new
      IMPORTING
        proftype = lv_profile_type
      EXCEPTIONS
        OTHERS   = 0.

    CALL FUNCTION &apos;SCPR_PRSET_DB_USED_IN&apos;
      EXPORTING
        profid   = iv_profile_id
        version  = lc_version_new
      TABLES
        profiles = lt_fatherprofiles.

    ls_fatherprofile-id = iv_profile_id.
    APPEND ls_fatherprofile TO lt_fatherprofiles.
    CALL FUNCTION &apos;SCPR_CT_TRANSPORT_ENTRIES&apos;
      TABLES
        profids                  = lt_fatherprofiles
      EXCEPTIONS
        error_in_transport_layer = 1
        user_abort               = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |error while deleting SCP1 - TRANSPORT, { sy-subrc }| ).
    ENDIF.

    CALL FUNCTION &apos;SCPR_PRSET_DB_DELETE_ALL&apos;
      EXPORTING
        profid      = iv_profile_id
        proftype    = lv_profile_type
      TABLES
        fatherprofs = lt_fatherprofiles
      EXCEPTIONS
        user_abort  = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |error while deleting SCP1 - DB_DELETE, { sy-subrc }| ).
    ENDIF.

    CALL FUNCTION &apos;SCPR_MEM_SCPR_ACTIONS_ADD&apos;
      EXPORTING
        bcset_id  = iv_profile_id
        operation = lc_operation_delete.

  ENDMETHOD.
  METHOD dequeue.

    DATA: lv_id TYPE scpr_id.
    lv_id = ms_item-obj_name.

    CALL FUNCTION &apos;SCPR_SV_DEQUEUE_BCSET&apos;
      EXPORTING
        bcset_id = lv_id.

  ENDMETHOD.
  METHOD enqueue.

    DATA: lv_id TYPE scpr_id.

    lv_id = ms_item-obj_name.

    CALL FUNCTION &apos;SCPR_SV_ENQUEUE_BCSET&apos;
      EXPORTING
        bcset_id          = lv_id
      EXCEPTIONS
        is_already_locked = 1
        system_failure    = 2
        OTHERS            = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |SCP1 locking error| ).
    ENDIF.

  ENDMETHOD.
  METHOD load.

    CALL FUNCTION &apos;SCPR_TEXT_GET&apos;
      EXPORTING
        profid        = cs_scp1-scprattr-id
        category      = cs_scp1-scprattr-category
      TABLES
        texts         = cs_scp1-scprtext
      EXCEPTIONS
        no_text_found = 1.

    CALL FUNCTION &apos;SCPR_TEMPL_DB_VALS_GET_DETAIL&apos;
      EXPORTING
        profid   = cs_scp1-scprattr-id
        category = cs_scp1-scprattr-category
      TABLES
        values   = cs_scp1-scprvals
        valuesl  = cs_scp1-scprvall
        recattr  = cs_scp1-scprreca.

    CALL FUNCTION &apos;SCPR_TEMPL_DB_FLDTXTVAR_GET&apos;
      EXPORTING
        bcset_id = cs_scp1-scprattr-id
        category = cs_scp1-scprattr-category
      TABLES
        it_fldv  = cs_scp1-scprfldv.

  ENDMETHOD.
  METHOD save.

    DATA: ls_scp1 TYPE ty_scp1,
          ls_text TYPE scprtext.
* copy everything to local, the function module changes the values
    ls_scp1 = is_scp1.

    READ TABLE ls_scp1-scprtext INTO ls_text WITH KEY langu = sy-langu.

    CALL FUNCTION &apos;SCPR_TEMPL_MN_TEMPLATE_SAVE&apos;
      EXPORTING
        profid                    = ls_scp1-scprattr-id
        proftext                  = ls_text-text
        category                  = ls_scp1-scprattr-category
        cli_dep                   = ls_scp1-scprattr-cli_dep
        cli_cas                   = ls_scp1-scprattr-cli_cas
        reftype                   = ls_scp1-scprattr-reftype
        refname                   = ls_scp1-scprattr-refname
        orgid                     = ls_scp1-scprattr-orgid
        component                 = ls_scp1-scprattr-component
        minrelease                = ls_scp1-scprattr-minrelease
        maxrelease                = ls_scp1-scprattr-maxrelease
        act_info                  = ls_scp1-scprattr-act_info
        bcset_type                = ls_scp1-scprattr-type
        fldtxtvar_supplied        = &apos;YES&apos;
        with_transp_insert        = abap_false
        with_progress_indicator   = abap_true
        remove_denied_data        = abap_true
        ask_for_cont_after_remove = abap_true
      TABLES
        values                    = ls_scp1-scprvals
        valuesl                   = ls_scp1-scprvall
        recattr                   = ls_scp1-scprreca
        it_fldv                   = ls_scp1-scprfldv
        texts                     = ls_scp1-scprtext
      EXCEPTIONS
        user_abort                = 1
        error_in_transport_layer  = 2
        inconsistent_data         = 3
        database_error            = 4
        OTHERS                    = 5.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error saving SCP1, { sy-tabix }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE modifier INTO rv_user FROM scprattr
      WHERE id = ms_item-obj_name
      AND version = &apos;N&apos;.
    IF sy-subrc &lt;&gt; 0 OR rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_profile_id TYPE scpr_id.

    lv_profile_id = ms_item-obj_name.

    enqueue( ).
    call_delete_fms( lv_profile_id ).
    dequeue( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_scp1 TYPE ty_scp1.
    io_xml-&gt;read(
      EXPORTING iv_name = &apos;SCP1&apos;
      CHANGING  cg_data = ls_scp1 ).

    adjust_inbound( CHANGING cs_scp1 = ls_scp1 ).

    IF ls_scp1-scprattr-type = &apos;TMP&apos;.
* todo, function module SCPR_PRSET_MN_BCSET_SAVE
      zcx_abapgit_exception=&gt;raise( |todo, SCP1| ).
    ELSE.
      save( ls_scp1 ).
    ENDIF.

    dequeue( ).

    tadir_insert( iv_package ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_rc     TYPE sy-subrc,
          lv_profid TYPE scprattr-id.
    lv_profid = ms_item-obj_name.

    CALL FUNCTION &apos;SCPR_BCSET_EXISTS&apos;
      EXPORTING
        profid = lv_profid
      IMPORTING
        rc     = lv_rc.
    rv_bool = boolc( lv_rc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lv_display_only TYPE scpr_txt20,
          lv_bcset_id     TYPE scpr_id.

    lv_display_only = abap_false.
    lv_bcset_id     = ms_item-obj_name.

    EXPORT scpr3_display_only = lv_display_only
           scpr3_bcset_id     = lv_bcset_id
        TO MEMORY ID &apos;SCPR3_PARAMETER&apos;.

    SUBMIT scpr3 AND RETURN.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_scp1 TYPE ty_scp1.
    ls_scp1-scprattr-id = ms_item-obj_name.

    CALL FUNCTION &apos;SCPR_DB_ATTR_GET_DETAIL&apos;
      EXPORTING
        profid     = ls_scp1-scprattr-id
      IMPORTING
        proftype   = ls_scp1-scprattr-type
        cli_dep    = ls_scp1-scprattr-cli_dep
        cli_cas    = ls_scp1-scprattr-cli_cas
        reftype    = ls_scp1-scprattr-reftype
        refname    = ls_scp1-scprattr-refname
        component  = ls_scp1-scprattr-component
        minrelease = ls_scp1-scprattr-minrelease
        maxrelease = ls_scp1-scprattr-maxrelease
        orgid      = ls_scp1-scprattr-orgid
        act_info   = ls_scp1-scprattr-act_info.

    IF ls_scp1-scprattr-type = &apos;TMP&apos;.
* todo, Hierarchical, fm SCPR_PRSET_DB_SUBP_GET_DETAIL, recursive?
      zcx_abapgit_exception=&gt;raise( |todo, SCP1| ).
    ELSE.
      load( CHANGING cs_scp1 = ls_scp1 ).
    ENDIF.

    adjust_outbound( CHANGING cs_scp1 = ls_scp1 ).

    io_xml-&gt;add(
      iv_name = &apos;SCP1&apos;
      ig_data  = ls_scp1 ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SAPC IMPLEMENTATION.
  METHOD get_data_class_name.

    rv_data_class_name = &apos;CL_APC_APPLICATION_OBJ_DATA&apos;.

  ENDMETHOD.
  METHOD get_data_structure_name.

    rv_data_structure_name = &apos;APC_APPLICATION_COMPLETE&apos;.

  ENDMETHOD.
  METHOD get_persistence_class_name.

    rv_persistence_class_name = &apos;CL_APC_APPLICATION_OBJ_PERS&apos;.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_SAMC IMPLEMENTATION.
  METHOD get_data_class_name.

    rv_data_class_name = &apos;CL_AMC_APPLICATION_OBJ_DATA&apos;.

  ENDMETHOD.
  METHOD get_data_structure_name.

    rv_data_structure_name = &apos;AMC_APPLICATION_COMPLETE&apos;.

  ENDMETHOD.
  METHOD get_persistence_class_name.

    rv_persistence_class_name = &apos;CL_AMC_APPLICATION_OBJ_PERS&apos;.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_prog IMPLEMENTATION.
  METHOD deserialize_texts.

    DATA: lt_tpool_i18n TYPE tt_tpool_i18n,
          lt_tpool      TYPE textpool_table.

    FIELD-SYMBOLS &lt;ls_tpool&gt; LIKE LINE OF lt_tpool_i18n.
    io_xml-&gt;read( EXPORTING iv_name = &apos;I18N_TPOOL&apos;
                  CHANGING  cg_data = lt_tpool_i18n ).

    LOOP AT lt_tpool_i18n ASSIGNING &lt;ls_tpool&gt;.
      lt_tpool = read_tpool( &lt;ls_tpool&gt;-textpool ).
      deserialize_textpool( iv_program  = ms_item-obj_name
                            iv_language = &lt;ls_tpool&gt;-language
                            it_tpool    = lt_tpool ).
    ENDLOOP.

  ENDMETHOD.
  METHOD is_program_locked.

    rv_is_program_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESRDIRE&apos;
                                                    iv_argument    = |{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD serialize_texts.

    DATA: lt_tpool_i18n TYPE tt_tpool_i18n,
          lt_tpool      TYPE textpool_table.

    FIELD-SYMBOLS &lt;ls_tpool&gt; LIKE LINE OF lt_tpool_i18n.
    &quot; Table d010tinf stores info. on languages in which program is maintained
    &quot; Select all active translations of program texts
    &quot; Skip master language - it was already serialized
    SELECT DISTINCT language
      INTO CORRESPONDING FIELDS OF TABLE lt_tpool_i18n
      FROM d010tinf
      WHERE r3state = &apos;A&apos;
      AND   prog = ms_item-obj_name
      AND   language &lt;&gt; mv_language.

    SORT lt_tpool_i18n BY language ASCENDING.
    LOOP AT lt_tpool_i18n ASSIGNING &lt;ls_tpool&gt;.
      READ TEXTPOOL ms_item-obj_name
        LANGUAGE &lt;ls_tpool&gt;-language
        INTO lt_tpool.
      &lt;ls_tpool&gt;-textpool = add_tpool( lt_tpool ).
    ENDLOOP.

    IF lines( lt_tpool_i18n ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;I18N_TPOOL&apos;
                   ig_data = lt_tpool_i18n ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    SELECT SINGLE unam FROM reposrc INTO rv_user
      WHERE progname = ms_item-obj_name
      AND r3state = &apos;A&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_program LIKE sy-repid.

    lv_program = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DELETE_PROGRAM&apos;
      EXPORTING
        program                    = lv_program
        suppress_popup             = abap_true
        force_delete_used_includes = abap_true
      EXCEPTIONS
        enqueue_lock               = 1
        object_not_found           = 2
        permission_failure         = 3
        reject_deletion            = 4
        OTHERS                     = 5.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_DELETE_PROGRAM: { sy-subrc }| ).
    ENDIF.

    delete_longtexts( c_longtext_id_prog ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_program_name TYPE programm,
          ls_progdir      TYPE ty_progdir,
          lt_tpool        TYPE textpool_table,
          lt_dynpros      TYPE ty_dynpro_tt,
          lt_tpool_ext    TYPE zif_abapgit_definitions=&gt;ty_tpool_tt,
          ls_cua          TYPE ty_cua,
          lt_source       TYPE abaptxt255_tab.

    lv_program_name = ms_item-obj_name.

    lt_source = mo_files-&gt;read_abap( ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;TPOOL&apos;
                  CHANGING cg_data = lt_tpool_ext ).
    lt_tpool = read_tpool( lt_tpool_ext ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;PROGDIR&apos;
                  CHANGING cg_data  = ls_progdir ).
    deserialize_program( is_progdir = ls_progdir
                         it_source  = lt_source
                         it_tpool   = lt_tpool
                         iv_package = iv_package ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DYNPROS&apos;
                  CHANGING cg_data  = lt_dynpros ).
    deserialize_dynpros( lt_dynpros ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;CUA&apos;
                  CHANGING cg_data  = ls_cua ).
    deserialize_cua( iv_program_name = lv_program_name
                     is_cua = ls_cua ).

    &quot; Texts deserializing (English)
    deserialize_textpool( iv_program = lv_program_name
                          it_tpool   = lt_tpool ).

    &quot; Texts deserializing (translations)
    deserialize_texts( io_xml ).

    deserialize_longtexts( io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_progname TYPE reposrc-progname.

    SELECT SINGLE progname FROM reposrc INTO lv_progname
      WHERE progname = ms_item-obj_name
      AND r3state = &apos;A&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = check_prog_changed_since(
      iv_program   = ms_item-obj_name
      iv_timestamp = iv_timestamp ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    IF is_program_locked( )                     = abap_true
    OR is_any_dynpro_locked( ms_item-obj_name ) = abap_true
    OR is_cua_locked( ms_item-obj_name )        = abap_true
    OR is_text_locked( ms_item-obj_name )       = abap_true.

      rv_is_locked = abap_true.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;PROG&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

* see SAP note 1025291, run report DELETE_TADIR_FOR_EIMP_INCLUDE to clean bad TADIR entries
    ASSERT NOT ms_item-obj_name CP &apos;*=E&apos;.

    serialize_program( io_xml   = io_xml
                       is_item  = ms_item
                       io_files = mo_files ).

    &quot; Texts serializing (translations)
    serialize_texts( io_xml ).

    serialize_longtexts( io_xml         = io_xml
                         iv_longtext_id = c_longtext_id_prog ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_prag IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_pragma TYPE REF TO cl_abap_pragma.

    TRY.
        lo_pragma = cl_abap_pragma=&gt;get_ref( ms_item-obj_name ).

        lo_pragma-&gt;delete( ).

      CATCH cx_abap_pragma_not_exists.
        _raise_pragma_not_exists( ).
      CATCH cx_abap_pragma_enqueue.
        _raise_pragma_enqueue( ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_pragma TYPE ty_pragma,
          lo_pragma TYPE REF TO cl_abap_pragma.

    TRY.
        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;PRAG&apos;
          CHANGING
            cg_data = ls_pragma ).

        lo_pragma = cl_abap_pragma=&gt;create( p_pragma  = ms_item-obj_name
                                            p_package = iv_package ).

        lo_pragma-&gt;set_info( p_description = ls_pragma-description
                             p_signature   = ls_pragma-signature
                             p_extension   = ls_pragma-extension ).

        lo_pragma-&gt;save( ).

      CATCH cx_abap_pragma_not_exists.
        _raise_pragma_not_exists( ).
      CATCH cx_abap_pragma_exists.
        _raise_pragma_exists( ).
      CATCH cx_abap_pragma_enqueue.
        _raise_pragma_enqueue( ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    TRY.
        cl_abap_pragma=&gt;get_ref( ms_item-obj_name ).

      CATCH cx_abap_pragma_not_exists.
        rv_bool = abap_false.
        RETURN.
    ENDTRY.

    rv_bool = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_pragma TYPE REF TO cl_abap_pragma,
          ls_pragma TYPE zcl_abapgit_object_prag=&gt;ty_pragma.

    TRY.
        lo_pragma = cl_abap_pragma=&gt;get_ref( ms_item-obj_name ).

        ls_pragma-pragma      = lo_pragma-&gt;pragma.
        ls_pragma-extension   = lo_pragma-&gt;extension.
        ls_pragma-signature   = lo_pragma-&gt;signature.
        ls_pragma-description = lo_pragma-&gt;description.

        io_xml-&gt;add( iv_name = &apos;PRAG&apos;
                     ig_data = ls_pragma ).

      CATCH cx_abap_pragma_not_exists.
        _raise_pragma_not_exists( ).
    ENDTRY.

  ENDMETHOD.
  METHOD _raise_pragma_enqueue.
    zcx_abapgit_exception=&gt;raise( |Pragma { ms_item-obj_name } enqueue error| ).
  ENDMETHOD.
  METHOD _raise_pragma_exists.
    zcx_abapgit_exception=&gt;raise( |Pragma { ms_item-obj_name } exists| ).
  ENDMETHOD.
  METHOD _raise_pragma_not_exists.
    zcx_abapgit_exception=&gt;raise( |Pragma { ms_item-obj_name } doesn&apos;t exist| ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_pinf IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE changed_by FROM intf INTO rv_user
      WHERE intf_name = ms_item-obj_name.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_pack_name TYPE intf-pack_name,
          lv_main_pack TYPE tdevc-mainpack.
    SELECT SINGLE pack_name FROM intf INTO lv_pack_name
      WHERE intf_name = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

    IF rv_bool = abap_true.
      SELECT SINGLE mainpack FROM tdevc INTO lv_main_pack
        WHERE devclass = lv_pack_name.                  &quot;#EC CI_GENBUFF
      rv_bool = boolc( sy-subrc = 0 ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_pinf      TYPE ty_pinf,
          lv_name      TYPE scomifnam,
          lt_elements  TYPE ty_elements,
          li_interface TYPE REF TO if_package_interface.

    FIELD-SYMBOLS: &lt;lg_any&gt;     TYPE any,
                   &lt;li_element&gt; LIKE LINE OF lt_elements,
                   &lt;ls_element&gt; LIKE LINE OF ls_pinf-elements.
    lv_name = ms_item-obj_name.

    cl_package_interface=&gt;load_package_interface(
      EXPORTING
        i_package_interface_name = lv_name
        i_force_reload           = abap_true
      IMPORTING
        e_package_interface      = li_interface ).

    li_interface-&gt;get_all_attributes(
      IMPORTING e_package_interface_data = ls_pinf-attributes ).

    CLEAR: ls_pinf-attributes-pack_name,
           ls_pinf-attributes-author,
           ls_pinf-attributes-created_by,
           ls_pinf-attributes-created_on,
           ls_pinf-attributes-changed_by,
           ls_pinf-attributes-changed_on,
           ls_pinf-attributes-tadir_devc.

* fields does not exist in older SAP versions
    ASSIGN COMPONENT &apos;SW_COMP_LOGICAL_PACKAGE&apos; OF STRUCTURE ls_pinf-attributes TO &lt;lg_any&gt;.
    IF sy-subrc = 0.
      CLEAR &lt;lg_any&gt;.
    ENDIF.
    ASSIGN COMPONENT &apos;SW_COMP_TADIR_PACKAGE&apos; OF STRUCTURE ls_pinf-attributes TO &lt;lg_any&gt;.
    IF sy-subrc = 0.
      CLEAR &lt;lg_any&gt;.
    ENDIF.

    li_interface-&gt;get_elements( IMPORTING e_elements = lt_elements ).

    LOOP AT lt_elements ASSIGNING &lt;li_element&gt;.
      APPEND INITIAL LINE TO ls_pinf-elements ASSIGNING &lt;ls_element&gt;.
      &lt;li_element&gt;-&gt;get_all_attributes( IMPORTING e_element_data = &lt;ls_element&gt; ).
      CLEAR &lt;ls_element&gt;-elem_pack.
    ENDLOOP.

    io_xml-&gt;add( ig_data = ls_pinf
                 iv_name = &apos;PINF&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: li_interface TYPE REF TO if_package_interface,
          ls_pinf      TYPE ty_pinf.
    io_xml-&gt;read( EXPORTING iv_name = &apos;PINF&apos;
                  CHANGING cg_data = ls_pinf ).

    li_interface = create_or_load(
      is_pinf = ls_pinf
      iv_package = iv_package ).

    update_attributes(
      is_pinf      = ls_pinf
      ii_interface = li_interface ).

    update_elements(
      is_pinf      = ls_pinf
      ii_interface = li_interface ).

  ENDMETHOD.

  METHOD update_attributes.

    DATA: ls_sign       TYPE scompisign,
          lv_changeable TYPE flag.
    ii_interface-&gt;get_changeable( IMPORTING e_changeable = lv_changeable ).
    IF lv_changeable = abap_false.
* at creation the object is already in change mode
      ii_interface-&gt;set_changeable( abap_true ).
    ENDIF.

    ls_sign-descript       = abap_true.
    ls_sign-pinftype       = abap_true.
    ls_sign-restricted     = abap_true.
    ls_sign-default_if     = abap_true.
    ls_sign-def_sever      = abap_true.
    ls_sign-acl_flag       = abap_true.
    ls_sign-pifstablty     = abap_true.
    ls_sign-release_status = abap_true.

    ii_interface-&gt;set_all_attributes(
      i_package_interface_data = is_pinf-attributes
      i_data_sign              = ls_sign ).

* looks like setting &quot;i_suppress_dialog = abap_true&quot; will make
* it fail for local($) packages
    ii_interface-&gt;save( ).

    ii_interface-&gt;set_changeable( abap_false ).

  ENDMETHOD.

  METHOD update_elements.

    DATA: lt_existing TYPE ty_elements,
          lt_add      TYPE scomeldata,
          lv_index    TYPE i,
          lv_found    TYPE abap_bool,
*          ls_sign     TYPE scomelsign,
          ls_attr     TYPE scomeldtln.

    FIELD-SYMBOLS: &lt;li_element&gt; LIKE LINE OF lt_existing,
                   &lt;ls_element&gt; LIKE LINE OF is_pinf-elements.
*    ls_sign-usag_restr                 = abap_true.
*    ls_sign-stability                  = abap_true.
*    ls_sign-no_check                   = abap_true.
*    ls_sign-useastype                  = abap_true.
*    ls_sign-asforgnkey                 = abap_true.
*    ls_sign-deprecation_type           = abap_true. backport
*    ls_sign-replacement_object_type    = abap_true. backport
*    ls_sign-replacement_object_name    = abap_true. backport
*    ls_sign-replacement_subobject_type = abap_true. backport
*    ls_sign-replacement_subobject_name = abap_true. backport

    ii_interface-&gt;set_elements_changeable( abap_true ).

    ii_interface-&gt;get_elements( IMPORTING e_elements = lt_existing ).

    LOOP AT is_pinf-elements ASSIGNING &lt;ls_element&gt;.

      lv_found = abap_false.
      LOOP AT lt_existing ASSIGNING &lt;li_element&gt;.
        lv_index = sy-tabix.
        &lt;li_element&gt;-&gt;get_all_attributes( IMPORTING e_element_data = ls_attr ).
        IF &lt;ls_element&gt;-elem_type = ls_attr-elem_type
            AND &lt;ls_element&gt;-elem_key = ls_attr-elem_key.
          DELETE lt_existing INDEX lv_index.
          CONTINUE. &quot; current loop
        ENDIF.
      ENDLOOP.

      IF lv_found = abap_false.
        APPEND &lt;ls_element&gt; TO lt_add.
      ENDIF.
    ENDLOOP.

    ii_interface-&gt;remove_elements( lt_existing ).

    ii_interface-&gt;add_elements( lt_add ).

    ii_interface-&gt;save_elements( ).

    ii_interface-&gt;set_elements_changeable( abap_false ).

  ENDMETHOD.

  METHOD create_or_load.

    IF zif_abapgit_object~exists( ) = abap_false.
      cl_package_interface=&gt;create_new_package_interface(
        EXPORTING
          i_pkg_interface_name    = is_pinf-attributes-intf_name
          i_publisher_pkg_name    = iv_package
        IMPORTING
          e_package_interface     = ri_interface
        EXCEPTIONS
          object_already_existing = 1
          object_just_created     = 2
          interface_name_invalid  = 3
          unexpected_error        = 4
          OTHERS                  = 7 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error creating new package interface&apos; ).
      ENDIF.
    ELSE.
      cl_package_interface=&gt;load_package_interface(
        EXPORTING
          i_package_interface_name   = is_pinf-attributes-intf_name
          i_force_reload             = abap_true
        IMPORTING
          e_package_interface        = ri_interface
        EXCEPTIONS
          db_read_error              = 1
          unexpected_error           = 2
          object_not_existing        = 3
          shorttext_not_existing     = 4
          object_locked_and_modified = 5
          OTHERS                     = 6 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error loading package interface&apos; ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD delete_elements.

    DATA: lt_elements TYPE ty_elements.

    FIELD-SYMBOLS: &lt;li_element&gt; LIKE LINE OF lt_elements.
    ii_interface-&gt;set_elements_changeable( abap_true ).

    ii_interface-&gt;get_elements( IMPORTING e_elements = lt_elements ).

    LOOP AT lt_elements ASSIGNING &lt;li_element&gt;.
      &lt;li_element&gt;-&gt;delete( ).
    ENDLOOP.

    ii_interface-&gt;save_elements( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_name      TYPE scomifnam,
          li_interface TYPE REF TO if_package_interface.
    lv_name = ms_item-obj_name.

    cl_package_interface=&gt;load_package_interface(
      EXPORTING
        i_package_interface_name   = lv_name
      IMPORTING
        e_package_interface        = li_interface
      EXCEPTIONS
        db_read_error              = 1
        unexpected_error           = 2
        object_not_existing        = 3
        shorttext_not_existing     = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error loading package interface, delete&apos; ).
    ENDIF.

* elements must be deleted before the package interface
* can be deleted
    delete_elements( li_interface ).

    li_interface-&gt;set_changeable( abap_true ).

    li_interface-&gt;delete( ).

    li_interface-&gt;save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;PINF&apos;
        in_new_window = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_para IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
* looks like &quot;changed by user&quot; is not stored in the database
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
* Data elements can refer to PARA objects
    rs_metadata-ddic = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_paramid TYPE tpara-paramid.
    SELECT SINGLE paramid FROM tpara INTO lv_paramid
      WHERE paramid = ms_item-obj_name.                 &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_tpara  TYPE tpara,
          ls_tparat TYPE tparat.
    SELECT SINGLE * FROM tpara INTO ls_tpara
      WHERE paramid = ms_item-obj_name.                 &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tparat INTO ls_tparat
      WHERE paramid = ms_item-obj_name
      AND sprache = mv_language.          &quot;#EC CI_GENBUFF &quot;#EC CI_SUBRC

    io_xml-&gt;add( iv_name = &apos;TPARA&apos;
                 ig_data = ls_tpara ).
    io_xml-&gt;add( iv_name = &apos;TPARAT&apos;
                 ig_data = ls_tparat ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.
* see fm RS_PARAMETER_ADD and RS_PARAMETER_EDIT

    DATA: lv_mode   TYPE c LENGTH 1,
          ls_tpara  TYPE tpara,
          ls_tparat TYPE tparat.
    SELECT SINGLE * FROM tpara INTO ls_tpara
      WHERE paramid = ms_item-obj_name.                 &quot;#EC CI_GENBUFF
    IF sy-subrc = 0.
      lv_mode = &apos;M&apos;.
    ELSE.
      lv_mode = &apos;I&apos;.
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TPARA&apos;
                  CHANGING cg_data = ls_tpara ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TPARAT&apos;
                  CHANGING cg_data = ls_tparat ).

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = &apos;PARA&apos;
        mode                = lv_mode
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = mv_language
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT, PARA&apos; ).
    ENDIF.

    MODIFY tpara FROM ls_tpara.                           &quot;#EC CI_SUBRC
    ASSERT sy-subrc = 0.

    MODIFY tparat FROM ls_tparat.                         &quot;#EC CI_SUBRC
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    &quot; We can&apos;t use FM RS_PARAMETER_DELETE because of the popup to confirm
    &quot;Therefore we have to reimplement most of the FMs logic

    DATA: lv_paramid   TYPE tpara-paramid,
          ls_transpkey TYPE trkey.

    lv_paramid = ms_item-obj_name.

    CALL FUNCTION &apos;RS_ACCESS_PERMISSION&apos;
      EXPORTING
        global_lock              = abap_true
        language_upd_exit        = &apos;RS_PARAMETER_LANGUAGE_EXIT&apos;    &quot; Name FuBa for maintenance language change
        object                   = lv_paramid
        object_class             = ms_item-obj_type
        suppress_language_check  = space
      EXCEPTIONS
        canceled_in_corr         = 1
        enqueued_by_user         = 2
        enqueue_system_failure   = 3
        illegal_parameter_values = 4
        locked_by_author         = 5
        no_modify_permission     = 6
        no_show_permission       = 7
        permission_failure       = 8
        request_language_denied  = 9
        OTHERS                   = 10.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    SELECT COUNT(*) FROM cross WHERE ( type = &apos;P&apos; OR
                               type = &apos;Q&apos; )
                              AND name   = lv_paramid.
    IF sy-subrc = 0.
      zcx_abapgit_exception=&gt;raise( &apos;PARA: Parameter is still used&apos; ).
    ELSE.
      SELECT COUNT(*) FROM dd04l BYPASSING BUFFER
      WHERE  memoryid = lv_paramid
      AND as4local = &apos;A&apos;.
      IF sy-subrc = 0.
        zcx_abapgit_exception=&gt;raise( &apos;PARA: Parameter is still used&apos; ).
      ENDIF.
    ENDIF.
    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        global_lock         = abap_true
        object              = lv_paramid
        object_class        = &apos;PARA&apos;
        mode                = &apos;D&apos;
      IMPORTING
        transport_key       = ls_transpkey
      EXCEPTIONS
        cancelled           = 01
        permission_failure  = 02
        unknown_objectclass = 03.

    IF sy-subrc = 0.
      DELETE FROM tpara WHERE paramid = lv_paramid.
      DELETE FROM tparat WHERE paramid = lv_paramid.

      IF sy-subrc = 0.
        CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
          EXPORTING
            object    = lv_paramid
            operation = &apos;DELETE&apos;
            type      = &apos;CR&apos;.
      ENDIF.
    ELSE.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;PARA&apos;
        in_new_window = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = |PA{ ms_item-obj_name }|.
    OVERLAY lv_argument WITH &apos;                                          &apos;.
    lv_argument = lv_argument &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EEUDB&apos;
                                            iv_argument    = lv_argument ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_nrob IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_objectid TYPE cdhdr-objectid,
          lt_cdhdr    TYPE cdhdr_tab.

    FIELD-SYMBOLS: &lt;ls_cdhdr&gt; LIKE LINE OF lt_cdhdr.
    lv_objectid = ms_item-obj_name.

    CALL FUNCTION &apos;CHANGEDOCUMENT_READ_HEADERS&apos;
      EXPORTING
        objectclass                = &apos;NRKROBJ&apos;
        objectid                   = lv_objectid
      TABLES
        i_cdhdr                    = lt_cdhdr
      EXCEPTIONS
        no_position_found          = 1
        wrong_access_to_archive    = 2
        time_zone_conversion_error = 3
        OTHERS                     = 4.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
      RETURN.
    ENDIF.

    SORT lt_cdhdr BY udate DESCENDING utime DESCENDING.

    READ TABLE lt_cdhdr INDEX 1 ASSIGNING &lt;ls_cdhdr&gt;.
    ASSERT sy-subrc = 0.

    rv_user = &lt;ls_cdhdr&gt;-username.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-late_deser = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_object TYPE tnro-object.
    SELECT SINGLE object FROM tnro INTO lv_object
      WHERE object = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_object     TYPE tnro-object,
          ls_attributes TYPE tnro,
          ls_text       TYPE tnrot.
    lv_object = ms_item-obj_name.

    CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_READ&apos;
      EXPORTING
        language          = mv_language
        object            = lv_object
      IMPORTING
        object_attributes = ls_attributes
        object_text       = ls_text
      EXCEPTIONS
        object_not_found  = 1
        OTHERS            = 2.
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_OBJECT_READ&apos; ).
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;ATTRIBUTES&apos;
                 ig_data = ls_attributes ).
    io_xml-&gt;add( iv_name = &apos;TEXT&apos;
                 ig_data = ls_text ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lt_errors     TYPE TABLE OF inoer,
          ls_attributes TYPE tnro,
          ls_text       TYPE tnrot.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTRIBUTES&apos;
                  CHANGING cg_data = ls_attributes ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TEXT&apos;
                  CHANGING cg_data = ls_text ).

    CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_UPDATE&apos;
      EXPORTING
        indicator                 = &apos;I&apos;
        object_attributes         = ls_attributes
        object_text               = ls_text
      TABLES
        errors                    = lt_errors
      EXCEPTIONS
        object_already_exists     = 1
        object_attributes_missing = 2
        object_not_found          = 3
        object_text_missing       = 4
        wrong_indicator           = 5
        OTHERS                    = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_OBJECT_UPDATE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_CLOSE&apos;
      EXPORTING
        object                 = ls_attributes-object
      EXCEPTIONS
        object_not_initialized = 1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_OBJECT_CLOSE&apos; ).
    ENDIF.

    tadir_insert( iv_package ).

  ENDMETHOD.

  METHOD delete_intervals.

    DATA: lv_error    TYPE c LENGTH 1,
          ls_error    TYPE inrer,
          lt_list     TYPE STANDARD TABLE OF inriv WITH DEFAULT KEY,
          lt_error_iv TYPE STANDARD TABLE OF inriv WITH DEFAULT KEY.

    FIELD-SYMBOLS: &lt;ls_list&gt; LIKE LINE OF lt_list.
    CALL FUNCTION &apos;NUMBER_RANGE_INTERVAL_LIST&apos;
      EXPORTING
        object                     = iv_object
      TABLES
        interval                   = lt_list
      EXCEPTIONS
        nr_range_nr1_not_found     = 1
        nr_range_nr1_not_intern    = 2
        nr_range_nr2_must_be_space = 3
        nr_range_nr2_not_extern    = 4
        nr_range_nr2_not_found     = 5
        object_not_found           = 6
        subobject_must_be_space    = 7
        subobject_not_found        = 8
        OTHERS                     = 9.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_INTERVAL_LIST&apos; ).
    ENDIF.

    IF lines( lt_list ) = 0.
      RETURN.
    ENDIF.

    LOOP AT lt_list ASSIGNING &lt;ls_list&gt;.
      CLEAR &lt;ls_list&gt;-nrlevel.
      &lt;ls_list&gt;-procind = &apos;D&apos;.
    ENDLOOP.

    CALL FUNCTION &apos;NUMBER_RANGE_INTERVAL_UPDATE&apos;
      EXPORTING
        object           = iv_object
      IMPORTING
        error            = ls_error
        error_occured    = lv_error
      TABLES
        error_iv         = lt_error_iv
        interval         = lt_list
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.
    IF sy-subrc &lt;&gt; 0 OR lv_error = abap_true.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_INTERVAL_UPDATE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;NUMBER_RANGE_UPDATE_CLOSE&apos;
      EXPORTING
        object                 = iv_object
      EXCEPTIONS
        no_changes_made        = 1
        object_not_initialized = 2
        OTHERS                 = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_UPDATE_CLOSE&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_object TYPE tnro-object.
    lv_object = ms_item-obj_name.

    delete_intervals( lv_object ).

    CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_DELETE&apos;
      EXPORTING
        language           = mv_language
        object             = lv_object
      EXCEPTIONS
        delete_not_allowed = 1
        object_not_found   = 2
        wrong_indicator    = 3
        OTHERS             = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from NUMBER_RANGE_OBJECT_DELETE&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSNRO&apos;.
    ls_bcdata-dynpro   = &apos;0150&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;NRIV-OBJECT&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=DISP&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SNRO&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, NROB&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_MSAG IMPLEMENTATION.
  METHOD delete_documentation.
    DATA: lv_key_s TYPE dokhl-object.

    CLEAR lv_key_s.
    CALL FUNCTION &apos;DOCU_OBJECT_NAME_CONCATENATE&apos;
      EXPORTING
        docu_id  = &apos;NA&apos;
        element  = iv_message_id
        addition = &apos;   &apos;
      IMPORTING
        object   = lv_key_s
      EXCEPTIONS
        OTHERS   = 0.

    CALL FUNCTION &apos;DOKU_DELETE_ALL&apos;
      EXPORTING
        doku_id                        = &apos;NA&apos;
        doku_object                    = lv_key_s
        generic_use                    = &apos;X&apos;
        suppress_authority             = space
        suppress_enqueue               = space
        suppress_transport             = space
      EXCEPTIONS
        header_without_text            = 01
        index_without_header           = 02
        no_authority_for_devclass_xxxx = 03
        no_docu_found                  = 04
        object_is_already_enqueued     = 05
        object_is_enqueued_by_corr     = 06
        user_break                     = 07.

  ENDMETHOD.
  METHOD delete_msgid.

    delete_documentation( iv_message_id ).

    DELETE FROM t100a WHERE arbgb = iv_message_id.
    IF sy-subrc = 0 OR sy-subrc = 4.
      CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
        EXPORTING
          object    = iv_message_id
          operation = &apos;DELETE&apos;
          program   = space
          type      = &apos;CN&apos;.
      DELETE FROM t100o WHERE arbgb = iv_message_id.
      DELETE FROM t100t WHERE arbgb = iv_message_id.    &quot;#EC CI_NOFIRST
      DELETE FROM t100u WHERE arbgb = iv_message_id.
      DELETE FROM t100x WHERE arbgb = iv_message_id.
      DELETE FROM t100 WHERE arbgb = iv_message_id.
    ENDIF.
  ENDMETHOD.
  METHOD deserialize_texts.

    DATA: lv_msg_id     TYPE rglif-message_id,
          ls_t100       TYPE t100,
          lt_t100t      TYPE TABLE OF t100t,
          lt_t100_texts TYPE tt_t100_texts,
          lt_t100u      TYPE TABLE OF t100u.

    FIELD-SYMBOLS: &lt;ls_t100_text&gt; TYPE ty_t100_texts.
    lv_msg_id = ms_item-obj_name.

    SELECT * FROM t100u INTO TABLE lt_t100u
      WHERE arbgb = lv_msg_id ORDER BY PRIMARY KEY.     &quot;#EC CI_GENBUFF

    io_xml-&gt;read( EXPORTING iv_name = &apos;T100_TEXTS&apos;
                  CHANGING  cg_data = lt_t100_texts ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;T100T&apos;
                  CHANGING  cg_data = lt_t100t ).

    MODIFY t100t FROM TABLE lt_t100t.                     &quot;#EC CI_SUBRC

    LOOP AT lt_t100_texts ASSIGNING &lt;ls_t100_text&gt;.
      &quot;check if message exists
      READ TABLE lt_t100u TRANSPORTING NO FIELDS
        WITH KEY arbgb = lv_msg_id msgnr = &lt;ls_t100_text&gt;-msgnr BINARY SEARCH.
      CHECK sy-subrc = 0. &quot;if original message doesn&apos;t exist no translations added

      MOVE-CORRESPONDING &lt;ls_t100_text&gt; TO ls_t100.
      ls_t100-arbgb = lv_msg_id.
      MODIFY t100 FROM ls_t100.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;MSAG: Table T100 modify failed&apos; ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD free_access_permission.
    CALL FUNCTION &apos;RS_ACCESS_PERMISSION&apos;
      EXPORTING
        mode         = &apos;FREE&apos;
        object       = iv_message_id
        object_class = &apos;T100&apos;.
  ENDMETHOD.
  METHOD serialize_longtexts_msag.

    DATA: lv_object  TYPE dokhl-object,
          lt_objects TYPE STANDARD TABLE OF dokhl-object
                          WITH NON-UNIQUE DEFAULT KEY,
          lt_dokil   TYPE zif_abapgit_definitions=&gt;tty_dokil.

    FIELD-SYMBOLS: &lt;ls_t100&gt;  TYPE t100.

    IF lines( it_t100 ) = 0.
      RETURN.
    ENDIF.

    LOOP AT it_t100 ASSIGNING &lt;ls_t100&gt;.

      lv_object = &lt;ls_t100&gt;-arbgb &amp;&amp; &lt;ls_t100&gt;-msgnr.
      INSERT lv_object INTO TABLE lt_objects.

    ENDLOOP.

    SELECT * FROM dokil
             INTO TABLE lt_dokil
             FOR ALL ENTRIES IN lt_objects
             WHERE id     = &apos;NA&apos;
             AND   object = lt_objects-table_line.

    IF lines( lt_dokil ) &gt; 0.
      serialize_longtexts( io_xml   = io_xml
                           it_dokil = lt_dokil ).
    ENDIF.

  ENDMETHOD.
  METHOD serialize_texts.

    DATA: lv_msg_id     TYPE rglif-message_id,
          lt_t100_texts TYPE tt_t100_texts,
          lt_t100t      TYPE TABLE OF t100t,
          lt_i18n_langs TYPE TABLE OF langu.

    lv_msg_id = ms_item-obj_name.

    &quot; Collect additional languages
    &quot; Skip master lang - it has been already serialized
    SELECT DISTINCT sprsl AS langu INTO TABLE lt_i18n_langs
      FROM t100t
      WHERE arbgb = lv_msg_id
      AND   sprsl &lt;&gt; mv_language.       &quot;#EC CI_BYPASS &quot;#EC CI_GENBUFF.

    SORT lt_i18n_langs ASCENDING.

    IF lines( lt_i18n_langs ) &gt; 0.

      SELECT * FROM t100t INTO CORRESPONDING FIELDS OF TABLE lt_t100t
        WHERE sprsl &lt;&gt; mv_language
        AND arbgb = lv_msg_id.                          &quot;#EC CI_GENBUFF

      SELECT * FROM t100 INTO CORRESPONDING FIELDS OF TABLE lt_t100_texts
        FOR ALL ENTRIES IN lt_i18n_langs
        WHERE sprsl = lt_i18n_langs-table_line
        AND arbgb = lv_msg_id
        ORDER BY PRIMARY KEY.             &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

      SORT lt_t100t BY sprsl ASCENDING.
      SORT lt_t100_texts BY sprsl msgnr ASCENDING.

      io_xml-&gt;add( iv_name = &apos;I18N_LANGS&apos;
                   ig_data = lt_i18n_langs ).

      io_xml-&gt;add( iv_name = &apos;T100T&apos;
                   ig_data = lt_t100t ).

      io_xml-&gt;add( iv_name = &apos;T100_TEXTS&apos;
                   ig_data = lt_t100_texts ).

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM t100a INTO rv_user
      WHERE arbgb = ms_item-obj_name.                   &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0 OR rv_user = &apos;&apos;.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    DATA: lv_t100a          TYPE t100a,
          lv_frozen         TYPE flag,
          lv_message_id     TYPE arbgb,
          lv_access_granted TYPE abap_bool.

* parameter SUPPRESS_DIALOG doesnt exist in all versions of FM RS_DELETE_MESSAGE_ID
* replaced with a copy
    lv_message_id = ms_item-obj_name.
    IF ms_item-obj_name EQ space.
      zcx_abapgit_exception=&gt;raise( &apos;Error from (copy of) RS_DELETE_MESSAGE_ID&apos; ).&quot;blank message id
    ENDIF.

    SELECT SINGLE * FROM t100a INTO lv_t100a WHERE arbgb = ms_item-obj_name.
    IF sy-subrc NE 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from (copy of) RS_DELETE_MESSAGE_ID&apos; ).&quot;not found
    ENDIF.

    CLEAR lv_frozen.
    CALL FUNCTION &apos;RS_ACCESS_PERMISSION&apos;
      EXPORTING
        authority_check = &apos;X&apos;
        global_lock     = &apos;X&apos;
        mode            = &apos;MODIFY&apos;
        object          = lv_message_id
        object_class    = &apos;T100&apos;
      IMPORTING
        frozen          = lv_frozen
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0 OR lv_frozen NE space.
      zcx_abapgit_exception=&gt;raise( &apos;Error from (copy of) RS_DELETE_MESSAGE_ID&apos; ).&quot;can&apos;t access
    ENDIF.

    lv_access_granted = abap_true.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        global_lock        = &apos;X&apos;
        object             = lv_message_id
        object_class       = &apos;MSAG&apos;
        mode               = &apos;D&apos;
      EXCEPTIONS
        cancelled          = 01
        permission_failure = 02.

    IF sy-subrc NE 0.
      IF lv_access_granted = abap_true.
        free_access_permission( lv_message_id ).
      ENDIF.
      zcx_abapgit_exception=&gt;raise( &apos;Error from (copy of) RS_DELETE_MESSAGE_ID&apos; ).&quot;can&apos;t access
    ENDIF.

    delete_msgid( lv_message_id ).

    IF lv_access_granted = abap_true.
      free_access_permission( lv_message_id ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* fm RPY_MESSAGE_ID_INSERT almost works, but not in older versions

    DATA: ls_t100a  TYPE t100a,
          ls_t100t  TYPE t100t,
          ls_t100u  TYPE t100u,
          lt_t100   TYPE TABLE OF t100,
          lt_before TYPE TABLE OF t100u.

    FIELD-SYMBOLS: &lt;ls_t100&gt; LIKE LINE OF lt_t100.
    io_xml-&gt;read( EXPORTING iv_name = &apos;T100A&apos;
                  CHANGING cg_data = ls_t100a ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;T100&apos;
                  CHANGING cg_data = lt_t100 ).

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        global_lock         = abap_true
        devclass            = iv_package
        object              = ls_t100a-arbgb
        object_class        = &apos;T100&apos;
        mode                = &apos;INSERT&apos;
      EXCEPTIONS
        cancelled           = 01
        permission_failure  = 02
        unknown_objectclass = 03.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RS_CORR_INSERT&apos; ).
    ENDIF.

    SELECT * FROM t100u INTO TABLE lt_before
      WHERE arbgb = ls_t100a-arbgb ORDER BY msgnr. &quot;#EC CI_GENBUFF &quot;#EC CI_BYPASS

    LOOP AT lt_t100 ASSIGNING &lt;ls_t100&gt;.
      DELETE lt_before WHERE msgnr = &lt;ls_t100&gt;-msgnr.
      MODIFY t100 FROM &lt;ls_t100&gt;.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;MSAG: Table T100 modify failed&apos; ).
      ENDIF.
      CLEAR ls_t100u.
      MOVE-CORRESPONDING &lt;ls_t100&gt; TO ls_t100u ##enh_ok.
      ls_t100u-name    = sy-uname.
      ls_t100u-datum   = sy-datum.
      ls_t100u-selfdef = &apos;3&apos;.
      MODIFY t100u FROM ls_t100u.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;MSAG: Table T100U modify failed&apos; ).
      ENDIF.
    ENDLOOP.

    ls_t100a-masterlang = mv_language.
    ls_t100a-lastuser = sy-uname.
    ls_t100a-respuser = sy-uname.
    ls_t100a-ldate = sy-datum.
    ls_t100a-ltime = sy-uzeit.
    MODIFY t100a FROM ls_t100a.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;MSAG: Table T100A modify failed&apos; ).
    ENDIF.

    ls_t100t-sprsl = mv_language.
    ls_t100t-arbgb = ls_t100a-arbgb.
    ls_t100t-stext = ls_t100a-stext.
    MODIFY t100t FROM ls_t100t.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;MSAG: Table T100T modify failed&apos; ).
    ENDIF.

    LOOP AT lt_before INTO ls_t100u.
      DELETE FROM t100 WHERE arbgb = ls_t100u-arbgb
        AND msgnr = ls_t100u-msgnr.                       &quot;#EC CI_SUBRC

      DELETE FROM t100u WHERE arbgb = ls_t100u-arbgb
        AND msgnr = ls_t100u-msgnr.                       &quot;#EC CI_SUBRC
    ENDLOOP.

    deserialize_longtexts( io_xml ).

    deserialize_texts( io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_arbgb TYPE t100a-arbgb.
    SELECT SINGLE arbgb FROM t100a INTO lv_arbgb
      WHERE arbgb = ms_item-obj_name.                   &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument   = |{ ms_item-obj_name }|.
    OVERLAY lv_argument WITH &apos;                     &apos;.
    lv_argument = lv_argument &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = |ES_MSGSI|
                                            iv_argument    = lv_argument ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;MSAG&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_msg_id TYPE rglif-message_id,
          ls_inf    TYPE t100a,
          lt_source TYPE tty_t100.
    lv_msg_id = ms_item-obj_name.

    SELECT SINGLE * FROM t100a INTO ls_inf
      WHERE arbgb = lv_msg_id.                          &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.
    CLEAR ls_inf-respuser.

    SELECT * FROM t100 INTO TABLE lt_source
      WHERE sprsl = mv_language
      AND arbgb = lv_msg_id
      ORDER BY PRIMARY KEY.               &quot;#EC CI_SUBRC &quot;#EC CI_GENBUFF

    CLEAR: ls_inf-lastuser,
           ls_inf-ldate,
           ls_inf-ltime.

    io_xml-&gt;add( iv_name = &apos;T100A&apos;
                 ig_data = ls_inf ).
    io_xml-&gt;add( ig_data = lt_source
                 iv_name = &apos;T100&apos; ).

    serialize_longtexts_msag( it_t100 = lt_source
                              io_xml  = io_xml ).

    serialize_texts( io_xml ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_jobd IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_job_definition TYPE REF TO object,
          lv_name           TYPE c LENGTH 32.

    lv_name = ms_item-obj_name.

    TRY.
        CREATE OBJECT lo_job_definition TYPE (&apos;CL_JR_JOB_DEFINITION&apos;)
          EXPORTING
            im_jd_name = lv_name.

        CALL METHOD lo_job_definition-&gt;(&apos;DELETE_JD&apos;).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error deleting JOBD| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lr_job_definition TYPE REF TO data,
          lo_job_definition TYPE REF TO object,
          lv_name           TYPE ty_jd_name.

    FIELD-SYMBOLS: &lt;lg_job_definition&gt; TYPE any,
                   &lt;lg_field&gt;          TYPE any.
    lv_name = ms_item-obj_name.

    TRY.
        CREATE DATA lr_job_definition TYPE (&apos;CL_JR_JOB_DEFINITION=&gt;TY_JOB_DEFINITION&apos;).
        ASSIGN lr_job_definition-&gt;* TO &lt;lg_job_definition&gt;.
        ASSERT sy-subrc = 0.

        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;JOBD&apos;
          CHANGING
            cg_data = &lt;lg_job_definition&gt; ).

        CREATE OBJECT lo_job_definition TYPE (&apos;CL_JR_JOB_DEFINITION&apos;)
          EXPORTING
            im_jd_name = lv_name.

        ASSIGN COMPONENT &apos;JDPACKAGE&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.

        &lt;lg_field&gt; = iv_package.

        CALL METHOD lo_job_definition-&gt;(&apos;CREATE_JD&apos;)
          EXPORTING
            im_jd_attributes = &lt;lg_job_definition&gt;.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error deserializing JOBD| ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE ty_jd_name.

    lv_name = ms_item-obj_name.

    TRY.
        CALL METHOD (&apos;CL_JR_JD_MANAGER&apos;)=&gt;(&apos;CHECK_JD_EXISTENCE&apos;)
          EXPORTING
            im_jd_name     = lv_name
          IMPORTING
            ex_is_existing = rv_bool.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |JOBD not supported| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lv_obj_name TYPE e071-obj_name.
    lv_obj_name = ms_item-obj_name.

    CALL FUNCTION &apos;TR_OBJECT_JUMP_TO_TOOL&apos;
      EXPORTING
        iv_pgmid          = &apos;R3TR&apos;
        iv_object         = ms_item-obj_type
        iv_obj_name       = lv_obj_name
        iv_action         = &apos;SHOW&apos;
      EXCEPTIONS
        jump_not_possible = 1
        OTHERS            = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from TR_OBJECT_JUMP_TO_TOOL, JOBD| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lr_job_definition TYPE REF TO data,
          lo_job_definition TYPE REF TO object,
          lv_name           TYPE ty_jd_name.

    FIELD-SYMBOLS: &lt;lg_job_definition&gt; TYPE any,
                   &lt;lg_field&gt;          TYPE any.
    lv_name = ms_item-obj_name.

    TRY.
        CREATE DATA lr_job_definition TYPE (&apos;CL_JR_JOB_DEFINITION=&gt;TY_JOB_DEFINITION&apos;).
        ASSIGN lr_job_definition-&gt;* TO &lt;lg_job_definition&gt;.
        ASSERT sy-subrc = 0.

        CREATE OBJECT lo_job_definition TYPE (&apos;CL_JR_JOB_DEFINITION&apos;)
          EXPORTING
            im_jd_name = lv_name.

        CALL METHOD lo_job_definition-&gt;(&apos;GET_JD_ATTRIBUTES&apos;)
          IMPORTING
            ex_jd_attributes = &lt;lg_job_definition&gt;.

        ASSIGN COMPONENT &apos;JDPACKAGE&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;BTCJOB_USER&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;OWNER&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CREATED_DATE&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CREATED_TIME&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CHANGED_DATE&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CHANGED_TIME&apos; OF STRUCTURE &lt;lg_job_definition&gt; TO &lt;lg_field&gt;.
        CLEAR &lt;lg_field&gt;.

        io_xml-&gt;add( iv_name = &apos;JOBD&apos;
                     ig_data = &lt;lg_job_definition&gt; ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |Error serializing JOBD| ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_intf IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor(
      is_item     = is_item
      iv_language = iv_language ).
    mi_object_oriented_object_fct = zcl_abapgit_oo_factory=&gt;make( ms_item-obj_type ).
  ENDMETHOD.
  METHOD deserialize_abap.
    DATA: ls_vseointerf   TYPE vseointerf,
          lt_source       TYPE seop_source_string,
          lt_descriptions TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
          ls_clskey       TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.
    lt_source = mo_files-&gt;read_abap( ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;VSEOINTERF&apos;
                  CHANGING cg_data = ls_vseointerf ).

    mi_object_oriented_object_fct-&gt;create(
      EXPORTING
        iv_package    = iv_package
      CHANGING
        cg_properties = ls_vseointerf ).

    mi_object_oriented_object_fct-&gt;deserialize_source(
      is_key               = ls_clskey
      it_source            = lt_source ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DESCRIPTIONS&apos;
                  CHANGING cg_data = lt_descriptions ).

    mi_object_oriented_object_fct-&gt;update_descriptions(
      is_key          = ls_clskey
      it_descriptions = lt_descriptions ).

    mi_object_oriented_object_fct-&gt;add_to_activation_list( ms_item ).
  ENDMETHOD.
  METHOD deserialize_docu.

    DATA: lt_lines  TYPE tlinetab,
          lv_object TYPE dokhl-object.

    io_xml-&gt;read( EXPORTING iv_name = &apos;LINES&apos;
                  CHANGING cg_data = lt_lines ).

    IF lines( lt_lines ) = 0.
      RETURN.
    ENDIF.

    lv_object = ms_item-obj_name.

    mi_object_oriented_object_fct-&gt;create_documentation(
      it_lines       = lt_lines
      iv_object_name = lv_object
      iv_language    = mv_language ).
  ENDMETHOD.
  METHOD serialize_xml.
    DATA:
      lt_descriptions TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
      ls_vseointerf   TYPE vseointerf,
      ls_clskey       TYPE seoclskey,
      lt_lines        TYPE tlinetab.
    ls_clskey-clsname = ms_item-obj_name.

    ls_vseointerf = mi_object_oriented_object_fct-&gt;get_interface_properties( ls_clskey ).

    CLEAR: ls_vseointerf-uuid,
           ls_vseointerf-author,
           ls_vseointerf-createdon,
           ls_vseointerf-changedby,
           ls_vseointerf-changedon,
           ls_vseointerf-chgdanyby,
           ls_vseointerf-chgdanyon,
           ls_vseointerf-r3release.

    io_xml-&gt;add( iv_name = &apos;VSEOINTERF&apos;
                 ig_data = ls_vseointerf ).

    lt_lines = mi_object_oriented_object_fct-&gt;read_documentation(
      iv_class_name = ls_clskey-clsname
      iv_language   = mv_language ).
    IF lines( lt_lines ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;LINES&apos;
                   ig_data = lt_lines ).
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct-&gt;read_descriptions( ls_clskey-clsname ).
    IF lines( lt_descriptions ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;DESCRIPTIONS&apos;
                   ig_data = lt_descriptions ).
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    TYPES: BEGIN OF ty_includes,
             programm TYPE programm,
           END OF ty_includes.

    TYPES: BEGIN OF ty_reposrc,
             unam  TYPE reposrc-unam,
             udat  TYPE reposrc-udat,
             utime TYPE reposrc-utime,
           END OF ty_reposrc.

    DATA: lt_reposrc  TYPE STANDARD TABLE OF ty_reposrc,
          ls_reposrc  LIKE LINE OF lt_reposrc,
          lt_includes TYPE STANDARD TABLE OF ty_includes.

    lt_includes = mi_object_oriented_object_fct-&gt;get_includes( ms_item-obj_name ).
    ASSERT lines( lt_includes ) &gt; 0.

    SELECT unam udat utime FROM reposrc
      INTO TABLE lt_reposrc
      FOR ALL ENTRIES IN lt_includes
      WHERE progname = lt_includes-programm
      AND   r3state = &apos;A&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ELSE.
      SORT lt_reposrc BY udat DESCENDING utime DESCENDING.
      READ TABLE lt_reposrc INDEX 1 INTO ls_reposrc.
      ASSERT sy-subrc = 0.
      rv_user = ls_reposrc-unam.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    DATA: ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    mi_object_oriented_object_fct-&gt;delete( ls_clskey ).
  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
    deserialize_abap( io_xml     = io_xml
                      iv_package = iv_package ).

    deserialize_docu( io_xml ).
  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_class_key TYPE seoclskey,
          lv_category  TYPE seoclassdf-category.

    ls_class_key-clsname = ms_item-obj_name.

    rv_bool = mi_object_oriented_object_fct-&gt;exists( ls_class_key ).

    IF rv_bool = abap_true.
      SELECT SINGLE category FROM seoclassdf INTO lv_category
        WHERE clsname = ls_class_key-clsname
        AND ( version = &apos;1&apos;
        OR version = &apos;0&apos; ) ##warn_ok.                   &quot;#EC CI_GENBUFF
      IF sy-subrc = 0 AND lv_category = seoc_category_webdynpro_class.
        rv_bool = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    DATA:
      lv_program  TYPE program,
      lt_includes TYPE seoincl_t.

    lt_includes = mi_object_oriented_object_fct-&gt;get_includes( ms_item-obj_name ).
    READ TABLE lt_includes INDEX 1 INTO lv_program.
    &quot;lv_program = cl_oo_classname_service=&gt;get_interfacepool_name( lv_clsname ).
    rv_changed = check_prog_changed_since(
      iv_program   = lv_program
      iv_timestamp = iv_timestamp
      iv_skip_gui  = abap_true ).
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.
    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;INTF&apos;
        in_new_window = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lt_source        TYPE seop_source_string,
          ls_interface_key TYPE seoclskey.

    ls_interface_key-clsname = ms_item-obj_name.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        version = seoc_version_active
        force   = seox_true.
    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        version = seoc_version_inactive
        force   = seox_true.

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap( ls_interface_key ).

    mo_files-&gt;add_abap( lt_source ).

    serialize_xml( io_xml ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;==============================P&apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESEOCLASS&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_iext IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_extension = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_attributes TYPE edi_iapi01.

    CALL FUNCTION &apos;EXTTYPE_READ&apos;
      EXPORTING
        pi_cimtyp     = mv_extension
      IMPORTING
        pe_attributes = ls_attributes
      EXCEPTIONS
        OTHERS        = 1.

    rv_user = ls_attributes-plast.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CALL FUNCTION &apos;EXTTYPE_DELETE&apos;
      EXPORTING
        pi_cimtyp = mv_extension
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_extension  TYPE ty_extention,
          ls_attributes TYPE edi_iapi05.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;IEXT&apos;
      CHANGING
        cg_data = ls_extension ).

    MOVE-CORRESPONDING ls_extension-attributes TO ls_attributes.
    ls_attributes-presp = cl_abap_syst=&gt;get_user_name( ).
    ls_attributes-pwork = ls_attributes-presp.

    CALL FUNCTION &apos;EXTTYPE_CREATE&apos;
      EXPORTING
        pi_cimtyp     = mv_extension
        pi_devclass   = iv_package
        pi_attributes = ls_attributes
      TABLES
        pt_syntax     = ls_extension-t_syntax
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;EXTTYPE_READ&apos;
      EXPORTING
        pi_cimtyp = mv_extension
      EXCEPTIONS
        OTHERS    = 1.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPMSED5&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0010&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;SED5STRUC-OBJECT&apos;.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;SED5STRUC-SELECT_EXT&apos;.
    &lt;ls_bdcdata&gt;-fval = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=DISP&apos;.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;WE30&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bdcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_extension TYPE ty_extention.

    CALL FUNCTION &apos;EXTTYPE_READ&apos;
      EXPORTING
        pi_cimtyp     = mv_extension
      IMPORTING
        pe_attributes = ls_extension-attributes
      TABLES
        pt_syntax     = ls_extension-t_syntax
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    CLEAR: ls_extension-attributes-devc,
           ls_extension-attributes-plast,
           ls_extension-attributes-credate,
           ls_extension-attributes-cretime,
           ls_extension-attributes-ldate,
           ls_extension-attributes-ltime,
           ls_extension-attributes-pwork,
           ls_extension-attributes-presp.

    io_xml-&gt;add( iv_name = &apos;IEXT&apos;
                 ig_data = ls_extension ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_idoc IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_idoctyp = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_attributes TYPE edi_iapi01.

    CALL FUNCTION &apos;IDOCTYPE_READ&apos;
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      IMPORTING
        pe_attributes    = ls_attributes
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    rv_user = ls_attributes-plast.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CALL FUNCTION &apos;IDOCTYPE_DELETE&apos;
      EXPORTING
        pi_idoctyp          = mv_idoctyp
      EXCEPTIONS
        object_not_found    = 1
        lock_error          = 2
        action_not_possible = 3
        transport_error     = 4
        db_error            = 5
        no_authority        = 6
        OTHERS              = 7.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_idoc       TYPE ty_idoc,
          ls_attributes TYPE edi_iapi05.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;IDOC&apos;
      CHANGING
        cg_data = ls_idoc ).

    MOVE-CORRESPONDING ls_idoc-attributes TO ls_attributes.

    CALL FUNCTION &apos;IDOCTYPE_CREATE&apos;
      EXPORTING
        pi_idoctyp          = mv_idoctyp
        pi_devclass         = iv_package
        pi_attributes       = ls_attributes
      TABLES
        pt_syntax           = ls_idoc-t_syntax
      EXCEPTIONS
        object_not_found    = 1
        object_exists       = 2
        action_not_possible = 3
        syntax_error        = 4
        segment_error       = 5
        transport_error     = 6
        db_error            = 7
        no_authority        = 8
        OTHERS              = 9.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;IDOCTYPE_READ&apos;
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPMSED5&apos;.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;0010&apos;.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;SED5STRUC-OBJECT&apos;.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;SED5STRUC-SELECT_ORG&apos;.
    &lt;ls_bdcdata&gt;-fval = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos;.
    &lt;ls_bdcdata&gt;-fval = &apos;=DISP&apos;.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode                 = &apos;WE30&apos;
        mode_val              = &apos;E&apos;
      TABLES
        using_tab             = lt_bdcdata
      EXCEPTIONS
        system_failure        = 1
        communication_failure = 2
        resource_failure      = 3
        OTHERS                = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_idoc TYPE ty_idoc.

    CALL FUNCTION &apos;IDOCTYPE_READ&apos;
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      IMPORTING
        pe_attributes    = ls_idoc-attributes
      TABLES
        pt_syntax        = ls_idoc-t_syntax
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    CLEAR: ls_idoc-attributes-devc,
           ls_idoc-attributes-plast,
           ls_idoc-attributes-credate,
           ls_idoc-attributes-cretime,
           ls_idoc-attributes-ldate,
           ls_idoc-attributes-ltime.

    io_xml-&gt;add( iv_name = &apos;IDOC&apos;
                 ig_data = ls_idoc ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_iatu IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD read.

    DATA: li_template TYPE REF TO if_w3_api_template,
          lt_source   TYPE w3htmltabtype,
          ls_name     TYPE iacikeyt.
    ls_name = ms_item-obj_name.

    cl_w3_api_template=&gt;if_w3_api_template~load(
      EXPORTING
        p_template_name     = ls_name
      IMPORTING
        p_template          = li_template
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3api_template~load&apos; ).
    ENDIF.

    li_template-&gt;get_attributes( IMPORTING p_attributes = es_attr ).

    CLEAR: es_attr-chname,
           es_attr-tdate,
           es_attr-ttime,
           es_attr-devclass.

    li_template-&gt;get_source( IMPORTING p_source = lt_source ).

    CONCATENATE LINES OF lt_source INTO ev_source RESPECTING BLANKS.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_attr   TYPE w3tempattr,
          lv_source TYPE string.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    read( IMPORTING es_attr   = ls_attr
                    ev_source = lv_source ).

    io_xml-&gt;add( iv_name = &apos;ATTR&apos;
                 ig_data = ls_attr ).

    mo_files-&gt;add_string( iv_ext    = &apos;html&apos;
                          iv_string = lv_source ) ##NO_TEXT.

  ENDMETHOD.

  METHOD save.

    DATA: lt_source   TYPE w3htmltabtype,
          lv_source   TYPE string,
          li_template TYPE REF TO if_w3_api_template.
    cl_w3_api_template=&gt;if_w3_api_template~create_new(
      EXPORTING p_template_data = is_attr
                p_program_name = is_attr-programm
      IMPORTING p_template = li_template ).

    li_template-&gt;set_attributes( is_attr ).

    lv_source = iv_source.
    WHILE strlen( lv_source ) &gt;= 255.
      APPEND lv_source(255) TO lt_source.
      lv_source = lv_source+255.
    ENDWHILE.
    IF NOT lv_source IS INITIAL.
      APPEND lv_source TO lt_source.
    ENDIF.

    li_template-&gt;set_source( lt_source ).

    li_template-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_attr   TYPE w3tempattr,
          lv_source TYPE string.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTR&apos;
                  CHANGING cg_data = ls_attr ).

    lv_source = mo_files-&gt;read_string( &apos;html&apos; ) ##NO_TEXT.

    ls_attr-devclass = iv_package.
    save( is_attr   = ls_attr
          iv_source = lv_source ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_template TYPE REF TO if_w3_api_template,
          ls_name     TYPE iacikeyt.
    ls_name = ms_item-obj_name.

    cl_w3_api_template=&gt;if_w3_api_template~load(
      EXPORTING
        p_template_name     = ls_name
      IMPORTING
        p_template          = li_template
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from if_w3_api_template~load&apos; ).
    ENDIF.

    li_template-&gt;if_w3_api_object~set_changeable( abap_true ).
    li_template-&gt;if_w3_api_object~delete( ).
    li_template-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_name TYPE iacikeyt.
    ls_name = ms_item-obj_name.

    cl_w3_api_template=&gt;if_w3_api_template~load(
      EXPORTING
        p_template_name     = ls_name
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc = 1.
      rv_bool = abap_false.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3_api_template~load&apos; ).
    ELSE.
      rv_bool = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_iasp IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD read.

    DATA: li_service TYPE REF TO if_w3_api_service,
          lv_name    TYPE itsappl.
    lv_name = ms_item-obj_name.

    cl_w3_api_service=&gt;if_w3_api_service~load(
      EXPORTING
        p_service_name     = lv_name
      IMPORTING
        p_service          = li_service
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3api_service~load&apos; ).
    ENDIF.

    li_service-&gt;get_attributes( IMPORTING p_attributes = es_attr ).

    CLEAR: es_attr-chname,
           es_attr-tdate,
           es_attr-ttime,
           es_attr-devclass.

    li_service-&gt;get_parameters( IMPORTING p_parameters = et_parameters ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_attr       TYPE w3servattr,
          lt_parameters TYPE w3servpara_tabletype.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    read( IMPORTING es_attr       = ls_attr
                    et_parameters = lt_parameters ).

    io_xml-&gt;add( iv_name = &apos;ATTR&apos;
                 ig_data = ls_attr ).
    io_xml-&gt;add( iv_name = &apos;PARAMETERS&apos;
                 ig_data = lt_parameters ).

  ENDMETHOD.

  METHOD save.

    DATA: li_service TYPE REF TO if_w3_api_service.
    cl_w3_api_service=&gt;if_w3_api_service~create_new(
      EXPORTING p_service_data = is_attr
      IMPORTING p_service = li_service ).

    li_service-&gt;set_attributes( is_attr ).
    li_service-&gt;set_parameters( it_parameters ).

    li_service-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_attr       TYPE w3servattr,
          lt_parameters TYPE w3servpara_tabletype.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTR&apos;
                  CHANGING cg_data = ls_attr ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PARAMETERS&apos;
                  CHANGING cg_data = lt_parameters ).

    ls_attr-devclass = iv_package.
    save( is_attr       = ls_attr
          it_parameters = lt_parameters ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_service TYPE REF TO if_w3_api_service,
          lv_name    TYPE itsappl.
    lv_name = ms_item-obj_name.

    cl_w3_api_service=&gt;if_w3_api_service~load(
      EXPORTING
        p_service_name      = lv_name
      IMPORTING
        p_service           = li_service
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from if_w3_api_service~load&apos; ).
    ENDIF.

    li_service-&gt;if_w3_api_object~set_changeable( abap_true ).
    li_service-&gt;if_w3_api_object~delete( ).
    li_service-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_name TYPE itsappl.
    lv_name = ms_item-obj_name.

    cl_w3_api_service=&gt;if_w3_api_service~load(
      EXPORTING
        p_service_name      = lv_name
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc = 1.
      rv_bool = abap_false.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3_api_service~load&apos; ).
    ELSE.
      rv_bool = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_iarp IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD read.

    DATA: li_resource TYPE REF TO if_w3_api_resource,
          ls_name     TYPE w3resokey.
    ls_name = ms_item-obj_name.

    cl_w3_api_resource=&gt;if_w3_api_resource~load(
      EXPORTING
        p_resource_name     = ls_name
      IMPORTING
        p_resource          = li_resource
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3api_resource~load&apos; ).
    ENDIF.

    li_resource-&gt;get_attributes( IMPORTING p_attributes = es_attr ).

    CLEAR: es_attr-chname,
           es_attr-tdate,
           es_attr-ttime,
           es_attr-devclass.

    li_resource-&gt;get_parameters( IMPORTING p_parameters = et_parameters ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_attr       TYPE w3resoattr,
          lt_parameters TYPE w3resopara_tabletype.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    read( IMPORTING es_attr       = ls_attr
                    et_parameters = lt_parameters ).

    io_xml-&gt;add( iv_name = &apos;ATTR&apos;
                 ig_data = ls_attr ).
    io_xml-&gt;add( iv_name = &apos;PARAMETERS&apos;
                 ig_data = lt_parameters ).

  ENDMETHOD.

  METHOD save.

    DATA: li_resource TYPE REF TO if_w3_api_resource.
    cl_w3_api_resource=&gt;if_w3_api_resource~create_new(
      EXPORTING p_resource_data = is_attr
      IMPORTING p_resource = li_resource ).

    li_resource-&gt;set_attributes( is_attr ).
    li_resource-&gt;set_parameters( it_parameters ).

    li_resource-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_attr       TYPE w3resoattr,
          lt_parameters TYPE w3resopara_tabletype.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTR&apos;
                  CHANGING cg_data = ls_attr ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PARAMETERS&apos;
                  CHANGING cg_data = lt_parameters ).

    ls_attr-devclass = iv_package.
    save( is_attr       = ls_attr
          it_parameters = lt_parameters ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_resource TYPE REF TO if_w3_api_resource,
          ls_name     TYPE w3resokey.
    ls_name = ms_item-obj_name.

    cl_w3_api_resource=&gt;if_w3_api_resource~load(
      EXPORTING
        p_resource_name     = ls_name
      IMPORTING
        p_resource          = li_resource
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from if_w3_api_resource~load&apos; ).
    ENDIF.

    li_resource-&gt;if_w3_api_object~set_changeable( abap_true ).
    li_resource-&gt;if_w3_api_object~delete( ).
    li_resource-&gt;if_w3_api_object~save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_name TYPE w3resokey.
    ls_name = ms_item-obj_name.

    cl_w3_api_resource=&gt;if_w3_api_resource~load(
      EXPORTING
        p_resource_name     = ls_name
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        error_occured       = 3
        OTHERS              = 4 ).
    IF sy-subrc = 1.
      rv_bool = abap_false.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from w3_api_resource~load&apos; ).
    ELSE.
      rv_bool = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_iamu IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_internet_appl_comp_binary TYPE ty_internet_appl_comp_binary.

    ls_internet_appl_comp_binary = read( ).

    io_xml-&gt;add( iv_name = &apos;IAMU&apos;
                 ig_data = ls_internet_appl_comp_binary ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_internet_appl_comp_binary TYPE ty_internet_appl_comp_binary.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;IAMU&apos;
      CHANGING
        cg_data = ls_internet_appl_comp_binary ).

    ls_internet_appl_comp_binary-attributes-devclass = iv_package.

    save( ls_internet_appl_comp_binary ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    load_mime_api( ).

    mo_mime_api-&gt;if_w3_api_object~set_changeable(
      EXPORTING
        p_changeable                 = abap_true
      EXCEPTIONS
        action_cancelled             = 1
        object_locked_by_other_user  = 2
        permission_failure           = 3
        object_already_changeable    = 4
        object_already_unlocked      = 5
        object_just_created          = 6
        object_deleted               = 7
        object_modified              = 8
        object_not_existing          = 9
        object_invalid               = 10
        error_occured                = 11
        OTHERS                       = 12 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~set_changeable| ).
    ENDIF.

    mo_mime_api-&gt;if_w3_api_object~delete(
      EXCEPTIONS
        object_not_empty      = 1
        object_not_changeable = 2
        object_invalid        = 3
        error_occured         = 4
        OTHERS                = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~delete| ).
    ENDIF.

    mo_mime_api-&gt;if_w3_api_object~save(
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        action_cancelled      = 3
        permission_failure    = 4
        not_changed           = 5
        data_invalid          = 6
        error_occured         = 7
        OTHERS                = 8 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~save| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_mime_name TYPE iacikeym.

    ls_mime_name = ms_item-obj_name.

    cl_w3_api_mime=&gt;s_check_exist(
      EXPORTING
        p_mime_name = ls_mime_name
      IMPORTING
        p_exists    = rv_bool ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation   = &apos;SHOW&apos;
        object_name = ms_item-obj_name
        object_type = ms_item-obj_type.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.

  METHOD load_mime_api.

    DATA: ls_mime_name TYPE iacikeym.

    ls_mime_name = ms_item-obj_name.

    cl_w3_api_mime=&gt;if_w3_api_mime~load(
      EXPORTING
        p_mime_name         = ls_mime_name
      IMPORTING
        p_mime              = mo_mime_api
      EXCEPTIONS
        object_not_existing = 1
        permission_failure  = 2
        data_corrupt        = 3
        error_occured       = 4
        OTHERS              = 6 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from if_w3_api_mime~load&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD read.

    load_mime_api( ).

    mo_mime_api-&gt;get_attributes(
      IMPORTING
        p_attributes   = rs_internet_appl_comp_binary-attributes
      EXCEPTIONS
        object_invalid = 1
        mime_deleted   = 2
        error_occured  = 3
        OTHERS         = 4 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~get_attributes| ).
    ENDIF.

    CLEAR: rs_internet_appl_comp_binary-attributes-chname,
           rs_internet_appl_comp_binary-attributes-tdate,
           rs_internet_appl_comp_binary-attributes-ttime,
           rs_internet_appl_comp_binary-attributes-devclass.

    mo_mime_api-&gt;get_source(
      IMPORTING
        p_source       = rs_internet_appl_comp_binary-source
        p_datalength   = rs_internet_appl_comp_binary-length
      EXCEPTIONS
        object_invalid = 1
        mime_deleted   = 2
        error_occured  = 3
        OTHERS         = 4 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~get_source| ).
    ENDIF.

  ENDMETHOD.

  METHOD save.

    cl_w3_api_mime=&gt;if_w3_api_mime~create_new(
      EXPORTING
        p_mime_data             = is_internet_appl_comp_binary-attributes
        p_mime_content          = is_internet_appl_comp_binary-source
        p_datalength            = is_internet_appl_comp_binary-length
      IMPORTING
        p_mime                  = mo_mime_api
      EXCEPTIONS
        object_already_existing = 1
        object_just_created     = 2
        not_authorized          = 3
        undefined_name          = 4
        author_not_existing     = 5
        action_cancelled        = 6
        error_occured           = 7
        OTHERS                  = 8 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~create_ne| ).
    ENDIF.

    mo_mime_api-&gt;if_w3_api_object~save(
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        action_cancelled      = 3
        permission_failure    = 4
        not_changed           = 5
        data_invalid          = 6
        error_occured         = 7
        OTHERS                = 8 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~save| ).
    ENDIF.

    release_lock( ).

  ENDMETHOD.

  METHOD release_lock.

    &quot; As a side effect this method removes also existing locks
    mo_mime_api-&gt;if_w3_api_object~set_changeable(
      EXPORTING
        p_changeable                 = abap_false
      EXCEPTIONS
        action_cancelled             = 1
        object_locked_by_other_user  = 2
        permission_failure           = 3
        object_already_changeable    = 4
        object_already_unlocked      = 5
        object_just_created          = 6
        object_deleted               = 7
        object_modified              = 8
        object_not_existing          = 9
        object_invalid               = 10
        error_occured                = 11
        OTHERS                       = 12 ).

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from if_w3_api_mime~set_changeable| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_FUGR IMPLEMENTATION.
  METHOD are_exceptions_class_based.
    DATA:
      lt_dokumentation    TYPE TABLE OF funct,
      lt_exception_list   TYPE TABLE OF rsexc,
      lt_export_parameter TYPE TABLE OF rsexp,
      lt_import_parameter TYPE TABLE OF rsimp,
      lt_tables_parameter TYPE TABLE OF rstbl.

    CALL FUNCTION &apos;FUNCTION_IMPORT_DOKU&apos;
      EXPORTING
        funcname           = iv_function_name
      IMPORTING
        exception_class    = rv_return
      TABLES
        dokumentation      = lt_dokumentation
        exception_list     = lt_exception_list
        export_parameter   = lt_export_parameter
        import_parameter   = lt_import_parameter
        tables_parameter   = lt_tables_parameter
      EXCEPTIONS
        error_message      = 1
        function_not_found = 2
        invalid_name       = 3
        OTHERS             = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from FUNCTION_IMPORT_DOKU&apos; ).
    ENDIF.
  ENDMETHOD.
  METHOD deserialize_functions.

    DATA: lv_include   TYPE rs38l-include,
          lv_area      TYPE rs38l-area,
          lv_group     TYPE rs38l-area,
          lv_namespace TYPE rs38l-namespace,
          lt_source    TYPE TABLE OF abaptxt255.

    FIELD-SYMBOLS: &lt;ls_func&gt; LIKE LINE OF it_functions.

    LOOP AT it_functions ASSIGNING &lt;ls_func&gt;.

      lt_source = mo_files-&gt;read_abap( iv_extra = &lt;ls_func&gt;-funcname ).

      lv_area = ms_item-obj_name.

      CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
        EXPORTING
          complete_area = lv_area
        IMPORTING
          namespace     = lv_namespace
          group         = lv_group
        EXCEPTIONS
          OTHERS        = 12.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from FUNCTION_INCLUDE_SPLIT&apos; ).
      ENDIF.

      CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
        EXPORTING
          funcname           = &lt;ls_func&gt;-funcname
        IMPORTING
          include            = lv_include
        EXCEPTIONS
          function_not_exist = 1.
      IF sy-subrc = 0.
* delete the function module to make sure the parameters are updated
* havent found a nice way to update the paramters
        CALL FUNCTION &apos;FUNCTION_DELETE&apos;
          EXPORTING
            funcname                 = &lt;ls_func&gt;-funcname
            suppress_success_message = abap_true
          EXCEPTIONS
            error_message            = 1
            OTHERS                   = 2.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;error from FUNCTION_DELETE&apos; ).
        ENDIF.
      ENDIF.

      CALL FUNCTION &apos;RS_FUNCTIONMODULE_INSERT&apos;
        EXPORTING
          funcname                = &lt;ls_func&gt;-funcname
          function_pool           = lv_group
          interface_global        = &lt;ls_func&gt;-global_flag
          remote_call             = &lt;ls_func&gt;-remote_call
          short_text              = &lt;ls_func&gt;-short_text
          update_task             = &lt;ls_func&gt;-update_task
          exception_class         = &lt;ls_func&gt;-exception_classes
          namespace               = lv_namespace
          remote_basxml_supported = &lt;ls_func&gt;-remote_basxml
        IMPORTING
          function_include        = lv_include
        TABLES
          import_parameter        = &lt;ls_func&gt;-import
          export_parameter        = &lt;ls_func&gt;-export
          tables_parameter        = &lt;ls_func&gt;-tables
          changing_parameter      = &lt;ls_func&gt;-changing
          exception_list          = &lt;ls_func&gt;-exception
          parameter_docu          = &lt;ls_func&gt;-documentation
        EXCEPTIONS
          double_task             = 1
          error_message           = 2
          function_already_exists = 3
          invalid_function_pool   = 4
          invalid_name            = 5
          too_many_functions      = 6
          no_modify_permission    = 7
          no_show_permission      = 8
          enqueue_system_failure  = 9
          canceled_in_corr        = 10
          OTHERS                  = 11.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |error from RS_FUNCTIONMODULE_INSERT: {
          sy-subrc } { sy-msgid }{ sy-msgno }| ).
      ENDIF.

      INSERT REPORT lv_include FROM lt_source.
    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_includes.

    DATA: lo_xml       TYPE REF TO zcl_abapgit_xml_input,
          ls_progdir   TYPE ty_progdir,
          lt_includes  TYPE ty_sobj_name_tt,
          lt_tpool     TYPE textpool_table,
          lt_tpool_ext TYPE zif_abapgit_definitions=&gt;ty_tpool_tt,
          lt_source    TYPE TABLE OF abaptxt255.

    FIELD-SYMBOLS: &lt;lv_include&gt; LIKE LINE OF lt_includes.
    tadir_insert( iv_package ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;INCLUDES&apos;
                  CHANGING cg_data = lt_includes ).

    LOOP AT lt_includes ASSIGNING &lt;lv_include&gt;.

      lt_source = mo_files-&gt;read_abap( iv_extra = &lt;lv_include&gt; ).

      lo_xml = mo_files-&gt;read_xml( &lt;lv_include&gt; ).

      lo_xml-&gt;read( EXPORTING iv_name = &apos;PROGDIR&apos;
                    CHANGING cg_data = ls_progdir ).

      lo_xml-&gt;read( EXPORTING iv_name = &apos;TPOOL&apos;
                    CHANGING cg_data = lt_tpool_ext ).
      lt_tpool = read_tpool( lt_tpool_ext ).

      deserialize_program( is_progdir = ls_progdir
                           it_source  = lt_source
                           it_tpool   = lt_tpool
                           iv_package = iv_package ).

      deserialize_textpool( iv_program    = &lt;lv_include&gt;
                            it_tpool      = lt_tpool
                            iv_is_include = abap_true ).

    ENDLOOP.

  ENDMETHOD.
  METHOD deserialize_xml.

    DATA: lv_complete     TYPE rs38l-area,
          lv_namespace    TYPE rs38l-namespace,
          lv_areat        TYPE tlibt-areat,
          lv_stext        TYPE tftit-stext,
          lv_group        TYPE rs38l-area,
          lv_abap_version TYPE trdir-uccheck.

    lv_abap_version = get_abap_version( io_xml ).
    lv_complete = ms_item-obj_name.

    CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
      EXPORTING
        complete_area                = lv_complete
      IMPORTING
        namespace                    = lv_namespace
        group                        = lv_group
      EXCEPTIONS
        include_not_exists           = 1
        group_not_exists             = 2
        no_selections                = 3
        no_function_include          = 4
        no_function_pool             = 5
        delimiter_wrong_position     = 6
        no_customer_function_group   = 7
        no_customer_function_include = 8
        reserved_name_customer       = 9
        namespace_too_long           = 10
        area_length_error            = 11
        OTHERS                       = 12.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from FUNCTION_INCLUDE_SPLIT&apos; ).
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;AREAT&apos;
                  CHANGING cg_data = lv_areat ).
    lv_stext = lv_areat.

    CALL FUNCTION &apos;RS_FUNCTION_POOL_INSERT&apos;
      EXPORTING
        function_pool           = lv_group
        short_text              = lv_stext
        namespace               = lv_namespace
        devclass                = iv_package
        unicode_checks          = lv_abap_version
      EXCEPTIONS
        name_already_exists     = 1
        name_not_correct        = 2
        function_already_exists = 3
        invalid_function_pool   = 4
        invalid_name            = 5
        too_many_functions      = 6
        no_modify_permission    = 7
        no_show_permission      = 8
        enqueue_system_failure  = 9
        canceled_in_corr        = 10
        undefined_error         = 11
        OTHERS                  = 12.

    CASE sy-subrc.
      WHEN 0.
        &quot; Everything is ok
      WHEN 1 OR 3.
        &quot; If the function group exists we need to manually update the short text
        update_func_group_short_text( iv_group      = lv_group
                                      iv_short_text = lv_stext ).
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |error from RS_FUNCTION_POOL_INSERT, code: { sy-subrc }| ).
    ENDCASE.

  ENDMETHOD.
  METHOD functions.

    DATA: lv_area TYPE rs38l-area.
    lv_area = ms_item-obj_name.

    CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
      EXPORTING
        function_pool           = lv_area
      TABLES
        functab                 = rt_functab
      EXCEPTIONS
        function_pool_not_found = 1
        OTHERS                  = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RS_FUNCTION_POOL_CONTENTS&apos; ).
    ENDIF.

    SORT rt_functab BY funcname ASCENDING.
    DELETE ADJACENT DUPLICATES FROM rt_functab COMPARING funcname.

  ENDMETHOD.
  METHOD get_abap_version.

    DATA: lt_includes TYPE ty_sobj_name_tt,
          ls_progdir  TYPE ty_progdir,
          lo_xml      TYPE REF TO zcl_abapgit_xml_input.

    FIELD-SYMBOLS: &lt;lv_include&gt; LIKE LINE OF lt_includes.

    io_xml-&gt;read( EXPORTING iv_name = &apos;INCLUDES&apos;
                  CHANGING cg_data = lt_includes ).

    LOOP AT lt_includes ASSIGNING &lt;lv_include&gt;.

      lo_xml = mo_files-&gt;read_xml( &lt;lv_include&gt; ).

      lo_xml-&gt;read( EXPORTING iv_name = &apos;PROGDIR&apos;
                    CHANGING cg_data = ls_progdir ).

      IF ls_progdir-uccheck IS INITIAL.
        CONTINUE.
      ELSEIF rv_abap_version IS INITIAL.
        rv_abap_version = ls_progdir-uccheck.
        CONTINUE.
      ELSEIF rv_abap_version NE ls_progdir-uccheck.
*** All includes need to have the same ABAP language version
        zcx_abapgit_exception=&gt;raise( &apos;different ABAP Language Versions&apos; ).
      ENDIF.
    ENDLOOP.

    IF rv_abap_version IS INITIAL.
      rv_abap_version = &apos;X&apos;.
    ENDIF.

  ENDMETHOD.
  METHOD includes.

    TYPES: BEGIN OF ty_reposrc,
             progname TYPE reposrc-progname,
             cnam     TYPE reposrc-cnam,
           END OF ty_reposrc.

    DATA: lt_reposrc   TYPE STANDARD TABLE OF ty_reposrc WITH DEFAULT KEY,
          ls_reposrc   LIKE LINE OF lt_reposrc,
          lv_program   TYPE program,
          lv_offset_ns TYPE i,
          lv_tabix     LIKE sy-tabix,
          lt_functab   TYPE ty_rs38l_incl_tt.

    FIELD-SYMBOLS: &lt;lv_include&gt; LIKE LINE OF rt_includes,
                   &lt;ls_func&gt;    LIKE LINE OF lt_functab.
    lv_program = main_name( ).
    lt_functab = functions( ).

    CALL FUNCTION &apos;RS_GET_ALL_INCLUDES&apos;
      EXPORTING
        program      = lv_program
*       WITH_RESERVED_INCLUDES =
*       WITH_CLASS_INCLUDES    = &apos; &apos; hmm, todo
      TABLES
        includetab   = rt_includes
      EXCEPTIONS
        not_existent = 1
        no_program   = 2
        OTHERS       = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RS_GET_ALL_INCLUDES&apos; ).
    ENDIF.

    LOOP AT lt_functab ASSIGNING &lt;ls_func&gt;.
      DELETE TABLE rt_includes FROM &lt;ls_func&gt;-include.
    ENDLOOP.

* handle generated maintenance views
    APPEND INITIAL LINE TO rt_includes ASSIGNING &lt;lv_include&gt;.
    IF ms_item-obj_name(1) &lt;&gt; &apos;/&apos;.
      &quot;FGroup name does not contain a namespace
      &lt;lv_include&gt; = |L{ ms_item-obj_name }T00|.
    ELSE.
      &quot;FGroup name contains a namespace
      lv_offset_ns = find( val = ms_item-obj_name+1 sub = &apos;/&apos; ).
      lv_offset_ns = lv_offset_ns + 2.
      &lt;lv_include&gt; = |{ ms_item-obj_name(lv_offset_ns) }L{ ms_item-obj_name+lv_offset_ns }T00|.
    ENDIF.

    IF lines( rt_includes ) &gt; 0.
      SELECT progname cnam FROM reposrc
        INTO TABLE lt_reposrc
        FOR ALL ENTRIES IN rt_includes
        WHERE progname = rt_includes-table_line
        AND r3state = &apos;A&apos;.
      SORT lt_reposrc BY progname ASCENDING.
    ENDIF.

    LOOP AT rt_includes ASSIGNING &lt;lv_include&gt;.
      lv_tabix = sy-tabix.

* skip SAP standard includes and also make sure the include exists
      READ TABLE lt_reposrc INTO ls_reposrc
        WITH KEY progname = &lt;lv_include&gt; BINARY SEARCH.
      IF sy-subrc &lt;&gt; 0 OR ls_reposrc-cnam = &apos;SAP&apos;.
        DELETE rt_includes INDEX lv_tabix.
      ENDIF.

    ENDLOOP.

    APPEND lv_program TO rt_includes.

  ENDMETHOD.
  METHOD is_any_function_module_locked.

    DATA: lt_functions TYPE zcl_abapgit_object_fugr=&gt;ty_rs38l_incl_tt.

    FIELD-SYMBOLS: &lt;ls_function&gt; TYPE rs38l_incl.

    TRY.
        lt_functions = functions( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    LOOP AT lt_functions ASSIGNING &lt;ls_function&gt;.

      IF exists_a_lock_entry_for( iv_lock_object = &apos;ESFUNCTION&apos;
                                  iv_argument    = |{ &lt;ls_function&gt;-funcname }| ) = abap_true.
        rv_any_function_module_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD is_any_include_locked.

    DATA: lt_includes TYPE ty_sobj_name_tt.
    FIELD-SYMBOLS: &lt;lv_include&gt; TYPE sobj_name.

    TRY.
        lt_includes = includes( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    LOOP AT lt_includes ASSIGNING &lt;lv_include&gt;.

      IF exists_a_lock_entry_for( iv_lock_object = &apos;ESRDIRE&apos;
                                  iv_argument    = |{ &lt;lv_include&gt; }| ) = abap_true.
        rv_is_any_include_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD is_function_group_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |FG{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_functions_group_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EEUDB&apos;
                                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD main_name.

    DATA: lv_area      TYPE rs38l-area,
          lv_namespace TYPE rs38l-namespace,
          lv_group     TYPE rs38l-area.
    lv_area = ms_item-obj_name.

    CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
      EXPORTING
        complete_area                = lv_area
      IMPORTING
        namespace                    = lv_namespace
        group                        = lv_group
      EXCEPTIONS
        include_not_exists           = 1
        group_not_exists             = 2
        no_selections                = 3
        no_function_include          = 4
        no_function_pool             = 5
        delimiter_wrong_position     = 6
        no_customer_function_group   = 7
        no_customer_function_include = 8
        reserved_name_customer       = 9
        namespace_too_long           = 10
        area_length_error            = 11
        OTHERS                       = 12.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from FUNCTION_INCLUDE_SPLIT&apos; ).
    ENDIF.

    CONCATENATE lv_namespace &apos;SAPL&apos; lv_group INTO rv_program.

  ENDMETHOD.
  METHOD serialize_functions.

    DATA:
      lt_source     TYPE TABLE OF rssource,
      lt_functab    TYPE ty_rs38l_incl_tt,
      lt_new_source TYPE rsfb_source,
      ls_function   LIKE LINE OF rt_functions.

    FIELD-SYMBOLS: &lt;ls_func&gt; LIKE LINE OF lt_functab.
    lt_functab = functions( ).

    LOOP AT lt_functab ASSIGNING &lt;ls_func&gt;.
* fm RPY_FUNCTIONMODULE_READ does not support source code
* lines longer than 72 characters
      CLEAR ls_function.
      MOVE-CORRESPONDING &lt;ls_func&gt; TO ls_function.

      CLEAR lt_new_source.
      CLEAR lt_source.

      CALL FUNCTION &apos;RPY_FUNCTIONMODULE_READ_NEW&apos;
        EXPORTING
          functionname            = &lt;ls_func&gt;-funcname
        IMPORTING
          global_flag             = ls_function-global_flag
          remote_call             = ls_function-remote_call
          update_task             = ls_function-update_task
          short_text              = ls_function-short_text
          remote_basxml_supported = ls_function-remote_basxml
        TABLES
          import_parameter        = ls_function-import
          changing_parameter      = ls_function-changing
          export_parameter        = ls_function-export
          tables_parameter        = ls_function-tables
          exception_list          = ls_function-exception
          documentation           = ls_function-documentation
          source                  = lt_source
        CHANGING
          new_source              = lt_new_source
        EXCEPTIONS
          error_message           = 1
          function_not_found      = 2
          invalid_name            = 3
          OTHERS                  = 4.
      IF sy-subrc = 2.
        CONTINUE.
      ELSEIF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Error from RPY_FUNCTIONMODULE_READ_NEW&apos; ).
      ENDIF.

      ls_function-exception_classes = are_exceptions_class_based( &lt;ls_func&gt;-funcname ).

      APPEND ls_function TO rt_functions.

      IF NOT lt_new_source IS INITIAL.
        mo_files-&gt;add_abap( iv_extra = &lt;ls_func&gt;-funcname
                            it_abap  = lt_new_source ).
      ELSE.
        mo_files-&gt;add_abap( iv_extra = &lt;ls_func&gt;-funcname
                            it_abap  = lt_source ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_includes.

    DATA: lt_includes TYPE ty_sobj_name_tt.

    FIELD-SYMBOLS: &lt;lv_include&gt; LIKE LINE OF lt_includes.
    lt_includes = includes( ).

    LOOP AT lt_includes ASSIGNING &lt;lv_include&gt;.

* todo, filename is not correct, a include can be used in several programs
      serialize_program( is_item    = ms_item
                         io_files   = mo_files
                         iv_program = &lt;lv_include&gt;
                         iv_extra   = &lt;lv_include&gt; ).

    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_xml.

    DATA: lt_includes TYPE ty_sobj_name_tt,
          lv_areat    TYPE tlibt-areat.
    SELECT SINGLE areat INTO lv_areat
      FROM tlibt
      WHERE spras = mv_language
      AND area = ms_item-obj_name.        &quot;#EC CI_GENBUFF &quot;#EC CI_SUBRC

    lt_includes = includes( ).

    io_xml-&gt;add( iv_name = &apos;AREAT&apos;
                 ig_data = lv_areat ).
    io_xml-&gt;add( iv_name = &apos;INCLUDES&apos;
                 ig_data = lt_includes ).

  ENDMETHOD.
  METHOD update_func_group_short_text.

    &quot; We update the short text directly.
    &quot; SE80 does the same in
    &quot;   Program SAPLSEUF / LSEUFF07
    &quot;   FORM GROUP_CHANGE

    UPDATE tlibt SET areat = iv_short_text
                 WHERE spras = sy-langu
                 AND   area  = iv_group.

  ENDMETHOD.
  METHOD update_where_used.
* make extra sure the where-used list is updated after deletion
* Experienced some problems with the T00 include
* this method just tries to update everything

    DATA: lv_include LIKE LINE OF it_includes,
          lo_cross   TYPE REF TO cl_wb_crossreference.
    LOOP AT it_includes INTO lv_include.

      CREATE OBJECT lo_cross
        EXPORTING
          p_name    = lv_include
          p_include = lv_include.

      lo_cross-&gt;index_actualize( ).

    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_stamps,
             user TYPE xubname,
             date TYPE d,
             time TYPE t,
           END OF ty_stamps.

    DATA: lt_stamps   TYPE STANDARD TABLE OF ty_stamps WITH DEFAULT KEY,
          lv_program  TYPE program,
          lt_includes TYPE ty_sobj_name_tt.

    FIELD-SYMBOLS: &lt;ls_stamp&gt;   LIKE LINE OF lt_stamps,
                   &lt;lv_include&gt; LIKE LINE OF lt_includes.
    lv_program = main_name( ).

    CALL FUNCTION &apos;RS_GET_ALL_INCLUDES&apos;
      EXPORTING
        program      = lv_program
      TABLES
        includetab   = lt_includes
      EXCEPTIONS
        not_existent = 1
        no_program   = 2
        OTHERS       = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from RS_GET_ALL_INCLUDES&apos; ).
    ENDIF.

    SELECT unam AS user udat AS date utime AS time FROM reposrc
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE progname = lv_program
      AND   r3state = &apos;A&apos;.                                &quot;#EC CI_SUBRC

    LOOP AT lt_includes ASSIGNING &lt;lv_include&gt;.
      SELECT unam AS user udat AS date utime AS time FROM reposrc
        APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
        WHERE progname = &lt;lv_include&gt;
        AND   r3state = &apos;A&apos;.                              &quot;#EC CI_SUBRC
    ENDLOOP.

    SELECT unam AS user udat AS date utime AS time FROM repotext &quot; Program text pool
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE progname = lv_program
      AND   r3state = &apos;A&apos;.                                &quot;#EC CI_SUBRC

    SELECT vautor AS user vdatum AS date vzeit AS time FROM eudb         &quot; GUI
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE relid = &apos;CU&apos;
      AND   name  = lv_program
      AND   srtf2 = 0 ##TOO_MANY_ITAB_FIELDS.

* Screens: username not stored in D020S database table

    SORT lt_stamps BY date DESCENDING time DESCENDING.

    READ TABLE lt_stamps INDEX 1 ASSIGNING &lt;ls_stamp&gt;.
    IF sy-subrc = 0.
      rv_user = &lt;ls_stamp&gt;-user.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_area     TYPE rs38l-area,
          lt_includes TYPE ty_sobj_name_tt.
    lt_includes = includes( ).

    lv_area = ms_item-obj_name.

    CALL FUNCTION &apos;RS_FUNCTION_POOL_DELETE&apos;
      EXPORTING
        area                   = lv_area
        suppress_popups        = abap_true
        skip_progress_ind      = abap_true
      EXCEPTIONS
        canceled_in_corr       = 1
        enqueue_system_failure = 2
        function_exist         = 3
        not_executed           = 4
        no_modify_permission   = 5
        no_show_permission     = 6
        permission_failure     = 7
        pool_not_exist         = 8
        cancelled              = 9
        OTHERS                 = 10.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_FUNCTION_POOL_DELETE&apos; ).
    ENDIF.

    update_where_used( lt_includes ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_program_name TYPE programm,
          lt_functions    TYPE ty_function_tt,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua.
    deserialize_xml(
      io_xml     = io_xml
      iv_package = iv_package ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;FUNCTIONS&apos;
                  CHANGING cg_data = lt_functions ).
    deserialize_functions( lt_functions ).

    deserialize_includes(
      io_xml     = io_xml
      iv_package = iv_package ).

    lv_program_name = main_name( ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DYNPROS&apos;
                  CHANGING cg_data = lt_dynpros ).
    deserialize_dynpros( lt_dynpros ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;CUA&apos;
                  CHANGING cg_data = ls_cua ).
    deserialize_cua( iv_program_name = lv_program_name
                     is_cua = ls_cua ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_pool  TYPE tlibg-area.
    lv_pool = ms_item-obj_name.
    CALL FUNCTION &apos;RS_FUNCTION_POOL_EXISTS&apos;
      EXPORTING
        function_pool   = lv_pool
      EXCEPTIONS
        pool_not_exists = 1.
    rv_bool = boolc( sy-subrc &lt;&gt; 1 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lt_functab  TYPE ty_rs38l_incl_tt,
          lt_includes TYPE ty_sobj_name_tt.

    FIELD-SYMBOLS: &lt;ls_func&gt;         LIKE LINE OF lt_functab,
                   &lt;lv_include_name&gt; LIKE LINE OF lt_includes.
    lt_includes = includes( ). &quot; Main prog also included here

    LOOP AT lt_includes ASSIGNING &lt;lv_include_name&gt;.
      rv_changed = check_prog_changed_since(
        iv_program   = &lt;lv_include_name&gt;
        iv_timestamp = iv_timestamp ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

    lt_functab = functions( ).

    LOOP AT lt_functab ASSIGNING &lt;ls_func&gt;.
      rv_changed = check_prog_changed_since(
        iv_program   = &lt;ls_func&gt;-include
        iv_timestamp = iv_timestamp ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_program TYPE program.

    lv_program = main_name( ).

    IF is_function_group_locked( )        = abap_true
    OR is_any_include_locked( )           = abap_true
    OR is_any_function_module_locked( )   = abap_true
    OR is_any_dynpro_locked( lv_program ) = abap_true
    OR is_cua_locked( lv_program )        = abap_true
    OR is_text_locked( lv_program )       = abap_true.

      rv_is_locked = abap_true.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;FUGR&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

* function group SEUF
* function group SIFP
* function group SUNI

    DATA: lt_functions    TYPE ty_function_tt,
          ls_progdir      TYPE ty_progdir,
          lv_program_name TYPE programm,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    serialize_xml( io_xml ).

    lt_functions = serialize_functions( ).
    io_xml-&gt;add( iv_name = &apos;FUNCTIONS&apos;
                 ig_data = lt_functions ).

    serialize_includes( ).

    lv_program_name = main_name( ).
    ls_progdir = read_progdir( lv_program_name ).

    IF ls_progdir-subc = &apos;F&apos;.
      lt_dynpros = serialize_dynpros( lv_program_name ).
      io_xml-&gt;add( iv_name = &apos;DYNPROS&apos;
                   ig_data = lt_dynpros ).

      ls_cua = serialize_cua( lv_program_name ).
      io_xml-&gt;add( iv_name = &apos;CUA&apos;
                   ig_data = ls_cua ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_form IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_form_name = ms_item-obj_name.

  ENDMETHOD.
  METHOD build_extra_from_header.

    DATA: lv_tdspras TYPE laiso.

    CALL FUNCTION &apos;CONVERSION_EXIT_ISOLA_OUTPUT&apos;
      EXPORTING
        input  = is_header-tdspras
      IMPORTING
        output = lv_tdspras.

    rv_result = c_objectname_tdlines &amp;&amp; &apos;_&apos; &amp;&amp; lv_tdspras.

  ENDMETHOD.
  METHOD build_extra_from_header_old.
    rv_result = c_objectname_tdlines &amp;&amp; &apos;_&apos; &amp;&amp; is_header-tdspras.
  ENDMETHOD.
  METHOD compress_lines.

    DATA lv_string TYPE string.
    DATA lo_xml TYPE REF TO zcl_abapgit_xml_output.

    CREATE OBJECT lo_xml.
    lo_xml-&gt;add( iv_name = c_objectname_tdlines
                 ig_data = it_lines ).
    lv_string = lo_xml-&gt;render( ).
    IF lv_string IS NOT INITIAL.
      mo_files-&gt;add_string( iv_extra  =
                    build_extra_from_header( is_form_data-form_header )
                            iv_ext    = c_extension_xml
                            iv_string = lv_string ).
    ENDIF.

  ENDMETHOD.
  METHOD extract_tdlines.

    DATA lv_string TYPE string.
    DATA lo_xml TYPE REF TO zcl_abapgit_xml_input.

    TRY.
        lv_string = mo_files-&gt;read_string( iv_extra =
                                   build_extra_from_header( is_form_data-form_header )
                                           iv_ext   = c_extension_xml ).
      CATCH zcx_abapgit_exception.

        lv_string = mo_files-&gt;read_string( iv_extra =
                               build_extra_from_header_old( is_form_data-form_header )
                                           iv_ext   = c_extension_xml ).

    ENDTRY.

    CREATE OBJECT lo_xml EXPORTING iv_xml = lv_string.
    lo_xml-&gt;read( EXPORTING iv_name = c_objectname_tdlines
                  CHANGING  cg_data = rt_lines ).

  ENDMETHOD.
  METHOD find_form.

    DATA: lv_text_name TYPE thead-tdname.

    lv_text_name = iv_object_name.

    CALL FUNCTION &apos;SELECT_TEXT&apos;
      EXPORTING
        database_only = abap_true
        id            = &apos;TXT&apos;
        language      = &apos;*&apos;
        name          = lv_text_name
        object        = c_objectname_form
      TABLES
        selections    = rt_text_header
      EXCEPTIONS
        OTHERS        = 1 ##fm_subrc_ok ##NO_TEXT.  &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD get_last_changes.

    DATA: lv_form_name         TYPE thead-tdform.

    CLEAR rs_last_changed.

    lv_form_name = iv_form_name.

    CALL FUNCTION &apos;READ_FORM&apos;
      EXPORTING
        form             = lv_form_name
        read_only_header = abap_true
      IMPORTING
        form_header      = rs_last_changed.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: ls_last_changed TYPE tys_form_header.

    ls_last_changed = get_last_changes( ms_item-obj_name ).

    IF ls_last_changed-tdluser IS NOT INITIAL.
      rv_user = ls_last_changed-tdluser.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CALL FUNCTION &apos;DELETE_FORM&apos;
      EXPORTING
        form     = mv_form_name
        language = &apos;*&apos;.

    order_check_and_insert( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lt_form_data            TYPE tyt_form_data.
    DATA: lt_lines TYPE tyt_lines.
    FIELD-SYMBOLS: &lt;ls_form_data&gt; TYPE LINE OF tyt_form_data.

    io_xml-&gt;read( EXPORTING iv_name = c_objectname_form
                  CHANGING  cg_data = lt_form_data ).

    LOOP AT lt_form_data ASSIGNING &lt;ls_form_data&gt;.

      lt_lines = extract_tdlines( &lt;ls_form_data&gt; ).

      _save_form( EXPORTING it_lines     = lt_lines
                  CHANGING  cs_form_data = &lt;ls_form_data&gt; ).

    ENDLOOP.

    CALL FUNCTION &apos;SAPSCRIPT_DELETE_LOAD&apos;
      EXPORTING
        delete = abap_true
        form   = &apos;*&apos;
        write  = space.

    tadir_insert( iv_package ).

    order_check_and_insert( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;READ_FORM&apos;
      EXPORTING
        form             = mv_form_name
        read_only_header = abap_true
      IMPORTING
        found            = rv_bool.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: ls_last_changed    TYPE tys_form_header.
    DATA: lv_last_changed_ts TYPE timestamp.

    ls_last_changed = get_last_changes( ms_item-obj_name ).

    CONVERT DATE ls_last_changed-tdldate TIME ls_last_changed-tdltime
            INTO TIME STAMP lv_last_changed_ts TIME ZONE sy-zonlo.

    rv_changed = boolc( sy-subrc &lt;&gt; 0 OR lv_last_changed_ts &gt; iv_timestamp ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    &quot; example lock entry
    &quot;&apos;001FORM      ZTEST_SAPSCRIPT                                                       TXT&apos;
    lv_object = |{ sy-mandt }{ ms_item-obj_type }      { ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                                                                   &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESSFORM&apos;
                                            iv_argument    = lv_object ).
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: &lt;ls_bdcdata&gt; LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-program  = &apos;SAPMSSCF&apos; ##NO_TEXT.
    &lt;ls_bdcdata&gt;-dynpro   = &apos;1102&apos; ##NO_TEXT.
    &lt;ls_bdcdata&gt;-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;BDC_OKCODE&apos; ##NO_TEXT.
    &lt;ls_bdcdata&gt;-fval = &apos;=SHOW&apos; ##NO_TEXT.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING &lt;ls_bdcdata&gt;.
    &lt;ls_bdcdata&gt;-fnam = &apos;RSSCF-TDFORM&apos; ##NO_TEXT.
    &lt;ls_bdcdata&gt;-fval = ms_item-obj_name.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SE71&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bdcdata
      EXCEPTIONS
        OTHERS    = 1
        ##fm_subrc_ok.                                                   &quot;#EC CI_SUBRC

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lt_form_data              TYPE tyt_form_data.
    DATA: ls_form_data              TYPE tys_form_data.
    DATA: lt_text_header            TYPE tyt_text_header.
    DATA: lt_lines                  TYPE tyt_lines.
*    DATA: lo_xml                    TYPE REF TO zcl_abapgit_xml_output.
    DATA: lv_form_found             TYPE flag.
    FIELD-SYMBOLS: &lt;ls_text_header&gt; LIKE LINE OF lt_text_header.

    lt_text_header = find_form( ms_item-obj_name ).

    LOOP AT lt_text_header ASSIGNING &lt;ls_text_header&gt;.
      CLEAR lt_lines.
      CLEAR ls_form_data.
*      FREE lo_xml.

      _read_form( EXPORTING is_text_header = &lt;ls_text_header&gt;
                  IMPORTING ev_form_found = lv_form_found
                            es_form_data  = ls_form_data
                            et_lines      = lt_lines ).

      IF lv_form_found = abap_true.

        _clear_changed_fields( CHANGING cs_form_data = ls_form_data ).

        compress_lines( is_form_data = ls_form_data
                         it_lines     = lt_lines ).

        INSERT ls_form_data INTO TABLE lt_form_data.

      ENDIF.

    ENDLOOP.

    IF lt_form_data IS NOT INITIAL.

      io_xml-&gt;add( iv_name = c_objectname_form
                   ig_data = lt_form_data ).

    ENDIF.

  ENDMETHOD.
  METHOD _clear_changed_fields.

    CLEAR: cs_form_data-form_header-tdfuser,
           cs_form_data-form_header-tdfdate,
           cs_form_data-form_header-tdftime,
           cs_form_data-form_header-tdfreles,
           cs_form_data-form_header-tdluser,
           cs_form_data-form_header-tdldate,
           cs_form_data-form_header-tdltime,
           cs_form_data-form_header-tdlreles.
    CLEAR: cs_form_data-text_header-tdfuser,
           cs_form_data-text_header-tdfdate,
           cs_form_data-text_header-tdftime,
           cs_form_data-text_header-tdfreles,
           cs_form_data-text_header-tdluser,
           cs_form_data-text_header-tdldate,
           cs_form_data-text_header-tdltime,
           cs_form_data-text_header-tdlreles.

  ENDMETHOD.
  METHOD _read_form.

    CLEAR es_form_data.

    CALL FUNCTION &apos;READ_FORM&apos;
      EXPORTING
        form         = is_text_header-tdform
        language     = is_text_header-tdspras
        status       = &apos; &apos;
      IMPORTING
        form_header  = es_form_data-form_header
        found        = ev_form_found
        header       = es_form_data-text_header
        olanguage    = es_form_data-orig_language
      TABLES
        form_lines   = et_lines
        pages        = es_form_data-pages
        page_windows = es_form_data-page_windows
        paragraphs   = es_form_data-paragraphs
        strings      = es_form_data-strings
        tabs         = es_form_data-tabs
        windows      = es_form_data-windows.

  ENDMETHOD.
  METHOD _save_form.

    CALL FUNCTION &apos;SAVE_FORM&apos;
      EXPORTING
        form_header  = cs_form_data-form_header
      TABLES
        form_lines   = it_lines
        pages        = cs_form_data-pages
        page_windows = cs_form_data-page_windows
        paragraphs   = cs_form_data-paragraphs
        strings      = cs_form_data-strings
        tabs         = cs_form_data-tabs
        windows      = cs_form_data-windows.

    CALL FUNCTION &apos;SAPSCRIPT_CHANGE_OLANGUAGE&apos;
      EXPORTING
        forced    = abap_true
        name      = cs_form_data-text_header-tdname
        object    = cs_form_data-text_header-tdobject
        olanguage = cs_form_data-orig_language
      EXCEPTIONS
        OTHERS    = 1
        ##fm_subrc_ok.                                                   &quot;#EC CI_SUBRC

  ENDMETHOD.

  METHOD order_check_and_insert.

    DATA: ls_order TYPE e071k-trkorr.

    CALL FUNCTION &apos;SAPSCRIPT_ORDER_CHECK&apos;
      EXPORTING
        objecttype           = ms_item-obj_type
        form                 = mv_form_name
      EXCEPTIONS
        invalid_input        = 1
        object_locked        = 2
        object_not_available = 3
        OTHERS               = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    CALL FUNCTION &apos;SAPSCRIPT_ORDER_INSERT&apos;
      EXPORTING
        objecttype     = ms_item-obj_type
        form           = mv_form_name
        masterlang     = mv_language
      CHANGING
        order          = ls_order
      EXCEPTIONS
        invalid_input  = 1
        order_canceled = 2
        OTHERS         = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_ENSC IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. &quot; todo
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    DATA: lv_spot_name TYPE enhspotcompositename,
          lv_message   TYPE string,
          lx_root      TYPE REF TO cx_root,
          li_spot_ref  TYPE REF TO if_enh_spot_composite.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=&gt;get_enhancement_spot_comp(
          lock = &apos;X&apos;
          name = lv_spot_name ).

        IF li_spot_ref IS BOUND.
          li_spot_ref-&gt;if_enh_object~delete(
            nevertheless_delete = &apos;X&apos;
            run_dark            = &apos;X&apos; ).
        ENDIF.
        li_spot_ref-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_root.
        lv_message = `Error occured while deleting ENSC: `
          &amp;&amp; lx_root-&gt;get_text( ) ##NO_TEXT.
        zcx_abapgit_exception=&gt;raise( lv_message ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_spot_name  TYPE enhspotcompositename,
          lv_message    TYPE string,
          lv_enh_shtext TYPE string,
          lv_enh_spot   TYPE enhspotname,
          lt_enh_spots  TYPE enhspotname_it,
          lt_comp_spots TYPE enhspotname_it,
          lx_root       TYPE REF TO cx_root,
          lv_package    LIKE iv_package,
          li_spot_ref   TYPE REF TO if_enh_spot_composite,
          lo_spot_ref   TYPE REF TO cl_enh_spot_composite.
    lv_spot_name = ms_item-obj_name.

    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING  cg_data = lv_enh_shtext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ENH_SPOTS&apos;     &quot;Enhancement spots
                  CHANGING  cg_data = lt_enh_spots ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;COMP_ENH_SPOTS&apos; &quot;Composite enhancement spots
                  CHANGING  cg_data = lt_comp_spots ).

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    lv_package = iv_package.

    TRY.
        cl_enh_factory=&gt;create_enhancement_spot_comp(
          EXPORTING
            name      = lv_spot_name
            run_dark  = abap_true
          IMPORTING
            composite = li_spot_ref
          CHANGING
            devclass  = lv_package ).

        lo_spot_ref ?= li_spot_ref.

        lo_spot_ref-&gt;if_enh_object_docu~set_shorttext( lv_enh_shtext ).
        &quot;Add subsequent enhancement spots
        LOOP AT lt_enh_spots INTO lv_enh_spot.
          lo_spot_ref-&gt;if_enh_spot_composite~add_enh_spot_child( lv_enh_spot ).
        ENDLOOP.
        &quot;Add subsequent composite enhancement spots
        LOOP AT lt_comp_spots INTO lv_enh_spot.
          lo_spot_ref-&gt;if_enh_spot_composite~add_composite_child( lv_enh_spot ).
        ENDLOOP.

        lo_spot_ref-&gt;if_enh_object~save( ).
        lo_spot_ref-&gt;if_enh_object~activate( ).
        lo_spot_ref-&gt;if_enh_object~unlock( ).

      CATCH cx_enh_root INTO lx_root.
        lv_message = `Error occured while deserializing ENSC: `
          &amp;&amp; lx_root-&gt;get_text( ) ##NO_TEXT.
        zcx_abapgit_exception=&gt;raise( lv_message ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_spot_name TYPE enhspotcompositename.
    lv_spot_name = ms_item-obj_name.

    TRY.
        cl_enh_factory=&gt;get_enhancement_spot_comp(
          lock = &apos;&apos;
          name = lv_spot_name ).
        rv_bool = abap_true.
      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;ENSC&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_spot_name  TYPE enhspotcompositename,
          lv_message    TYPE string,
          lv_enh_shtext TYPE string,
          lt_enh_spots  TYPE enhspotname_it,
          lt_comp_spots TYPE enhspotname_it,
          lx_root       TYPE REF TO cx_root,
          li_spot_ref   TYPE REF TO if_enh_spot_composite,
          lo_spot_ref   TYPE REF TO cl_enh_spot_composite.
    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=&gt;get_enhancement_spot_comp(
          lock = &apos;&apos;
          name = lv_spot_name ).

        lo_spot_ref ?= li_spot_ref.

        lv_enh_shtext = li_spot_ref-&gt;if_enh_object_docu~get_shorttext( ).
        &quot;find parent = composite enhancement (ENSC)
*        lv_parent = cl_r3standard_persistence=&gt;enh_find_parent_composite( lv_spot_name ).
        &quot;find subsequent enhancement spots
        lt_enh_spots = lo_spot_ref-&gt;if_enh_spot_composite~get_enh_spot_childs( ).
        &quot;find subsequent composite enhancement spots
        lt_comp_spots = lo_spot_ref-&gt;if_enh_spot_composite~get_composite_childs( ).

        io_xml-&gt;add( ig_data = lv_enh_shtext
                     iv_name = &apos;SHORTTEXT&apos; ).
        io_xml-&gt;add( ig_data = lt_enh_spots
                     iv_name = &apos;ENH_SPOTS&apos; ).         &quot;Enhancement spots
        io_xml-&gt;add( ig_data = lt_comp_spots
                     iv_name = &apos;COMP_ENH_SPOTS&apos; ).    &quot;Composite enhancement spots

      CATCH cx_enh_root INTO lx_root.
        lv_message = `Error occured while serializing ENSC: `
          &amp;&amp; lx_root-&gt;get_text( ) ##NO_TEXT.
        zcx_abapgit_exception=&gt;raise( lv_message ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_enqu IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd25l
      INTO rv_user
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;L&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, ENQU&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd25v TYPE dd25v,
          lt_dd26e TYPE TABLE OF dd26e,
          lt_dd27p TYPE tyt_dd27p.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD25V&apos;
                  CHANGING cg_data = ls_dd25v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD26E_TABLE&apos;
                  CHANGING cg_data = lt_dd26e ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD27P_TABLE&apos;
                  CHANGING cg_data = lt_dd27p ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_ENQU_PUT&apos;
      EXPORTING
        name              = lv_name
        dd25v_wa          = ls_dd25v
      TABLES
        dd26e_tab         = lt_dd26e
        dd27p_tab         = lt_dd27p
      EXCEPTIONS
        enqu_not_found    = 1
        name_inconsistent = 2
        enqu_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_ENQU_PUT&apos; ).
    ENDIF.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_viewname TYPE dd25l-viewname.
    SELECT SINGLE viewname FROM dd25l INTO lv_viewname
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd25l
      INTO (lv_date, lv_time)
      WHERE viewname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-ENQU&apos;
               iv_field = &apos;RSRD1-ENQU_VAL&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd25v TYPE dd25v,
          lt_dd26e TYPE TABLE OF dd26e,
          lt_dd27p TYPE tyt_dd27p.

    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
      EXPORTING
        name          = lv_name
        state         = &apos;A&apos;
        langu         = mv_language
      IMPORTING
        dd25v_wa      = ls_dd25v
      TABLES
        dd26e_tab     = lt_dd26e
        dd27p_tab     = lt_dd27p
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_ENQU_GET&apos; ).
    ENDIF.
    IF ls_dd25v IS INITIAL.
      RETURN. &quot; does not exist in system
    ENDIF.

    CLEAR: ls_dd25v-as4user,
           ls_dd25v-as4date,
           ls_dd25v-as4time.

    _clear_dd27p_fields( CHANGING ct_dd27p = lt_dd27p ).

    io_xml-&gt;add( iv_name = &apos;DD25V&apos;
                 ig_data = ls_dd25v ).
    io_xml-&gt;add( ig_data = lt_dd26e
                 iv_name = &apos;DD26E_TABLE&apos; ).
    io_xml-&gt;add( ig_data = lt_dd27p
                 iv_name = &apos;DD27P_TABLE&apos; ).

  ENDMETHOD.
  METHOD _clear_dd27p_fields.

    FIELD-SYMBOLS &lt;ls_dd27p&gt; TYPE dd27p.

    LOOP AT ct_dd27p ASSIGNING &lt;ls_dd27p&gt;.
      &quot;taken from table
      CLEAR &lt;ls_dd27p&gt;-headlen.
      CLEAR &lt;ls_dd27p&gt;-scrlen1.
      CLEAR &lt;ls_dd27p&gt;-scrlen2.
      CLEAR &lt;ls_dd27p&gt;-scrlen3.
      CLEAR &lt;ls_dd27p&gt;-intlen.
      CLEAR &lt;ls_dd27p&gt;-outputlen.
      CLEAR &lt;ls_dd27p&gt;-flength.
      CLEAR &lt;ls_dd27p&gt;-ddtext.
      CLEAR &lt;ls_dd27p&gt;-reptext.
      CLEAR &lt;ls_dd27p&gt;-scrtext_s.
      CLEAR &lt;ls_dd27p&gt;-scrtext_m.
      CLEAR &lt;ls_dd27p&gt;-scrtext_l.
      CLEAR &lt;ls_dd27p&gt;-rollname.
      CLEAR &lt;ls_dd27p&gt;-rollnamevi.
      CLEAR &lt;ls_dd27p&gt;-entitytab.
      CLEAR &lt;ls_dd27p&gt;-datatype.
      CLEAR &lt;ls_dd27p&gt;-inttype.
      CLEAR &lt;ls_dd27p&gt;-ddlanguage.
      CLEAR &lt;ls_dd27p&gt;-domname.
      CLEAR &lt;ls_dd27p&gt;-signflag.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_enhs_hook_d IMPLEMENTATION.

  METHOD zif_abapgit_object_enhs~deserialize.

    DATA: lv_enh_shorttext       TYPE string,
          ls_enh_hook_definition TYPE enh_hook_def,
          ls_hook_definition     TYPE ty_hook_defifnition,
          li_enh_object          TYPE REF TO if_enh_object,
          li_enh_object_docu     TYPE REF TO if_enh_object_docu,
          lo_hookdef_tool        TYPE REF TO cl_enh_tool_hook_def,
          lx_error               TYPE REF TO cx_enh_root,
          lv_text                TYPE string.

    FIELD-SYMBOLS: &lt;ls_hook_definition&gt; TYPE enh_hook_def_ext.

    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING  cg_data = lv_enh_shorttext ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;BADI_DATA&apos;
                  CHANGING  cg_data = ls_hook_definition ).

    li_enh_object ?= ii_enh_spot_tool.
    li_enh_object_docu ?= ii_enh_spot_tool.

    TRY.
        li_enh_object_docu-&gt;set_shorttext( lv_enh_shorttext ).

        lo_hookdef_tool ?= ii_enh_spot_tool.

        lo_hookdef_tool-&gt;set_original_object( pgmid     = ls_hook_definition-pgmid
                                              obj_name  = ls_hook_definition-obj_name
                                              obj_type  = ls_hook_definition-obj_type
                                              program   = ls_hook_definition-program
                                              main_type = ls_hook_definition-main_type
                                              main_name = ls_hook_definition-main_name ).

        LOOP AT ls_hook_definition-def_hooks ASSIGNING &lt;ls_hook_definition&gt;.
          MOVE-CORRESPONDING &lt;ls_hook_definition&gt; TO ls_enh_hook_definition.
          lo_hookdef_tool-&gt;add_hook_def( ls_enh_hook_definition ).
        ENDLOOP.

        li_enh_object-&gt;save( ).
        li_enh_object-&gt;activate( ).
        li_enh_object-&gt;unlock( ).

      CATCH cx_enh_root INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enhs~serialize.

    DATA: lo_hookdef_tool    TYPE REF TO cl_enh_tool_hook_def,
          lv_enh_shorttext   TYPE string,
          li_enh_object_docu TYPE REF TO if_enh_object_docu,
          ls_hook_definition TYPE ty_hook_defifnition.

    lo_hookdef_tool ?= ii_enh_spot_tool.

    li_enh_object_docu ?= ii_enh_spot_tool.
    lv_enh_shorttext = li_enh_object_docu-&gt;get_shorttext( ).

    ls_hook_definition-def_hooks = lo_hookdef_tool-&gt;get_hook_defs( ).

    lo_hookdef_tool-&gt;get_original_object(
      IMPORTING
        pgmid     = ls_hook_definition-pgmid
        obj_name  = ls_hook_definition-obj_name
        obj_type  = ls_hook_definition-obj_type
        main_type = ls_hook_definition-main_type
        main_name = ls_hook_definition-main_name
        program   = ls_hook_definition-program       ).

    io_xml-&gt;add( ig_data = ii_enh_spot_tool-&gt;get_tool( )
                 iv_name = &apos;TOOL&apos; ).

    io_xml-&gt;add( ig_data = lv_enh_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).

    io_xml-&gt;add( ig_data = ls_hook_definition
                 iv_name = &apos;BADI_DATA&apos; ).

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enhs_badi_d IMPLEMENTATION.

  METHOD zif_abapgit_object_enhs~deserialize.

    DATA: lv_parent          TYPE enhspotcompositename,
          lt_enh_badi        TYPE enh_badi_data_it,
          lo_badidef_tool    TYPE REF TO cl_enh_tool_badi_def,
          lv_enh_shorttext   TYPE string,
*          lv_package         LIKE iv_package,
          li_enh_object      TYPE REF TO if_enh_object,
          li_enh_object_docu TYPE REF TO if_enh_object_docu,
          lv_text            TYPE string,
          lx_error           TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: &lt;ls_enh_badi&gt; LIKE LINE OF lt_enh_badi.

    io_xml-&gt;read( EXPORTING iv_name = &apos;PARENT_COMP&apos;
                  CHANGING  cg_data = lv_parent ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;BADI_DATA&apos;
                  CHANGING  cg_data = lt_enh_badi ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING  cg_data = lv_enh_shorttext ).

*    lv_package = iv_package.

    li_enh_object ?= ii_enh_spot_tool.
    li_enh_object_docu ?= ii_enh_spot_tool.

    TRY.
        li_enh_object_docu-&gt;set_shorttext( lv_enh_shorttext ).

        lo_badidef_tool ?= ii_enh_spot_tool.

        LOOP AT lt_enh_badi ASSIGNING &lt;ls_enh_badi&gt;.
          lo_badidef_tool-&gt;add_badi_def( &lt;ls_enh_badi&gt; ).
        ENDLOOP.

        li_enh_object-&gt;save( ).
        li_enh_object-&gt;activate( ).
        li_enh_object-&gt;unlock( ).

      CATCH cx_enh_root INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enhs~serialize.

    DATA: lv_spot_name       TYPE enhspotname,
          lv_parent          TYPE enhspotcompositename,
          lt_enh_badi        TYPE enh_badi_data_it,
          lo_badidef_tool    TYPE REF TO cl_enh_tool_badi_def,
          lv_enh_shorttext   TYPE string,
          li_enh_object_docu TYPE REF TO if_enh_object_docu.

    lo_badidef_tool ?= ii_enh_spot_tool.

    li_enh_object_docu ?= ii_enh_spot_tool.
    lv_enh_shorttext = li_enh_object_docu-&gt;get_shorttext( ).

    &quot;get parent = composite enhs (ENHC)
    lv_parent = cl_r3standard_persistence=&gt;enh_find_parent_composite( lv_spot_name ).
    &quot;get subsequent BADI definitions
    lt_enh_badi = lo_badidef_tool-&gt;get_badi_defs( ).

    io_xml-&gt;add( ig_data = ii_enh_spot_tool-&gt;get_tool( )
                 iv_name = &apos;TOOL&apos; ).

    io_xml-&gt;add( ig_data = lv_enh_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).

    io_xml-&gt;add( ig_data = lv_parent
                 iv_name = &apos;PARENT_COMP&apos; ).

    io_xml-&gt;add( ig_data = lt_enh_badi
                 iv_name = &apos;BADI_DATA&apos; ).

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_ENHS IMPLEMENTATION.
  METHOD factory.

    CASE iv_tool.
      WHEN cl_enh_tool_badi_def=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enhs_badi_d.
      WHEN cl_enh_tool_hook_def=&gt;tool_type.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enhs_hook_d.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |ENHS: Unsupported tool { iv_tool }| ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=&gt;get_enhancement_spot( lv_spot_name ).
        li_spot_ref-&gt;get_attributes( IMPORTING changedby = rv_user ).

      CATCH cx_enh_root.
        rv_user = c_user_unknown.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_spot_name  TYPE enhspotname,
          li_enh_object TYPE REF TO if_enh_object.

    lv_spot_name  = ms_item-obj_name.

    TRY.
        li_enh_object ?= cl_enh_factory=&gt;get_enhancement_spot( spot_name = lv_spot_name
                                                               lock      = abap_true ).

        li_enh_object-&gt;delete( nevertheless_delete = abap_true
                               run_dark            = abap_true ).

        li_enh_object-&gt;unlock( ).

      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_ENH_FACTORY&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_parent    TYPE enhspotcompositename,
          lv_spot_name TYPE enhspotname,
          lv_tool      TYPE enhspottooltype,
          lv_package   LIKE iv_package,
          li_spot_ref  TYPE REF TO if_enh_spot_tool,
          li_enhs      TYPE REF TO zif_abapgit_object_enhs.

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TOOL&apos;
                  CHANGING  cg_data = lv_tool ).

    lv_spot_name = ms_item-obj_name.
    lv_package   = iv_package.

    TRY.
        cl_enh_factory=&gt;create_enhancement_spot(
          EXPORTING
            spot_name      = lv_spot_name
            tooltype       = lv_tool
            dark           = abap_false
            compositename  = lv_parent
          IMPORTING
            spot           = li_spot_ref
          CHANGING
            devclass       = lv_package ).

      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_ENH_FACTORY&apos; ).
    ENDTRY.

    li_enhs = factory( lv_tool ).

    li_enhs-&gt;deserialize( io_xml           = io_xml
                          iv_package       = iv_package
                          ii_enh_spot_tool = li_spot_ref ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=&gt;get_enhancement_spot( lv_spot_name ).

        rv_bool = abap_true.

      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;ENHS&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool,
          li_enhs      TYPE REF TO zif_abapgit_object_enhs,
          lx_root      TYPE REF TO cx_root.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=&gt;get_enhancement_spot( lv_spot_name ).

      CATCH cx_enh_root INTO lx_root.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_ENH_FACTORY&apos; ).
    ENDTRY.

    li_enhs = factory( li_spot_ref-&gt;get_tool( ) ).

    li_enhs-&gt;serialize( io_xml           = io_xml
                        ii_enh_spot_tool = li_spot_ref ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_enho_wdyn IMPLEMENTATION.
  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.
  METHOD zif_abapgit_object_enho~deserialize.

    DATA: ls_enh_data  TYPE enhwdyn,
          li_tool      TYPE REF TO if_enh_tool,
          lo_wdyn      TYPE REF TO cl_enh_tool_wdy,
          lv_tool_type TYPE enhtooltype,
          lv_package   TYPE devclass.

    FIELD-SYMBOLS: &lt;ls_controller_data&gt; TYPE enhwdyc,
                   &lt;ls_view_data&gt;       TYPE enhwdyv.
    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;TOOL&apos;
      CHANGING
        cg_data = lv_tool_type ).

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;COMPONENT_DATA&apos;
      CHANGING
        cg_data = ls_enh_data ).

    lv_package = iv_package.

    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = |{ ms_item-obj_name }|
            enhtype     = &apos;&apos;
            enhtooltype = lv_tool_type
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).

        lo_wdyn ?= li_tool.

        lo_wdyn-&gt;initialize( ls_enh_data-component_name ).

        lo_wdyn-&gt;set_component_data( ls_enh_data-component_data ).

        LOOP AT ls_enh_data-controller_data ASSIGNING &lt;ls_controller_data&gt;.

          lo_wdyn-&gt;set_controller_data( p_controller_name = &lt;ls_controller_data&gt;-controller_name
                                        p_enh_data        = &lt;ls_controller_data&gt; ).

        ENDLOOP.

        LOOP AT ls_enh_data-view_data ASSIGNING &lt;ls_view_data&gt;.

          lo_wdyn-&gt;set_view_data( p_view_name = &lt;ls_view_data&gt;-view_name
                                  p_enh_data  = &lt;ls_view_data&gt; ).

        ENDLOOP.

        lo_wdyn-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_wdyn-&gt;if_enh_object~unlock( ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( |error deserializing ENHO wdyn { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_wdyn           TYPE REF TO cl_enh_tool_wdy,
          lv_component_name TYPE wdy_component_name,
          ls_enh_data       TYPE enhwdyn.
    lo_wdyn ?= ii_enh_tool.
    lv_component_name = lo_wdyn-&gt;get_component_name( ).

    TRY.
        lo_wdyn-&gt;get_all_data_for_comp(
          EXPORTING
            p_component_name = lv_component_name
          IMPORTING
            p_enh_data       = ls_enh_data ).

        io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                     ig_data = ii_enh_tool-&gt;get_tool( ) ).

        io_xml-&gt;add( iv_name = &apos;COMPONENT_DATA&apos;
                     ig_data = ls_enh_data ).

      CATCH cx_enh_not_found.
        zcx_abapgit_exception=&gt;raise( |error serializing ENHO wdyn { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_enho_wdyc IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_enhname TYPE enhname,
          lo_wdyconf TYPE REF TO cl_wdr_cfg_enhancement,
          li_tool    TYPE REF TO if_enh_tool,
          ls_obj     TYPE wdy_config_key,
          lv_package TYPE devclass.
    io_xml-&gt;read( EXPORTING iv_name = &apos;ORIGINAL_OBJECT&apos;
                  CHANGING cg_data  = ls_obj ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = &apos;&apos;
            enhtooltype = cl_wdr_cfg_enhancement=&gt;tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_wdyconf ?= li_tool.

* todo
* io_xml-&gt;read_xml()
* CL_WDR_CFG_PERSISTENCE_UTILS=&gt;COMP_XML_TO_TABLES( )
* lo_wdyconf-&gt;set_enhancement_data( )
        ASSERT 0 = 1.

        lo_wdyconf-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_wdyconf-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;error deserializing ENHO wdyconf&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_wdyconf  TYPE REF TO cl_wdr_cfg_enhancement,
          lt_data     TYPE wdy_cfg_expl_data_tab,
          ls_outline  TYPE wdy_cfg_outline_data,
          ls_obj      TYPE wdy_config_key,
          li_document TYPE REF TO if_ixml_document,
          li_element  TYPE REF TO if_ixml_element.
    lo_wdyconf ?= ii_enh_tool.

    ls_obj = lo_wdyconf-&gt;get_original_object( ).
    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = ii_enh_tool-&gt;get_tool( ) ).
    io_xml-&gt;add( iv_name = &apos;ORIGINAL_OBJECT&apos;
                 ig_data = ls_obj ).

* only works on new ABAP versions, parameters differ between versions
    CALL METHOD lo_wdyconf-&gt;(&apos;GET_ENHANCEMENT_DATA&apos;)
      EXPORTING
        p_scope    = 1
      IMPORTING
        p_enh_data = lt_data.

    CALL METHOD cl_wdr_cfg_persistence_utils=&gt;(&apos;COMP_TABLES_TO_XML&apos;)
      EXPORTING
        outline_data  = ls_outline
        expl_data_tab = lt_data
      IMPORTING
        element       = li_element
      CHANGING
        document      = li_document.

    io_xml-&gt;add_xml( iv_name = &apos;ENHANCEMENT_DATA&apos;
                     ii_xml = li_element ).

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enho_intf IMPLEMENTATION.

  METHOD constructor.
    ms_item  = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_enh_intf  TYPE REF TO cl_enh_tool_intf,
          lv_class     TYPE seoclsname,
          lv_shorttext TYPE string.
    lo_enh_intf ?= ii_enh_tool.

    lv_shorttext = lo_enh_intf-&gt;if_enh_object_docu~get_shorttext( ).
    lo_enh_intf-&gt;get_class( IMPORTING class_name = lv_class ).

    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = ii_enh_tool-&gt;get_tool( ) ).
    io_xml-&gt;add( ig_data = lv_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).
    io_xml-&gt;add( iv_name = &apos;CLASS&apos;
                 ig_data = lv_class ).

    zcl_abapgit_object_enho_clif=&gt;serialize(
      io_xml  = io_xml
      io_files = mo_files
      io_clif = lo_enh_intf ).

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_enh_intf  TYPE REF TO cl_enh_tool_intf,
          li_tool      TYPE REF TO if_enh_tool,
          lv_shorttext TYPE string,
          lv_class     TYPE seoclsname,
          lv_enhname   TYPE enhname,
          lv_package   TYPE devclass.
    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING cg_data  = lv_shorttext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CLASS&apos;
                  CHANGING cg_data  = lv_class ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = &apos;&apos;
            enhtooltype = cl_enh_tool_intf=&gt;tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_enh_intf ?= li_tool.

        lo_enh_intf-&gt;if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_enh_intf-&gt;set_class( lv_class ).

        zcl_abapgit_object_enho_clif=&gt;deserialize(
          io_xml  = io_xml
          io_clif = lo_enh_intf ).

        lo_enh_intf-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_enh_intf-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;error deserializing ENHO interface&apos; ).
    ENDTRY.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enho_hook IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lv_shorttext       TYPE string,
          lo_hook_impl       TYPE REF TO cl_enh_tool_hook_impl,
          ls_original_object TYPE enh_hook_admin,
          lt_spaces          TYPE ty_spaces_tt,
          lt_enhancements    TYPE enh_hook_impl_it.
    lo_hook_impl ?= ii_enh_tool.

    lv_shorttext = lo_hook_impl-&gt;if_enh_object_docu~get_shorttext( ).
    lo_hook_impl-&gt;get_original_object(
      IMPORTING
        pgmid     = ls_original_object-pgmid
        obj_name  = ls_original_object-org_obj_name
        obj_type  = ls_original_object-org_obj_type
        main_type = ls_original_object-org_main_type
        main_name = ls_original_object-org_main_name
        program   = ls_original_object-programname ).
    ls_original_object-include_bound = lo_hook_impl-&gt;get_include_bound( ).
    lt_enhancements = lo_hook_impl-&gt;get_hook_impls( ).

    hook_impl_serialize(
      IMPORTING et_spaces = lt_spaces
      CHANGING ct_impl = lt_enhancements ).

    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = ii_enh_tool-&gt;get_tool( ) ).
    io_xml-&gt;add( ig_data = lv_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).
    io_xml-&gt;add( ig_data = ls_original_object
                 iv_name = &apos;ORIGINAL_OBJECT&apos; ).
    io_xml-&gt;add( iv_name = &apos;ENHANCEMENTS&apos;
                 ig_data = lt_enhancements ).
    io_xml-&gt;add( iv_name = &apos;SPACES&apos;
                 ig_data = lt_spaces ).

  ENDMETHOD.

  METHOD hook_impl_serialize.
* handle normalization of XML values
* i.e. remove leading spaces

    FIELD-SYMBOLS: &lt;ls_impl&gt;  LIKE LINE OF ct_impl,
                   &lt;ls_space&gt; LIKE LINE OF et_spaces,
                   &lt;lv_space&gt; TYPE i,
                   &lt;lv_line&gt;  TYPE string.
    LOOP AT ct_impl ASSIGNING &lt;ls_impl&gt;.
      APPEND INITIAL LINE TO et_spaces ASSIGNING &lt;ls_space&gt;.
      &lt;ls_space&gt;-full_name = &lt;ls_impl&gt;-full_name.
      LOOP AT &lt;ls_impl&gt;-source ASSIGNING &lt;lv_line&gt;.
        APPEND INITIAL LINE TO &lt;ls_space&gt;-spaces ASSIGNING &lt;lv_space&gt;.
        WHILE strlen( &lt;lv_line&gt; ) &gt;= 1 AND &lt;lv_line&gt;(1) = ` `.
          &lt;lv_line&gt; = &lt;lv_line&gt;+1.
          &lt;lv_space&gt; = &lt;lv_space&gt; + 1.
        ENDWHILE.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.

  METHOD hook_impl_deserialize.

    FIELD-SYMBOLS: &lt;ls_impl&gt;   LIKE LINE OF ct_impl,
                   &lt;lv_line&gt;   TYPE string,
                   &lt;lv_space&gt;  TYPE i,
                   &lt;ls_spaces&gt; LIKE LINE OF it_spaces.
    LOOP AT ct_impl ASSIGNING &lt;ls_impl&gt;.
      READ TABLE it_spaces ASSIGNING &lt;ls_spaces&gt; WITH KEY full_name = &lt;ls_impl&gt;-full_name.
      IF sy-subrc = 0.
        LOOP AT &lt;ls_impl&gt;-source ASSIGNING &lt;lv_line&gt;.
          READ TABLE &lt;ls_spaces&gt;-spaces ASSIGNING &lt;lv_space&gt; INDEX sy-tabix.
          IF sy-subrc = 0 AND &lt;lv_space&gt; &gt; 0.
            DO &lt;lv_space&gt; TIMES.
              CONCATENATE space &lt;lv_line&gt; INTO &lt;lv_line&gt; RESPECTING BLANKS.
            ENDDO.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_shorttext       TYPE string,
          lo_hook_impl       TYPE REF TO cl_enh_tool_hook_impl,
          li_tool            TYPE REF TO if_enh_tool,
          lv_enhname         TYPE enhname,
          lv_package         TYPE devclass,
          ls_original_object TYPE enh_hook_admin,
          lt_spaces          TYPE ty_spaces_tt,
          lt_enhancements    TYPE enh_hook_impl_it,
          lx_enh_root        TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: &lt;ls_enhancement&gt; LIKE LINE OF lt_enhancements.
    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING cg_data  = lv_shorttext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ORIGINAL_OBJECT&apos;
                  CHANGING cg_data  = ls_original_object ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;ENHANCEMENTS&apos;
                  CHANGING cg_data  = lt_enhancements ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;SPACES&apos;
                  CHANGING cg_data  = lt_spaces ).

    hook_impl_deserialize( EXPORTING it_spaces = lt_spaces
                           CHANGING ct_impl    = lt_enhancements ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = cl_abstract_enh_tool_redef=&gt;credefinition
            enhtooltype = cl_enh_tool_hook_impl=&gt;tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_hook_impl ?= li_tool.

        lo_hook_impl-&gt;if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_hook_impl-&gt;set_original_object(
            pgmid       = ls_original_object-pgmid
            obj_name    = ls_original_object-org_obj_name
            obj_type    = ls_original_object-org_obj_type
            program     = ls_original_object-programname
            main_type   = ls_original_object-org_main_type
            main_name   = ls_original_object-org_main_name ).
        lo_hook_impl-&gt;set_include_bound( ls_original_object-include_bound ).

        LOOP AT lt_enhancements ASSIGNING &lt;ls_enhancement&gt;.
          lo_hook_impl-&gt;add_hook_impl(
              overwrite        = &lt;ls_enhancement&gt;-overwrite
              method           = &lt;ls_enhancement&gt;-method
              enhmode          = &lt;ls_enhancement&gt;-enhmode
              full_name        = &lt;ls_enhancement&gt;-full_name
              source           = &lt;ls_enhancement&gt;-source
              spot             = &lt;ls_enhancement&gt;-spotname
              parent_full_name = &lt;ls_enhancement&gt;-parent_full_name ).
        ENDLOOP.
        lo_hook_impl-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_hook_impl-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=&gt;raise( lx_enh_root-&gt;get_text( ) ).
    ENDTRY.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enho_fugr IMPLEMENTATION.
  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.
  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_fugrdata  TYPE REF TO cl_enh_tool_fugr,
          ls_enha_data TYPE enhfugrdata,
          li_tool      TYPE REF TO if_enh_tool,
          lv_tool      TYPE enhtooltype,
          lv_package   TYPE devclass.

    FIELD-SYMBOLS: &lt;ls_fuba&gt; TYPE enhfugrfuncdata.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;TOOL&apos;
      CHANGING
        cg_data = lv_tool ).

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;FUGRDATA&apos;
      CHANGING
        cg_data = ls_enha_data ).

    lv_package = iv_package.

    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = |{ ms_item-obj_name }|
            enhtype     = &apos;&apos;
            enhtooltype = lv_tool
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).

        lo_fugrdata ?= li_tool.

        lo_fugrdata-&gt;set_fugr( ls_enha_data-fugr ).

        LOOP AT ls_enha_data-enh_fubas ASSIGNING &lt;ls_fuba&gt;.

          lo_fugrdata-&gt;set_func_data( func_name     = &lt;ls_fuba&gt;-fuba
                                      func_enhadata = &lt;ls_fuba&gt; ).

        ENDLOOP.

        lo_fugrdata-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_fugrdata-&gt;if_enh_object~unlock( ).

      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( |error deserializing ENHO fugrdata { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_fugrdata  TYPE REF TO cl_enh_tool_fugr,
          lv_fugr_name TYPE rs38l-area,
          ls_enha_data TYPE enhfugrdata.

    FIELD-SYMBOLS: &lt;ls_docuobj&gt; TYPE enhfugrparamdocu.
    lo_fugrdata ?= ii_enh_tool.

    lo_fugrdata-&gt;get_fugr(
      IMPORTING
        fugr_name = lv_fugr_name ).

    TRY.
        lo_fugrdata-&gt;get_all_data_for_fugr(
          EXPORTING
            fugr_name = lv_fugr_name
          IMPORTING
            enha_data = ls_enha_data ).

        LOOP AT ls_enha_data-docuobjs ASSIGNING &lt;ls_docuobj&gt;.
          CLEAR: &lt;ls_docuobj&gt;-shorttext,
                 &lt;ls_docuobj&gt;-longtext.
        ENDLOOP.

      CATCH cx_enh_not_found.
        zcx_abapgit_exception=&gt;raise( |error deserializing ENHO fugrdata { ms_item-obj_name }| ).
    ENDTRY.

    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = lo_fugrdata-&gt;if_enh_tool~get_tool( ) ).

    io_xml-&gt;add( iv_name = &apos;FUGRDATA&apos;
                 ig_data = ls_enha_data ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_enho_clif IMPLEMENTATION.

  METHOD serialize_includes.

    DATA: lt_includes TYPE enhnewmeth_tabincl_plus_enha,
          lt_source   TYPE TABLE OF abaptxt255,
          lv_include  TYPE programm.

    FIELD-SYMBOLS: &lt;ls_include&gt; LIKE LINE OF lt_includes.
    lt_includes = io_clif-&gt;get_enh_method_includes( ).
    LOOP AT lt_includes ASSIGNING &lt;ls_include&gt;.
      lv_include = io_clif-&gt;if_enh_tool~get_name( ).
      TRANSLATE lv_include USING &apos; =&apos;.
      lv_include+30 = &apos;EM&apos;.
      lv_include+32(8) = &lt;ls_include&gt;-includenr.

      CALL FUNCTION &apos;RPY_PROGRAM_READ&apos;
        EXPORTING
          program_name     = lv_include
          with_lowercase   = abap_true
        TABLES
          source_extended  = lt_source
        EXCEPTIONS
          cancelled        = 1
          not_found        = 2
          permission_error = 3
          OTHERS           = 4.
      IF sy-subrc = 0.
        io_files-&gt;add_abap( iv_extra = |EM{ &lt;ls_include&gt;-includenr }|
                            it_abap  = lt_source ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize.

    DATA: lt_tab_attributes TYPE enhclasstabattrib,
          lt_tab_methods    TYPE enhnewmeth_tab.

    FIELD-SYMBOLS: &lt;ls_attr&gt; LIKE LINE OF lt_tab_attributes,
                   &lt;ls_meth&gt; LIKE LINE OF lt_tab_methods.
    io_clif-&gt;get_enhattributes(
      IMPORTING
        tab_attributes = lt_tab_attributes ).

    io_clif-&gt;get_enh_new_methodes(
      IMPORTING
        tab_methodes = lt_tab_methods ).

    serialize_includes( io_clif  = io_clif
                        io_files = io_files ).

    LOOP AT lt_tab_attributes ASSIGNING &lt;ls_attr&gt;.
      CLEAR: &lt;ls_attr&gt;-author,
             &lt;ls_attr&gt;-createdon,
             &lt;ls_attr&gt;-changedby,
             &lt;ls_attr&gt;-changedon.
    ENDLOOP.

    LOOP AT lt_tab_methods ASSIGNING &lt;ls_meth&gt;.
      CLEAR: &lt;ls_meth&gt;-meth_header-author,
             &lt;ls_meth&gt;-meth_header-createdon,
             &lt;ls_meth&gt;-meth_header-changedby,
             &lt;ls_meth&gt;-meth_header-changedon,
             &lt;ls_meth&gt;-meth_header-descript_id.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;TAB_ATTRIBUTES&apos;
                 ig_data = lt_tab_attributes ).
    io_xml-&gt;add( iv_name = &apos;TAB_METHODS&apos;
                 ig_data = lt_tab_methods ).

  ENDMETHOD.

  METHOD deserialize.

    DATA: lt_tab_attributes TYPE enhclasstabattrib,
          lt_tab_methods    TYPE enhnewmeth_tab,
          ls_header         TYPE vseomethod,
          ls_param          TYPE vseomepara,
          ls_exc            TYPE vseoexcep.

    FIELD-SYMBOLS: &lt;ls_method&gt; LIKE LINE OF lt_tab_methods,
                   &lt;ls_param&gt;  LIKE LINE OF &lt;ls_method&gt;-meth_param,
                   &lt;ls_exc&gt;    LIKE LINE OF &lt;ls_method&gt;-meth_exc.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TAB_ATTRIBUTES&apos;
                  CHANGING cg_data = lt_tab_attributes ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TAB_METHODS&apos;
                  CHANGING cg_data = lt_tab_methods ).

    io_clif-&gt;set_enhattributes( lt_tab_attributes ).

* todo: deserialize includes

* SAP standard SET_ENH_NEW_METHOS does not work

    LOOP AT lt_tab_methods ASSIGNING &lt;ls_method&gt;.

      MOVE-CORRESPONDING &lt;ls_method&gt;-meth_header TO ls_header.

      io_clif-&gt;add_change_new_enh_method(
        methkey       = &lt;ls_method&gt;-methkey
        method_header = ls_header ).

* parameters
      LOOP AT &lt;ls_method&gt;-meth_param ASSIGNING &lt;ls_param&gt;.
        MOVE-CORRESPONDING &lt;ls_param&gt; TO ls_param.
        io_clif-&gt;add_change_enh_methparam(
          methname   = &lt;ls_method&gt;-methkey-cmpname
          param_line = ls_param ).
      ENDLOOP.

* exceptions
      LOOP AT &lt;ls_method&gt;-meth_exc ASSIGNING &lt;ls_exc&gt;.
        MOVE-CORRESPONDING &lt;ls_exc&gt; TO ls_exc.
        io_clif-&gt;add_change_enh_methexc(
          methname    = &lt;ls_method&gt;-methkey-cmpname
          except_line = ls_exc ).
      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enho_class IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_enh_class TYPE REF TO cl_enh_tool_class,
          lt_owr       TYPE enhmeth_tabkeys,
          lt_pre       TYPE enhmeth_tabkeys,
          lt_post      TYPE enhmeth_tabkeys,
          lt_source    TYPE rswsourcet,
          lv_class     TYPE seoclsname,
          lv_shorttext TYPE string.
    lo_enh_class ?= ii_enh_tool.

    lv_shorttext = lo_enh_class-&gt;if_enh_object_docu~get_shorttext( ).
    lt_owr = lo_enh_class-&gt;get_owr_methods( ).
    lt_pre = lo_enh_class-&gt;get_pre_methods( ).
    lt_post = lo_enh_class-&gt;get_post_methods( ).
    lt_source = lo_enh_class-&gt;get_eimp_include( ).
    lo_enh_class-&gt;get_class( IMPORTING class_name = lv_class ).

    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = ii_enh_tool-&gt;get_tool( ) ).
    io_xml-&gt;add( ig_data = lv_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).
    io_xml-&gt;add( iv_name = &apos;CLASS&apos;
                 ig_data = lv_class ).
    io_xml-&gt;add( iv_name = &apos;OWR_METHODS&apos;
                 ig_data = lt_owr ).
    io_xml-&gt;add( iv_name = &apos;PRE_METHODS&apos;
                 ig_data = lt_pre ).
    io_xml-&gt;add( iv_name = &apos;POST_METHODS&apos;
                 ig_data = lt_post ).

    mo_files-&gt;add_abap( lt_source ).

    zcl_abapgit_object_enho_clif=&gt;serialize(
      io_xml   = io_xml
      io_files = mo_files
      io_clif  = lo_enh_class ).

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_enh_class TYPE REF TO cl_enh_tool_class,
          lt_owr       TYPE enhmeth_tabkeys,
          lt_pre       TYPE enhmeth_tabkeys,
          lt_post      TYPE enhmeth_tabkeys,
          lt_source    TYPE rswsourcet,
          li_tool      TYPE REF TO if_enh_tool,
          lv_shorttext TYPE string,
          lv_class     TYPE seoclsname,
          lv_enhname   TYPE enhname,
          lv_package   TYPE devclass.
    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING cg_data  = lv_shorttext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;OWR_METHODS&apos;
                  CHANGING cg_data  = lt_owr ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;PRE_METHODS&apos;
                  CHANGING cg_data  = lt_pre ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;POST_METHODS&apos;
                  CHANGING cg_data  = lt_post ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;CLASS&apos;
                  CHANGING cg_data  = lv_class ).
    lt_source = mo_files-&gt;read_abap( ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = &apos;&apos;
            enhtooltype = cl_enh_tool_class=&gt;tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_enh_class ?= li_tool.

        lo_enh_class-&gt;if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_enh_class-&gt;set_class( lv_class ).
        lo_enh_class-&gt;set_owr_methods( version     = &apos;I&apos;
                                       owr_methods = lt_owr ).
        lo_enh_class-&gt;set_pre_methods( version     = &apos;I&apos;
                                       pre_methods = lt_pre ).
        lo_enh_class-&gt;set_post_methods( version      = &apos;I&apos;
                                        post_methods = lt_post ).
        lo_enh_class-&gt;set_eimp_include( version     = &apos;I&apos;
                                        eimp_source = lt_source ).

        zcl_abapgit_object_enho_clif=&gt;deserialize(
          io_xml  = io_xml
          io_clif = lo_enh_class ).

        lo_enh_class-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_enh_class-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;error deserializing ENHO class&apos; ).
    ENDTRY.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_enho_badi IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_badi_impl TYPE REF TO cl_enh_tool_badi_impl,
          lv_spot_name TYPE enhspotname,
          lv_shorttext TYPE string,
          lt_impl      TYPE enh_badi_impl_data_it.

    FIELD-SYMBOLS: &lt;ls_impl&gt;   LIKE LINE OF lt_impl,
                   &lt;ls_values&gt; LIKE LINE OF &lt;ls_impl&gt;-filter_values,
                   &lt;ls_filter&gt; LIKE LINE OF &lt;ls_impl&gt;-filters.
    lo_badi_impl ?= ii_enh_tool.

    lv_shorttext = lo_badi_impl-&gt;if_enh_object_docu~get_shorttext( ).
    lv_spot_name = lo_badi_impl-&gt;get_spot_name( ).
    lt_impl      = lo_badi_impl-&gt;get_implementations( ).

    LOOP AT lt_impl ASSIGNING &lt;ls_impl&gt;.
* make sure the XML serialization does not dump, field type = N
      LOOP AT &lt;ls_impl&gt;-filter_values ASSIGNING &lt;ls_values&gt;.
        IF &lt;ls_values&gt;-filter_numeric_value1 CA space.
          CLEAR &lt;ls_values&gt;-filter_numeric_value1.
        ENDIF.
      ENDLOOP.
      LOOP AT &lt;ls_impl&gt;-filters ASSIGNING &lt;ls_filter&gt;.
        IF &lt;ls_filter&gt;-filter_numeric_value1 CA space.
          CLEAR &lt;ls_filter&gt;-filter_numeric_value1.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    io_xml-&gt;add( iv_name = &apos;TOOL&apos;
                 ig_data = ii_enh_tool-&gt;get_tool( ) ).
    io_xml-&gt;add( ig_data = lv_shorttext
                 iv_name = &apos;SHORTTEXT&apos; ).
    io_xml-&gt;add( iv_name = &apos;SPOT_NAME&apos;
                 ig_data = lv_spot_name ).
    io_xml-&gt;add( iv_name = &apos;IMPL&apos;
                 ig_data = lt_impl ).

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_spot_name TYPE enhspotname,
          lv_shorttext TYPE string,
          lv_enhname   TYPE enhname,
          lo_badi      TYPE REF TO cl_enh_tool_badi_impl,
          li_tool      TYPE REF TO if_enh_tool,
          lv_package   TYPE devclass,
          lt_impl      TYPE enh_badi_impl_data_it.

    FIELD-SYMBOLS: &lt;ls_impl&gt; LIKE LINE OF lt_impl.
    io_xml-&gt;read( EXPORTING iv_name = &apos;SHORTTEXT&apos;
                  CHANGING cg_data  = lv_shorttext ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;SPOT_NAME&apos;
                  CHANGING cg_data  = lv_spot_name ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;IMPL&apos;
                  CHANGING cg_data  = lt_impl ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=&gt;create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = cl_abstract_enh_tool_redef=&gt;credefinition
            enhtooltype = cl_enh_tool_badi_impl=&gt;tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_badi ?= li_tool.

        lo_badi-&gt;set_spot_name( lv_spot_name ).
        lo_badi-&gt;if_enh_object_docu~set_shorttext( lv_shorttext ).
        LOOP AT lt_impl ASSIGNING &lt;ls_impl&gt;.
          lo_badi-&gt;add_implementation( &lt;ls_impl&gt; ).
        ENDLOOP.
        lo_badi-&gt;if_enh_object~save( run_dark = abap_true ).
        lo_badi-&gt;if_enh_object~unlock( ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;error deserializing ENHO badi&apos; ).
    ENDTRY.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_ENHO IMPLEMENTATION.
  METHOD factory.

    CASE iv_tool.
      WHEN cl_enh_tool_badi_impl=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_badi
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_enh_tool_hook_impl=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_hook
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_enh_tool_class=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_class
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_enh_tool_intf=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_intf
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_wdr_cfg_enhancement=&gt;tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_wdyc
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN &apos;FUGRENH&apos;.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_fugr
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN &apos;WDYENH&apos;.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_wdyn
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( |Unsupported ENHO type { iv_tool }| ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lv_enh_id   TYPE enhname,
          lt_log      TYPE enh_log_it,
          li_log_obj  TYPE REF TO if_enh_log,
          ls_enhlog   TYPE enhlog,
          lv_lines    TYPE i,
          lt_enhlog   TYPE STANDARD TABLE OF enhlog WITH DEFAULT KEY,
          li_enh_tool TYPE REF TO if_enh_tool.
    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_tool = cl_enh_factory=&gt;get_enhancement(
          enhancement_id   = lv_enh_id
          bypassing_buffer = abap_true ).
      CATCH cx_enh_root.
        rv_user = c_user_unknown.
        RETURN.
    ENDTRY.

    lt_log = li_enh_tool-&gt;get_log( ).

    LOOP AT lt_log INTO li_log_obj.
      ls_enhlog = li_log_obj-&gt;get_enhlog( ).
      APPEND ls_enhlog TO lt_enhlog.
    ENDLOOP.

    lv_lines = lines( lt_enhlog ).
    READ TABLE lt_enhlog INTO ls_enhlog INDEX lv_lines.
    IF sy-subrc = 0.
      rv_user = ls_enhlog-loguser.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_enh_id     TYPE enhname,
          li_enh_object TYPE REF TO if_enh_object.
    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_object = cl_enh_factory=&gt;get_enhancement(
          enhancement_id = lv_enh_id
          lock           = abap_true ).
        li_enh_object-&gt;delete( ).
        li_enh_object-&gt;save( run_dark = abap_true ).
        li_enh_object-&gt;unlock( ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;Error deleting ENHO&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lv_tool TYPE enhtooltype,
          li_enho TYPE REF TO zif_abapgit_object_enho.
    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( ).
    ENDIF.

    io_xml-&gt;read( EXPORTING iv_name = &apos;TOOL&apos;
                  CHANGING cg_data = lv_tool ).

    li_enho = factory( lv_tool ).

    li_enho-&gt;deserialize( io_xml     = io_xml
                          iv_package = iv_package ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_enh_id TYPE enhname.
    lv_enh_id = ms_item-obj_name.
    TRY.
        cl_enh_factory=&gt;get_enhancement(
          enhancement_id   = lv_enh_id
          bypassing_buffer = abap_true ).
        rv_bool = abap_true.
      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    lv_object = |{ ms_item-obj_type }{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;E_ENHANCE&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;ENHO&apos;
        in_new_window = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_enh_id   TYPE enhname,
          li_enho     TYPE REF TO zif_abapgit_object_enho,
          li_enh_tool TYPE REF TO if_enh_tool.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_tool = cl_enh_factory=&gt;get_enhancement(
          enhancement_id   = lv_enh_id
          bypassing_buffer = abap_true ).
      CATCH cx_enh_root.
        zcx_abapgit_exception=&gt;raise( &apos;Error from CL_ENH_FACTORY&apos; ).
    ENDTRY.

    li_enho = factory( li_enh_tool-&gt;get_tool( ) ).

    li_enho-&gt;serialize( io_xml      = io_xml
                        ii_enh_tool = li_enh_tool ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_ecvo IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

*    constant missing in 702
*    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_ecatt_vo.
    rv_object_type = &apos;ECVO&apos;.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_val_obj_upl.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_val_obj_down.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT_TD&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_ectd IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_test_data.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_data_upload.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_data_downl.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT_TD&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_ectc IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_test_config.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_config_upl.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_config_downl.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT_TC&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_ecsp IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

*    constant missing in 702
*    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_start_profile.
    rv_object_type = &apos;ECSP&apos;.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_sp_upload.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_sp_download.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT_SP&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_ecsd IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_system_data.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_system_upl.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_system_downl.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT_SD&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_ecatt_super IMPLEMENTATION.
  METHOD clear_attributes.

    DATA: lo_element     TYPE REF TO if_ixml_element,
          lv_object_type TYPE etobj_type.

    lv_object_type = get_object_type( ).

    lo_element = ci_document-&gt;find_from_name( |{ lv_object_type }| ).
    lo_element-&gt;remove_attribute( |SAPRL| ).
    lo_element-&gt;remove_attribute( |DOWNLOADDATE| ).
    lo_element-&gt;remove_attribute( |DOWNLOADTIME| ).

  ENDMETHOD.
  METHOD clear_element.

    DATA: lo_element TYPE REF TO if_ixml_element.

    lo_element = ci_document-&gt;find_from_name( iv_name ).

    IF lo_element IS BOUND.
      lo_element-&gt;set_value( || ).
    ENDIF.

  ENDMETHOD.
  METHOD clear_elements.

    clear_element( EXPORTING iv_name     = |FUSER|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |FDATE|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |LUSER|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |LDATE|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |LTIME|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |TWB_RESP|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |DEVCLASS|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |TADIR_RESP|
                   CHANGING  ci_document = ci_document ).

    clear_element( EXPORTING iv_name     = |VAR_EXT_PATH|
                   CHANGING  ci_document = ci_document ).

  ENDMETHOD.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_object_name = ms_item-obj_name.

  ENDMETHOD.
  METHOD deserialize_version.

    DATA: ls_object   TYPE etmobjects,
          lo_upload   TYPE REF TO cl_apl_ecatt_upload,
          lv_xml      TYPE xstring,
          lv_text     TYPE string,
          li_document TYPE REF TO if_ixml_document,
          lv_version  TYPE string,
          lx_error    TYPE REF TO cx_ecatt.

    lv_version = get_version_from_node( ii_version_node ).

    IF lv_version IS INITIAL.
      RETURN.
    ENDIF.

    lo_upload = get_upload( ).

    li_document = cl_ixml=&gt;create( )-&gt;create_document( ).
    li_document-&gt;append_child( ii_version_node-&gt;get_first_child( ) ).

    lv_xml = cl_ixml_80_20=&gt;render_to_xstring( li_document ).

    CALL METHOD lo_upload-&gt;(&apos;Z_SET_STREAM_FOR_UPLOAD&apos;)
      EXPORTING
        iv_xml = lv_xml.

    ls_object-d_obj_name  = mv_object_name.
    ls_object-s_obj_type  = get_object_type( ).
    ls_object-d_devclass  = iv_package.
    ls_object-d_obj_ver   = lv_version.
    ls_object-d_overwrite = abap_true.

    TRY.
        lo_upload-&gt;upload(
          CHANGING
            ch_object      = ls_object ).

      CATCH cx_ecatt INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD get_changed_by_user.

    rv_changed_by_user = ii_document-&gt;find_from_name( &apos;LUSER&apos; )-&gt;get_value( ).

  ENDMETHOD.
  METHOD get_changed_date.

    DATA: lv_changed_date_external TYPE string.

    lv_changed_date_external = ii_document-&gt;find_from_name( &apos;LDATE&apos; )-&gt;get_value( ).

    CALL FUNCTION &apos;CONVERSION_EXIT_RSDAT_INPUT&apos;
      EXPORTING
        input        = lv_changed_date_external
      IMPORTING
        output       = rv_changed_date
      EXCEPTIONS
        invalid_date = 1
        OTHERS       = 2.

    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

  ENDMETHOD.
  METHOD get_changed_time.

    DATA: lv_changed_time_external TYPE string.

    lv_changed_time_external =  ii_document-&gt;find_from_name( &apos;LTIME&apos; )-&gt;get_value( ).

    CALL FUNCTION &apos;CONVERSION_EXIT_TIMLO_INPUT&apos;
      EXPORTING
        input       = lv_changed_time_external
      IMPORTING
        output      = rv_changed_time
      EXCEPTIONS
        wrong_input = 1
        OTHERS      = 2.

    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

  ENDMETHOD.
  METHOD get_change_information.

    DATA: li_document    TYPE REF TO if_ixml_document,
          lv_xml         TYPE xstring,
          lo_download    TYPE REF TO cl_apl_ecatt_download,
          lv_object_type TYPE etobj_type.

    lo_download = get_download( ).

    lv_object_type = get_object_type( ).

    zcl_abapgit_ecatt_helper=&gt;build_xml_of_object(
      EXPORTING
        im_object_name    = mv_object_name
        im_object_version = is_version_info-version
        im_object_type    = lv_object_type
        io_download       = lo_download
      IMPORTING
        ex_xml_stream     = lv_xml ).

    li_document = cl_ixml_80_20=&gt;parse_to_document( stream_xstring = lv_xml ).

    rs_change_information-ldate = get_changed_date( li_document ).
    rs_change_information-ltime = get_changed_time( li_document ).
    rs_change_information-luser = get_changed_by_user( li_document ).

  ENDMETHOD.
  METHOD get_version_from_node.

    TRY.
        rv_version = ii_node-&gt;get_first_child(
                           )-&gt;get_first_child(
                           )-&gt;get_first_child(
                           )-&gt;get_first_child(
                           )-&gt;get_value( ).

      CATCH cx_sy_ref_is_initial.
        RETURN.
    ENDTRY.

  ENDMETHOD.
  METHOD is_change_more_recent_than.

    IF ( is_currently_changed-ldate &gt; is_last_changed-ldate )
      OR (     is_currently_changed-ldate = is_last_changed-ldate
           AND is_currently_changed-ltime &gt; is_last_changed-ltime ).

      rv_is_change_more_recent = abap_true.

    ENDIF.

  ENDMETHOD.
  METHOD serialize_version.

    DATA: li_document    TYPE REF TO if_ixml_document,
          lv_xml         TYPE xstring,
          lo_node        TYPE REF TO if_ixml_element,
          lo_download    TYPE REF TO cl_apl_ecatt_download,
          lv_object_type TYPE etobj_type.

    lo_download = get_download( ).

    lv_object_type = get_object_type( ).

    zcl_abapgit_ecatt_helper=&gt;build_xml_of_object(
      EXPORTING
        im_object_name    = mv_object_name
        im_object_version = iv_version
        im_object_type    = lv_object_type
        io_download       = lo_download
      IMPORTING
        ex_xml_stream     = lv_xml ).

    li_document = cl_ixml_80_20=&gt;parse_to_document( stream_xstring = lv_xml ).

    clear_attributes(
      CHANGING
        ci_document = li_document ).

    clear_elements(
      CHANGING
        ci_document = li_document ).

    lo_node = li_document-&gt;create_element( co_name-version ).
    lo_node-&gt;append_child( li_document-&gt;get_root_element( ) ).

    ci_node-&gt;append_child( lo_node ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: ls_last_changed      TYPE ty_last_changed,
          ls_currently_changed TYPE ty_last_changed,
          lt_version_info      TYPE etversinfo_tabtype,
          lx_error             TYPE REF TO cx_ecatt,
          lv_text              TYPE string,
          lv_object_type       TYPE etobj_type.

    FIELD-SYMBOLS: &lt;ls_version_info&gt; LIKE LINE OF lt_version_info.

    TRY.
        lv_object_type = get_object_type( ).

        cl_apl_ecatt_object=&gt;get_version_info_object(
          EXPORTING
            im_name          = mv_object_name
            im_obj_type      = lv_object_type
          IMPORTING
            ex_version_info  = lt_version_info  ).

        LOOP AT lt_version_info ASSIGNING &lt;ls_version_info&gt;.

          ls_currently_changed = get_change_information( &lt;ls_version_info&gt; ).

          IF is_change_more_recent_than( is_currently_changed = ls_currently_changed
                                         is_last_changed      = ls_last_changed ) = abap_true.

            ls_last_changed = ls_currently_changed.

          ENDIF.

        ENDLOOP.

      CATCH cx_ecatt INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        MESSAGE lv_text TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

    IF ls_last_changed-luser IS NOT INITIAL.

      rv_user = ls_last_changed-luser.

    ELSE.

      rv_user = c_user_unknown.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lx_error       TYPE REF TO cx_ecatt_apl,
          lv_text        TYPE string,
          lv_object_type TYPE etobj_type.

    lv_object_type = get_object_type( ).

    TRY.
        cl_apl_ecatt_object=&gt;delete_object( im_obj_type            = lv_object_type
                                            im_name                = mv_object_name
                                            &quot; we have to supply a version, so let&apos;s use the default version
                                            &quot; and delete them all
                                            im_version             = co_default_version
                                            im_delete_all_versions = abap_true ).

      CATCH cx_ecatt_apl INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: li_document         TYPE REF TO if_ixml_document,
          li_versions         TYPE REF TO if_ixml_node_collection,
          li_version_iterator TYPE REF TO if_ixml_node_iterator,
          lo_version_node     TYPE REF TO if_ixml_node.

    li_document = io_xml-&gt;get_raw( ).

    li_versions = li_document-&gt;get_elements_by_tag_name( depth = 0
                                                         name  = co_name-version ).

    li_version_iterator = li_versions-&gt;create_iterator( ).

    DO.
      lo_version_node = li_version_iterator-&gt;get_next( ).

      IF lo_version_node IS NOT BOUND.
        EXIT.
      ENDIF.

      deserialize_version( ii_version_node = lo_version_node
                           iv_package      = iv_package ).

    ENDDO.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_object_type TYPE etobj_type.

    lv_object_type = get_object_type( ).

    TRY.
        rv_bool = cl_apl_ecatt_object=&gt;existence_check_object( im_name               = mv_object_name
                                                               im_version            = co_default_version
                                                               im_obj_type           = lv_object_type
                                                               im_exists_any_version = abap_true ).

      CATCH cx_ecatt.
        RETURN.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error { sy-subrc } from RS_TOOL_ACCESS | ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA:
      lt_version_info TYPE etversinfo_tabtype,
      li_document     TYPE REF TO if_ixml_document,
      lx_error        TYPE REF TO cx_ecatt,
      lv_text         TYPE string,
      lv_object_type  TYPE etobj_type.

    lv_object_type = get_object_type( ).

    TRY.
        cl_apl_ecatt_object=&gt;get_version_info_object(
          EXPORTING
            im_name          = mv_object_name
            im_obj_type      = lv_object_type
          IMPORTING
            ex_version_info  = lt_version_info  ).

        li_document = cl_ixml=&gt;create( )-&gt;create_document( ).

        serialize_versions(
          EXPORTING
            it_version_info  = lt_version_info
          CHANGING
            ci_document      = li_document ).

        io_xml-&gt;set_raw( li_document-&gt;get_root_element( ) ).

      CATCH cx_ecatt INTO lx_error.
        lv_text = lx_error-&gt;get_text( ).
        MESSAGE lv_text TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

  ENDMETHOD.
  METHOD serialize_versions.

    DATA: li_versions_node TYPE REF TO if_ixml_element.
    FIELD-SYMBOLS: &lt;ls_version_info&gt; LIKE LINE OF it_version_info.

    li_versions_node = ci_document-&gt;create_element( co_name-versions ).

    IF lines( it_version_info ) &gt; 0.

      LOOP AT it_version_info ASSIGNING &lt;ls_version_info&gt;.

        serialize_version(
          EXPORTING
            iv_version = &lt;ls_version_info&gt;-version
          CHANGING
            ci_node    = li_versions_node ).

      ENDLOOP.

    ELSE.

      serialize_version(
        EXPORTING
          iv_version = co_default_version
        CHANGING
          ci_node    = li_versions_node ).

    ENDIF.

    ci_document-&gt;append_child( li_versions_node ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    lv_object = ms_item-obj_name.
    OVERLAY lv_object WITH &apos;                              &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = get_lock_object( )
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_ecat IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

  ENDMETHOD.
  METHOD get_object_type.

    rv_object_type = cl_apl_ecatt_const=&gt;obj_type_test_script.

  ENDMETHOD.

  METHOD get_upload.

    CREATE OBJECT ro_upload TYPE zcl_abapgit_ecatt_script_upl.

  ENDMETHOD.

  METHOD get_download.

    CREATE OBJECT ro_download TYPE zcl_abapgit_ecatt_script_downl.

  ENDMETHOD.

  METHOD get_lock_object.

    rv_lock_object = &apos;E_ECATT&apos;.

  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_dtel IMPLEMENTATION.
  METHOD deserialize_texts.

    DATA: lv_name       TYPE ddobjname,
          ls_dd04v_tmp  TYPE dd04v,
          lt_i18n_langs TYPE TABLE OF langu,
          lt_dd04_texts TYPE tt_dd04_texts.

    FIELD-SYMBOLS: &lt;lv_lang&gt;      LIKE LINE OF lt_i18n_langs,
                   &lt;ls_dd04_text&gt; TYPE ty_dd04_texts.
    lv_name = ms_item-obj_name.

    io_xml-&gt;read( EXPORTING iv_name = &apos;I18N_LANGS&apos;
                  CHANGING  cg_data = lt_i18n_langs ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DD04_TEXTS&apos;
                  CHANGING  cg_data = lt_dd04_texts ).

    SORT lt_i18n_langs.
    SORT lt_dd04_texts BY ddlanguage. &quot; Optimization

    LOOP AT lt_i18n_langs ASSIGNING &lt;lv_lang&gt;.

      &quot; Data element description
      ls_dd04v_tmp = is_dd04v.
      READ TABLE lt_dd04_texts ASSIGNING &lt;ls_dd04_text&gt; WITH KEY ddlanguage = &lt;lv_lang&gt;.
      IF sy-subrc &gt; 0.
        zcx_abapgit_exception=&gt;raise( |DD04_TEXTS cannot find lang { &lt;lv_lang&gt; } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING &lt;ls_dd04_text&gt; TO ls_dd04v_tmp.
      CALL FUNCTION &apos;DDIF_DTEL_PUT&apos;
        EXPORTING
          name              = lv_name
          dd04v_wa          = ls_dd04v_tmp
        EXCEPTIONS
          dtel_not_found    = 1
          name_inconsistent = 2
          dtel_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_DTEL_PUT @TEXTS&apos; ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_texts.

    DATA: lv_name       TYPE ddobjname,
          lv_index      TYPE i,
          ls_dd04v      TYPE dd04v,
          lt_dd04_texts TYPE tt_dd04_texts,
          lt_i18n_langs TYPE TABLE OF langu.

    FIELD-SYMBOLS: &lt;lv_lang&gt;      LIKE LINE OF lt_i18n_langs,
                   &lt;ls_dd04_text&gt; TYPE ty_dd04_texts.
    lv_name = ms_item-obj_name.

    &quot; Collect additional languages, skip master lang - it was serialized already
    SELECT DISTINCT ddlanguage AS langu INTO TABLE lt_i18n_langs
      FROM dd04v
      WHERE rollname = lv_name
      AND   ddlanguage &lt;&gt; mv_language.                    &quot;#EC CI_SUBRC

    LOOP AT lt_i18n_langs ASSIGNING &lt;lv_lang&gt;.
      lv_index = sy-tabix.
      CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
        EXPORTING
          name          = lv_name
          langu         = &lt;lv_lang&gt;
        IMPORTING
          dd04v_wa      = ls_dd04v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0 OR ls_dd04v-ddlanguage IS INITIAL.
        DELETE lt_i18n_langs INDEX lv_index. &quot; Don&apos;t save this lang
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO lt_dd04_texts ASSIGNING &lt;ls_dd04_text&gt;.
      MOVE-CORRESPONDING ls_dd04v TO &lt;ls_dd04_text&gt;.

    ENDLOOP.

    SORT lt_i18n_langs ASCENDING.
    SORT lt_dd04_texts BY ddlanguage ASCENDING.

    IF lines( lt_i18n_langs ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;I18N_LANGS&apos;
                   ig_data = lt_i18n_langs ).

      io_xml-&gt;add( iv_name = &apos;DD04_TEXTS&apos;
                   ig_data = lt_dd04_texts ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd04l INTO rv_user
      WHERE rollname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname.

    lv_objname = ms_item-obj_name.
    CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
      EXPORTING
        no_ask               = abap_true
        objname              = lv_objname
        objtype              = &apos;E&apos;
      EXCEPTIONS
        not_executed         = 1
        object_not_found     = 2
        object_not_specified = 3
        permission_failure   = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, DTEL&apos; ).
    ENDIF.

    delete_longtexts( c_longtext_id_dtel ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_dd04v TYPE dd04v,
          lv_name  TYPE ddobjname,
          ls_tpara TYPE tpara.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD04V&apos;
                  CHANGING cg_data = ls_dd04v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;TPARA&apos;
                  CHANGING cg_data = ls_tpara ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name. &quot; type conversion

    CALL FUNCTION &apos;DDIF_DTEL_PUT&apos;
      EXPORTING
        name              = lv_name
        dd04v_wa          = ls_dd04v
      EXCEPTIONS
        dtel_not_found    = 1
        name_inconsistent = 2
        dtel_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_DTEL_PUT&apos; ).
    ENDIF.

    deserialize_texts( io_xml   = io_xml
                       is_dd04v = ls_dd04v ).

    deserialize_longtexts( io_xml ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_rollname TYPE dd04l-rollname.
    SELECT SINGLE rollname FROM dd04l INTO lv_rollname
      WHERE rollname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd04l
      INTO (lv_date, lv_time)
      WHERE rollname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-DDTYPE&apos;
               iv_field = &apos;RSRD1-DDTYPE_VAL&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.
* fm DDIF_DTEL_GET bypasses buffer, so SELECTs are
* done directly from here

    DATA: lv_name  TYPE ddobjname,
          ls_dd04v TYPE dd04v,
          ls_tpara TYPE tpara.

    lv_name = ms_item-obj_name.
    SELECT SINGLE * FROM dd04l
      INTO CORRESPONDING FIELDS OF ls_dd04v
      WHERE rollname = lv_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    IF sy-subrc &lt;&gt; 0 OR ls_dd04v IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Not found in DD04L&apos; ).
    ENDIF.

    SELECT SINGLE * FROM dd04t
      INTO CORRESPONDING FIELDS OF ls_dd04v
      WHERE rollname = lv_name
      AND ddlanguage = mv_language
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.

    IF NOT ls_dd04v-memoryid IS INITIAL.
      SELECT SINGLE tpara~paramid tparat~partext
        FROM tpara LEFT JOIN tparat
        ON tparat~paramid = tpara~paramid AND
        tparat~sprache = mv_language
        INTO ls_tpara
        WHERE tpara~paramid = ls_dd04v-memoryid.       &quot;#EC CI_BUFFJOIN
    ENDIF.

    CLEAR: ls_dd04v-as4user,
           ls_dd04v-as4date,
           ls_dd04v-as4time.

    IF ls_dd04v-refkind = &apos;D&apos;.
* clear values inherited from domain
      CLEAR: ls_dd04v-datatype,
             ls_dd04v-leng,
             ls_dd04v-decimals,
             ls_dd04v-outputlen,
             ls_dd04v-valexi,
             ls_dd04v-lowercase,
             ls_dd04v-signflag,
             ls_dd04v-convexit,
             ls_dd04v-entitytab.
    ENDIF.

    IF ls_dd04v-routputlen = &apos;&apos;.
* numeric field, make sure it is initial or XML serilization will dump
      CLEAR ls_dd04v-routputlen.
    ENDIF.
    IF ls_dd04v-authclass = &apos;&apos;.
      CLEAR ls_dd04v-authclass.
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;DD04V&apos;
                 ig_data = ls_dd04v ).
    io_xml-&gt;add( iv_name = &apos;TPARA&apos;
                 ig_data = ls_tpara ).

    serialize_texts( io_xml ).

    serialize_longtexts( io_xml         = io_xml
                         iv_longtext_id = c_longtext_id_dtel ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_DSYS IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_object  = ms_item-obj_name.
    mv_dokname = mv_object+4(*).

  ENDMETHOD.
  METHOD read.

    CALL FUNCTION &apos;DOCU_READ&apos;
      EXPORTING
        id       = c_id
        langu    = mv_language
        object   = mv_object
        typ      = c_typ
        version  = c_version
      IMPORTING
        doktitle = rs_data-doctitle
        head     = rs_data-head
      TABLES
        line     = rs_data-lines.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = read( )-head-tdluser.
    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    CALL FUNCTION &apos;DOCU_DEL&apos;
      EXPORTING
        id       = c_id
        langu    = mv_language
        object   = mv_object
        typ      = c_typ
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DOCU_DEL&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_data TYPE ty_data.

    io_xml-&gt;read( EXPORTING iv_name = &apos;DSYS&apos;
                  CHANGING cg_data = ls_data ).

    CALL FUNCTION &apos;DOCU_UPDATE&apos;
      EXPORTING
        head    = ls_data-head
        state   = &apos;A&apos;
        typ     = c_typ
        version = c_version
      TABLES
        line    = ls_data-lines.

    tadir_insert( iv_package ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    SELECT SINGLE object FROM dokil INTO mv_object
           WHERE id   = c_id
           AND object = mv_object.                      &quot;#EC CI_GENBUFF

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;DSYS_SHOW&apos;
      EXPORTING
        dokclass         = c_dokclas
        dokname          = mv_dokname
      EXCEPTIONS
        class_unknown    = 1
        object_not_found = 2
        OTHERS           = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DSYS_EDIT&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_data   TYPE ty_data.

    ls_data = read( ).

    CLEAR: ls_data-head-tdfuser,
           ls_data-head-tdfreles,
           ls_data-head-tdfdate,
           ls_data-head-tdftime,
           ls_data-head-tdluser,
           ls_data-head-tdlreles,
           ls_data-head-tdldate,
           ls_data-head-tdltime.

    io_xml-&gt;add( iv_name = &apos;DSYS&apos;
                 ig_data = ls_data ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_DOMA IMPLEMENTATION.
  METHOD deserialize_texts.

    DATA: lv_name       TYPE ddobjname,
          ls_dd01v_tmp  TYPE dd01v,
          lt_dd07v_tmp  TYPE TABLE OF dd07v,
          lt_i18n_langs TYPE TABLE OF langu,
          lt_dd01_texts TYPE tt_dd01_texts,
          lt_dd07_texts TYPE tt_dd07_texts.

    FIELD-SYMBOLS: &lt;lv_lang&gt;      LIKE LINE OF lt_i18n_langs,
                   &lt;ls_dd07v&gt;     LIKE LINE OF it_dd07v,
                   &lt;ls_dd01_text&gt; LIKE LINE OF lt_dd01_texts,
                   &lt;ls_dd07_text&gt; LIKE LINE OF lt_dd07_texts.

    lv_name = ms_item-obj_name.

    io_xml-&gt;read( EXPORTING iv_name = &apos;I18N_LANGS&apos;
                  CHANGING  cg_data = lt_i18n_langs ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DD01_TEXTS&apos;
                  CHANGING  cg_data = lt_dd01_texts ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DD07_TEXTS&apos;
                  CHANGING  cg_data = lt_dd07_texts ).

    SORT lt_i18n_langs.
    SORT lt_dd07_texts BY ddlanguage. &quot; Optimization

    LOOP AT lt_i18n_langs ASSIGNING &lt;lv_lang&gt;.

      &quot; Domain description
      ls_dd01v_tmp = is_dd01v.
      READ TABLE lt_dd01_texts ASSIGNING &lt;ls_dd01_text&gt; WITH KEY ddlanguage = &lt;lv_lang&gt;.
      IF sy-subrc &gt; 0.
        zcx_abapgit_exception=&gt;raise( |DD01_TEXTS cannot find lang { &lt;lv_lang&gt; } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING &lt;ls_dd01_text&gt; TO ls_dd01v_tmp.

      &quot; Domain values
      lt_dd07v_tmp = it_dd07v.
      LOOP AT lt_dd07v_tmp ASSIGNING &lt;ls_dd07v&gt;.
        READ TABLE lt_dd07_texts ASSIGNING &lt;ls_dd07_text&gt;
          WITH KEY ddlanguage = &lt;lv_lang&gt; valpos = &lt;ls_dd07v&gt;-valpos.
        CHECK sy-subrc = 0. &quot; ! no translation -&gt; master translation remain (maybe not OK)
        MOVE-CORRESPONDING &lt;ls_dd07_text&gt; TO &lt;ls_dd07v&gt;.
        DELETE lt_dd07_texts INDEX sy-tabix. &quot; Optimization
      ENDLOOP.

      CALL FUNCTION &apos;DDIF_DOMA_PUT&apos;
        EXPORTING
          name              = lv_name
          dd01v_wa          = ls_dd01v_tmp
        TABLES
          dd07v_tab         = lt_dd07v_tmp
        EXCEPTIONS
          doma_not_found    = 1
          name_inconsistent = 2
          doma_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_DOMA_PUT @TEXTS&apos; ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD serialize_texts.

    DATA: lv_name       TYPE ddobjname,
          lv_index      TYPE i,
          ls_dd01v      TYPE dd01v,
          lt_dd07v      TYPE TABLE OF dd07v,
          lt_i18n_langs TYPE TABLE OF langu,
          lt_dd01_texts TYPE tt_dd01_texts,
          lt_dd07_texts TYPE tt_dd07_texts.

    FIELD-SYMBOLS: &lt;lv_lang&gt;      LIKE LINE OF lt_i18n_langs,
                   &lt;ls_dd07v&gt;     LIKE LINE OF lt_dd07v,
                   &lt;ls_dd01_text&gt; LIKE LINE OF lt_dd01_texts,
                   &lt;ls_dd07_text&gt; LIKE LINE OF lt_dd07_texts.
    lv_name = ms_item-obj_name.

    &quot; Collect additional languages, skip master lang - it was serialized already
    SELECT DISTINCT ddlanguage AS langu INTO TABLE lt_i18n_langs
      FROM dd01v
      WHERE domname = lv_name
      AND   ddlanguage &lt;&gt; mv_language.                    &quot;#EC CI_SUBRC

    LOOP AT lt_i18n_langs ASSIGNING &lt;lv_lang&gt;.
      lv_index = sy-tabix.

      CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
        EXPORTING
          name          = lv_name
          langu         = &lt;lv_lang&gt;
        IMPORTING
          dd01v_wa      = ls_dd01v
        TABLES
          dd07v_tab     = lt_dd07v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0 OR ls_dd01v-ddlanguage IS INITIAL.
        DELETE lt_i18n_langs INDEX lv_index. &quot; Don&apos;t save this lang
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO lt_dd01_texts ASSIGNING &lt;ls_dd01_text&gt;.
      MOVE-CORRESPONDING ls_dd01v TO &lt;ls_dd01_text&gt;.

      LOOP AT lt_dd07v ASSIGNING &lt;ls_dd07v&gt;.
        APPEND INITIAL LINE TO lt_dd07_texts ASSIGNING &lt;ls_dd07_text&gt;.
        MOVE-CORRESPONDING &lt;ls_dd07v&gt; TO &lt;ls_dd07_text&gt;.
      ENDLOOP.

    ENDLOOP.

    SORT lt_i18n_langs ASCENDING.
    SORT lt_dd01_texts BY ddlanguage ASCENDING.
    SORT lt_dd07_texts BY valpos ASCENDING ddlanguage ASCENDING.

    IF lines( lt_i18n_langs ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;I18N_LANGS&apos;
                   ig_data = lt_i18n_langs ).

      io_xml-&gt;add( iv_name = &apos;DD01_TEXTS&apos;
                   ig_data = lt_dd01_texts ).

      io_xml-&gt;add( iv_name = &apos;DD07_TEXTS&apos;
                   ig_data = lt_dd07_texts ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd01l INTO rv_user
      WHERE domname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
* see class CL_WB_DDIC

    DATA: lv_objname TYPE rsedd0-ddobjname.
    lv_objname = ms_item-obj_name.

    TRY.
        CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
          EXPORTING
            no_ask               = abap_true
            objname              = lv_objname
            objtype              = &apos;D&apos;
            no_ask_delete_append = abap_true
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 2
            object_not_specified = 3
            permission_failure   = 4.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, DOMA&apos; ).
        ENDIF.

      CATCH cx_sy_dyn_call_param_not_found.

        CALL FUNCTION &apos;RS_DD_DELETE_OBJ&apos;
          EXPORTING
            no_ask               = abap_true
            objname              = lv_objname
            objtype              = &apos;D&apos;
*           no_ask_delete_append = abap_true parameter not available in lower NW versions
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 2
            object_not_specified = 3
            permission_failure   = 4.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;error from RS_DD_DELETE_OBJ, DOMA&apos; ).
        ENDIF.

    ENDTRY.

    delete_longtexts( c_longtext_id_doma ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

* package SEDD
* package SDIC

* fm TR_TADIR_INTERFACE
* fm RS_CORR_INSERT ?

    DATA: lv_name  TYPE ddobjname,
          ls_dd01v TYPE dd01v,
          lt_dd07v TYPE TABLE OF dd07v.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD01V&apos;
                  CHANGING cg_data = ls_dd01v ).
    io_xml-&gt;read( EXPORTING iv_name = &apos;DD07V_TAB&apos;
                  CHANGING cg_data = lt_dd07v ).

    corr_insert( iv_package ).

    lv_name = ms_item-obj_name. &quot; type conversion

    CALL FUNCTION &apos;DDIF_DOMA_PUT&apos;
      EXPORTING
        name              = lv_name
        dd01v_wa          = ls_dd01v
      TABLES
        dd07v_tab         = lt_dd07v
      EXCEPTIONS
        doma_not_found    = 1
        name_inconsistent = 2
        doma_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_DOMA_PUT&apos; ).
    ENDIF.

    deserialize_texts( io_xml   = io_xml
                       is_dd01v = ls_dd01v
                       it_dd07v = lt_dd07v ).

    deserialize_longtexts( io_xml ).

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_domname TYPE dd01l-domname.
    SELECT SINGLE domname FROM dd01l INTO lv_domname
      WHERE domname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers = &apos;0000&apos;.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-ddic = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    DATA: lv_date TYPE dats,
          lv_time TYPE tims.

    SELECT SINGLE as4date as4time FROM dd01l
      INTO (lv_date, lv_time)
      WHERE domname = ms_item-obj_name
      AND as4local = &apos;A&apos;
      AND as4vers  = &apos;0000&apos;.

    rv_changed = check_timestamp(
      iv_timestamp = iv_timestamp
      iv_date      = lv_date
      iv_time      = lv_time ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    jump_se11( iv_radio = &apos;RSRD1-DOMA&apos;
               iv_field = &apos;RSRD1-DOMA_VAL&apos; ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_name    TYPE ddobjname,
          ls_dd01v   TYPE dd01v,
          lv_masklen TYPE c LENGTH 4,
          lt_dd07v   TYPE TABLE OF dd07v.
    lv_name = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
      EXPORTING
        name          = lv_name
        langu         = mv_language
      IMPORTING
        dd01v_wa      = ls_dd01v
      TABLES
        dd07v_tab     = lt_dd07v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0 OR ls_dd01v IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;error from DDIF_DOMA_GET&apos; ).
    ENDIF.

    CLEAR: ls_dd01v-as4user,
           ls_dd01v-as4date,
           ls_dd01v-as4time.

* make sure XML serialization does not dump if the field contains invalid data
* note that this is a N field, so &apos;&apos; is not valid
    IF ls_dd01v-authclass = &apos;&apos;.
      CLEAR ls_dd01v-authclass.
    ENDIF.
    lv_masklen = ls_dd01v-masklen.
    IF lv_masklen = &apos;&apos; OR NOT lv_masklen CO &apos;0123456789&apos;.
      CLEAR ls_dd01v-masklen.
    ENDIF.

    SORT lt_dd07v BY
      valpos ASCENDING
      ddlanguage ASCENDING.

    io_xml-&gt;add( iv_name = &apos;DD01V&apos;
                 ig_data = ls_dd01v ).
    io_xml-&gt;add( iv_name = &apos;DD07V_TAB&apos;
                 ig_data = lt_dd07v ).

    serialize_texts( io_xml ).

    serialize_longtexts( io_xml         = io_xml
                         iv_longtext_id = c_longtext_id_doma ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_docv IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = read( )-head-tdluser.
    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.

  METHOD read.

    DATA: lv_object TYPE dokhl-object,
          lv_id     TYPE dokhl-id.
    lv_id = ms_item-obj_name(2).
    lv_object = ms_item-obj_name+2.

    CALL FUNCTION &apos;DOCU_READ&apos;
      EXPORTING
        id       = lv_id
        langu    = mv_language
        object   = lv_object
        typ      = c_typ
        version  = c_version
      IMPORTING
        doktitle = rs_data-doctitle
        head     = rs_data-head
      TABLES
        line     = rs_data-lines.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_id     TYPE dokhl-id,
          lv_object TYPE dokhl-object.
    lv_id = ms_item-obj_name(2).
    lv_object = ms_item-obj_name+2.

    SELECT SINGLE id FROM dokil INTO lv_id
      WHERE id     = lv_id
        AND object = lv_object.                         &quot;#EC CI_GENBUFF

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( &apos;todo, jump DOCV&apos; ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_id     TYPE dokhl-id,
          lv_object TYPE dokhl-object.
    lv_id = ms_item-obj_name(2).
    lv_object = ms_item-obj_name+2.

    CALL FUNCTION &apos;DOCU_DEL&apos;
      EXPORTING
        id       = lv_id
        langu    = mv_language
        object   = lv_object
        typ      = c_typ
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DOCU_DEL&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_data TYPE ty_data.
    io_xml-&gt;read( EXPORTING iv_name = c_name
                  CHANGING cg_data = ls_data ).

    CALL FUNCTION &apos;DOCU_UPDATE&apos;
      EXPORTING
        head    = ls_data-head
        state   = &apos;A&apos;
        typ     = c_typ
        version = c_version
      TABLES
        line    = ls_data-lines.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_data   TYPE ty_data.
    ls_data = read( ).

    CLEAR: ls_data-head-tdfuser,
           ls_data-head-tdfreles,
           ls_data-head-tdfdate,
           ls_data-head-tdftime,
           ls_data-head-tdluser,
           ls_data-head-tdlreles,
           ls_data-head-tdldate,
           ls_data-head-tdltime.

    io_xml-&gt;add( iv_name = c_name
                 ig_data = ls_data ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_doct IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD read.

    DATA: lv_object TYPE dokhl-object.
    lv_object = ms_item-obj_name.

    CALL FUNCTION &apos;DOCU_READ&apos;
      EXPORTING
        id       = c_id
        langu    = mv_language
        object   = lv_object
        typ      = c_typ
        version  = c_version
      IMPORTING
        doktitle = rs_data-doctitle
        head     = rs_data-head
      TABLES
        line     = rs_data-lines.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = read( )-head-tdluser.
    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_id     TYPE dokil-id,
          lv_object TYPE dokhl-object.
    lv_object = ms_item-obj_name.

    SELECT SINGLE id FROM dokil INTO lv_id
      WHERE id         = c_id
        AND object     = lv_object.                     &quot;#EC CI_GENBUFF

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_dokentry TYPE dokentry,
          ls_bcdata   TYPE bdcdata,
          lt_bcdata   TYPE STANDARD TABLE OF bdcdata.

    &quot; We need to modify dokentry directly, otherwise
    &quot; Batch Input on SE61 wouldn&apos;t work because it stores
    &quot; the last seen Document Class in this table. There&apos;s
    &quot; no standard function to do this. SE61 does this
    &quot; directly in its dialog modules
    ls_dokentry-username = sy-uname.
    ls_dokentry-langu    = sy-langu.
    ls_dokentry-class    = c_id.
    MODIFY dokentry FROM ls_dokentry.

    ls_bcdata-program  = &apos;SAPMSDCU&apos;.
    ls_bcdata-dynpro   = &apos;0100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;RSDCU-OBJECT7&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=SHOW&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      STARTING NEW TASK &apos;GIT&apos;
      EXPORTING
        tcode     = &apos;SE61&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, DOCT&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_object TYPE dokhl-object.
    lv_object = ms_item-obj_name.

    CALL FUNCTION &apos;DOCU_DEL&apos;
      EXPORTING
        id       = c_id
        langu    = mv_language
        object   = lv_object
        typ      = c_typ
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from DOCU_DEL&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_data TYPE ty_data.
    io_xml-&gt;read( EXPORTING iv_name = c_name
                  CHANGING cg_data = ls_data ).

    CALL FUNCTION &apos;DOCU_UPDATE&apos;
      EXPORTING
        head    = ls_data-head
        state   = &apos;A&apos;
        typ     = c_typ
        version = c_version
      TABLES
        line    = ls_data-lines.

    tadir_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_data TYPE ty_data.
    ls_data = read( ).

    CLEAR: ls_data-head-tdfuser,
           ls_data-head-tdfreles,
           ls_data-head-tdfdate,
           ls_data-head-tdftime,
           ls_data-head-tdluser,
           ls_data-head-tdlreles,
           ls_data-head-tdldate,
           ls_data-head-tdltime.

    io_xml-&gt;add( iv_name = c_name
                 ig_data = ls_data ).

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_dial IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.

    rv_user = c_user_unknown.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: ls_bcdata TYPE bdcdata,
          lt_bcdata TYPE STANDARD TABLE OF bdcdata.

    ls_bcdata-program  = &apos;SAPMSDIA&apos;.
    ls_bcdata-dynpro   = &apos;1010&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;DIAPAR-DNAM&apos;.
    ls_bcdata-fval     = ms_item-obj_name.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam     = &apos;RS38L-PARM&apos;.
    ls_bcdata-fval     = abap_true.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=DELF&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-program  = &apos;SAPLSPO1&apos;.
    ls_bcdata-dynpro   = &apos;0100&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=YES&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    ls_bcdata-program  = &apos;SAPMSDIA&apos;.
    ls_bcdata-dynpro   = &apos;1010&apos;.
    ls_bcdata-dynbegin = &apos;X&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CLEAR ls_bcdata.
    ls_bcdata-fnam = &apos;BDC_OKCODE&apos;.
    ls_bcdata-fval = &apos;=BACK&apos;.
    APPEND ls_bcdata TO lt_bcdata.

    CALL FUNCTION &apos;ABAP4_CALL_TRANSACTION&apos;
      EXPORTING
        tcode     = &apos;SE35&apos;
        mode_val  = &apos;E&apos;
      TABLES
        using_tab = lt_bcdata
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from ABAP4_CALL_TRANSACTION, SE35&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_dialog_module TYPE ty_dialog_module.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;DIAL&apos;
      CHANGING
        cg_data = ls_dialog_module ).

    CALL FUNCTION &apos;RS_DIALOG_CREATE&apos;
      EXPORTING
        dialogname            = ls_dialog_module-tdct-dnam
        dynpronumber          = ls_dialog_module-tdct-dynr
        programname           = ls_dialog_module-tdct-prog
        suppress_corr_check   = abap_false
*     It seems that dia_par parameter doesn&apos;t do anything, but we can&apos;t omit it
*     Parameters are inserted below
      TABLES
        dia_par               = ls_dialog_module-dia_pars
      EXCEPTIONS
        dialog_already_exists = 1
        invalid_name          = 2
        OTHERS                = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error deserializing dialogmodule { ms_item-obj_name }| ).
    ENDIF.

    &quot; It seems that there&apos;s no API for diapar, therefore we manipulate it directly
    INSERT diapar FROM TABLE ls_dialog_module-dia_pars.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_tdct TYPE tdct.

    ls_tdct = _read_tdct( ).

    rv_bool = boolc( ls_tdct IS NOT INITIAL ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lv_objectname TYPE tdct-dnam.

    lv_objectname = ms_item-obj_name.

    CALL FUNCTION &apos;RS_DIALOG_SHOW&apos;
      EXPORTING
        objectname       = lv_objectname
        type             = &apos;VW&apos;
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_DIALOG_SHOW, DIAL| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_dialog_module TYPE ty_dialog_module.

    ls_dialog_module-tdct = _read_tdct( ).

    SELECT * FROM diapar
             INTO TABLE ls_dialog_module-dia_pars
             WHERE dnam = ls_dialog_module-tdct-dnam.

    io_xml-&gt;add( iv_name = &apos;DIAL&apos;
                 ig_data = ls_dialog_module ).

  ENDMETHOD.
  METHOD _read_tdct.

    DATA: lv_dnam TYPE tdct-dnam.

    lv_dnam = ms_item-obj_name.

    SELECT SINGLE * FROM tdct
           INTO rs_tdct
           WHERE dnam = lv_dnam.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_devc IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).
    IF is_item-devclass IS NOT INITIAL.
      mv_local_devclass = is_item-devclass.
    ELSE.
      mv_local_devclass = is_item-obj_name.
    ENDIF.
  ENDMETHOD.
  METHOD get_package.
    IF me-&gt;zif_abapgit_object~exists( ) = abap_true.
      ri_package = load_package( mv_local_devclass ).
    ENDIF.
  ENDMETHOD.
  METHOD is_empty.

    DATA: lv_object_name TYPE tadir-obj_name,
          lt_subpackages TYPE zif_abapgit_sap_package=&gt;ty_devclass_tt.

    lt_subpackages = zcl_abapgit_factory=&gt;get_sap_package( iv_package_name )-&gt;list_subpackages( ).

    IF lines( lt_subpackages ) &gt; 0.
      rv_is_empty = abap_false.
      RETURN.
    ENDIF.

    SELECT SINGLE obj_name
           FROM tadir
           INTO lv_object_name
           WHERE pgmid    =  &apos;R3TR&apos;
           AND   NOT ( object = &apos;DEVC&apos; AND obj_name = iv_package_name )
           AND   devclass = iv_package_name.
    rv_is_empty = boolc( sy-subrc &lt;&gt; 0 ).

  ENDMETHOD.
  METHOD load_package.

    cl_package_factory=&gt;load_package(
      EXPORTING
        i_package_name             = iv_package_name
        i_force_reload             = abap_true
      IMPORTING
        e_package                  = ri_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD set_lock.
    DATA: lv_changeable TYPE abap_bool.

    ii_package-&gt;get_changeable( IMPORTING e_changeable = lv_changeable ).
    IF lv_changeable &lt;&gt; iv_lock.
      ii_package-&gt;set_changeable(
        EXPORTING
          i_changeable                = iv_lock
        EXCEPTIONS
          object_locked_by_other_user = 1
          permission_failure          = 2
          object_already_changeable   = 3
          object_already_unlocked     = 4
          object_just_created         = 5
          object_deleted              = 6
          object_modified             = 7
          object_not_existing         = 8
          object_invalid              = 9
          unexpected_error            = 10
          OTHERS                      = 11 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.
    ENDIF.

    ii_package-&gt;set_permissions_changeable(
      EXPORTING
        i_changeable                = iv_lock
* downport, does not exist in 7.30. Let&apos;s see if we can get along without it
*        i_suppress_dialog           = abap_true
      EXCEPTIONS
        object_already_changeable   = 1
        object_already_unlocked     = 2
        object_locked_by_other_user = 3
        object_modified             = 4
        object_just_created         = 5
        object_deleted              = 6
        permission_failure          = 7
        object_invalid              = 8
        unexpected_error            = 9
        OTHERS                      = 10 ).
    IF ( sy-subrc = 1 AND iv_lock = abap_true ) OR ( sy-subrc = 2 AND iv_lock = abap_false ).
      &quot; There&apos;s no getter to find out beforehand...
    ELSEIF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.
  ENDMETHOD.
  METHOD update_pinf_usages.
    DATA: lt_current_permissions TYPE tpak_permission_to_use_list,
          li_usage               TYPE REF TO if_package_permission_to_use,
          ls_data_sign           TYPE scomppsign,
          ls_add_permission_data TYPE pkgpermdat,
          lt_handled             TYPE SORTED TABLE OF i WITH UNIQUE KEY table_line.
    FIELD-SYMBOLS: &lt;ls_usage_data&gt; LIKE LINE OF it_usage_data.

    &quot; Get the current permissions
    ii_package-&gt;get_permissions_to_use(
      IMPORTING
        e_permissions    = lt_current_permissions
      EXCEPTIONS
        object_invalid   = 1
        unexpected_error = 2
        OTHERS           = 3 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    ls_data_sign-err_sever = abap_true.

    &quot; New permissions
    LOOP AT it_usage_data ASSIGNING &lt;ls_usage_data&gt;.
      READ TABLE lt_current_permissions
           WITH KEY table_line-&gt;package_interface_name = &lt;ls_usage_data&gt;-intf_name
           INTO li_usage.

      IF sy-subrc = 0 AND li_usage IS BOUND.
        INSERT sy-tabix INTO TABLE lt_handled.

        &quot; Permission already exists, update attributes
        li_usage-&gt;set_all_attributes(
          EXPORTING
            i_permission_data     = &lt;ls_usage_data&gt;
            i_data_sign           = ls_data_sign
          EXCEPTIONS
            object_not_changeable = 1
            object_invalid        = 2
            intern_err            = 3
            OTHERS                = 4 ).
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise_t100( ).
        ENDIF.

      ELSE.
        &quot; Permission does not exist yet, add it
        MOVE-CORRESPONDING &lt;ls_usage_data&gt; TO ls_add_permission_data.
        ii_package-&gt;add_permission_to_use(
          EXPORTING
            i_pkg_permission_data   = ls_add_permission_data
          EXCEPTIONS
            object_not_changeable   = 1
            object_access_error     = 2
            object_already_existing = 3
            object_invalid          = 4
            unexpected_error        = 5
            OTHERS                  = 6 ).
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise_t100( ).
        ENDIF.

      ENDIF.

      FREE li_usage.
    ENDLOOP.

    &quot; Delete missing usages
    LOOP AT lt_current_permissions INTO li_usage.
      READ TABLE lt_handled WITH TABLE KEY table_line = sy-tabix TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.

      li_usage-&gt;delete(
        EXCEPTIONS
          object_not_changeable = 1
          object_invalid        = 2
*          deletion_not_allowed  = 3 downport, does not exist in 7.30
          intern_err            = 4
          OTHERS                = 5 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = get_package( )-&gt;changed_by.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: li_package TYPE REF TO if_package,
          lv_package TYPE devclass.

    &quot; Package deletion is a bit tricky. A package can only be deleted if there are no objects
    &quot; contained in it. This includes subpackages, so first the leaf packages need to be deleted.
    &quot; Unfortunately deleted objects that are still contained in an unreleased transport request
    &quot; also count towards the contained objects counter.
    &quot; -&gt; Currently we delete only empty packages
    &quot;
    &quot; If objects are deleted, the TADIR entry is deleted when the transport request is released.
    &quot; So before we can delete the package, the transport which deletes the objects
    &quot; in the package has to be released.

    lv_package = ms_item-obj_name.

    IF is_empty( lv_package ) = abap_true.

      li_package = load_package( lv_package ).

      IF li_package IS NOT BOUND.
        RETURN.
      ENDIF.

      TRY.
          CALL METHOD li_package-&gt;(&apos;SET_CHANGEABLE&apos;)
            EXPORTING
              i_changeable                = abap_true
              i_suppress_dialog           = abap_true &quot; Parameter missing in 702
            EXCEPTIONS
              object_locked_by_other_user = 1
              permission_failure          = 2
              object_already_changeable   = 3
              object_already_unlocked     = 4
              object_just_created         = 5
              object_deleted              = 6
              object_modified             = 7
              object_not_existing         = 8
              object_invalid              = 9
              unexpected_error            = 10
              OTHERS                      = 11.

        CATCH cx_root.
          li_package-&gt;set_changeable(
            EXPORTING
              i_changeable                = abap_true
            EXCEPTIONS
              object_locked_by_other_user = 1
              permission_failure          = 2
              object_already_changeable   = 3
              object_already_unlocked     = 4
              object_just_created         = 5
              object_deleted              = 6
              object_modified             = 7
              object_not_existing         = 8
              object_invalid              = 9
              unexpected_error            = 10
              OTHERS                      = 11 ).
      ENDTRY.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

      TRY.
          CALL METHOD li_package-&gt;(&apos;DELETE&apos;)
            EXPORTING
              i_suppress_dialog     = abap_true  &quot; Parameter missing in 702
            EXCEPTIONS
              object_not_empty      = 1
              object_not_changeable = 2
              object_invalid        = 3
              intern_err            = 4
              OTHERS                = 5.

        CATCH cx_root.

          li_package-&gt;delete(
            EXCEPTIONS
              object_not_empty      = 1
              object_not_changeable = 2
              object_invalid        = 3
              intern_err            = 4
              OTHERS                = 5 ).

      ENDTRY.

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

      li_package-&gt;save(
        EXPORTING
          i_suppress_dialog     = abap_true
        EXCEPTIONS
          object_invalid        = 1
          object_not_changeable = 2
          cancelled_in_corr     = 3
          permission_failure    = 4
          unexpected_error      = 5
          intern_err            = 6
          OTHERS                = 7 ).

      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
    DATA: li_package      TYPE REF TO if_package,
          ls_package_data TYPE scompkdtln,
          ls_data_sign    TYPE scompksign,
          lt_usage_data   TYPE scomppdata,
          ls_save_sign    TYPE paksavsign.

    FIELD-SYMBOLS: &lt;ls_usage_data&gt; TYPE scomppdtln.
    mv_local_devclass = iv_package.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;DEVC&apos;
      CHANGING
        cg_data = ls_package_data ).

    li_package = get_package( ).

    &quot; Swap out repository package name with the local installation package name
    ls_package_data-devclass = mv_local_devclass.
    ls_package_data-pdevclass = li_package-&gt;transport_layer.

    &quot; Parent package is not changed. Assume the folder logic already created the package and set
    &quot; the hierarchy before.
    CLEAR ls_package_data-parentcl.

    ls_data_sign-ctext            = abap_true.
*    ls_data_sign-korrflag         = abap_true.
    ls_data_sign-as4user          = abap_true.
    ls_data_sign-pdevclass        = abap_true.
*    ls_data_sign-dlvunit          = abap_true.
    ls_data_sign-comp_posid       = abap_true.
    ls_data_sign-component        = abap_true.
*    ls_data_sign-parentcl         = abap_true. &quot; No parent package change here
    ls_data_sign-perminher        = abap_true.
    ls_data_sign-intfprefx        = abap_true.
    ls_data_sign-packtype         = abap_true.
    ls_data_sign-restricted       = abap_true.
    ls_data_sign-mainpack         = abap_true.
    ls_data_sign-srv_check        = abap_true.
    ls_data_sign-cli_check        = abap_true.
    ls_data_sign-ext_alias        = abap_true.
    ls_data_sign-project_guid     = abap_true.
    ls_data_sign-project_id       = abap_true.
    ls_data_sign-project_passdown = abap_true.

    IF ls_package_data-ctext IS INITIAL.
      ls_package_data-ctext = mv_local_devclass.
    ENDIF.
    IF ls_package_data-dlvunit IS INITIAL.
      ls_package_data-dlvunit = &apos;HOME&apos;.
    ENDIF.

    ls_package_data-as4user = cl_abap_syst=&gt;get_user_name( ).

    IF li_package IS BOUND.
      &quot; Package already exists, change it
      set_lock( ii_package = li_package iv_lock = abap_true ).

      li_package-&gt;set_all_attributes(
        EXPORTING
          i_package_data             = ls_package_data
          i_data_sign                = ls_data_sign
        EXCEPTIONS
          object_not_changeable      = 1
          object_deleted             = 2
          object_invalid             = 3
          short_text_missing         = 4
          author_not_existing        = 5
          local_package              = 6
          software_component_invalid = 7
          layer_invalid              = 8
          korrflag_invalid           = 9
          component_not_existing     = 10
          component_missing          = 11
          authorize_failure          = 12
          prefix_in_use              = 13
          unexpected_error           = 14
          intern_err                 = 15
*          wrong_mainpack_value       = 16  downport, does not exist in 7.30
*          superpackage_invalid       = 17  downport, does not exist in 7.30
          OTHERS                     = 18 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

*      &quot; If the application component was cleared SET_ALL_ATTRIBUTES doesn&apos;t change it
*      IF ls_package_data-component IS INITIAL AND li_package-&gt;application_component IS NOT INITIAL.
*
*      ENDIF.

    ELSE.
      &quot; Package does not exist yet, create it
      &quot; This shouldn&apos;t really happen, because the folder logic initially creates the packages.
      cl_package_factory=&gt;create_new_package(
        IMPORTING
          e_package                  = li_package
        CHANGING
          c_package_data             = ls_package_data
        EXCEPTIONS
          object_already_existing    = 1
          object_just_created        = 2
          not_authorized             = 3
          wrong_name_prefix          = 4
          undefined_name             = 5
          reserved_local_name        = 6
          invalid_package_name       = 7
          short_text_missing         = 8
          software_component_invalid = 9
          layer_invalid              = 10
          author_not_existing        = 11
          component_not_existing     = 12
          component_missing          = 13
          prefix_in_use              = 14
          unexpected_error           = 15
          intern_err                 = 16
          no_access                  = 17
*          invalid_translation_depth  = 18 downport, does not exist in 7.30
*          wrong_mainpack_value       = 19 downport, does not exist in 7.30
*          superpackage_invalid       = 20 downport, does not exist in 7.30
*          error_in_cts_checks        = 21 downport, does not exist in 7.31
          OTHERS                     = 22 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.
    ENDIF.

    &quot; Load package interface usages
    TRY.
        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;PERMISSION&apos;
          CHANGING
            cg_data = lt_usage_data ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
        &quot; No permissions saved
    ENDTRY.

    LOOP AT lt_usage_data ASSIGNING &lt;ls_usage_data&gt;.
      &lt;ls_usage_data&gt;-client_pak = mv_local_devclass.
    ENDLOOP.

    update_pinf_usages( ii_package    = li_package
                        it_usage_data = lt_usage_data ).

    ls_save_sign-pack = ls_save_sign-permis = ls_save_sign-elems = ls_save_sign-interf = abap_true.
    li_package-&gt;save_generic(
      EXPORTING
        i_save_sign           = ls_save_sign
      EXCEPTIONS
        cancelled_in_corr     = 1
        permission_failure    = 2
        object_not_changeable = 3
        object_invalid        = 4
        OTHERS                = 5 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    set_lock( ii_package = li_package iv_lock = abap_false ).
  ENDMETHOD.
  METHOD zif_abapgit_object~exists.
    &quot; Check remote package if deserialize has not been called before this
    IF mv_local_devclass IS INITIAL.
      rv_bool = abap_false.
    ELSE.
      cl_package_helper=&gt;check_package_existence(
        EXPORTING
          i_package_name          = mv_local_devclass
        IMPORTING
          e_package_exists        = rv_bool
        EXCEPTIONS
          intern_err              = 1
          OTHERS                  = 2 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |DV{ ms_item-obj_name }|.
    OVERLAY lv_object WITH &apos;                                          &apos;.
    lv_object = lv_object &amp;&amp; &apos;*&apos;.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;EEUDB&apos;
                                            iv_argument    = lv_object ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.
    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = &apos;DEVC&apos;
        in_new_window       = abap_true
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.
    DATA: ls_package_data TYPE scompkdtln,
          li_package      TYPE REF TO if_package,
          lt_intf_usages  TYPE tpak_permission_to_use_list,
          lt_usage_data   TYPE scomppdata,
          ls_usage_data   TYPE scomppdtln,
          li_usage        TYPE REF TO if_package_permission_to_use.

    FIELD-SYMBOLS: &lt;lg_field&gt; TYPE any.
    li_package = get_package( ).
    IF li_package IS NOT BOUND.
      zcx_abapgit_exception=&gt;raise( |Could not find package to serialize.| ).
    ENDIF.

    li_package-&gt;get_all_attributes(
      IMPORTING
        e_package_data  = ls_package_data
      EXCEPTIONS
        object_invalid  = 1
        package_deleted = 2
        intern_err      = 3
        OTHERS          = 4 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    CLEAR: ls_package_data-devclass,
           ls_package_data-parentcl.

    &quot; Clear administrative data to prevent diffs
    CLEAR: ls_package_data-created_by,
           ls_package_data-created_on,
           ls_package_data-changed_by,
           ls_package_data-changed_on,
           ls_package_data-as4user.

    &quot; Clear text descriptions that might be localized
    CLEAR: ls_package_data-comp_text,
           ls_package_data-dlvu_text,
           ls_package_data-layer_text.

    ASSIGN COMPONENT &apos;TRANSLATION_DEPTH_TEXT&apos;
           OF STRUCTURE ls_package_data
           TO &lt;lg_field&gt;.
    IF sy-subrc = 0.
      CLEAR: &lt;lg_field&gt;.
    ENDIF.

    ASSIGN COMPONENT &apos;TRANSLATION_GRAPH_DEPTH_TEXT&apos;
           OF STRUCTURE ls_package_data
           TO &lt;lg_field&gt;.
    IF sy-subrc = 0.
      CLEAR: &lt;lg_field&gt;.
    ENDIF.

    &quot; Clear things related to local installation package
    CLEAR: ls_package_data-namespace,
           ls_package_data-dlvunit,
           ls_package_data-pdevclass.

    &quot; Not usable on customer systems
    ASSIGN COMPONENT &apos;TRANSLATION_DEPTH&apos;
           OF STRUCTURE ls_package_data
           TO &lt;lg_field&gt;.
    IF sy-subrc = 0.
      CLEAR: &lt;lg_field&gt;.
    ENDIF.

    ASSIGN COMPONENT &apos;TRANSLATION_GRAPH_DEPTH&apos;
           OF STRUCTURE ls_package_data
           TO &lt;lg_field&gt;.
    IF sy-subrc = 0.
      CLEAR: &lt;lg_field&gt;.
    ENDIF.

    CLEAR: ls_package_data-korrflag.

    io_xml-&gt;add( iv_name = &apos;DEVC&apos; ig_data = ls_package_data ).

    &quot; Save package interface usages
    li_package-&gt;get_permissions_to_use(
      IMPORTING
        e_permissions    = lt_intf_usages
      EXCEPTIONS
        object_invalid   = 1
        unexpected_error = 2
        OTHERS           = 3 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    LOOP AT lt_intf_usages INTO li_usage.
      li_usage-&gt;get_all_attributes(
        IMPORTING
          e_permission_data = ls_usage_data
        EXCEPTIONS
          object_invalid    = 1
          intern_err        = 2
          OTHERS            = 3 ).
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise_t100( ).
      ENDIF.

      CLEAR: ls_usage_data-pack_name, ls_usage_data-client_pak.

      APPEND ls_usage_data TO lt_usage_data.
    ENDLOOP.

    IF lt_usage_data IS NOT INITIAL.
      io_xml-&gt;add( iv_name = &apos;PERMISSION&apos; ig_data = lt_usage_data ).
    ENDIF.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_ddlx IMPLEMENTATION.
  METHOD clear_field.

    FIELD-SYMBOLS: &lt;lg_field&gt; TYPE data.

    ASSIGN COMPONENT iv_fieldname
           OF STRUCTURE cs_metadata
           TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.

    CLEAR: &lt;lg_field&gt;.

  ENDMETHOD.
  METHOD clear_fields.

    FIELD-SYMBOLS: &lt;lg_metadata&gt; TYPE any.

    ASSIGN COMPONENT &apos;METADATA&apos;
           OF STRUCTURE cs_data
           TO &lt;lg_metadata&gt;.
    ASSERT sy-subrc = 0.

    clear_field( EXPORTING iv_fieldname = &apos;CHANGED_AT&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;CHANGED_BY&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;CREATED_AT&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;CREATED_BY&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;RESPONSIBLE&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;PACKAGE_REF-NAME&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

    clear_field( EXPORTING iv_fieldname = &apos;CONTAINER_REF-PACKAGE_NAME&apos;
                 CHANGING  cs_metadata  = &lt;lg_metadata&gt; ).

  ENDMETHOD.
  METHOD get_persistence.

    DATA: lx_error TYPE REF TO cx_root.

    TRY.
        IF mo_persistence IS NOT BOUND.

          CREATE OBJECT mo_persistence
                 TYPE (&apos;CL_DDLX_ADT_OBJECT_PERSIST&apos;).

        ENDIF.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    ri_persistence = mo_persistence.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_object_key TYPE seu_objkey,
          li_data_model TYPE REF TO if_wb_object_data_model,
          lx_error      TYPE REF TO cx_root.
    lv_object_key = ms_item-obj_name.

    TRY.
        CREATE OBJECT li_data_model TYPE (&apos;CL_DDLX_WB_OBJECT_DATA&apos;).

        get_persistence( )-&gt;delete( p_object_key = lv_object_key
                                    p_version    = swbm_version_active ).

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: li_data_model TYPE REF TO if_wb_object_data_model,
          lr_data       TYPE REF TO data,
          lx_error      TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;    TYPE any,
                   &lt;lg_source&gt;  TYPE data,
                   &lt;lg_version&gt; TYPE data.

    TRY.
        CREATE DATA lr_data
          TYPE (&apos;CL_DDLX_WB_OBJECT_DATA=&gt;TY_OBJECT_DATA&apos;).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;DDLX&apos;
          CHANGING
            cg_data = &lt;lg_data&gt; ).

        ASSIGN COMPONENT &apos;CONTENT-SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_source&gt;.
        ASSERT sy-subrc = 0.

        TRY.
            &quot; If the file doesn&apos;t exist that&apos;s ok, because previously
            &quot; the source code was stored in the xml. We are downward compatible.
            &lt;lg_source&gt; = mo_files-&gt;read_string( &apos;asddlxs&apos; ) ##no_text.
          CATCH zcx_abapgit_exception.
        ENDTRY.

        CREATE OBJECT li_data_model
          TYPE (&apos;CL_DDLX_WB_OBJECT_DATA&apos;).

        ASSIGN COMPONENT &apos;METADATA-VERSION&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_version&gt;.
        ASSERT sy-subrc = 0.

        &quot; We have to always save as inactive. Standard activation below activates then
        &quot; and also creates transport request entry if necessary
        &lt;lg_version&gt; = &apos;inactive&apos;.

        li_data_model-&gt;set_data( &lt;lg_data&gt; ).

        get_persistence( )-&gt;save( li_data_model ).

        tadir_insert( iv_package ).

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_object_key TYPE seu_objkey.

    lv_object_key = ms_item-obj_name.

    rv_bool = abap_true.

    TRY.
        get_persistence( )-&gt;get( p_object_key           = lv_object_key
                                 p_version              = swbm_version_active
                                 p_existence_check_only = abap_true ).

      CATCH cx_swb_exception.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    TRY.
        jump_adt( iv_obj_name = ms_item-obj_name
                  iv_obj_type = ms_item-obj_type ).

      CATCH zcx_abapgit_exception.
        zcx_abapgit_exception=&gt;raise( &apos;DDLX Jump Error&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lv_object_key  TYPE seu_objkey,
          li_data_model  TYPE REF TO if_wb_object_data_model,
          li_persistence TYPE REF TO if_wb_object_persist,
          lr_data        TYPE REF TO data,
          lx_error       TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE data.

    lv_object_key = ms_item-obj_name.

    TRY.
        CREATE DATA lr_data
          TYPE (&apos;CL_DDLX_WB_OBJECT_DATA=&gt;TY_OBJECT_DATA&apos;).
        ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

        CREATE OBJECT li_data_model
          TYPE (&apos;CL_DDLX_WB_OBJECT_DATA&apos;).

        li_persistence = get_persistence( ).
        li_persistence-&gt;get(
          EXPORTING
            p_object_key  = lv_object_key
            p_version     = swbm_version_active
          CHANGING
            p_object_data = li_data_model ).

        li_data_model-&gt;get_data(
          IMPORTING
            p_data = &lt;lg_data&gt; ).

        clear_fields( CHANGING cs_data = &lt;lg_data&gt; ).

        ASSIGN COMPONENT &apos;CONTENT-SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.

        mo_files-&gt;add_string( iv_ext    = &apos;asddlxs&apos;
                              iv_string = &lt;lg_field&gt; ).

        CLEAR &lt;lg_field&gt;.

        io_xml-&gt;add( iv_name = &apos;DDLX&apos;
                     ig_data = &lt;lg_data&gt; ).

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_DDLS IMPLEMENTATION.
  METHOD open_adt_stob.

    DATA: lr_data  TYPE REF TO data,
          lo_ddl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lt_ddnames&gt;     TYPE STANDARD TABLE.
    FIELD-SYMBOLS: &lt;lt_entity_view&gt; TYPE STANDARD TABLE.
    FIELD-SYMBOLS: &lt;lg_ddnames&gt;     TYPE any.
    FIELD-SYMBOLS: &lt;lg_entity_view&gt; TYPE any.
    FIELD-SYMBOLS: &lt;lg_ddname&gt;      TYPE any.
    FIELD-SYMBOLS: &lt;lg_ddlname&gt;     TYPE any.
    TRY.
        CREATE DATA lr_data TYPE (&apos;IF_DD_DDL_TYPES=&gt;TY_T_DDOBJ&apos;).
        ASSIGN lr_data-&gt;* TO &lt;lt_ddnames&gt;.

        CREATE DATA lr_data LIKE LINE OF &lt;lt_ddnames&gt;.
        ASSIGN lr_data-&gt;* TO &lt;lg_ddnames&gt;.

        CREATE DATA lr_data TYPE (&apos;IF_DD_DDL_TYPES=&gt;TY_T_ENTITY_OF_VIEW&apos;).
        ASSIGN lr_data-&gt;* TO &lt;lt_entity_view&gt;.

        CREATE DATA lr_data LIKE LINE OF &lt;lt_entity_view&gt;.
        ASSIGN lr_data-&gt;* TO &lt;lg_entity_view&gt;.

        CLEAR &lt;lt_ddnames&gt;.
        ASSIGN COMPONENT &apos;NAME&apos; OF STRUCTURE &lt;lg_ddnames&gt; TO &lt;lg_ddname&gt;.
        &lt;lg_ddname&gt; = iv_ddls_name.
        INSERT &lt;lg_ddnames&gt; INTO TABLE &lt;lt_ddnames&gt;.

        CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
          RECEIVING
            handler = lo_ddl.

        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~GET_VIEWNAME_FROM_ENTITYNAME&apos;)
          EXPORTING
            ddnames        = &lt;lt_ddnames&gt;
          IMPORTING
            view_of_entity = &lt;lt_entity_view&gt;.

        READ TABLE &lt;lt_entity_view&gt; ASSIGNING &lt;lg_entity_view&gt; INDEX 1.
        IF sy-subrc = 0.
          ASSIGN COMPONENT &apos;DDLNAME&apos; OF STRUCTURE &lt;lg_entity_view&gt; TO &lt;lg_ddlname&gt;.

          jump_adt( iv_obj_name = &lt;lg_ddlname&gt;
                    iv_obj_type = &apos;DDLS&apos; ).

        ENDIF.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lo_ddl   TYPE REF TO object,
          lr_data  TYPE REF TO data,
          lx_error TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE any.
    CREATE DATA lr_data TYPE (&apos;DDDDLSRCV&apos;).
    ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.
    CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
      RECEIVING
        handler = lo_ddl.

    TRY.
        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~READ&apos;)
          EXPORTING
            name         = ms_item-obj_name
            get_state    = &apos;A&apos;
          IMPORTING
            ddddlsrcv_wa = &lt;lg_data&gt;.

        ASSIGN COMPONENT &apos;AS4USER&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        IF sy-subrc = 0.
          rv_user = &lt;lg_field&gt;.
        ENDIF.
      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_ddl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.
    CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
      RECEIVING
        handler = lo_ddl.

    TRY.
        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~DELETE&apos;)
          EXPORTING
            name = ms_item-obj_name.
      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lo_ddl   TYPE REF TO object,
          lr_data  TYPE REF TO data,
          lx_error TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE any.
    CREATE DATA lr_data TYPE (&apos;DDDDLSRCV&apos;).
    ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

    io_xml-&gt;read( EXPORTING iv_name = &apos;DDLS&apos;
                  CHANGING cg_data  = &lt;lg_data&gt; ).

    ASSIGN COMPONENT &apos;SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    &lt;lg_field&gt; = mo_files-&gt;read_string( &apos;asddls&apos; ) ##no_text.

    CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
      RECEIVING
        handler = lo_ddl.

    TRY.
        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~SAVE&apos;)
          EXPORTING
            name         = ms_item-obj_name
            put_state    = &apos;N&apos;
            ddddlsrcv_wa = &lt;lg_data&gt;.

        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~WRITE_TADIR&apos;)
          EXPORTING
            objectname = ms_item-obj_name
            devclass   = iv_package
            prid       = 0.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_state TYPE objstate,
          lo_ddl   TYPE REF TO object.
    CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
      RECEIVING
        handler = lo_ddl.

    TRY.
        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~READ&apos;)
          EXPORTING
            name      = ms_item-obj_name
            get_state = &apos;A&apos;
          IMPORTING
            got_state = lv_state.
        IF lv_state IS INITIAL.
          rv_bool = abap_false.
        ELSE.
          rv_bool = abap_true.
        ENDIF.
      CATCH cx_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).

    rs_metadata-ddic         = abap_true.
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESDICT&apos;
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    DATA: lv_typename   TYPE typename.
    DATA: lv_ddtypekind TYPE ddtypekind.

    lv_typename = ms_item-obj_name.

    CALL FUNCTION &apos;DDIF_TYPEINFO_GET&apos;
      EXPORTING
        typename = lv_typename
      IMPORTING
        typekind = lv_ddtypekind.

    CASE lv_ddtypekind.
      WHEN &apos;STOB&apos;.
        me-&gt;open_adt_stob( ms_item-obj_name ).
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;DDLS Jump Error&apos; ).
    ENDCASE.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_ddl       TYPE REF TO object,
          lr_data      TYPE REF TO data,
          lt_clr_comps TYPE STANDARD TABLE OF fieldname WITH DEFAULT KEY,
          lx_error     TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE any,
                   &lt;lv_comp&gt;  LIKE LINE OF lt_clr_comps.
    CREATE DATA lr_data TYPE (&apos;DDDDLSRCV&apos;).
    ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

    CALL METHOD (&apos;CL_DD_DDL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
      RECEIVING
        handler = lo_ddl.

    TRY.
        CALL METHOD lo_ddl-&gt;(&apos;IF_DD_DDL_HANDLER~READ&apos;)
          EXPORTING
            name         = ms_item-obj_name
            get_state    = &apos;A&apos;
          IMPORTING
            ddddlsrcv_wa = &lt;lg_data&gt;.
      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    APPEND &apos;AS4USER&apos; TO lt_clr_comps.
    APPEND &apos;AS4DATE&apos; TO lt_clr_comps.
    APPEND &apos;AS4TIME&apos; TO lt_clr_comps.
    APPEND &apos;ACTFLAG&apos; TO lt_clr_comps.
    APPEND &apos;CHGFLAG&apos; TO lt_clr_comps.

    LOOP AT lt_clr_comps ASSIGNING &lt;lv_comp&gt;.
      ASSIGN COMPONENT &lt;lv_comp&gt; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
      IF sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.
      ENDIF.
    ENDLOOP.

    ASSIGN COMPONENT &apos;SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.

    mo_files-&gt;add_string( iv_ext    = &apos;asddls&apos;
                          iv_string = &lt;lg_field&gt; ) ##no_text.

    CLEAR &lt;lg_field&gt;.

    io_xml-&gt;add( iv_name = &apos;DDLS&apos;
                 ig_data = &lt;lg_data&gt; ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_DCLS IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_dcl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.

    TRY.
        CALL METHOD (&apos;CL_ACM_DCL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
          RECEIVING
            ro_handler = lo_dcl.

        CALL METHOD lo_dcl-&gt;(&apos;DELETE&apos;)
          EXPORTING
            iv_dclname = ms_item-obj_name.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lr_data  TYPE REF TO data,
          lo_dcl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE any.
    CREATE DATA lr_data TYPE (&apos;ACM_S_DCLSRC&apos;).
    ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;DCLS&apos;
      CHANGING
        cg_data = &lt;lg_data&gt; ).

    ASSIGN COMPONENT &apos;SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
    ASSERT sy-subrc = 0.
    &lt;lg_field&gt; = mo_files-&gt;read_string( &apos;asdcls&apos; ).

    TRY.
        tadir_insert( iv_package ).

        CALL METHOD (&apos;CL_ACM_DCL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
          RECEIVING
            ro_handler = lo_dcl.

        CALL METHOD lo_dcl-&gt;(&apos;SAVE&apos;)
          EXPORTING
            iv_dclname     = ms_item-obj_name
            iv_put_state   = &apos;I&apos;
            is_dclsrc      = &lt;lg_data&gt;
            iv_devclass    = iv_package
            iv_access_mode = &apos;INSERT&apos;.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

    zcl_abapgit_objects_activation=&gt;add_item( ms_item ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lo_dcl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.

    TRY.
        CALL METHOD (&apos;CL_ACM_DCL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
          RECEIVING
            ro_handler = lo_dcl.

        CALL METHOD lo_dcl-&gt;(&apos;CHECK_EXISTENCE&apos;)
          EXPORTING
            iv_objectname = ms_item-obj_name
          RECEIVING
            rv_exists     = rv_bool.

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).

    rs_metadata-delete_tadir = abap_true.
    rs_metadata-late_deser   = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;E_ACMDCLSRC&apos;
                                            iv_argument    = |{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    TRY.

        jump_adt( iv_obj_name = ms_item-obj_name
                  iv_obj_type = ms_item-obj_type ).

      CATCH zcx_abapgit_exception.
        zcx_abapgit_exception=&gt;raise( &apos;DCLS Jump Error&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lr_data  TYPE REF TO data,
          lo_dcl   TYPE REF TO object,
          lx_error TYPE REF TO cx_root.

    FIELD-SYMBOLS: &lt;lg_data&gt;  TYPE any,
                   &lt;lg_field&gt; TYPE any.
    CREATE DATA lr_data TYPE (&apos;ACM_S_DCLSRC&apos;).
    ASSIGN lr_data-&gt;* TO &lt;lg_data&gt;.

    TRY.
        CALL METHOD (&apos;CL_ACM_DCL_HANDLER_FACTORY&apos;)=&gt;(&apos;CREATE&apos;)
          RECEIVING
            ro_handler = lo_dcl.

        CALL METHOD lo_dcl-&gt;(&apos;READ&apos;)
          EXPORTING
            iv_dclname = ms_item-obj_name
          IMPORTING
            es_dclsrc  = &lt;lg_data&gt;.

        ASSIGN COMPONENT &apos;AS4USER&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;AS4DATE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;AS4TIME&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CREATED_BY&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;CREATED_DATE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.
        CLEAR &lt;lg_field&gt;.

        ASSIGN COMPONENT &apos;SOURCE&apos; OF STRUCTURE &lt;lg_data&gt; TO &lt;lg_field&gt;.
        ASSERT sy-subrc = 0.

        mo_files-&gt;add_string( iv_ext = &apos;asdcls&apos;  iv_string = &lt;lg_field&gt; ).

        CLEAR &lt;lg_field&gt;.

        io_xml-&gt;add( iv_name = &apos;DCLS&apos;
                     ig_data = &lt;lg_data&gt; ).

      CATCH cx_root INTO lx_error.
        zcx_abapgit_exception=&gt;raise( iv_text     = lx_error-&gt;get_text( )
                                      ix_previous = lx_error ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_cus2 IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_img_attribute = ms_item-obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |TODO: Jump| ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;S_CUS_ATTRIBUTES_EXIST&apos;
      EXPORTING
        img_attribute         = mv_img_attribute
      EXCEPTIONS
        attributes_exists_not = 1
        OTHERS                = 2.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: ls_message TYPE hier_mess.

    CALL FUNCTION &apos;S_CUS_ATTRIBUTES_DELETE&apos;
      EXPORTING
        img_attribute = mv_img_attribute
      IMPORTING
        message       = ls_message.

    IF ls_message-msgty &lt;&gt; &apos;S&apos;.
      zcx_abapgit_exception=&gt;raise( |error from delete CUS2 { mv_img_attribute } S_CUS_ATTRIBUTES_DELETE| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_customizing_attribute TYPE ty_customizing_attribute.

    CALL FUNCTION &apos;S_CUS_ATTRIBUTES_READ&apos;
      EXPORTING
        img_attribute                 = mv_img_attribute
      IMPORTING
        attribute_header              = ls_customizing_attribute-header
      TABLES
        attribute_title               = ls_customizing_attribute-titles
        attribute_countries           = ls_customizing_attribute-countries
        attribute_components          = ls_customizing_attribute-components
        attribute_components_variants = ls_customizing_attribute-components_variants.

    CLEAR: ls_customizing_attribute-header-fdatetime,
           ls_customizing_attribute-header-fuser,
           ls_customizing_attribute-header-ldatetime,
           ls_customizing_attribute-header-luser.

    io_xml-&gt;add( iv_name = &apos;CUS2&apos;
                 ig_data = ls_customizing_attribute ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_customizing_attribute TYPE ty_customizing_attribute,
          ls_message               TYPE hier_mess.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;CUS2&apos;
      CHANGING
        cg_data = ls_customizing_attribute ).

    CALL FUNCTION &apos;S_CUS_ATTRIBUTES_SAVE&apos;
      EXPORTING
        img_attribute         = ls_customizing_attribute-header
      IMPORTING
        message               = ls_message
      TABLES
        attributes_title      = ls_customizing_attribute-titles
        attributes_countries  = ls_customizing_attribute-countries
        attributes_components = ls_customizing_attribute-components.

    IF ls_message-msgty &lt;&gt; &apos;S&apos;.
      zcx_abapgit_exception=&gt;raise( |error from deserialize CUS2 { mv_img_attribute } S_CUS_ATTRIBUTES_SAVE| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = abap_true.
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_cus1 IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_customizing_activity = ms_item-obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |TODO: Jump| ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    CALL FUNCTION &apos;S_CUS_ACTIVITY_EXIST&apos;
      EXPORTING
        activity            = mv_customizing_activity
      EXCEPTIONS
        activity_exists_not = 1
        OTHERS              = 2.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: ls_message TYPE hier_mess.

    CALL FUNCTION &apos;S_CUS_ACTIVITY_DELETE&apos;
      EXPORTING
        activity = mv_customizing_activity
      IMPORTING
        message  = ls_message.

    IF ls_message-msgty &lt;&gt; &apos;S&apos;.
      zcx_abapgit_exception=&gt;raise( |error from delete CUS1 { mv_customizing_activity } S_CUS_ACTIVITY_DELETE| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_customzing_activity TYPE ty_customzing_activity.

    CALL FUNCTION &apos;S_CUS_ACTIVITY_READ&apos;
      EXPORTING
        activity               = mv_customizing_activity
      IMPORTING
        activity_header        = ls_customzing_activity-activity_header
        activity_customer_exit = ls_customzing_activity-activity_customer_exit
      TABLES
        activity_title         = ls_customzing_activity-activity_title
        objects                = ls_customzing_activity-objects
        objects_title          = ls_customzing_activity-objects_title.

    CLEAR: ls_customzing_activity-activity_header-fdatetime,
           ls_customzing_activity-activity_header-fuser,
           ls_customzing_activity-activity_header-ldatetime,
           ls_customzing_activity-activity_header-luser.

    io_xml-&gt;add( iv_name = &apos;CUS1&apos;
                 ig_data = ls_customzing_activity ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_customzing_activity TYPE ty_customzing_activity,
          ls_message             TYPE hier_mess.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;CUS1&apos;
      CHANGING
        cg_data = ls_customzing_activity ).

    CALL FUNCTION &apos;S_CUS_ACTIVITY_SAVE&apos;
      EXPORTING
        activity                     = ls_customzing_activity-activity_header-act_id
        activity_type                = ls_customzing_activity-activity_header-act_type
        tcode                        = ls_customzing_activity-activity_header-tcode
        customer_exit                = ls_customzing_activity-activity_customer_exit-exit_name
        customer_exit_enhancement    = ls_customzing_activity-activity_customer_exit-enhancement
        customer_exit_implementation = ls_customzing_activity-activity_customer_exit-impl_name
      IMPORTING
        message                      = ls_message
      TABLES
        activity_title               = ls_customzing_activity-activity_title
        objects                      = ls_customzing_activity-objects
        objects_texts                = ls_customzing_activity-objects_title.

    IF ls_message-msgty &lt;&gt; &apos;S&apos;.
      zcx_abapgit_exception=&gt;raise( |error from deserialize CUS1 { mv_customizing_activity } S_CUS_ACTIVITY_SAVE| ).
    ENDIF.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = ms_item-obj_type
        mode                = &apos;I&apos;
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = sy-langu
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT, CUS0&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
METHOD zif_abapgit_object~is_active.
    rv_active = abap_true.
  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_OBJECT_CUS0 IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item = is_item
                        iv_language = iv_language ).

    mv_img_activity = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: ls_message TYPE hier_mess.

    CALL FUNCTION &apos;S_CUS_IMG_ACTIVITY_DELETE&apos;
      EXPORTING
        img_activity = mv_img_activity
      IMPORTING
        message      = ls_message.

    IF ls_message-msgty &lt;&gt; &apos;S&apos;.
      zcx_abapgit_exception=&gt;raise( |error from delete CUS0 { mv_img_activity } S_CUS_IMG_ACTIVITY_DELETE| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_img_activity TYPE ty_img_activity,
          ls_text         LIKE LINE OF ls_img_activity-texts.

    io_xml-&gt;read(
      EXPORTING
        iv_name = &apos;CUS0&apos;
      CHANGING
        cg_data = ls_img_activity ).

    READ TABLE ls_img_activity-texts INTO ls_text
                                     WITH KEY spras = sy-langu.

    CALL FUNCTION &apos;S_CUS_IMG_ACTIVITY_SAVE&apos;
      EXPORTING
        img_activity  = ls_img_activity-header-activity
        i_docu        = ls_img_activity-header-docu_id
        i_attributes  = ls_img_activity-header-attributes
        i_activity    = ls_img_activity-header-c_activity
        i_description = ls_text
        i_tcode       = ls_img_activity-header-tcode.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = ms_item-obj_type
        mode                = &apos;I&apos;
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = sy-langu
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT, CUS0&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: ls_message TYPE hier_mess.

    CALL FUNCTION &apos;S_CUS_IMG_ACTIVITY_EXISTS&apos;
      EXPORTING
        img_activity = mv_img_activity
      IMPORTING
        message      = ls_message.

    rv_bool = boolc( ls_message IS INITIAL ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |TODO: Jump| ).

*   doesn&apos;t work...
*    CALL FUNCTION &apos;S_CUS_IMG_ACTIVITY_MAINTAIN&apos;
*      EXPORTING
*        i_display        = &apos;X&apos;
*        i_no_replacement = &apos;X&apos;
*      CHANGING
*        img_activity     = mv_img_activity.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_img_activity TYPE ty_img_activity.

    CALL FUNCTION &apos;S_CUS_IMG_ACTIVITY_READ&apos;
      EXPORTING
        img_activity        = mv_img_activity
      IMPORTING
        img_activity_header = ls_img_activity-header
      TABLES
        img_activity_texts  = ls_img_activity-texts.

    CLEAR: ls_img_activity-header-fuser,
           ls_img_activity-header-fdate,
           ls_img_activity-header-ftime,
           ls_img_activity-header-luser,
           ls_img_activity-header-ldate,
           ls_img_activity-header-ltime.

    io_xml-&gt;add( iv_name = &apos;CUS0&apos;
                 ig_data = ls_img_activity ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = abap_true.
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_cmpt IMPLEMENTATION.
  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    TRY.
        CALL METHOD (&apos;CL_CMP_TEMPLATE&apos;)=&gt;(&apos;S_GET_DB_ACCESS&apos;)
          RECEIVING
            r_ref_db_access = mo_cmp_db.

      CATCH cx_root.
    ENDTRY.

    mv_name = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lo_cmp_template TYPE REF TO object.

    TRY.
        CALL METHOD (&apos;CL_CMP_TEMPLATE&apos;)=&gt;(&apos;S_CREATE_FROM_DB&apos;)
          EXPORTING
            i_name         = mv_name
            i_version      = &apos;A&apos;
          RECEIVING
            r_ref_template = lo_cmp_template.

        CALL METHOD lo_cmp_template-&gt;(&apos;IF_CMP_TEMPLATE_EDIT~GET_CHANGE_USER&apos;)
          RECEIVING
            r_user = rv_user.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;CMPT not supported&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.

    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.

  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lv_deleted TYPE abap_bool.

    TRY.
        CALL METHOD mo_cmp_db-&gt;(&apos;IF_CMP_TEMPLATE_DB~DELETE_TEMPLATE&apos;)
          EXPORTING
            i_name        = mv_name
            i_version     = &apos;A&apos;
            i_flg_header  = abap_true
            i_flg_lines   = abap_true
          RECEIVING
            r_flg_deleted = lv_deleted.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;CMPT not supported&apos; ).
    ENDTRY.

    IF lv_deleted = abap_false.
      zcx_abapgit_exception=&gt;raise( |Error deleting CMPT { ms_item-obj_name }| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lr_template TYPE REF TO data.
    FIELD-SYMBOLS: &lt;lg_template&gt; TYPE any.

    TRY.
        CREATE DATA lr_template TYPE (&apos;IF_CMP_TEMPLATE_DB=&gt;TYP_TEMPLATE&apos;).
        ASSIGN lr_template-&gt;* TO &lt;lg_template&gt;.

        io_xml-&gt;read(
          EXPORTING
            iv_name = &apos;CMPT&apos;
          CHANGING
            cg_data = &lt;lg_template&gt; ).

        CALL METHOD mo_cmp_db-&gt;(&apos;IF_CMP_TEMPLATE_DB~SAVE_TEMPLATE&apos;)
          EXPORTING
            i_template_db = &lt;lg_template&gt;
            i_flg_header  = abap_true
            i_flg_lines   = abap_true.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;CMPT not supported&apos; ).
    ENDTRY.

    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = ms_item-obj_name
        object_class        = ms_item-obj_type
        mode                = &apos;I&apos;
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = mv_language
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from RS_CORR_INSERT, CMPT&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    TRY.
        CALL METHOD (&apos;CL_CMP_TEMPLATE&apos;)=&gt;(&apos;S_TEMPLATE_EXISTS&apos;)
          EXPORTING
            i_name       = mv_name
            i_version    = &apos;A&apos;
          RECEIVING
            r_flg_exists = rv_bool.

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;CMPT not supported&apos; ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_TOOL_ACCESS, CMPT| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lr_template TYPE REF TO data.
    FIELD-SYMBOLS: &lt;lg_template&gt; TYPE any.

    TRY.
        CREATE DATA lr_template TYPE (&apos;IF_CMP_TEMPLATE_DB=&gt;TYP_TEMPLATE&apos;).
        ASSIGN lr_template-&gt;* TO &lt;lg_template&gt;.

        CALL METHOD mo_cmp_db-&gt;(&apos;IF_CMP_TEMPLATE_DB~READ_TEMPLATE&apos;)
          EXPORTING
            i_name     = |{ ms_item-obj_name }|
            i_version  = &apos;A&apos;
          RECEIVING
            r_template = &lt;lg_template&gt;.

        io_xml-&gt;add( iv_name = &apos;CMPT&apos;
                     ig_data = &lt;lg_template&gt; ).

      CATCH cx_root.
        zcx_abapgit_exception=&gt;raise( &apos;CMPT not supported&apos; ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_clas_new IMPLEMENTATION.

  METHOD get_metadata.
    rs_metadata = super-&gt;get_metadata( ).
    rs_metadata-class = &apos;ZCL_ABAPGIT_OBJECT_CLAS&apos;.
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_clas IMPLEMENTATION.

  METHOD constructor.
    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    CREATE OBJECT mi_object_oriented_object_fct TYPE zcl_abapgit_oo_class_new.
  ENDMETHOD.

  METHOD deserialize_abap.
* same as in zcl_abapgit_object_clas, but without &quot;mo_object_oriented_object_fct-&gt;add_to_activation_list&quot;

    DATA: ls_vseoclass             TYPE vseoclass,
          lt_source                TYPE seop_source_string,
          lt_local_definitions     TYPE seop_source_string,
          lt_local_implementations TYPE seop_source_string,
          lt_local_macros          TYPE seop_source_string,
          lt_test_classes          TYPE seop_source_string,
          lt_descriptions          TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
          ls_class_key             TYPE seoclskey,
          lt_attributes            TYPE zif_abapgit_definitions=&gt;ty_obj_attribute_tt.
    lt_source = mo_files-&gt;read_abap( ).

    lt_local_definitions = mo_files-&gt;read_abap( iv_extra = &apos;locals_def&apos;
                                                iv_error = abap_false ). &quot;#EC NOTEXT

    lt_local_implementations = mo_files-&gt;read_abap( iv_extra = &apos;locals_imp&apos;
                                                    iv_error = abap_false ). &quot;#EC NOTEXT

    lt_local_macros = mo_files-&gt;read_abap( iv_extra = &apos;macros&apos;
                                           iv_error = abap_false ). &quot;#EC NOTEXT

    lt_test_classes = mo_files-&gt;read_abap( iv_extra = &apos;testclasses&apos;
                                           iv_error = abap_false ). &quot;#EC NOTEXT

    ls_class_key-clsname = ms_item-obj_name.

    io_xml-&gt;read( EXPORTING iv_name = &apos;VSEOCLASS&apos;
                  CHANGING  cg_data = ls_vseoclass ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;ATTRIBUTES&apos;
                  CHANGING  cg_data = lt_attributes ).

    mi_object_oriented_object_fct-&gt;create(
      EXPORTING
        iv_package    = iv_package
        it_attributes = lt_attributes
      CHANGING
        cg_properties = ls_vseoclass ).

    mi_object_oriented_object_fct-&gt;generate_locals(
      is_key                   = ls_class_key
      iv_force                 = seox_true
      it_local_definitions     = lt_local_definitions
      it_local_implementations = lt_local_implementations
      it_local_macros          = lt_local_macros
      it_local_test_classes    = lt_test_classes ).

    mi_object_oriented_object_fct-&gt;deserialize_source(
      is_key    = ls_class_key
      it_source = lt_source ).

    io_xml-&gt;read( EXPORTING iv_name = &apos;DESCRIPTIONS&apos;
                  CHANGING cg_data = lt_descriptions ).

    mi_object_oriented_object_fct-&gt;update_descriptions(
      is_key          = ls_class_key
      it_descriptions = lt_descriptions ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_includes,
             programm TYPE programm,
           END OF ty_includes.

    TYPES: BEGIN OF ty_reposrc,
             unam  TYPE reposrc-unam,
             udat  TYPE reposrc-udat,
             utime TYPE reposrc-utime,
           END OF ty_reposrc.

    DATA: lt_reposrc  TYPE STANDARD TABLE OF ty_reposrc,
          ls_reposrc  LIKE LINE OF lt_reposrc,
          lt_includes TYPE STANDARD TABLE OF ty_includes.

    lt_includes = mi_object_oriented_object_fct-&gt;get_includes( ms_item-obj_name ).
    ASSERT lines( lt_includes ) &gt; 0.

    SELECT unam udat utime FROM reposrc
      INTO TABLE lt_reposrc
      FOR ALL ENTRIES IN lt_includes
      WHERE progname = lt_includes-programm
      AND   r3state = &apos;A&apos;.
    IF sy-subrc &lt;&gt; 0.
      rv_user = c_user_unknown.
    ELSE.
      SORT lt_reposrc BY udat DESCENDING utime DESCENDING.
      READ TABLE lt_reposrc INDEX 1 INTO ls_reposrc.
      ASSERT sy-subrc = 0.
      rv_user = ls_reposrc-unam.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.
    DATA: ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    mi_object_oriented_object_fct-&gt;delete( ls_clskey ).
  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
    deserialize_abap( io_xml     = io_xml
                      iv_package = iv_package ).

    deserialize_tpool( io_xml ).

    deserialize_sotr( io_xml     = io_xml
                      iv_package = iv_package ).

    deserialize_docu( io_xml ).
  ENDMETHOD.
  METHOD zif_abapgit_object~exists.
    DATA: ls_class_key TYPE seoclskey.
    ls_class_key-clsname = ms_item-obj_name.

    rv_bool = mi_object_oriented_object_fct-&gt;exists( ls_class_key ).
  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    DATA: lt_includes TYPE seoincl_t.

    FIELD-SYMBOLS &lt;lv_incl&gt; LIKE LINE OF lt_includes.
    lt_includes = mi_object_oriented_object_fct-&gt;get_includes( ms_item-obj_name ).
    LOOP AT lt_includes ASSIGNING &lt;lv_incl&gt;.
      rv_changed = check_prog_changed_since(
        iv_program   = &lt;lv_incl&gt;
        iv_timestamp = iv_timestamp
        iv_skip_gui  = abap_true ).
      IF rv_changed = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.
    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;CLAS&apos;
        in_new_window = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lt_source    TYPE seop_source_string,
          ls_class_key TYPE seoclskey.

    ls_class_key-clsname = ms_item-obj_name.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        version = seoc_version_active
        force   = seox_true.
    CALL FUNCTION &apos;SEO_BUFFER_REFRESH&apos;
      EXPORTING
        version = seoc_version_inactive
        force   = seox_true.

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap( ls_class_key ).

    mo_files-&gt;add_abap( lt_source ).

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_locals_def ).
    IF lines( lt_source ) &gt; 0.
      mo_files-&gt;add_abap( iv_extra = &apos;locals_def&apos;
                          it_abap  = lt_source ).           &quot;#EC NOTEXT
    ENDIF.

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_locals_imp ).
    IF lines( lt_source ) &gt; 0.
      mo_files-&gt;add_abap( iv_extra = &apos;locals_imp&apos;
                          it_abap  = lt_source ).           &quot;#EC NOTEXT
    ENDIF.

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap(
      is_class_key            = ls_class_key
      iv_type                 = seop_ext_class_testclasses ).

    mv_skip_testclass = mi_object_oriented_object_fct-&gt;get_skip_test_classes( ).
    IF lines( lt_source ) &gt; 0 AND mv_skip_testclass = abap_false.
      mo_files-&gt;add_abap( iv_extra = &apos;testclasses&apos;
                          it_abap  = lt_source ).           &quot;#EC NOTEXT
    ENDIF.

    lt_source = mi_object_oriented_object_fct-&gt;serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_macros ).
    IF lines( lt_source ) &gt; 0.
      mo_files-&gt;add_abap( iv_extra = &apos;macros&apos;
                          it_abap  = lt_source ).           &quot;#EC NOTEXT
    ENDIF.

    serialize_xml( io_xml ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_classpool TYPE program.

    lv_classpool = cl_oo_classname_service=&gt;get_classpool_name( |{ ms_item-obj_name }| ).

    IF is_class_locked( )             = abap_true
    OR is_text_locked( lv_classpool ) = abap_true.

      rv_is_locked = abap_true.

    ENDIF.

  ENDMETHOD.

  METHOD deserialize_docu.

    DATA: lt_lines  TYPE tlinetab,
          lv_object TYPE dokhl-object.

    io_xml-&gt;read( EXPORTING iv_name = &apos;LINES&apos;
                  CHANGING cg_data = lt_lines ).

    IF lines( lt_lines ) = 0.
      RETURN.
    ENDIF.

    lv_object = ms_item-obj_name.

    mi_object_oriented_object_fct-&gt;create_documentation(
      it_lines       = lt_lines
      iv_object_name = lv_object
      iv_language    = mv_language ).
  ENDMETHOD.

  METHOD deserialize_sotr.
    &quot;OTR stands for Online Text Repository
    DATA: lt_sotr    TYPE zif_abapgit_definitions=&gt;ty_sotr_tt.

    io_xml-&gt;read( EXPORTING iv_name = &apos;SOTR&apos;
                  CHANGING cg_data = lt_sotr ).

    IF lines( lt_sotr ) = 0.
      RETURN.
    ENDIF.

    mi_object_oriented_object_fct-&gt;create_sotr(
      iv_package    = iv_package
      it_sotr       = lt_sotr ).
  ENDMETHOD.

  METHOD deserialize_tpool.

    DATA: lv_clsname   TYPE seoclsname,
          lt_tpool_ext TYPE zif_abapgit_definitions=&gt;ty_tpool_tt,
          lt_tpool     TYPE textpool_table.
    io_xml-&gt;read( EXPORTING iv_name = &apos;TPOOL&apos;
                  CHANGING cg_data = lt_tpool_ext ).
    lt_tpool = read_tpool( lt_tpool_ext ).

    IF lines( lt_tpool ) = 0.
      RETURN.
    ENDIF.

    lv_clsname = ms_item-obj_name.

    mi_object_oriented_object_fct-&gt;insert_text_pool(
      iv_class_name = lv_clsname
      it_text_pool  = lt_tpool
      iv_language   = mv_language ).

  ENDMETHOD.

  METHOD serialize_xml.

    DATA: ls_vseoclass    TYPE vseoclass,
          lt_tpool        TYPE textpool_table,
          lt_descriptions TYPE zif_abapgit_definitions=&gt;ty_seocompotx_tt,
          ls_clskey       TYPE seoclskey,
          lt_sotr         TYPE zif_abapgit_definitions=&gt;ty_sotr_tt,
          lt_lines        TYPE tlinetab,
          lt_attributes   TYPE zif_abapgit_definitions=&gt;ty_obj_attribute_tt.

    ls_clskey-clsname = ms_item-obj_name.

    &quot;If class was deserialized with a previous versions of abapGit and current language was different
    &quot;from master language at this time, this call would return SY-LANGU as master language. To fix
    &quot;these objects, set SY-LANGU to master language temporarily.
    zcl_abapgit_language=&gt;set_current_language( mv_language ).

    TRY.
        ls_vseoclass = mi_object_oriented_object_fct-&gt;get_class_properties( ls_clskey ).

      CLEANUP.
        zcl_abapgit_language=&gt;restore_login_language( ).

    ENDTRY.

    zcl_abapgit_language=&gt;restore_login_language( ).

    CLEAR: ls_vseoclass-uuid,
           ls_vseoclass-author,
           ls_vseoclass-createdon,
           ls_vseoclass-changedby,
           ls_vseoclass-changedon,
           ls_vseoclass-r3release,
           ls_vseoclass-chgdanyby,
           ls_vseoclass-chgdanyon.

    IF mv_skip_testclass = abap_true.
      CLEAR ls_vseoclass-with_unit_tests.
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;VSEOCLASS&apos;
                 ig_data = ls_vseoclass ).

    lt_tpool = mi_object_oriented_object_fct-&gt;read_text_pool(
      iv_class_name = ls_clskey-clsname
      iv_language   = mv_language ).
    io_xml-&gt;add( iv_name = &apos;TPOOL&apos;
                 ig_data = add_tpool( lt_tpool ) ).

    IF ls_vseoclass-category = seoc_category_exception.
      lt_sotr =  mi_object_oriented_object_fct-&gt;read_sotr( ms_item-obj_name ).
      IF lines( lt_sotr ) &gt; 0.
        io_xml-&gt;add( iv_name = &apos;SOTR&apos;
                     ig_data = lt_sotr ).
      ENDIF.
    ENDIF.

    lt_lines = mi_object_oriented_object_fct-&gt;read_documentation(
      iv_class_name = ls_clskey-clsname
      iv_language   = mv_language ).
    IF lines( lt_lines ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;LINES&apos;
                   ig_data = lt_lines ).
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct-&gt;read_descriptions( ls_clskey-clsname ).
    IF lines( lt_descriptions ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;DESCRIPTIONS&apos;
                   ig_data = lt_descriptions ).
    ENDIF.

    lt_attributes = mi_object_oriented_object_fct-&gt;read_attributes( ls_clskey-clsname ).
    IF lines( lt_attributes ) &gt; 0.
      io_xml-&gt;add( iv_name = &apos;ATTRIBUTES&apos;
                   ig_data = lt_attributes ).
    ENDIF.

  ENDMETHOD.

  METHOD is_class_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = ms_item-obj_name.
    OVERLAY lv_argument WITH &apos;==============================&apos;.
    lv_argument = lv_argument &amp;&amp; &apos;*&apos;.

    rv_is_class_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ESEOCLASS&apos;
                                                  iv_argument    = lv_argument ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_char IMPLEMENTATION.
  METHOD instantiate_char.

    DATA: lv_new  TYPE abap_bool,
          lv_name TYPE cls_attribute_name.
    SELECT SINGLE name FROM cls_attribute INTO lv_name WHERE name = ms_item-obj_name.
    lv_new = boolc( sy-subrc &lt;&gt; 0 ).
    lv_name = ms_item-obj_name.

    TRY.
        CREATE OBJECT ro_char
          EXPORTING
            im_name       = lv_name
            im_type_group = iv_type_group
            im_new        = lv_new.
      CATCH cx_pak_invalid_data
          cx_pak_not_authorized
          cx_pak_invalid_state
          cx_pak_wb_object_locked.
        zcx_abapgit_exception=&gt;raise( &apos;Error while instantiating CL_CLS_ATTRIBUTE&apos; ).
    ENDTRY.

    IF lv_new = abap_false.
      TRY.
          ro_char-&gt;if_pak_wb_object~lock_and_refresh( ).
        CATCH cx_pak_invalid_data
            cx_pak_not_authorized
            cx_pak_invalid_state
            cx_pak_wb_object_locked.
          zcx_abapgit_exception=&gt;raise( |Could not aquire lock, CHAR { lv_name }| ).
      ENDTRY.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE changed_by FROM cls_attribute INTO rv_user
      WHERE name = ms_item-obj_name
      AND activation_state = &apos;A&apos;.

    IF rv_user IS INITIAL.
      SELECT SINGLE created_by FROM cls_attribute INTO rv_user
        WHERE name = ms_item-obj_name
        AND activation_state = &apos;A&apos;.
    ENDIF.

    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_char       TYPE REF TO cl_cls_attribute,
          lv_type_group TYPE cls_attribute-type_group,
          lx_pak_error  TYPE REF TO cx_root,
          lv_text       TYPE string.
    SELECT SINGLE type_group FROM cls_attribute INTO lv_type_group
      WHERE name = ms_item-obj_name
      AND activation_state = &apos;A&apos;.

    lo_char = instantiate_char( lv_type_group ).

    TRY.
        lo_char-&gt;if_pak_wb_object~delete( ).

        lo_char-&gt;if_pak_wb_object~save( ).

        lo_char-&gt;if_pak_wb_object_internal~unlock( ).

      CATCH cx_pak_invalid_state cx_pak_invalid_data cx_pak_not_authorized INTO lx_pak_error.
        lv_text = lx_pak_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_char        TYPE ty_char,
          ls_description LIKE LINE OF ls_char-cls_attributet,
          lo_char        TYPE REF TO cl_cls_attribute,
          lx_pak_error   TYPE REF TO cx_root,
          lv_text        TYPE string.

    FIELD-SYMBOLS: &lt;ls_value&gt;  LIKE LINE OF ls_char-cls_attr_value,
                   &lt;ls_valuet&gt; LIKE LINE OF ls_char-cls_attr_valuet.
    io_xml-&gt;read( EXPORTING iv_name = &apos;CHAR&apos;
                  CHANGING cg_data = ls_char ).

    tadir_insert( iv_package ).

    lo_char = instantiate_char( ls_char-cls_attribute-type_group ).

    TRY.
        lo_char-&gt;if_cls_attribute~set_kind( ls_char-cls_attribute-kind ).
        lo_char-&gt;if_cls_attribute~set_single_valued( ls_char-cls_attribute-is_single_valued ).
        lo_char-&gt;if_cls_attribute~set_aspect(
          im_aspect_for   = ls_char-cls_attribute-is_aspect_for
          im_aspect_value = ls_char-cls_attribute-aspect_value ).
        lo_char-&gt;if_cls_attribute~set_default_flag( ls_char-cls_attribute-default_flag ).
        lo_char-&gt;if_cls_attribute~set_default_value( ls_char-cls_attribute-default_value ).
        lo_char-&gt;if_cls_attribute~set_sub_object_treatment( ls_char-cls_attribute-sub_obj_treatm ).
        lo_char-&gt;if_cls_attribute~set_automatic_changes_allowed( ls_char-cls_attribute-automatic_change ).
        lo_char-&gt;if_cls_attribute~set_manual_changes_allowed( ls_char-cls_attribute-manu_chag_allow ).
        lo_char-&gt;if_cls_attribute~set_implicit_changes_allowed( ls_char-cls_attribute-implicit_change ).
        lo_char-&gt;if_cls_attribute~set_expl_values_dominate_links( ls_char-cls_attribute-weak_links ).
        lo_char-&gt;if_cls_attribute~set_assignment_package_rule( ls_char-cls_attribute-assignment_devc ).
        lo_char-&gt;if_cls_attribute~set_hide_remark( ls_char-cls_attribute-hide_remark ).
        lo_char-&gt;if_cls_attribute~set_visible_in_customer_system( ls_char-cls_attribute-visible_for_cust ).
        lo_char-&gt;if_cls_attribute~set_value_table( ls_char-cls_attribute-value_table ).
        lo_char-&gt;if_cls_attribute~set_vtable_field( ls_char-cls_attribute-vtable_field ).
        lo_char-&gt;if_cls_attribute~set_vtable_icon_f( ls_char-cls_attribute-vtable_icon_f ).
        lo_char-&gt;if_cls_attribute~set_vtext_langu_f( ls_char-cls_attribute-vtext_langu_f ).
        lo_char-&gt;if_cls_attribute~set_vtext_table( ls_char-cls_attribute-vtext_table ).
        lo_char-&gt;if_cls_attribute~set_vtext_text_f( ls_char-cls_attribute-vtext_text_f ).
        lo_char-&gt;if_cls_attribute~set_vtext_value_f( ls_char-cls_attribute-vtext_value_f ).
        lo_char-&gt;if_cls_attribute~set_existing_objects_only( ls_char-cls_attribute-existing_objects ).
        lo_char-&gt;if_cls_attribute~set_objs_of_typegr( ls_char-cls_attribute-objs_of_typegr ).
        lo_char-&gt;if_cls_attribute~set_obj_values_have_subtypes( ls_char-cls_attribute-objs_w_subtype ).
        lo_char-&gt;if_cls_attribute~set_arbtry_val_type( ls_char-cls_attribute-arbtry_val_type ).

        READ TABLE ls_char-cls_attributet INTO ls_description WITH KEY langu = sy-langu.
        IF sy-subrc &lt;&gt; 0.
          READ TABLE ls_char-cls_attributet INTO ls_description INDEX 1.
        ENDIF.
        lo_char-&gt;if_cls_attribute~set_description( ls_description-text ).

        LOOP AT ls_char-cls_attr_value ASSIGNING &lt;ls_value&gt;.
          &lt;ls_value&gt;-activation_state = &apos;I&apos;.
        ENDLOOP.
        LOOP AT ls_char-cls_attr_valuet ASSIGNING &lt;ls_valuet&gt;.
          &lt;ls_valuet&gt;-activation_state = &apos;I&apos;.
        ENDLOOP.

        lo_char-&gt;if_cls_attribute~set_values(
          im_values   = ls_char-cls_attr_value
          im_values_t = ls_char-cls_attr_valuet ).

        set_default_package( iv_package ).

        lo_char-&gt;if_pak_wb_object~save( ).

        lo_char-&gt;if_pak_wb_object~activate( ).

        lo_char-&gt;if_pak_wb_object_internal~unlock( ).

      CATCH cx_pak_invalid_state cx_pak_invalid_data cx_pak_not_authorized INTO lx_pak_error.
        lv_text = lx_pak_error-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    rv_bool = cl_cls_attribute=&gt;exists_object_attribute( ms_item-obj_name ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = &apos;ECLS_ATTRIBUTE&apos;
                                            iv_argument    = |{ ms_item-obj_name }*| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation           = &apos;SHOW&apos;
        object_name         = ms_item-obj_name
        object_type         = ms_item-obj_type
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error from RS_TOOL_ACCESS, CHAR| ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_char TYPE ty_char.

    CONSTANTS: lc_active TYPE c LENGTH 1 VALUE &apos;A&apos;.
    SELECT SINGLE * FROM cls_attribute INTO ls_char-cls_attribute
      WHERE name = ms_item-obj_name
      AND activation_state = lc_active.
* todo, ASSIGNMENT_DEVC?

    CLEAR: ls_char-cls_attribute-created_by,
           ls_char-cls_attribute-created_on,
           ls_char-cls_attribute-changed_by,
           ls_char-cls_attribute-changed_on.

    SELECT * FROM cls_attributet INTO TABLE ls_char-cls_attributet
      WHERE name = ms_item-obj_name
      AND activation_state = lc_active.

    SELECT * FROM cls_attr_value INTO TABLE ls_char-cls_attr_value
      WHERE name = ms_item-obj_name
      AND activation_state = lc_active.

    SELECT * FROM cls_attr_valuet INTO TABLE ls_char-cls_attr_valuet
      WHERE name = ms_item-obj_name
      AND activation_state = lc_active.

    io_xml-&gt;add( iv_name = &apos;CHAR&apos;
                 ig_data = ls_char ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_avas IMPLEMENTATION.
  METHOD insert_assignments.

    DATA: lt_assignment TYPE STANDARD TABLE OF cls_assignment,
          ls_assignment LIKE LINE OF lt_assignment,
          ls_value      LIKE LINE OF is_avas-values.
    LOOP AT is_avas-values INTO ls_value.
      CLEAR ls_assignment.
      ls_assignment-guid        = is_avas-header-guid.
      ls_assignment-value       = ls_value-value.
      ls_assignment-trobjtype   = is_avas-header-object-trobjtype.
      ls_assignment-sobj_name   = is_avas-header-object-sobj_name.
      ls_assignment-object_type = is_avas-header-object-object_type.
      ls_assignment-sub_key     = is_avas-header-object-sub_key.
      ls_assignment-attribute   = is_avas-header-attribute.
      ls_assignment-set_by      = sy-uname.
      ls_assignment-changed_on  = sy-datum.
      ls_assignment-remark      = ls_value-remark.
      APPEND ls_assignment TO lt_assignment.
    ENDLOOP.

    DELETE FROM cls_assignment WHERE guid = is_avas-header-guid.

    INSERT cls_assignment FROM TABLE lt_assignment.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Error inserting into CLS_ASSIGNMENT| ).
    ENDIF.

  ENDMETHOD.
  METHOD insert_links.

* todo, how does links work?
*    LOOP AT ls_avas-links INTO ls_linked_obj.
*    ENDLOOP.

**    DELETE FROM cls_linked_obj WHERE guid = ls_avas-header-guid.
**    INSERT cls_linked_obj FROM TABLE lt_linked.
*    if sy-subrc &lt;&gt; 0.
*    endif.

  ENDMETHOD.
  METHOD instantiate.

    DATA: lv_id  TYPE guid_32,
          lo_err TYPE REF TO cx_root.

    lv_id = ms_item-obj_name.

    TRY.
        CREATE OBJECT ro_avas
          EXPORTING
            im_assignment_id = lv_id.
      CATCH cx_pak_wb_object_locked INTO lo_err.
        zcx_abapgit_exception=&gt;raise( |AVAS { lv_id }: locked: { lo_err-&gt;get_longtext( ) }| ).
      CATCH cx_pak_not_authorized INTO lo_err.
        zcx_abapgit_exception=&gt;raise( |AVAS { lv_id }: not authorized: { lo_err-&gt;get_longtext( ) }| ).
      CATCH cx_pak_invalid_state INTO lo_err.
        zcx_abapgit_exception=&gt;raise( |AVAS { lv_id }: invalid state: { lo_err-&gt;get_longtext( ) }| ).
      CATCH cx_pak_invalid_data INTO lo_err.
        zcx_abapgit_exception=&gt;raise( |AVAS { lv_id }: invalid data: { lo_err-&gt;get_longtext( ) }| ).
    ENDTRY.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.

    DATA: lo_avas TYPE REF TO cl_cls_attr_value_assignment.
    lo_avas = instantiate( ).

    lo_avas-&gt;if_pak_wb_object~get_last_changed(
      IMPORTING
        ex_changed_by = rv_user ).

    IF rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_avas TYPE REF TO cl_cls_attr_value_assignment.
    lo_avas = instantiate( ).

    TRY.
        lo_avas-&gt;if_cls_attr_value_assignment~lock_and_refresh(
          im_allow_popups = abap_false ).
      CATCH cx_pak_invalid_state
          cx_pak_invalid_data
          cx_pak_not_authorized
          cx_pak_wb_object_locked.
        zcx_abapgit_exception=&gt;raise( |AVAS error| ).
    ENDTRY.

    lo_avas-&gt;if_pak_wb_object~delete( ).

    lo_avas-&gt;if_pak_wb_object~save( ).

    lo_avas-&gt;if_pak_wb_object_internal~unlock( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: ls_avas TYPE ty_avas.
    io_xml-&gt;read( EXPORTING iv_name = &apos;AVAS&apos;
                  CHANGING cg_data = ls_avas ).

* The AVAS API cannot be used in this case, as it will always create a new GUID

    ASSERT NOT ls_avas-header-guid IS INITIAL.

    tadir_insert( iv_package ).

    insert_assignments( ls_avas ).
    insert_links( ls_avas ).

* corr_insert?

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lv_guid TYPE cls_assignment-guid.

    SELECT SINGLE guid FROM cls_assignment INTO lv_guid
      WHERE guid = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for(
      iv_lock_object = &apos;CLS_ENQUEUE_STRU&apos;
      iv_argument    = |{ ms_item-obj_name }| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |Todo, AVAS jump| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_avas TYPE REF TO cl_cls_attr_value_assignment,
          ls_avas TYPE ty_avas.

    FIELD-SYMBOLS: &lt;ls_value&gt; LIKE LINE OF ls_avas-values,
                   &lt;ls_link&gt;  LIKE LINE OF ls_avas-links.
    lo_avas = instantiate( ).

    ls_avas-header-guid      = lo_avas-&gt;if_cls_attr_value_assignment~get_guid( ).
    ls_avas-header-attribute = lo_avas-&gt;if_cls_attr_value_assignment~get_attribute( ).
    ls_avas-header-object    = lo_avas-&gt;if_cls_attr_value_assignment~get_object( ).

    lo_avas-&gt;if_cls_attr_value_assignment~get_values(
      IMPORTING
        ex_values = ls_avas-values ).

    lo_avas-&gt;if_cls_attr_value_assignment~get_links(
      IMPORTING
        ex_links = ls_avas-links ).

    LOOP AT ls_avas-values ASSIGNING &lt;ls_value&gt;.
      CLEAR: &lt;ls_value&gt;-set_by, &lt;ls_value&gt;-changed_on.
    ENDLOOP.

    LOOP AT ls_avas-links ASSIGNING &lt;ls_link&gt;.
      CLEAR: &lt;ls_link&gt;-set_by, &lt;ls_link&gt;-changed_on.
    ENDLOOP.

    io_xml-&gt;add(
      iv_name = &apos;AVAS&apos;
      ig_data = ls_avas ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_object_auth IMPLEMENTATION.

  METHOD constructor.

    super-&gt;constructor( is_item     = is_item
                        iv_language = iv_language ).

    mv_fieldname = ms_item-obj_name.

  ENDMETHOD.
  METHOD zif_abapgit_object~changed_by.
* looks like &quot;changed by user&quot; is not stored in the database
    rv_user = c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    &quot; there is a bug in SAP standard, the TADIR entries are not deleted
    &quot; when the AUTH object is deleted in transaction SU20

    &quot; FM SUSR_AUTF_DELETE_FIELD calls the UI, therefore we reimplement its logic

    DATA:
      lt_objlst TYPE susr_t_xuobject,
      lo_auth   TYPE REF TO cl_auth_tools,
      lv_dummy  TYPE string.

    &quot; authority check
    CREATE OBJECT lo_auth.
    IF lo_auth-&gt;authority_check_suso( actvt     = &apos;06&apos;
                                      fieldname = mv_fieldname ) &lt;&gt; 0.
      MESSAGE e463(01) WITH mv_fieldname INTO lv_dummy.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    &quot; if field is used check
    lt_objlst = lo_auth-&gt;suso_where_used_afield( mv_fieldname ).
    IF lt_objlst IS NOT INITIAL.
      MESSAGE i453(01) WITH mv_fieldname INTO lv_dummy.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    &quot; collect fieldname into a transport task
    IF lo_auth-&gt;add_afield_to_trkorr( mv_fieldname ) &lt;&gt; 0.
      &quot;no transport -&gt; no deletion
      MESSAGE e507(0m) INTO lv_dummy.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

    DELETE FROM authx WHERE fieldname = mv_fieldname.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE e507(0m) INTO lv_dummy.
      zcx_abapgit_exception=&gt;raise_t100( ).
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.
* see include LSAUT_FIELDF02

    DATA: ls_authx TYPE authx,
          lo_auth  TYPE REF TO cl_auth_tools.
    io_xml-&gt;read( EXPORTING iv_name = &apos;AUTHX&apos;
                  CHANGING cg_data = ls_authx ).

    tadir_insert( iv_package ).

    CREATE OBJECT lo_auth.

    IF lo_auth-&gt;add_afield_to_trkorr( ls_authx-fieldname ) &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error deserializing AUTH&apos; ).
    ENDIF.

    MODIFY authx FROM ls_authx.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error deserializing AUTH&apos; ).
    ENDIF.

    CALL FUNCTION &apos;DB_COMMIT&apos;.
    lo_auth-&gt;set_authfld_info_from_db( ls_authx-fieldname ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    SELECT SINGLE fieldname FROM authx
      INTO mv_fieldname
      WHERE fieldname = ms_item-obj_name.               &quot;#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

* TODO, this function module does not exist in 702
    CALL FUNCTION &apos;SU20_MAINTAIN_SNGL&apos;
      EXPORTING
        id_field    = mv_fieldname
        id_wbo_mode = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: ls_authx TYPE authx.
    SELECT SINGLE * FROM authx INTO ls_authx
      WHERE fieldname = ms_item-obj_name.               &quot;#EC CI_GENBUFF
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    io_xml-&gt;add( iv_name = &apos;AUTHX&apos;
                 ig_data = ls_authx ).

  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_asfc IMPLEMENTATION.
  METHOD zif_abapgit_object~changed_by.
    rv_user = zcl_abapgit_objects_super=&gt;c_user_unknown.
  ENDMETHOD.
  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.
  METHOD zif_abapgit_object~delete.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;delete( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~deserialize.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;deserialize(
      iv_package = iv_package
      io_xml     = io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~exists.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    rv_bool = lo_generic-&gt;exists( ).

  ENDMETHOD.
  METHOD zif_abapgit_object~get_metadata.

    rs_metadata = get_metadata( ).
    rs_metadata-delete_tadir = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~has_changed_since.

    rv_changed = abap_true.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~jump.

    zcx_abapgit_exception=&gt;raise( |TODO: Jump| ).

  ENDMETHOD.
  METHOD zif_abapgit_object~serialize.

    DATA: lo_generic TYPE REF TO zcl_abapgit_objects_generic.

    CREATE OBJECT lo_generic
      EXPORTING
        is_item = ms_item.

    lo_generic-&gt;serialize( io_xml ).

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

ENDCLASS.
CLASS zcl_abapgit_object_acid IMPLEMENTATION.

  METHOD zif_abapgit_object~has_changed_since.
    rv_changed = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
* looks like &quot;changed by user&quot; is not stored in the database
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD create_object.

    DATA: lv_name TYPE aab_id_name.
    lv_name = ms_item-obj_name.

    CREATE OBJECT ro_aab
      EXPORTING
        im_name          = lv_name
      EXCEPTIONS
        name_not_allowed = 1
        OTHERS           = 2.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error creating CL_AAB_ID object&apos; ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lo_aab         TYPE REF TO cl_aab_id,
          lv_description TYPE aab_id_descript.
    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_aab = create_object( ).

    lo_aab-&gt;get_descript(
      IMPORTING ex_descript = lv_description
      EXCEPTIONS no_description_found = 1 ).

    io_xml-&gt;add( iv_name = &apos;DESCRIPTION&apos;
                 ig_data = lv_description ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_description TYPE aab_id_descript,
          lo_aab         TYPE REF TO cl_aab_id.
    io_xml-&gt;read( EXPORTING iv_name = &apos;DESCRIPTION&apos;
                  CHANGING cg_data = lv_description ).

    lo_aab = create_object( ).
    lo_aab-&gt;enqueue( ).
    lo_aab-&gt;set_descript( lv_description ).
    tadir_insert( iv_package ).
    lo_aab-&gt;save( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lo_aab TYPE REF TO cl_aab_id.
    lo_aab = create_object( ).
    lo_aab-&gt;enqueue( ).
    lo_aab-&gt;delete(
      EXCEPTIONS
        prop_error       = 1
        propt_error      = 2
        act_error        = 3
        cts_error        = 4
        cts_devclass     = 5
        id_not_found     = 6
        no_authorization = 7
        id_still_used    = 8
        where_used_error = 9
        OTHERS           = 10 ).
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error deleting ACID object&apos; ).
    ENDIF.
    lo_aab-&gt;dequeue( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_state TYPE flag,
          lo_aab   TYPE REF TO cl_aab_id.
    lo_aab = create_object( ).

    lo_aab-&gt;get_state(
      IMPORTING
        ex_state = lv_state ).
    rv_bool = boolc( lv_state = abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
      EXPORTING
        operation     = &apos;SHOW&apos;
        object_name   = ms_item-obj_name
        object_type   = &apos;ACID&apos;
        in_new_window = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~compare_to_remote_version.
    CREATE OBJECT ro_comparison_result TYPE zcl_abapgit_comparison_null.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.
  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_COMPARISON_NULL IMPLEMENTATION.
  METHOD zif_abapgit_comparison_result~is_result_complete_halt.
    rv_response = abap_false.
  ENDMETHOD.
  METHOD zif_abapgit_comparison_result~show_confirmation_dialog.
    RETURN.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_VAL_OBJ_UPL IMPLEMENTATION.
  METHOD get_business_msgs_from_dom.

    &quot; downport from CL_APL_ECATT_VO_UPLOAD

    DATA: li_section            TYPE REF TO if_ixml_element,
          lt_buss_msg_ref       TYPE zif_abapgit_ecatt=&gt;etvo_bus_msg_tabtype,
          lv_exception_occurred TYPE etonoff,
          lo_ecatt_vo           TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    li_section = template_over_all-&gt;find_from_name_ns( &apos;ETVO_MSG&apos; ).

    IF NOT li_section IS INITIAL.
      CALL FUNCTION &apos;SDIXML_DOM_TO_DATA&apos;
        EXPORTING
          data_as_dom    = li_section
        IMPORTING
          dataobject     = lt_buss_msg_ref
        EXCEPTIONS
          illegal_object = 1
          OTHERS         = 2.
      IF sy-subrc &lt;&gt; 0.
        CLEAR lt_buss_msg_ref.
      ENDIF.
    ENDIF.

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    TRY.
        CALL METHOD lo_ecatt_vo-&gt;(&apos;SET_BUSSINESS_MSG&apos;)
          EXPORTING
            im_buss_msg_ref = lt_buss_msg_ref.
      CATCH cx_ecatt_apl INTO exception_to_raise.
        lv_exception_occurred = &apos;X&apos;.
    ENDTRY.

    IF lv_exception_occurred = &apos;X&apos;.
      raise_upload_exception( previous = exception_to_raise ).
    ENDIF.

  ENDMETHOD.
  METHOD get_impl_detail_from_dom.

    &quot; downport from CL_APL_ECATT_VO_UPLOAD

    DATA: li_section            TYPE REF TO if_ixml_element,
          ls_impl_details       TYPE zif_abapgit_ecatt=&gt;etvoimpl_det,
          lv_exception_occurred TYPE etonoff,
          lo_ecatt_vo           TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    li_section = template_over_all-&gt;find_from_name_ns( &apos;IMPL_DET&apos; ).

    IF NOT li_section IS INITIAL.
      CALL FUNCTION &apos;SDIXML_DOM_TO_DATA&apos;
        EXPORTING
          data_as_dom    = li_section
        IMPORTING
          dataobject     = ls_impl_details
        EXCEPTIONS
          illegal_object = 1
          OTHERS         = 2.
      IF sy-subrc &lt;&gt; 0.
        CLEAR ls_impl_details.
      ENDIF.
    ENDIF.

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    TRY.
        CALL METHOD lo_ecatt_vo-&gt;(&apos;SET_IMPL_DETAILS&apos;)
          EXPORTING
            im_impl_details = ls_impl_details.
      CATCH cx_ecatt_apl INTO exception_to_raise.
        lv_exception_occurred = &apos;X&apos;.
    ENDTRY.

    IF lv_exception_occurred = &apos;X&apos;.
      raise_upload_exception( previous = exception_to_raise ).
    ENDIF.

  ENDMETHOD.
  METHOD get_vo_flags_from_dom.

    &quot; downport from CL_APL_ECATT_VO_UPLOAD

    DATA: li_section            TYPE REF TO if_ixml_element,
          lv_error_prio         TYPE zif_abapgit_ecatt=&gt;etvo_error_prio,
          lv_invert_validation  TYPE zif_abapgit_ecatt=&gt;etvo_invert_validation,
          lv_exception_occurred TYPE etonoff,
          lo_ecatt_vo           TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    li_section = template_over_all-&gt;find_from_name_ns( &apos;INVERT_VALIDATION&apos; ).

    IF NOT li_section IS INITIAL.
      CALL FUNCTION &apos;SDIXML_DOM_TO_DATA&apos;
        EXPORTING
          data_as_dom    = li_section
        IMPORTING
          dataobject     = lv_invert_validation
        EXCEPTIONS
          illegal_object = 1
          OTHERS         = 2.
      IF sy-subrc &lt;&gt; 0.
        CLEAR lv_invert_validation.
      ENDIF.
    ENDIF.

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    TRY.
        CALL METHOD lo_ecatt_vo-&gt;(&apos;SET_INVERT_VALIDATION_FLAG&apos;)
          EXPORTING
            im_invert_validation = lv_invert_validation.

      CATCH cx_ecatt_apl INTO exception_to_raise.
        lv_exception_occurred = &apos;X&apos;.
    ENDTRY.

    li_section = template_over_all-&gt;find_from_name_ns( &apos;ERROR_PRIORITY&apos; ).

    IF NOT li_section IS INITIAL.
      CALL FUNCTION &apos;SDIXML_DOM_TO_DATA&apos;
        EXPORTING
          data_as_dom    = li_section
        IMPORTING
          dataobject     = lv_error_prio
        EXCEPTIONS
          illegal_object = 1
          OTHERS         = 2.
      IF sy-subrc &lt;&gt; 0.
        CLEAR lv_invert_validation.
      ENDIF.
    ENDIF.

    TRY.
        CALL METHOD lo_ecatt_vo-&gt;(&apos;SET_ERROR_PRIORITY&apos;)
          EXPORTING
            im_error_prio = lv_error_prio.
      CATCH cx_ecatt_apl INTO exception_to_raise.
        lv_exception_occurred = &apos;X&apos;.
    ENDTRY.

    IF lv_exception_occurred = &apos;X&apos;.
      raise_upload_exception( previous = exception_to_raise ).
    ENDIF.

  ENDMETHOD.
  METHOD upload.

    &quot; We inherit from CL_APL_ECATT_UPLOAD because CL_APL_ECATT_VO_UPLOAD
    &quot; doesn&apos;t exist in 702

    &quot; downport from CL_APL_ECATT_VO_UPLOAD

    DATA: lx_ex       TYPE REF TO cx_ecatt_apl,
          lv_exists   TYPE etonoff,
          lv_exc_occ  TYPE etonoff,
          ls_tadir    TYPE tadir,
          lo_ecatt_vo TYPE REF TO object,
          lo_params   TYPE REF TO cl_apl_ecatt_params.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any,
                   &lt;lg_params&gt;   TYPE data,
                   &lt;lv_d_akh&gt;    TYPE data,
                   &lt;lv_i_akh&gt;    TYPE data.

    TRY.
        ch_object-i_devclass = ch_object-d_devclass.

        ASSIGN COMPONENT &apos;D_AKH&apos; OF STRUCTURE ch_object
               TO &lt;lv_d_akh&gt;. &quot; doesn&apos;t exist in 702
        ASSIGN COMPONENT &apos;I_AKH&apos; OF STRUCTURE ch_object
               TO &lt;lv_i_akh&gt;. &quot; doesn&apos;t exist in 702
        IF &lt;lv_d_akh&gt; IS ASSIGNED AND &lt;lv_i_akh&gt; IS ASSIGNED.
          &lt;lv_i_akh&gt; = &lt;lv_d_akh&gt;.
        ENDIF.

        super-&gt;upload(
          CHANGING
            ch_object = ch_object ).

        upload_data_from_stream( ch_object-filename ).
      CATCH cx_ecatt_apl INTO lx_ex.
        IF template_over_all IS INITIAL.
          RAISE EXCEPTION lx_ex.
        ELSE.
          lv_exc_occ = &apos;X&apos;.
        ENDIF.
    ENDTRY.

    TRY.
        CALL METHOD (&apos;GET_ATTRIBUTES_FROM_DOM_NEW&apos;) &quot; doesn&apos;t exit in 702
          CHANGING
            ch_object = ch_object.
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    ASSIGN lo_ecatt_vo-&gt;(&apos;PARAMS&apos;) TO &lt;lg_params&gt;.
    ASSERT sy-subrc = 0.

    lo_params = &lt;lg_params&gt;.

    TRY.
        get_impl_detail_from_dom( ).
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        get_vo_flags_from_dom( ).
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        get_business_msgs_from_dom( ).
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        CALL METHOD (&apos;GET_PARAMS_FROM_DOM_NEW&apos;) &quot; doesn&apos;t exist in 702
          EXPORTING
            im_params = lo_params.
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        get_variants_from_dom( lo_params ).
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        lv_exists = cl_apl_ecatt_object=&gt;existence_check_object(
                im_name               = ch_object-d_obj_name
                im_version            = ch_object-d_obj_ver
                im_obj_type           = ch_object-s_obj_type
                im_exists_any_version = &apos;X&apos; ).

        IF lv_exists EQ space.
          CALL METHOD lo_ecatt_vo-&gt;(&apos;SET_TADIR_FOR_NEW_OBJECT&apos;)
            EXPORTING
              im_tadir_for_new_object = tadir_preset.
        ENDIF.
      CATCH cx_ecatt.
        CLEAR lv_exists.
    ENDTRY.

    TRY.
        CALL METHOD lo_ecatt_vo-&gt;(&apos;SAVE&apos;)
          EXPORTING
            im_do_commit = &apos;X&apos;.
      CATCH cx_ecatt_apl INTO lx_ex.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

*     get devclass from existing object
    TRY.
        cl_apl_ecatt_object=&gt;get_tadir_entry(
          EXPORTING im_obj_name = ch_object-d_obj_name
                    im_obj_type = ch_object-s_obj_type
          IMPORTING ex_tadir = ls_tadir ).

        ch_object-d_devclass = ls_tadir-devclass.

      CATCH cx_ecatt.
        CLEAR ls_tadir.
    ENDTRY.
    IF lv_exc_occ = &apos;X&apos;.
      raise_upload_exception( previous = lx_ex ).
    ENDIF.

  ENDMETHOD.
  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; downport from CL_ABAPGIT_ECATT_DATA_UPLOAD SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_VAL_OBJ_DOWN IMPLEMENTATION.
  METHOD download.

    &quot; We inherit from CL_APL_ECATT_DOWNLOAD because CL_APL_ECATT_VO_DOWNLOAD
    &quot; doesn&apos;t exist in 702

    &quot; Downport

    DATA: lv_partyp   TYPE string,
          lo_ecatt_vo TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any,
                   &lt;lt_params&gt;   TYPE REF TO cl_apl_ecatt_params.

    load_help = im_load_help.
    typ = im_object_type.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

    lv_partyp = cl_apl_ecatt_const=&gt;params_type_par.
    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    set_attributes_to_template( ).
    set_ecatt_impl_detail( ).
    set_ecatt_flags( ).
    set_business_msgs( ).

    ASSIGN lo_ecatt_vo-&gt;(&apos;PARAMS&apos;)
           TO &lt;lt_params&gt;.
    ASSERT sy-subrc = 0.

    get_general_params_data( im_params = &lt;lt_params&gt;
                             im_ptyp   = lv_partyp ).
    LOOP AT parm INTO wa_parm.
      set_general_params_data_to_dom( ).
      IF NOT wa_parm-val_type IS INITIAL.
        set_deep_stru_to_dom( &lt;lt_params&gt; ).
        set_deep_data_to_dom( im_params = &lt;lt_params&gt;
                              im_pindex = wa_parm-pindex ).
      ENDIF.
    ENDLOOP.

    set_variants_to_dom( &lt;lt_params&gt; ).

    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
  METHOD set_business_msgs.

    DATA:
      lt_buss_msg_ref   TYPE zif_abapgit_ecatt=&gt;etvo_bus_msg_tabtype,
      li_element        TYPE REF TO if_ixml_element,
      li_insert_objects TYPE REF TO if_ixml_element,
      lo_ecatt_vo       TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    mi_objects_node = template_over_all-&gt;create_simple_element(
                                           name   = &apos;BUSINESS_MESSAGES&apos;
                                           parent = root_node ).

    CALL METHOD lo_ecatt_vo-&gt;(&apos;GET_BUSSINESS_MSG&apos;)
      IMPORTING
        ex_buss_msg_ref = lt_buss_msg_ref.

    CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
      EXPORTING
        name         = &apos;ETVO_MSG&apos;
        dataobject   = lt_buss_msg_ref
      IMPORTING
        data_as_dom  = li_element
      CHANGING
        document     = template_over_all
      EXCEPTIONS
        illegal_name = 1
        OTHERS       = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    li_insert_objects ?= template_over_all-&gt;find_from_name( &apos;BUSINESS_MESSAGES&apos; ).

    li_insert_objects-&gt;append_child( new_child = li_element ).

  ENDMETHOD.
  METHOD set_ecatt_flags.

    DATA:
      lv_invert_validation TYPE zif_abapgit_ecatt=&gt;etvo_invert_validation,
      lv_error_prio        TYPE zif_abapgit_ecatt=&gt;etvo_error_prio,
      li_element           TYPE REF TO if_ixml_element,
      li_insert_objects    TYPE REF TO if_ixml_element,
      lo_ecatt_vo          TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    mi_objects_node = template_over_all-&gt;create_simple_element(
                                           name   = &apos;VO_FLAGS&apos;
                                           parent = root_node ).

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    CALL METHOD lo_ecatt_vo-&gt;(&apos;GET_INVERT_VALIDATION_FLAG&apos;)
      RECEIVING
        re_invert_validation = lv_invert_validation.

    CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
      EXPORTING
        name         = &apos;INVERT_VALIDATION&apos;
        dataobject   = lv_invert_validation
      IMPORTING
        data_as_dom  = li_element
      CHANGING
        document     = template_over_all
      EXCEPTIONS
        illegal_name = 1
        OTHERS       = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    li_insert_objects ?= template_over_all-&gt;find_from_name( &apos;VO_FLAGS&apos; ).

    li_insert_objects-&gt;append_child( new_child = li_element ).

    CALL METHOD lo_ecatt_vo-&gt;(&apos;GET_ERROR_PRIORITY&apos;)
      RECEIVING
        re_error_prio = lv_error_prio.

    CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
      EXPORTING
        name         = &apos;ERROR_PRIORITY&apos;
        dataobject   = lv_error_prio
      IMPORTING
        data_as_dom  = li_element
      CHANGING
        document     = template_over_all
      EXCEPTIONS
        illegal_name = 1
        OTHERS       = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    li_insert_objects = template_over_all-&gt;find_from_name( &apos;VO_FLAGS&apos; ).

    li_insert_objects-&gt;append_child( new_child = li_element ).

  ENDMETHOD.
  METHOD set_ecatt_impl_detail.

    DATA:
      ls_impl_details   TYPE zif_abapgit_ecatt=&gt;etvoimpl_det,
      li_element        TYPE REF TO if_ixml_element,
      li_insert_objects TYPE REF TO if_ixml_element,
      lo_ecatt_vo       TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_vo&gt; TYPE any.

    mi_objects_node = template_over_all-&gt;create_simple_element(
                                           name   = &apos;IMPL_DETAILS&apos;
                                           parent = root_node ).

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_vo&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_vo = &lt;lg_ecatt_vo&gt;.

    CALL METHOD lo_ecatt_vo-&gt;(&apos;GET_IMPL_DETAILS&apos;)
      RECEIVING
        re_impl_details = ls_impl_details.

    CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
      EXPORTING
        name         = &apos;IMPL_DET&apos;
        dataobject   = ls_impl_details
      IMPORTING
        data_as_dom  = li_element
      CHANGING
        document     = template_over_all
      EXCEPTIONS
        illegal_name = 1
        OTHERS       = 2.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    li_insert_objects = template_over_all-&gt;find_from_name( &apos;IMPL_DETAILS&apos; ).

    li_insert_objects-&gt;append_child( new_child = li_element ).

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_ecatt_system_upl IMPLEMENTATION.

  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; downport from CL_APL_ECATT_SYSTEMS_UPLOAD SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.

ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_SYSTEM_DOWNL IMPLEMENTATION.
  METHOD download.

    &quot; Downport

    load_help = im_load_help.
    typ = im_object_type.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

* build_schema( ).
* set_attributes_to_schema( ).
    set_attributes_to_template( ).
* set_systems_data_to_schema( ).
    set_systems_data_to_template( ).
* download_schema( ).
    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
  METHOD set_systems_data_to_template.

    DATA: lo_ecatt_systems TYPE REF TO cl_apl_ecatt_system_data,
          lt_sys_data      TYPE etsys_def_tabtype,
          ls_sys_data      TYPE etsys_def,
          li_item          TYPE REF TO if_ixml_element,
          li_sysdata_node  TYPE REF TO if_ixml_element.

    lo_ecatt_systems ?= ecatt_object.
    lt_sys_data = lo_ecatt_systems-&gt;get_system_data( ).

    li_sysdata_node = template_over_all-&gt;create_simple_element(
                        name = &apos;SYSTEMS_DATA&apos;
                        parent = root_node ).

    etpar_node = template_over_all-&gt;create_simple_element(
                   name = &apos;ETSYS_DEF&apos;
                   parent = li_sysdata_node ).

    LOOP AT lt_sys_data INTO ls_sys_data.

      CLEAR: ls_sys_data-sys_desc, ls_sys_data-instance.

      CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
        EXPORTING
          name         = &apos;item&apos;
          dataobject   = ls_sys_data
        IMPORTING
          data_as_dom  = li_item
        CHANGING
          document     = template_over_all
        EXCEPTIONS
          illegal_name = 1
          OTHERS       = 2.

      etpar_node-&gt;append_child( new_child = li_item ).

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_SP_UPLOAD IMPLEMENTATION.
  METHOD get_ecatt_sp.

    &quot; downport

    DATA: li_ixml               TYPE REF TO if_ixml,
          li_section            TYPE REF TO if_ixml_element,
          li_dom                TYPE REF TO if_ixml_document,
          li_root               TYPE REF TO if_ixml_node,
          lv_start_profile      TYPE etxml_line_str,
          lv_exception_occurred TYPE etonoff,
          lo_ecatt_sp           TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_object&gt; TYPE any.

    TRY.
        li_section = template_over_all-&gt;find_from_name_ns( &apos;START_PROFILE&apos; ).

        IF NOT li_section IS INITIAL.
          li_ixml = cl_ixml=&gt;create( ).
          li_dom  = li_ixml-&gt;create_document( ).
          li_root ?= li_section-&gt;clone( ).
          li_dom-&gt;append_child( new_child = li_root ).
          CALL FUNCTION &apos;SDIXML_DOM_TO_XML&apos;
            EXPORTING
              document      = li_dom
            IMPORTING
              xml_as_string = lv_start_profile.

          ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_object&gt;.
          ASSERT sy-subrc = 0.

          lo_ecatt_sp = &lt;lg_ecatt_object&gt;.

          CALL METHOD lo_ecatt_sp-&gt;(&apos;SET_SP_ATTRIBUTES&apos;)
            EXPORTING
              i_sp_xml = lv_start_profile.

        ENDIF.
      CATCH cx_ecatt_apl.
        lv_exception_occurred = &apos;X&apos;.
    ENDTRY.

    IF lv_exception_occurred = &apos;X&apos;.
      raise_upload_exception( previous = exception_to_raise ).
    ENDIF.
  ENDMETHOD.
  METHOD upload.

    &quot; We inherit from CL_APL_ECATT_UPLOAD because CL_APL_ECATT_SP_UPLOAD
    &quot; doesn&apos;t exist in 702

    &quot; Downport

    &quot;26.03.2013

    DATA: lx_ecatt              TYPE REF TO cx_ecatt_apl,
          lv_exists             TYPE etonoff,
          lv_exc_occ            TYPE etonoff,
          ls_tadir              TYPE tadir,
          lo_ecatt_sp           TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_sp&gt; TYPE any,
                   &lt;lv_d_akh&gt;    TYPE data,
                   &lt;lv_i_akh&gt;    TYPE data.

    TRY.
        ch_object-i_devclass = ch_object-d_devclass.

        ASSIGN COMPONENT &apos;D_AKH&apos; OF STRUCTURE ch_object
               TO &lt;lv_d_akh&gt;. &quot; doesn&apos;t exist in 702
        ASSIGN COMPONENT &apos;I_AKH&apos; OF STRUCTURE ch_object
               TO &lt;lv_i_akh&gt;. &quot; doesn&apos;t exist in 702
        IF &lt;lv_d_akh&gt; IS ASSIGNED AND &lt;lv_i_akh&gt; IS ASSIGNED.
          &lt;lv_i_akh&gt; = &lt;lv_d_akh&gt;.
        ENDIF.

        super-&gt;upload(
          CHANGING
            ch_object = ch_object ).

        upload_data_from_stream( ch_object-filename ).

      CATCH cx_ecatt_apl INTO lx_ecatt.
        IF template_over_all IS INITIAL.
          RAISE EXCEPTION lx_ecatt.
        ELSE.
          lv_exc_occ = &apos;X&apos;.
        ENDIF.
    ENDTRY.

    TRY.
        CALL METHOD (&apos;GET_ATTRIBUTES_FROM_DOM_NEW&apos;) &quot; doesn&apos;t exist in 720
          CHANGING
            ch_object = ch_object.
      CATCH cx_ecatt_apl INTO lx_ecatt.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    ASSIGN me-&gt;ecatt_object TO &lt;lg_ecatt_sp&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_sp = &lt;lg_ecatt_sp&gt;.

    TRY.
        get_ecatt_sp( ).
      CATCH cx_ecatt_apl INTO lx_ecatt.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.

    TRY.
        lv_exists = cl_apl_ecatt_object=&gt;existence_check_object(
                      im_name               = ch_object-d_obj_name
                      im_version            = ch_object-d_obj_ver
                      im_obj_type           = ch_object-s_obj_type
                      im_exists_any_version = &apos;X&apos; ).

        IF lv_exists EQ space.
          CALL METHOD lo_ecatt_sp-&gt;(&apos;SET_TADIR_FOR_NEW_OBJECT&apos;)
            EXPORTING
              im_tadir_for_new_object = tadir_preset.
        ENDIF.
      CATCH cx_ecatt.
        CLEAR lv_exists.
    ENDTRY.

    TRY.
        CALL METHOD lo_ecatt_sp-&gt;(&apos;SAVE&apos;)
          EXPORTING
            im_do_commit = &apos;X&apos;.
      CATCH cx_ecatt_apl INTO lx_ecatt.
        lv_exc_occ = &apos;X&apos;.
    ENDTRY.
* Devesh,C5129871  18.07.2011  Releasing enqueu after uploading
*begin
    TRY.
        ecatt_object-&gt;close_object( im_suppress_events =&apos;X&apos; ).
      CATCH cx_ecatt_apl INTO lx_ecatt.
    ENDTRY.
*end
*     get devclass from existing object
    TRY.
        cl_apl_ecatt_object=&gt;get_tadir_entry(
          EXPORTING im_obj_name = ch_object-d_obj_name
                    im_obj_type = ch_object-s_obj_type
          IMPORTING ex_tadir = ls_tadir ).

        ch_object-d_devclass = ls_tadir-devclass.

      CATCH cx_ecatt.
        CLEAR ls_tadir.
    ENDTRY.
    IF lv_exc_occ = &apos;X&apos;.
      raise_upload_exception( previous = lx_ecatt ).
    ENDIF.

  ENDMETHOD.
  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; downport from CL_APL_ECATT_START_PROFIL SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_SP_DOWNLOAD IMPLEMENTATION.
  METHOD download.

    &quot; We inherit from CL_APL_ECATT_DOWNLOAD because CL_APL_ECATT_SP_DOWNLOAD
    &quot; doesn&apos;t exist in 702

    &quot; Downport

    load_help = im_load_help.
    typ = im_object_type.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

    set_attributes_to_template( ).

    set_sp_data_to_template( ).

    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
  METHOD set_sp_data_to_template.

    &quot; downport

    DATA: li_dom                     TYPE REF TO if_ixml_document,
          li_start_profile_data_node TYPE REF TO if_ixml_element,
          li_element                 TYPE REF TO if_ixml_element,
          lv_sp_xml                  TYPE etxml_line_str,
          lo_ecatt_sp                TYPE REF TO object.

    FIELD-SYMBOLS: &lt;lg_ecatt_object&gt; TYPE data.

    li_start_profile_data_node = template_over_all-&gt;create_simple_element(
                                   name = &apos;START_PROFILE&apos;
                                   parent = root_node ).

    ASSIGN (&apos;ECATT_OBJECT&apos;) TO &lt;lg_ecatt_object&gt;.
    ASSERT sy-subrc = 0.

    lo_ecatt_sp = &lt;lg_ecatt_object&gt;.

    TRY.
        CALL METHOD lo_ecatt_sp-&gt;(&apos;GET_SP_ATTRIBUTES&apos;)
          IMPORTING
            e_sp_xml = lv_sp_xml.
      CATCH cx_ecatt_apl.
    ENDTRY.

    CALL FUNCTION &apos;SDIXML_XML_TO_DOM&apos;
      EXPORTING
        xml      = lv_sp_xml
      IMPORTING
        document = li_dom.

    li_element = li_dom-&gt;get_root_element( ).
    li_start_profile_data_node-&gt;append_child( new_child = li_element ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_SCRIPT_UPL IMPLEMENTATION.
  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; downport from CL_ABAPGIT_ECATT_DATA_UPLOAD SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_SCRIPT_DOWNL IMPLEMENTATION.
  METHOD download.

    &quot; Downport

    load_help = im_load_help.
    typ = im_object_type.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

    toolname = ecatt_object-&gt;attrib-&gt;get_tool_name( ).
* build_schema( ).
* set_attributes_to_schema( ).
    set_attributes_to_template( ).

    IF toolname EQ cl_apl_ecatt_const=&gt;toolname_ecatt.

      ecatt_script ?= ecatt_object.

*   set_script_to_schema( ).
      set_script_to_template( ).

*   set_params_to_schema( ).
      TRY.
          get_general_params_data( ecatt_script-&gt;params ).
        CATCH cx_ecatt_apl.                              &quot;#EC NOHANDLER
*         proceed with download and report errors later
      ENDTRY.

      LOOP AT parm INTO wa_parm.
        TRY.
            IF wa_parm-value = &apos;&lt;INITIAL&gt;&apos;.
              CLEAR wa_parm-value.
            ENDIF.
            set_general_params_data_to_dom( ).
            IF NOT wa_parm-pstruc_typ IS INITIAL.
              set_deep_stru_to_dom( ecatt_script-&gt;params ).
              set_deep_data_to_dom( ecatt_script-&gt;params ).
              IF wa_parm-xmlref_typ EQ cl_apl_ecatt_const=&gt;ref_type_c_tcd.
                set_control_data_for_tcd( is_param  =  wa_parm
                                          io_params = ecatt_script-&gt;params ).

              ENDIF.
            ENDIF.
          CATCH cx_ecatt_apl.                            &quot;#EC NOHANDLER
*         proceed with download and report errors later
        ENDTRY.
      ENDLOOP.

    ELSE.

      set_blob_to_template( ).
      set_artmp_to_template( ).

    ENDIF.

* download_schema( ).
    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD escape_control_data.

    &quot; Downport

    DATA: li_iter     TYPE REF TO if_ixml_node_iterator,
          li_textit   TYPE REF TO if_ixml_node_iterator,
          li_abapctrl TYPE REF TO if_ixml_node_collection,
          li_text     TYPE REF TO if_ixml_text,
          li_filter   TYPE REF TO if_ixml_node_filter,
          li_list     TYPE REF TO if_ixml_node_list,
          lv_value    TYPE etdom_name,
          li_vars     TYPE REF TO if_ixml_element,
          li_elem     TYPE REF TO if_ixml_element.

    li_vars = ii_element-&gt;find_from_name_ns( iv_tabname ).
    li_filter = ii_element-&gt;create_filter_node_type(
    if_ixml_node=&gt;co_node_text ).
    IF li_vars IS NOT INITIAL.
      li_abapctrl = ii_element-&gt;get_elements_by_tag_name_ns( iv_node ).

* just for debugging
      li_iter = li_abapctrl-&gt;create_iterator( ).
      li_elem ?= li_iter-&gt;get_next( ).
      WHILE li_elem IS NOT INITIAL.
        li_list = li_elem-&gt;get_children( ).

        li_textit = li_list-&gt;create_rev_iterator_filtered( li_filter  ).
        li_text ?= li_textit-&gt;get_next( ).
        IF li_text IS NOT INITIAL.
          lv_value = li_text-&gt;get_data( ).
          IF lv_value(1) = cl_abap_char_utilities=&gt;minchar.
            REPLACE SECTION OFFSET 0 LENGTH 1 OF lv_value WITH space.
            li_text-&gt;set_value( value = lv_value ).
          ENDIF.
        ENDIF.
        CLEAR: li_textit, li_list, li_elem, lv_value.
        li_elem ?= li_iter-&gt;get_next( ).
      ENDWHILE.
      CLEAR: li_abapctrl, li_elem, li_iter.

    ENDIF.

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
  METHOD set_artmp_to_template.

    &quot; Downport

    DATA: li_artmp_node   TYPE REF TO if_ixml_element,
          lv_rc           TYPE sy-subrc,
          lv_text         TYPE string,
          lv_rc_args_tmpl TYPE int4,
          lv_errmsg       TYPE string.

    li_artmp_node = template_over_all-&gt;create_simple_element(
                      name   = &apos;ECET_ARTMP&apos;
                      parent = root_node ).

    ecatt_extprog-&gt;get_args_tmpl(
      IMPORTING
        ex_xml_arg_tmpl = lv_text
        ex_rc           = lv_rc_args_tmpl
        ex_errmsg       = lv_errmsg ).

    IF li_artmp_node IS INITIAL OR lv_rc_args_tmpl &gt; 0.
      me-&gt;raise_download_exception(
          textid        = cx_ecatt_apl_util=&gt;download_processing
          previous      = ex_ecatt
          called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_ARTMP_TO_TEMPLATE&apos;
          free_text     = lv_errmsg ).
    ENDIF.

    lv_rc = li_artmp_node-&gt;set_value( value = lv_text ).
    IF lv_rc &lt;&gt; 0.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_ARTMP_TO_TEMPLATE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD set_blob_to_template.

    &quot; Downport

    DATA: li_blob_node TYPE REF TO if_ixml_element,
          lv_rc        TYPE sy-subrc,
          lv_text      TYPE string.

    li_blob_node = template_over_all-&gt;create_simple_element(
                  name   = &apos;ECET_BLOBS&apos;
                  parent = root_node ).

    IF li_blob_node IS INITIAL.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_BLOB_TO_TEMPLATE&apos; ).
    ENDIF.

    ecatt_extprog-&gt;get_blob(
      EXPORTING
        im_whole_data = 1
      IMPORTING
        ex_xml_blob   = lv_text ).

    lv_rc = li_blob_node-&gt;set_value( value = lv_text ).
    IF lv_rc &lt;&gt; 0.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_BLOB_TO_TEMPLATE&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD set_control_data_for_tcd.

    &quot; Downport

    DATA: lt_params TYPE ettcd_params_tabtype,
          lt_verbs  TYPE ettcd_verbs_tabtype,
          lt_vars   TYPE ettcd_vars_tabtype,
          lt_dp_tab TYPE ettcd_dp_tab_tabtype,
          lt_dp_for TYPE ettcd_dp_for_tabtype,
          lt_dp_pro TYPE ettcd_dp_pro_tabtype,
          lt_dp_fld TYPE ettcd_dp_fld_tabtype,
          lt_svars  TYPE ettcd_svars_tabtype.

    DATA: li_element   TYPE REF TO if_ixml_element,
          li_deep_tcd  TYPE REF TO if_ixml_element,
          lv_rc        TYPE sy-subrc,
          lv_name      TYPE string,
          lv_parname   TYPE string,
          lo_pval_xml  TYPE REF TO cl_apl_ecatt_xml_data,
          lo_ctrl_tabs TYPE REF TO cl_apl_ecatt_control_tables.

    FIELD-SYMBOLS: &lt;lt_tab&gt; TYPE STANDARD TABLE.

    IF is_param-xmlref_typ &lt;&gt; cl_apl_ecatt_const=&gt;ref_type_c_tcd
      OR  io_params IS INITIAL.
      RETURN.
    ENDIF.

    lv_parname = is_param-pname.

    io_params-&gt;get_param_value(     &quot;TCD command interface
      EXPORTING
        im_var_id   = cl_apl_ecatt_const=&gt;varid_default_val
        im_pname    = lv_parname
        im_pindex   = is_param-pindex
      IMPORTING
        ex_pval_xml = lo_pval_xml ).

    lo_ctrl_tabs = lo_pval_xml-&gt;get_control_tables_ref( ).
    IF lo_ctrl_tabs IS INITIAL.
      RETURN.
    ENDIF.

    lo_ctrl_tabs-&gt;get_control_tables(          &quot;Read 8 control tables
      IMPORTING
        ex_params = lt_params
        ex_verbs  = lt_verbs
        ex_vars   = lt_vars
        ex_dp_tab = lt_dp_tab
        ex_dp_for = lt_dp_for
        ex_dp_pro = lt_dp_pro
        ex_dp_fld = lt_dp_fld
        ex_svars  = lt_svars ).

    IF lt_params IS INITIAL OR
       lt_verbs  IS INITIAL OR
       lt_vars   IS INITIAL OR
       lt_dp_tab IS INITIAL OR
       lt_dp_for IS INITIAL OR
       lt_dp_pro IS INITIAL OR
       lt_dp_fld IS INITIAL OR
       lt_svars  IS INITIAL.

      RETURN.
    ENDIF.

    li_deep_tcd = template_over_all-&gt;create_simple_element_ns(
                    name   = cl_apl_xml_const=&gt;upl_tcd_node
                    parent = ap_current_param ).

    IF li_deep_tcd IS INITIAL.
      raise_download_exception(
            textid   = cx_ecatt_apl_util=&gt;download_processing
            previous = ex_ecatt ).
    ENDIF.

    DO 8 TIMES.                                &quot;Loop at 8 control tables
      CASE sy-index.
        WHEN 1.
          lv_name = &apos;ETTCD_PARAMS_TABTYPE&apos;.
          ASSIGN lt_params TO &lt;lt_tab&gt;.
        WHEN 2.
          lv_name = &apos;ETTCD_VERBS_TABTYPE&apos;.
          ASSIGN lt_verbs TO &lt;lt_tab&gt;.
        WHEN 3.
          lv_name = &apos;ETTCD_VARS_TABTYPE&apos;.
          ASSIGN lt_vars TO &lt;lt_tab&gt;.
        WHEN 4.
          lv_name = &apos;ETTCD_DP_TAB_TABTYPE&apos;.
          ASSIGN lt_dp_tab TO &lt;lt_tab&gt;.
        WHEN 5.
          lv_name = &apos;ETTCD_DP_FOR_TABTYPE&apos;.
          ASSIGN lt_dp_for TO &lt;lt_tab&gt;.
        WHEN 6.
          lv_name = &apos;ETTCD_DP_PRO_TABTYPE&apos;.
          ASSIGN lt_dp_pro TO &lt;lt_tab&gt;.
        WHEN 7.
          lv_name = &apos;ETTCD_DP_FLD_TABTYPE&apos;.
          ASSIGN lt_dp_fld TO &lt;lt_tab&gt;.
        WHEN 8.
          lv_name = &apos;ETTCD_SVARS_TABTYPE&apos;.
          ASSIGN lt_svars TO &lt;lt_tab&gt;.
      ENDCASE.

      CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;       &quot;Ast generieren lassen
        EXPORTING
          name         = lv_name
          dataobject   = &lt;lt_tab&gt;
        IMPORTING
          data_as_dom  = li_element
        EXCEPTIONS
          illegal_name = 1
          OTHERS       = 2.

      IF sy-subrc &lt;&gt; 0.
        me-&gt;raise_download_exception(
              textid   = cx_ecatt_apl_util=&gt;download_processing
              previous = ex_ecatt ).
      ENDIF.

* Ast in Hauptbaum haengen
      lv_rc = li_deep_tcd-&gt;append_child( new_child = li_element ).

      IF lv_rc &lt;&gt; 0.
        me-&gt;raise_download_exception(
              textid   = cx_ecatt_apl_util=&gt;download_processing
              previous = ex_ecatt ).
      ENDIF.
      FREE li_element.
      UNASSIGN &lt;lt_tab&gt;.
    ENDDO.

    escape_control_data( ii_element = li_deep_tcd
      iv_tabname = &apos;ETTCD_VARS_TABTYPE&apos;
      iv_node    = &apos;CB_INDEX&apos; ).

    escape_control_data(
      ii_element = li_deep_tcd
      iv_tabname = &apos;ETTCD_VERBS_TABTYPE&apos;
      iv_node    = &apos;NAME&apos; ).

    FREE: lt_dp_tab, lt_dp_for, lt_dp_fld, lt_svars,
          lt_params, lt_vars,   lt_dp_pro, lt_verbs.

  ENDMETHOD.
  METHOD set_script_to_template.

    &quot; Downport

    DATA:
      lt_text    TYPE etxml_line_tabtype,
      li_element TYPE REF TO if_ixml_element,
      lv_rc      TYPE sy-subrc.

    ecatt_script-&gt;get_script_text(
      CHANGING
        scripttext = lt_text ).

    mi_script_node = template_over_all-&gt;create_simple_element(
                        name = &apos;SCRIPT&apos;
                        parent = root_node ).

    IF mi_script_node IS INITIAL.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_SCRIPT_TO_TEMPLATE&apos; ).
    ENDIF.

    CALL FUNCTION &apos;SDIXML_DATA_TO_DOM&apos;
      EXPORTING
        name         = &apos;ETXML_LINE_TABTYPE&apos;
        dataobject   = lt_text
      IMPORTING
        data_as_dom  = li_element
      CHANGING
        document     = template_over_all
      EXCEPTIONS
        illegal_name = 1
        OTHERS       = 2.
    IF sy-subrc &lt;&gt; 0.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_SCRIPT_TO_TEMPLATE&apos; ).

    ENDIF.

    lv_rc = mi_script_node-&gt;append_child( li_element ).
    IF lv_rc &lt;&gt; 0.
      me-&gt;raise_download_exception(
            textid        = cx_ecatt_apl_util=&gt;download_processing
            previous      = ex_ecatt
            called_method = &apos;CL_APL_ECATT_SCRIPT_DOWNLOAD-&gt;SET_SCRIPT_TO_TEMPLATE&apos; ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_HELPER IMPLEMENTATION.
  METHOD build_xml_of_object.

    &quot; downport of CL_APL_ECATT_DOWNLOAD=&gt;BUILD_XML_OF_OBJECT

    DATA: lo_load_help_dummy TYPE REF TO cl_apl_ecatt_load_help,
          lx_ecatt           TYPE REF TO cx_ecatt_apl,
          lv_text            TYPE string.

    &quot;download method will create the xml stream
    &quot;note: it&apos;s the redefined download( ) of each object type specific download, which is called
    TRY.
        CREATE OBJECT lo_load_help_dummy
          EXPORTING
            im_maintain_function = &apos;&apos;.

        io_download-&gt;download( im_object_name    = im_object_name
                               im_object_version = im_object_version
                               im_object_type    = im_object_type
                               im_load_help      = lo_load_help_dummy ).

      CATCH cx_ecatt_apl INTO lx_ecatt.
        lv_text = lx_ecatt-&gt;get_text( ).
        zcx_abapgit_exception=&gt;raise( lv_text ).
        &quot; CATCH cx_ecatt_ui_attachment. &quot; Doesn&apos;t exist in 702
      CATCH cx_ecatt.
        &quot;will never be raised from download, when called with mv_generate_xml_no_download = &apos;X&apos;.
    ENDTRY.

    CALL METHOD io_download-&gt;(&apos;GET_XML_STREAM&apos;)
      RECEIVING
        rv_xml_stream = ex_xml_stream.

    CALL METHOD io_download-&gt;(&apos;GET_XML_STREAM_SIZE&apos;)
      RECEIVING
        rv_xml_stream_size = ex_xml_stream_size.

  ENDMETHOD.
  METHOD download_data.

    DATA:
      lo_xml   TYPE REF TO cl_apl_ecatt_xml,
      lv_size  TYPE int4.

    CLEAR: ev_xml_stream,
           ev_xml_stream_size.

    TRY.
        CALL METHOD cl_apl_ecatt_xml=&gt;(&apos;CREATE&apos;) &quot; doesn&apos;t exist in 702
          EXPORTING
            im_type = co_xml
          RECEIVING
            re_xml  = lo_xml.

        lo_xml-&gt;set_attributes( im_dom = ii_template_over_all ).

        lo_xml-&gt;get_attributes(
          IMPORTING
            ex_size_xstring = lv_size
            ex_xml          = ev_xml_stream ).

        ev_xml_stream_size = lv_size.

      CATCH cx_ecatt_apl_xml.
        RETURN.
    ENDTRY.

  ENDMETHOD.
  METHOD upload_data_from_stream.

    DATA:
      lo_xml           TYPE REF TO cl_apl_ecatt_xml,
      lv_xstr          TYPE xstring,
      lv_nc_xmlref_typ TYPE REF TO if_ixml_node_collection,
      lv_n_xmlref_typ  TYPE REF TO if_ixml_node,
      lv_index         TYPE i VALUE 0,
      lv_count         TYPE i.

    lv_xstr = iv_xml_stream.

    CALL METHOD cl_apl_ecatt_xml=&gt;(&apos;CREATE&apos;) &quot; doesn&apos;t exist in 702
      EXPORTING
        im_type = co_xml
      RECEIVING
        re_xml  = lo_xml.

* whitespace stripping needs a namespace
* remove white spaces only at the time of upload
    lo_xml-&gt;stream_to_dom( im_xstream            = lv_xstr
                           im_ignore_white_space = &apos;X&apos;
                           im_uri                = cl_apl_xml_const=&gt;schema_uri ).

    lo_xml-&gt;get_attributes(
      IMPORTING
        ex_dom = ri_template_over_all ).

* MD: Workaround, because nodes starting with &quot;XML&quot; are not allowed
    lv_nc_xmlref_typ ?= ri_template_over_all-&gt;get_elements_by_tag_name_ns(
                          &apos;XMLREF_TYP&apos; ).                   &quot;#EC NOTEXT
    CALL METHOD lv_nc_xmlref_typ-&gt;(&apos;GET_LENGTH&apos;)  &quot; downport
      RECEIVING
        rval = lv_count.

    WHILE lv_index LT lv_count.
      lv_n_xmlref_typ = lv_nc_xmlref_typ-&gt;get_item( lv_index ).
      lv_n_xmlref_typ-&gt;set_name( &apos;X-MLREF_TYP&apos; ).
      lv_index = lv_index + 1.
    ENDWHILE.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_ecatt_data_upload IMPLEMENTATION.
  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; donwnpoort from CL_ABAPGIT_ECATT_DATA_UPLOAD SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_ECATT_DATA_DOWNL IMPLEMENTATION.
  METHOD download.

    &quot; Downport

    DATA: lv_partyp TYPE string.

    load_help = im_load_help.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

    typ = im_object_type.

    lv_partyp = cl_apl_ecatt_const=&gt;params_type_par.

    ecatt_data ?= ecatt_object.
* build_schema( ).
* set_attributes_to_schema( ).
    set_attributes_to_template( ).
* set_params_to_schema( ).
    get_general_params_data( im_params = ecatt_data-&gt;params
                             im_ptyp   = lv_partyp ).

    LOOP AT parm INTO wa_parm.
      set_general_params_data_to_dom( ).
      IF NOT wa_parm-val_type IS INITIAL.
        set_deep_stru_to_dom( ecatt_data-&gt;params ).
        set_deep_data_to_dom( im_params = ecatt_data-&gt;params
                              im_pindex = wa_parm-pindex ).
      ENDIF.
    ENDLOOP.

* MS180406
    set_var_mode_to_dom( ).
* ENDMS180406
    set_variants_to_dom( ecatt_data-&gt;params ).

* download_schema( ).
    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_ecatt_config_upl IMPLEMENTATION.
  METHOD upload_data_from_stream.

    &quot; Downport
    template_over_all = zcl_abapgit_ecatt_helper=&gt;upload_data_from_stream( mv_external_xml ).

  ENDMETHOD.
  METHOD z_set_stream_for_upload.

    &quot; downport from CL_ABAPGIT_ECATT_DATA_UPLOAD SET_STREAM_FOR_UPLOAD
    mv_external_xml = iv_xml.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_ecatt_config_downl IMPLEMENTATION.
  METHOD download.

    &quot; Downport

    DATA: lv_partyp TYPE string.

    load_help = im_load_help.
    typ = im_object_type.

    TRY.
        cl_apl_ecatt_object=&gt;show_object(
          EXPORTING
            im_obj_type = im_object_type
            im_name     = im_object_name
            im_version  = im_object_version
          IMPORTING
            re_object   = ecatt_object ).
      CATCH cx_ecatt INTO ex_ecatt.
        RETURN.
    ENDTRY.

    lv_partyp = cl_apl_ecatt_const=&gt;params_type_par.

    set_attributes_to_template( ).
    ecatt_config ?= ecatt_object.

    CALL METHOD (&apos;SET_ECATT_OBJECTS_TO_TEMPLATE&apos;). &quot; doesn&apos;t exist in 702

* MS180406
    set_var_mode_to_dom( ).
* ENDMS180406
    get_general_params_data( im_params = ecatt_config-&gt;params
                             im_ptyp   = lv_partyp ).
    LOOP AT parm INTO wa_parm.
      set_general_params_data_to_dom( ).
      IF NOT wa_parm-val_type IS INITIAL.
        set_deep_stru_to_dom( ecatt_config-&gt;params ).
        set_deep_data_to_dom( im_params = ecatt_config-&gt;params
                              im_pindex = wa_parm-pindex ).
      ENDIF.
    ENDLOOP.

    set_variants_to_dom( ecatt_config-&gt;params ).

    download_data( ).

  ENDMETHOD.
  METHOD download_data.

    &quot; Downport

    zcl_abapgit_ecatt_helper=&gt;download_data(
      EXPORTING
        ii_template_over_all = template_over_all
      IMPORTING
        ev_xml_stream        = mv_xml_stream
        ev_xml_stream_size   = mv_xml_stream_size ).

  ENDMETHOD.
  METHOD get_xml_stream.

    rv_xml_stream = mv_xml_stream.

  ENDMETHOD.
  METHOD get_xml_stream_size.

    rv_xml_stream_size = mv_xml_stream_size.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PROXY_CONFIG IMPLEMENTATION.
  METHOD constructor.

    mo_settings = zcl_abapgit_persist_settings=&gt;get_instance( )-&gt;read( ).

    mi_exit = zcl_abapgit_exit=&gt;get_instance( ).

  ENDMETHOD.
  METHOD get_proxy_authentication.

    rv_auth = mo_settings-&gt;get_proxy_authentication( ).

    mi_exit-&gt;change_proxy_authentication(
      EXPORTING
        iv_repo_url            = iv_repo_url
      CHANGING
        cv_proxy_authentication = rv_auth ).

  ENDMETHOD.
  METHOD get_proxy_port.

    rv_port = mo_settings-&gt;get_proxy_port( ).

    mi_exit-&gt;change_proxy_port(
      EXPORTING
        iv_repo_url  = iv_repo_url
      CHANGING
        cv_proxy_port = rv_port ).

  ENDMETHOD.
  METHOD get_proxy_url.

    rv_proxy_url = mo_settings-&gt;get_proxy_url( ).

    mi_exit-&gt;change_proxy_url(
      EXPORTING
        iv_repo_url = iv_repo_url
      CHANGING
        cv_proxy_url = rv_proxy_url ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_PROXY_AUTH IMPLEMENTATION.
  METHOD enter.

    zcl_abapgit_password_dialog=&gt;popup(
      EXPORTING
        iv_repo_url = &apos;Proxy Authentication&apos;
      CHANGING
        cv_user     = gv_username
        cv_pass     = gv_password ).

    IF gv_username IS INITIAL OR gv_password IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Proxy auth failed&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD run.

    IF gv_username IS INITIAL OR gv_password IS INITIAL.
      enter( ).
    ENDIF.

    ii_client-&gt;authenticate(
      proxy_authentication = abap_true
      username             = gv_username
      password             = gv_password ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_HTTP_DIGEST IMPLEMENTATION.
  METHOD constructor.

    parse( ii_client ).

    mv_ha1 = md5( |{ iv_username }:{ mv_realm }:{ iv_password }| ).

    mv_username = iv_username.

  ENDMETHOD.
  METHOD hash.

    DATA: lv_ha2 TYPE string.
    lv_ha2 = md5( |{ iv_method }:{ iv_uri }| ).

    ASSERT NOT iv_cnonse IS INITIAL.

    rv_response = md5( |{ mv_ha1 }:{ iv_nonce }:{ gv_nc }:{ iv_cnonse }:{ iv_qop }:{ lv_ha2 }| ).

  ENDMETHOD.
  METHOD md5.

    DATA: lv_xstr TYPE xstring,
          lv_hash TYPE xstring.
    lv_xstr = zcl_abapgit_convert=&gt;string_to_xstring_utf8( iv_data ).

    CALL FUNCTION &apos;CALCULATE_HASH_FOR_RAW&apos;
      EXPORTING
        alg            = &apos;MD5&apos;
        data           = lv_xstr
      IMPORTING
        hashxstring    = lv_hash
      EXCEPTIONS
        unknown_alg    = 1
        param_error    = 2
        internal_error = 3
        OTHERS         = 4.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;error from CALCULATE_HASH_FOR_RAW&apos; ).
    ENDIF.

    rv_hash = lv_hash.
    TRANSLATE rv_hash TO LOWER CASE.

  ENDMETHOD.
  METHOD parse.

    DATA: lv_value TYPE string.
    lv_value = ii_client-&gt;response-&gt;get_header_field( &apos;www-authenticate&apos; ).

    FIND REGEX &apos;realm=&quot;([\w ]+)&quot;&apos; IN lv_value SUBMATCHES mv_realm.
    FIND REGEX &apos;qop=&quot;(\w+)&quot;&apos; IN lv_value SUBMATCHES mv_qop.
    FIND REGEX &apos;nonce=&quot;([\w=/+\$]+)&quot;&apos; IN lv_value SUBMATCHES mv_nonce.

  ENDMETHOD.
  METHOD run.

    DATA: lv_response TYPE string,
          lv_method   TYPE string,
          lv_cnonce   TYPE string,
          lv_uri      TYPE string,
          lv_auth     TYPE string.
    ASSERT NOT mv_nonce IS INITIAL.

    lv_method = ii_client-&gt;request-&gt;get_header_field( &apos;~request_method&apos; ).
    lv_uri = ii_client-&gt;request-&gt;get_header_field( &apos;~request_uri&apos; ).

    CALL FUNCTION &apos;GENERAL_GET_RANDOM_STRING&apos;
      EXPORTING
        number_chars  = 24
      IMPORTING
        random_string = lv_cnonce.

    lv_response = hash(
      iv_qop    = mv_qop
      iv_nonce  = mv_nonce
      iv_uri    = lv_uri
      iv_method = lv_method
      iv_cnonse = lv_cnonce ).

* client response
    lv_auth = |Digest username=&quot;{ mv_username
      }&quot;, realm=&quot;{ mv_realm
      }&quot;, nonce=&quot;{ mv_nonce
      }&quot;, uri=&quot;{ lv_uri
      }&quot;, qop={ mv_qop
      }, nc={ gv_nc
      }, cnonce=&quot;{ lv_cnonce
      }&quot;, response=&quot;{ lv_response }&quot;|.

    ii_client-&gt;request-&gt;set_header_field(
      name  = &apos;Authorization&apos;
      value = lv_auth ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_HTTP IMPLEMENTATION.
  METHOD acquire_login_details.

    DATA: lv_default_user TYPE string,
          lv_user         TYPE string,
          lv_pass         TYPE string,
          lo_digest       TYPE REF TO zcl_abapgit_http_digest.
    lv_default_user = zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;get_repo_login( iv_url ).
    lv_user         = lv_default_user.

    zcl_abapgit_password_dialog=&gt;popup(
      EXPORTING
        iv_repo_url     = iv_url
      CHANGING
        cv_user         = lv_user
        cv_pass         = lv_pass ).

    IF lv_user IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;HTTP 401, unauthorized&apos; ).
    ENDIF.

    IF lv_user &lt;&gt; lv_default_user.
      zcl_abapgit_persistence_user=&gt;get_instance( )-&gt;set_repo_login(
        iv_url   = iv_url
        iv_login = lv_user ).
    ENDIF.

    &quot; Offer two factor authentication if it is available and required
    zcl_abapgit_2fa_auth_registry=&gt;use_2fa_if_required(
      EXPORTING
        iv_url      = iv_url
      CHANGING
        cv_username = lv_user
        cv_password = lv_pass ).

    rv_scheme = ii_client-&gt;response-&gt;get_header_field( &apos;www-authenticate&apos; ).
    FIND REGEX &apos;^(\w+)&apos; IN rv_scheme SUBMATCHES rv_scheme.

    CASE rv_scheme.
      WHEN c_scheme-digest.
* https://en.wikipedia.org/wiki/Digest_access_authentication
* e.g. used by https://www.gerritcodereview.com/
        CREATE OBJECT lo_digest
          EXPORTING
            ii_client   = ii_client
            iv_username = lv_user
            iv_password = lv_pass.
        lo_digest-&gt;run( ii_client ).
        io_client-&gt;set_digest( lo_digest ).
      WHEN OTHERS.
* https://en.wikipedia.org/wiki/Basic_access_authentication
        ii_client-&gt;authenticate(
          username = lv_user
          password = lv_pass ).
    ENDCASE.

  ENDMETHOD.
  METHOD check_auth_requested.

    DATA: lv_code TYPE i.

    ii_client-&gt;response-&gt;get_status(
      IMPORTING
        code   = lv_code ).
    IF lv_code = 401.
      rv_auth_requested = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD create_by_url.

    DATA: lv_uri                 TYPE string,
          lv_scheme              TYPE string,
          li_client              TYPE REF TO if_http_client,
          lo_proxy_configuration TYPE REF TO zcl_abapgit_proxy_config,
          lv_text                TYPE string.
    CREATE OBJECT lo_proxy_configuration.

    li_client = zcl_abapgit_exit=&gt;get_instance( )-&gt;create_http_client( iv_url ).

    IF li_client IS NOT BOUND.

      cl_http_client=&gt;create_by_url(
        EXPORTING
          url                = zcl_abapgit_url=&gt;host( iv_url )
          ssl_id             = zcl_abapgit_exit=&gt;get_instance( )-&gt;get_ssl_id( )
          proxy_host         = lo_proxy_configuration-&gt;get_proxy_url( iv_url )
          proxy_service      = lo_proxy_configuration-&gt;get_proxy_port( iv_url )
        IMPORTING
          client             = li_client
        EXCEPTIONS
          argument_not_found = 1
          plugin_not_active  = 2
          internal_error     = 3
          OTHERS             = 4 ).
      IF sy-subrc &lt;&gt; 0.
        CASE sy-subrc.
          WHEN 1.
            &quot; make sure:
            &quot; a) SSL is setup properly in STRUST
            lv_text = &apos;HTTPS ARGUMENT_NOT_FOUND | STRUST/SSL Setup correct?&apos;.
          WHEN OTHERS.
            lv_text = &apos;While creating HTTP Client&apos;.         &quot;#EC NOTEXT

        ENDCASE.
        zcx_abapgit_exception=&gt;raise( lv_text ).
      ENDIF.

    ENDIF.

    IF lo_proxy_configuration-&gt;get_proxy_authentication( iv_url ) = abap_true.
      zcl_abapgit_proxy_auth=&gt;run( li_client ).
    ENDIF.

    CREATE OBJECT ro_client
      EXPORTING
        ii_client = li_client.

    IF is_local_system( iv_url ) = abap_true.
      li_client-&gt;send_sap_logon_ticket( ).
    ENDIF.

    li_client-&gt;request-&gt;set_cdata( &apos;&apos; ).
    li_client-&gt;request-&gt;set_header_field(
        name  = &apos;~request_method&apos;
        value = &apos;GET&apos; ).
    li_client-&gt;request-&gt;set_header_field(
        name  = &apos;user-agent&apos;
        value = get_agent( ) ).                             &quot;#EC NOTEXT
    lv_uri = zcl_abapgit_url=&gt;path_name( iv_url ) &amp;&amp;
             &apos;/info/refs?service=git-&apos; &amp;&amp;
             iv_service &amp;&amp;
             &apos;-pack&apos;.
    li_client-&gt;request-&gt;set_header_field(
        name  = &apos;~request_uri&apos;
        value = lv_uri ).

    &quot; Disable internal auth dialog (due to its unclarity)
    li_client-&gt;propertytype_logon_popup = if_http_client=&gt;co_disabled.

    zcl_abapgit_login_manager=&gt;load( iv_uri    = iv_url
                                     ii_client = li_client ).

    zcl_abapgit_exit=&gt;get_instance( )-&gt;http_client( li_client ).

    ro_client-&gt;send_receive( ).
    IF check_auth_requested( li_client ) = abap_true.
      lv_scheme = acquire_login_details( ii_client = li_client
                                         io_client = ro_client
                                         iv_url    = iv_url ).
      ro_client-&gt;send_receive( ).
    ENDIF.
    ro_client-&gt;check_http_200( ).

    IF lv_scheme &lt;&gt; c_scheme-digest.
      zcl_abapgit_login_manager=&gt;save( iv_uri    = iv_url
                                       ii_client = li_client ).
    ENDIF.

  ENDMETHOD.
  METHOD get_agent.

* bitbucket require agent prefix = &quot;git/&quot;
* also see https://github.com/larshp/abapGit/issues/1432
    rv_agent = |git/2.0 (abapGit { zif_abapgit_version=&gt;gc_abap_version })|.

  ENDMETHOD.
  METHOD is_local_system.

    DATA: lv_host TYPE string,
          lt_list TYPE zif_abapgit_exit=&gt;ty_icm_sinfo2_tt,
          li_exit TYPE REF TO zif_abapgit_exit.

    FIELD-SYMBOLS: &lt;ls_list&gt; LIKE LINE OF lt_list.
    CALL FUNCTION &apos;ICM_GET_INFO2&apos;
      TABLES
        servlist    = lt_list
      EXCEPTIONS
        icm_error   = 1
        icm_timeout = 2
        OTHERS      = 3.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO lt_list ASSIGNING &lt;ls_list&gt;.
    &lt;ls_list&gt;-hostname = &apos;localhost&apos;.

    li_exit = zcl_abapgit_exit=&gt;get_instance( ).
    li_exit-&gt;change_local_host( CHANGING ct_hosts = lt_list ).

    FIND REGEX &apos;https?://([^/^:]*)&apos; IN iv_url
      SUBMATCHES lv_host.

    READ TABLE lt_list WITH KEY hostname = lv_host TRANSPORTING NO FIELDS.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_2FA_GITHUB_AUTH IMPLEMENTATION.
  METHOD constructor.

    DATA: lv_match TYPE string.

    IF iv_override IS SUPPLIED.
      lv_match = iv_override.
    ELSE.
      lv_match = &apos;^https?://(www\.)?github.com.*$&apos;.
    ENDIF.

    super-&gt;constructor( lv_match ).

  ENDMETHOD.
  METHOD get_authenticated_client.
    DATA: lv_http_code             TYPE i,
          lv_http_code_description TYPE string.

    &quot; If there is a cached client return it instead
    IF is_session_running( ) = abap_true AND mi_authenticated_session IS BOUND.
      ri_client = mi_authenticated_session.
      RETURN.
    ENDIF.

    &quot; Try to login to GitHub API with username, password and 2fa token
    ri_client = get_http_client_for_url( mv_github_api_url ).

    &quot; https://developer.github.com/v3/auth/#working-with-two-factor-authentication
    ri_client-&gt;propertytype_accept_cookie = if_http_client=&gt;co_enabled.
    ri_client-&gt;request-&gt;set_header_field( name = c_otp_header_name value = iv_2fa_token ).
    ri_client-&gt;authenticate( username = iv_username password = iv_password ).
    ri_client-&gt;propertytype_logon_popup = if_http_client=&gt;co_disabled.

    ri_client-&gt;send( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    ri_client-&gt;receive( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    &quot; Check if authentication has succeeded
    ri_client-&gt;response-&gt;get_status(
      IMPORTING
        code   = lv_http_code
        reason = lv_http_code_description ).
    IF lv_http_code &lt;&gt; 200.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_auth_failed
        EXPORTING
          mv_text = |Authentication failed: { lv_http_code_description }|.
    ENDIF.

    &quot; Cache the authenticated http session / client to avoid unnecessary additional authentication
    IF is_session_running( ) = abap_true.
      mi_authenticated_session = ri_client.
    ENDIF.
  ENDMETHOD.
  METHOD get_tobedel_tokens_from_resp.
    CONSTANTS: lc_search_regex TYPE string
               VALUE `\{&quot;id&quot;: ?(\d+)[^\{]*&quot;app&quot;:\{[^\{^\}]*\}[^\{]*&quot;fingerprint&quot;: ?` &amp;
               `&quot;abapGit2FA&quot;[^\{]*\}`.
    DATA: lv_response TYPE string,
          lo_regex    TYPE REF TO cl_abap_regex,
          lo_matcher  TYPE REF TO cl_abap_matcher.

    lv_response = cl_abap_codepage=&gt;convert_from( ii_response-&gt;get_data( ) ).

    CREATE OBJECT lo_regex
      EXPORTING
        pattern = lc_search_regex.

    lo_matcher = lo_regex-&gt;create_matcher( text = lv_response ).
    WHILE lo_matcher-&gt;find_next( ) = abap_true.
      APPEND lo_matcher-&gt;get_submatch( 1 ) TO rt_ids.
    ENDWHILE.
  ENDMETHOD.
  METHOD get_token_from_response.
    CONSTANTS: lc_search_regex TYPE string VALUE `.*&quot;token&quot;:&quot;([^&quot;]*).*$`.
    DATA: lv_response TYPE string,
          lo_regex    TYPE REF TO cl_abap_regex,
          lo_matcher  TYPE REF TO cl_abap_matcher.

    lv_response = cl_abap_codepage=&gt;convert_from( ii_response-&gt;get_data( ) ).

    CREATE OBJECT lo_regex
      EXPORTING
        pattern = lc_search_regex.

    lo_matcher = lo_regex-&gt;create_matcher( text = lv_response ).
    IF lo_matcher-&gt;match( ) = abap_true.
      rv_token = lo_matcher-&gt;get_submatch( 1 ).
    ENDIF.
  ENDMETHOD.
  METHOD set_del_token_request.
    DATA: lv_url TYPE string.

    lv_url = |{ c_restendpoint_authorizations }/{ iv_token_id }|.

    ii_request-&gt;set_header_field( name  = if_http_header_fields_sap=&gt;request_uri
                                  value = lv_url ).
    &quot; Other methods than POST and GET do not have constants unfortunately
    &quot; ii_request-&gt;set_method( if_http_request=&gt;co_request_method_delete ).
    ii_request-&gt;set_method( &apos;DELETE&apos; ).
  ENDMETHOD.
  METHOD set_list_token_request.
    ii_request-&gt;set_header_field( name  = if_http_header_fields_sap=&gt;request_uri
                                  value = c_restendpoint_authorizations ).
    ii_request-&gt;set_method( if_http_request=&gt;co_request_method_get ).
  ENDMETHOD.
  METHOD set_new_token_request.
    DATA: lv_json_string TYPE string.

    lv_json_string = `{&quot;scopes&quot;:[&quot;repo&quot;],&quot;note&quot;:&quot;Generated by abapGit&quot;,&quot;fingerprint&quot;:&quot;abapGit2FA&quot;}`.

    ii_request-&gt;set_data( cl_abap_codepage=&gt;convert_to( lv_json_string ) ).
    ii_request-&gt;set_header_field( name  = if_http_header_fields_sap=&gt;request_uri
                                  value = c_restendpoint_authorizations ).
    ii_request-&gt;set_method( if_http_request=&gt;co_request_method_post ).
  ENDMETHOD.
  METHOD zif_abapgit_2fa_authenticator~authenticate.
    DATA: li_http_client           TYPE REF TO if_http_client,
          lv_http_code             TYPE i,
          lv_http_code_description TYPE string.

    &quot; 1. Try to login to GitHub API
    li_http_client = get_authenticated_client( iv_username  = iv_username
                                               iv_password  = iv_password
                                               iv_2fa_token = iv_2fa_token ).

    &quot; 2. Create an access token which can be used instead of a password
    &quot; https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization

    set_new_token_request( li_http_client-&gt;request ).

    li_http_client-&gt;send( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    li_http_client-&gt;receive( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    li_http_client-&gt;response-&gt;get_status(
      IMPORTING
        code   = lv_http_code
        reason = lv_http_code_description ).
    IF lv_http_code &lt;&gt; 201.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_gen_failed
        EXPORTING
          mv_text = |Token generation failed: { lv_http_code } { lv_http_code_description }|.
    ENDIF.

    rv_access_token = get_token_from_response( li_http_client-&gt;response ).
    IF rv_access_token IS INITIAL.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_gen_failed
        EXPORTING
          mv_text = &apos;Token generation failed: parser error&apos; ##NO_TEXT.
    ENDIF.

    &quot; GitHub might need some time until the new token is ready to use, give it a second
    CALL FUNCTION &apos;RZL_SLEEP&apos;.
  ENDMETHOD.
  METHOD zif_abapgit_2fa_authenticator~delete_access_tokens.

    DATA: li_http_client           TYPE REF TO if_http_client,
          lv_http_code             TYPE i,
          lv_http_code_description TYPE string,
          lt_tobedeleted_tokens    TYPE stringtab.
    FIELD-SYMBOLS: &lt;lv_id&gt; TYPE string.

    li_http_client = get_authenticated_client( iv_username  = iv_username
                                               iv_password  = iv_password
                                               iv_2fa_token = iv_2fa_token ).

    set_list_token_request( li_http_client-&gt;request ).
    li_http_client-&gt;send( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    li_http_client-&gt;receive( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    li_http_client-&gt;response-&gt;get_status(
      IMPORTING
        code   = lv_http_code
        reason = lv_http_code_description ).
    IF lv_http_code &lt;&gt; 200.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_del_failed
        EXPORTING
          mv_text = |Could not fetch current 2FA authorizations: | &amp;&amp;
                    |{ lv_http_code } { lv_http_code_description }|.
    ENDIF.

    lt_tobedeleted_tokens = get_tobedel_tokens_from_resp( li_http_client-&gt;response ).
    LOOP AT lt_tobedeleted_tokens ASSIGNING &lt;lv_id&gt; WHERE table_line IS NOT INITIAL.
      set_del_token_request( ii_request  = li_http_client-&gt;request
                             iv_token_id = &lt;lv_id&gt; ).
      li_http_client-&gt;send( EXCEPTIONS OTHERS = 1 ).
      IF sy-subrc &lt;&gt; 0.
        raise_comm_error_from_sy( ).
      ENDIF.

      li_http_client-&gt;receive( EXCEPTIONS OTHERS = 1 ).
      IF sy-subrc &lt;&gt; 0.
        raise_comm_error_from_sy( ).
      ENDIF.

      li_http_client-&gt;response-&gt;get_status(
        IMPORTING
          code   = lv_http_code
          reason = lv_http_code_description ).
      IF lv_http_code &lt;&gt; 204.
        RAISE EXCEPTION TYPE zcx_abapgit_2fa_del_failed
          EXPORTING
            mv_text = |Could not delete token &apos;{ &lt;lv_id&gt; }&apos;: | &amp;&amp;
                      |{ lv_http_code } { lv_http_code_description }|.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD zif_abapgit_2fa_authenticator~end.
    super-&gt;end( ).
    FREE mi_authenticated_session.
  ENDMETHOD.
  METHOD zif_abapgit_2fa_authenticator~is_2fa_required.

    DATA: li_client TYPE REF TO if_http_client.

    li_client = get_http_client_for_url( mv_github_api_url ).

    li_client-&gt;propertytype_logon_popup = if_http_client=&gt;co_disabled.

    &quot; The request needs to use something other than GET and it needs to be send to an endpoint
    &quot; to trigger a SMS.
    li_client-&gt;request-&gt;set_header_field( name  = if_http_header_fields_sap=&gt;request_uri
                                          value = c_restendpoint_authorizations ).
    li_client-&gt;request-&gt;set_method( if_http_request=&gt;co_request_method_post ).

    &quot; Try to authenticate, if 2FA is required there will be a specific response header
    li_client-&gt;authenticate( username = iv_username password = iv_password ).

    li_client-&gt;send( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    li_client-&gt;receive( EXCEPTIONS OTHERS = 1 ).
    IF sy-subrc &lt;&gt; 0.
* if the code fails here with a SSL error, make sure STRUST is setup to
* work with https://api.github.com
      raise_comm_error_from_sy( ).
    ENDIF.

    &quot; The response will either be UNAUTHORIZED or MALFORMED which is both fine.

    IF li_client-&gt;response-&gt;get_header_field( c_otp_header_name ) CP &apos;required*&apos;.
      rv_required = abap_true.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_2FA_AUTH_REGISTRY IMPLEMENTATION.
  METHOD class_constructor.

    DATA: lt_sub           TYPE seo_relkeys,
          ls_sub           LIKE LINE OF lt_sub,
          li_authenticator TYPE REF TO zif_abapgit_2fa_authenticator,
          lo_class         TYPE REF TO cl_oo_class.
    TRY.
        lo_class ?= cl_oo_class=&gt;get_instance( &apos;ZCL_ABAPGIT_2FA_AUTH_BASE&apos; ).
        lt_sub = lo_class-&gt;get_subclasses( ).
        SORT lt_sub BY clsname ASCENDING AS TEXT.
        LOOP AT lt_sub INTO ls_sub.
          CREATE OBJECT li_authenticator TYPE (ls_sub-clsname).
          INSERT li_authenticator INTO TABLE gt_registered_authenticators.
        ENDLOOP.
      CATCH cx_class_not_existent.
* class in local report
        CREATE OBJECT li_authenticator TYPE zcl_abapgit_2fa_github_auth.
        INSERT li_authenticator INTO TABLE gt_registered_authenticators.
    ENDTRY.

  ENDMETHOD.
  METHOD get_authenticator_for_url.
    FIELD-SYMBOLS: &lt;li_authenticator&gt; LIKE LINE OF gt_registered_authenticators.

    LOOP AT gt_registered_authenticators ASSIGNING &lt;li_authenticator&gt;.
      IF &lt;li_authenticator&gt;-&gt;supports_url( iv_url ) = abap_true.
        ri_authenticator = &lt;li_authenticator&gt;.
        RETURN.
      ENDIF.
    ENDLOOP.

    RAISE EXCEPTION TYPE zcx_abapgit_2fa_unsupported.
  ENDMETHOD.
  METHOD is_url_supported.
    TRY.
        get_authenticator_for_url( iv_url ).
        rv_supported = abap_true.
      CATCH zcx_abapgit_2fa_unsupported ##NO_HANDLER.
    ENDTRY.
  ENDMETHOD.
  METHOD popup_token.

    DATA: lv_returncode TYPE c,
          lt_fields     TYPE TABLE OF sval.

    FIELD-SYMBOLS: &lt;ls_field&gt; LIKE LINE OF lt_fields.
    APPEND INITIAL LINE TO lt_fields ASSIGNING &lt;ls_field&gt;.
    &lt;ls_field&gt;-tabname   = &apos;TADIR&apos;.
    &lt;ls_field&gt;-fieldname = &apos;OBJ_NAME&apos;.
    &lt;ls_field&gt;-fieldtext = &apos;Two factor auth. token&apos;.

    CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
      EXPORTING
        no_value_check  = abap_true
        popup_title     = &apos;Two factor auth. token&apos;
      IMPORTING
        returncode      = lv_returncode
      TABLES
        fields          = lt_fields
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2. &quot;#EC NOTEXT
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Error from POPUP_GET_VALUES&apos; ).
    ENDIF.

    IF lv_returncode = &apos;A&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;Authentication cancelled&apos; ).
    ENDIF.

    READ TABLE lt_fields INDEX 1 ASSIGNING &lt;ls_field&gt;.
    ASSERT sy-subrc = 0.
    rv_token = &lt;ls_field&gt;-value.

  ENDMETHOD.
  METHOD use_2fa_if_required.
    DATA: li_authenticator TYPE REF TO zif_abapgit_2fa_authenticator,
          lv_2fa_token     TYPE string,
          lv_access_token  TYPE string,
          lx_ex            TYPE REF TO cx_root.

    IF is_url_supported( iv_url ) = abap_false.
      RETURN.
    ENDIF.

    TRY.
        li_authenticator = get_authenticator_for_url( iv_url ).
        li_authenticator-&gt;begin( ).

        &quot; Is two factor authentication required for this account?
        IF li_authenticator-&gt;is_2fa_required( iv_url      = iv_url
                                              iv_username = cv_username
                                              iv_password = cv_password ) = abap_true.

          lv_2fa_token = popup_token( ).

          &quot; Delete an old access token if it exists
          li_authenticator-&gt;delete_access_tokens( iv_url       = iv_url
                                                  iv_username  = cv_username
                                                  iv_password  = cv_password
                                                  iv_2fa_token = lv_2fa_token ).

          &quot; Get a new access token
          lv_access_token = li_authenticator-&gt;authenticate( iv_url       = iv_url
                                                            iv_username  = cv_username
                                                            iv_password  = cv_password
                                                            iv_2fa_token = lv_2fa_token ).

          &quot; Use the access token instead of the password
          cv_password = lv_access_token.
        ENDIF.

        li_authenticator-&gt;end( ).

      CATCH zcx_abapgit_2fa_error INTO lx_ex.
        TRY.
            li_authenticator-&gt;end( ).
          CATCH zcx_abapgit_2fa_illegal_state ##NO_HANDLER.
        ENDTRY.

        zcx_abapgit_exception=&gt;raise( |2FA error: { lx_ex-&gt;get_text( ) }| ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_2FA_AUTH_BASE IMPLEMENTATION.
  METHOD authenticate.
    RAISE EXCEPTION TYPE zcx_abapgit_2fa_auth_failed. &quot; Needs to be overwritten in subclasses
  ENDMETHOD.
  METHOD begin.
    IF mv_session_running = abap_true.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_illegal_state.
    ENDIF.

    mv_session_running = abap_true.
  ENDMETHOD.
  METHOD constructor.
    CREATE OBJECT mo_url_regex
      EXPORTING
        pattern     = iv_supported_url_regex
        ignore_case = abap_true.
  ENDMETHOD.
  METHOD delete_access_tokens.
    RAISE EXCEPTION TYPE zcx_abapgit_2fa_del_failed. &quot; Needs to be overwritten in subclasses
  ENDMETHOD.
  METHOD end.
    IF mv_session_running = abap_false.
      RAISE EXCEPTION TYPE zcx_abapgit_2fa_illegal_state.
    ENDIF.

    mv_session_running = abap_false.
  ENDMETHOD.
  METHOD get_http_client_for_url.
    DATA: lo_proxy       TYPE REF TO zcl_abapgit_proxy_config,
          lo_abapgit_exc TYPE REF TO zcx_abapgit_exception,
          lv_error_text  TYPE string.

    CREATE OBJECT lo_proxy.
    cl_http_client=&gt;create_by_url(
      EXPORTING
        url                = iv_url
        ssl_id             = zcl_abapgit_exit=&gt;get_instance( )-&gt;get_ssl_id( )
        proxy_host         = lo_proxy-&gt;get_proxy_url( iv_url )
        proxy_service      = lo_proxy-&gt;get_proxy_port( iv_url  )
      IMPORTING
        client             = ri_client
      EXCEPTIONS
        argument_not_found = 1
        plugin_not_active  = 2
        internal_error     = 3
        OTHERS             = 4 ).
    IF sy-subrc &lt;&gt; 0.
      raise_comm_error_from_sy( ).
    ENDIF.

    IF lo_proxy-&gt;get_proxy_authentication( iv_url ) = abap_true.
      TRY.
          zcl_abapgit_proxy_auth=&gt;run( ri_client ).
        CATCH zcx_abapgit_exception INTO lo_abapgit_exc.
          lv_error_text = lo_abapgit_exc-&gt;get_text( ).
          IF lv_error_text IS INITIAL.
            lv_error_text = `Proxy authentication error`.
          ENDIF.
          RAISE EXCEPTION TYPE zcx_abapgit_2fa_comm_error EXPORTING mv_text = lv_error_text previous = lo_abapgit_exc.
      ENDTRY.
    ENDIF.
  ENDMETHOD.
  METHOD is_2fa_required.
    rv_required = abap_false.
  ENDMETHOD.
  METHOD is_session_running.
    rv_running = mv_session_running.
  ENDMETHOD.
  METHOD raise_comm_error_from_sy.
    DATA: lv_error_msg TYPE string.

    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            INTO lv_error_msg.
    RAISE EXCEPTION TYPE zcx_abapgit_2fa_comm_error
      EXPORTING
        mv_text = |Communication error: { lv_error_msg }| ##NO_TEXT.
  ENDMETHOD.
  METHOD supports_url.
    rv_supported = mo_url_regex-&gt;create_matcher( text = iv_url )-&gt;match( ).
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_TAG IMPLEMENTATION.
  METHOD add_tag_prefix.

    rv_text = zif_abapgit_definitions=&gt;c_tag_prefix &amp;&amp; iv_text.

  ENDMETHOD.
  METHOD remove_tag_prefix.

    rv_text = iv_text.

    REPLACE FIRST OCCURRENCE OF zif_abapgit_definitions=&gt;c_tag_prefix
            IN rv_text
            WITH &apos;&apos;.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GIT_UTILS IMPLEMENTATION.
  METHOD get_null.

    DATA: lv_x(4) TYPE x VALUE &apos;00000000&apos;,
          lv_z(2) TYPE c.

    FIELD-SYMBOLS &lt;lv_y&gt; TYPE c.
    ASSIGN lv_x TO &lt;lv_y&gt; CASTING.
    lv_z = &lt;lv_y&gt;.
    rv_c = lv_z(1).

  ENDMETHOD.
  METHOD length_utf8_hex.

    DATA: lv_xstring TYPE xstring,
          lv_string  TYPE string,
          lv_char4   TYPE c LENGTH 4,
          lv_x       TYPE x LENGTH 2,
          lo_obj     TYPE REF TO cl_abap_conv_in_ce,
          lv_len     TYPE int4.

* hmm, can this be done easier?

    lv_xstring = iv_data(4).

    lo_obj = cl_abap_conv_in_ce=&gt;create(
        input    = lv_xstring
        encoding = &apos;UTF-8&apos; ).
    lv_len = xstrlen( lv_xstring ).

    TRY.
        lo_obj-&gt;read( EXPORTING n    = lv_len
                      IMPORTING data = lv_string ).
      CATCH cx_sy_conversion_codepage.
        zcx_abapgit_exception=&gt;raise( &apos;error converting to hex, LENGTH_UTF8_HEX&apos; ).
    ENDTRY.

    lv_char4 = lv_string.
    TRANSLATE lv_char4 TO UPPER CASE.
    lv_x = lv_char4.
    rv_len = lv_x.

  ENDMETHOD.
  METHOD pkt_string.

    DATA: lv_x   TYPE x,
          lv_len TYPE i.
    lv_len = strlen( iv_string ).

    IF lv_len &gt;= 255.
      zcx_abapgit_exception=&gt;raise( &apos;PKT, todo&apos; ).
    ENDIF.

    lv_x = lv_len + 4.

    rv_pkt = rv_pkt &amp;&amp; &apos;00&apos; &amp;&amp; lv_x &amp;&amp; iv_string.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_git_transport IMPLEMENTATION.
  METHOD branches.

    DATA: lo_client TYPE REF TO zcl_abapgit_http_client.
    branch_list(
      EXPORTING
        iv_url         = iv_url
        iv_service     = c_service-upload
      IMPORTING
        eo_client      = lo_client
        eo_branch_list = ro_branch_list ).

    lo_client-&gt;close( ).

  ENDMETHOD.
  METHOD branch_list.

    DATA: lv_data TYPE string.
    DATA: lv_expected_content_type TYPE string.

    eo_client = zcl_abapgit_http=&gt;create_by_url(
      iv_url     = iv_url
      iv_service = iv_service ).

    lv_expected_content_type = c_smart_response_check-get_refs-content_type.
    REPLACE &apos;&lt;service&gt;&apos; IN lv_expected_content_type WITH iv_service.

    eo_client-&gt;check_smart_response(
        iv_expected_content_type = lv_expected_content_type
        iv_content_regex         = c_smart_response_check-get_refs-content_regex ).

    lv_data = eo_client-&gt;get_cdata( ).

    CREATE OBJECT eo_branch_list
      EXPORTING
        iv_data = lv_data.

  ENDMETHOD.
  METHOD find_branch.

    branch_list(
      EXPORTING
        iv_url          = iv_url
        iv_service      = iv_service
      IMPORTING
        eo_client       = eo_client
        eo_branch_list  = eo_branch_list ).

    IF ev_branch IS SUPPLIED.
      ev_branch = eo_branch_list-&gt;find_by_name( iv_branch_name )-sha1.
    ENDIF.

  ENDMETHOD.
  METHOD parse.

    CONSTANTS: lc_band1 TYPE x VALUE &apos;01&apos;.

    DATA: lv_len      TYPE i,
          lv_contents TYPE xstring,
          lv_pack     TYPE xstring.
    WHILE xstrlen( cv_data ) &gt;= 4.
      lv_len = zcl_abapgit_git_utils=&gt;length_utf8_hex( cv_data ).

      IF lv_len &gt; xstrlen( cv_data ).
        zcx_abapgit_exception=&gt;raise( &apos;parse, string length too large&apos; ).
      ENDIF.

      lv_contents = cv_data(lv_len).
      IF lv_len = 0.
        cv_data = cv_data+4.
        CONTINUE.
      ELSE.
        cv_data = cv_data+lv_len.
      ENDIF.

      lv_contents = lv_contents+4.

      IF xstrlen( lv_contents ) &gt; 1 AND lv_contents(1) = lc_band1.
        CONCATENATE lv_pack lv_contents+1 INTO lv_pack IN BYTE MODE.
      ENDIF.

    ENDWHILE.

    ev_pack = lv_pack.

  ENDMETHOD.
  METHOD receive_pack.

    DATA: lo_client   TYPE REF TO zcl_abapgit_http_client,
          lv_cmd_pkt  TYPE string,
          lv_line     TYPE string,
          lv_tmp      TYPE xstring,
          lv_xstring  TYPE xstring,
          lv_string   TYPE string,
          lv_cap_list TYPE string,
          lv_buffer   TYPE string.
    find_branch(
      EXPORTING
        iv_url         = iv_url
        iv_service     = c_service-receive
        iv_branch_name = iv_branch_name
      IMPORTING
        eo_client      = lo_client ).

    lo_client-&gt;set_headers(
      iv_url     = iv_url
      iv_service = c_service-receive ).

    lv_cap_list = &apos;report-status&apos; ##NO_TEXT.

    lv_line = iv_old &amp;&amp;
              ` ` &amp;&amp;
              iv_new &amp;&amp;
              ` ` &amp;&amp;
              iv_branch_name &amp;&amp;
              zcl_abapgit_git_utils=&gt;get_null( ) &amp;&amp;
              ` ` &amp;&amp;
              lv_cap_list &amp;&amp;
              zif_abapgit_definitions=&gt;c_newline.           &quot;#EC NOTEXT
    lv_cmd_pkt = zcl_abapgit_git_utils=&gt;pkt_string( lv_line ).

    lv_buffer = lv_cmd_pkt &amp;&amp; &apos;0000&apos;.
    lv_tmp = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_buffer ).

    CONCATENATE lv_tmp iv_pack INTO lv_xstring IN BYTE MODE.

    lv_xstring = lo_client-&gt;send_receive_close( lv_xstring ).

* todo, this part should be changed, instead of looking at texts
* parse the reply and look for the &quot;ng&quot; not good indicator
    lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( lv_xstring ).
    IF NOT lv_string CP &apos;*unpack ok*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;unpack not ok&apos; ).
    ELSEIF lv_string CP &apos;*pre-receive hook declined*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;pre-receive hook declined&apos; ).
    ELSEIF lv_string CP &apos;*push declined due to email privacy*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;push declined due to email privacy&apos; ).
    ELSEIF lv_string CP &apos;*funny refname*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;funny refname&apos; ).
    ELSEIF lv_string CP &apos;*failed to update ref*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;failed to update ref&apos; ).
    ELSEIF lv_string CP &apos;*missing necessary objects*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;missing necessary objects&apos; ).
    ELSEIF lv_string CP &apos;*refusing to delete the current branch*&apos;.
      zcx_abapgit_exception=&gt;raise( &apos;branch delete not allowed&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD upload_pack.

    DATA: lo_client   TYPE REF TO zcl_abapgit_http_client,
          lv_buffer   TYPE string,
          lv_xstring  TYPE xstring,
          lv_line     TYPE string,
          lv_pack     TYPE xstring,
          lt_branches TYPE zif_abapgit_definitions=&gt;ty_git_branch_list_tt,
          lv_capa     TYPE string.

    FIELD-SYMBOLS: &lt;ls_branch&gt; LIKE LINE OF lt_branches.
    CLEAR: et_objects,
           ev_branch,
           eo_branch_list.

    find_branch(
      EXPORTING
        iv_url         = iv_url
        iv_service     = c_service-upload
        iv_branch_name = iv_branch_name
      IMPORTING
        eo_client      = lo_client
        eo_branch_list = eo_branch_list
        ev_branch      = ev_branch ).

    IF it_branches IS INITIAL.
      APPEND INITIAL LINE TO lt_branches ASSIGNING &lt;ls_branch&gt;.
      &lt;ls_branch&gt;-sha1 = ev_branch.
    ELSE.
      lt_branches = it_branches.
    ENDIF.

    lo_client-&gt;set_headers( iv_url     = iv_url
                            iv_service = c_service-upload ).

    LOOP AT lt_branches FROM 1 ASSIGNING &lt;ls_branch&gt;.
      IF sy-tabix = 1.
        lv_capa = &apos;side-band-64k no-progress multi_ack&apos; ##NO_TEXT.
        lv_line = &apos;want&apos; &amp;&amp; ` ` &amp;&amp; &lt;ls_branch&gt;-sha1
          &amp;&amp; ` ` &amp;&amp; lv_capa &amp;&amp; zif_abapgit_definitions=&gt;c_newline. &quot;#EC NOTEXT
      ELSE.
        lv_line = &apos;want&apos; &amp;&amp; ` ` &amp;&amp; &lt;ls_branch&gt;-sha1
          &amp;&amp; zif_abapgit_definitions=&gt;c_newline.            &quot;#EC NOTEXT
      ENDIF.
      lv_buffer = lv_buffer &amp;&amp; zcl_abapgit_git_utils=&gt;pkt_string( lv_line ).
    ENDLOOP.

    IF iv_deepen = abap_true.
      lv_buffer = lv_buffer &amp;&amp; zcl_abapgit_git_utils=&gt;pkt_string( &apos;deepen 1&apos;
        &amp;&amp; zif_abapgit_definitions=&gt;c_newline ).            &quot;#EC NOTEXT
    ENDIF.

    lv_buffer = lv_buffer
             &amp;&amp; &apos;0000&apos;
             &amp;&amp; &apos;0009done&apos; &amp;&amp; zif_abapgit_definitions=&gt;c_newline.

    lv_xstring = lo_client-&gt;send_receive_close(
      zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_buffer ) ).

    parse( IMPORTING ev_pack = lv_pack
           CHANGING cv_data = lv_xstring ).

    IF lv_pack IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;empty pack&apos; ).
    ENDIF.

    et_objects = zcl_abapgit_git_pack=&gt;decode( lv_pack ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GIT_PORCELAIN IMPLEMENTATION.
  METHOD build_trees.

    DATA: lt_nodes   TYPE zcl_abapgit_git_pack=&gt;ty_nodes_tt,
          ls_tree    LIKE LINE OF rt_trees,
          lv_len     TYPE i,
          lt_folders TYPE ty_folders_tt.

    FIELD-SYMBOLS: &lt;ls_folder&gt; LIKE LINE OF lt_folders,
                   &lt;ls_node&gt;   LIKE LINE OF lt_nodes,
                   &lt;ls_sub&gt;    LIKE LINE OF lt_folders,
                   &lt;ls_exp&gt;    LIKE LINE OF it_expanded.
    lt_folders = find_folders( it_expanded ).

* start with the deepest folders
    SORT lt_folders BY count DESCENDING.

    LOOP AT lt_folders ASSIGNING &lt;ls_folder&gt;.
      CLEAR lt_nodes.

* files
      LOOP AT it_expanded ASSIGNING &lt;ls_exp&gt; WHERE path = &lt;ls_folder&gt;-path.
        APPEND INITIAL LINE TO lt_nodes ASSIGNING &lt;ls_node&gt;.
        &lt;ls_node&gt;-chmod = &lt;ls_exp&gt;-chmod.
        &lt;ls_node&gt;-name  = &lt;ls_exp&gt;-name.
        &lt;ls_node&gt;-sha1  = &lt;ls_exp&gt;-sha1.
      ENDLOOP.

* folders
      LOOP AT lt_folders ASSIGNING &lt;ls_sub&gt; WHERE count = &lt;ls_folder&gt;-count + 1.
        lv_len = strlen( &lt;ls_folder&gt;-path ).
        IF strlen( &lt;ls_sub&gt;-path ) &gt; lv_len AND &lt;ls_sub&gt;-path(lv_len) = &lt;ls_folder&gt;-path.
          APPEND INITIAL LINE TO lt_nodes ASSIGNING &lt;ls_node&gt;.
          &lt;ls_node&gt;-chmod = zif_abapgit_definitions=&gt;c_chmod-dir.

* extract folder name, this can probably be done easier using regular expressions
          &lt;ls_node&gt;-name = &lt;ls_sub&gt;-path+lv_len.
          lv_len = strlen( &lt;ls_node&gt;-name ) - 1.
          &lt;ls_node&gt;-name = &lt;ls_node&gt;-name(lv_len).

          &lt;ls_node&gt;-sha1 = &lt;ls_sub&gt;-sha1.
        ENDIF.
      ENDLOOP.

      CLEAR ls_tree.
      ls_tree-path = &lt;ls_folder&gt;-path.
      ls_tree-data = zcl_abapgit_git_pack=&gt;encode_tree( lt_nodes ).
      ls_tree-sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-tree iv_data = ls_tree-data ).
      APPEND ls_tree TO rt_trees.

      &lt;ls_folder&gt;-sha1 = ls_tree-sha1.
    ENDLOOP.

  ENDMETHOD.
  METHOD create_annotated_tag.

    receive_pack_create_tag(
      is_tag = is_tag
      iv_url = iv_url ).

  ENDMETHOD.
  METHOD create_branch.

    DATA: lt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
          lv_pack    TYPE xstring.

    IF iv_name CS ` `.
      zcx_abapgit_exception=&gt;raise( &apos;Branch name cannot contain blank spaces&apos; ).
    ENDIF.

* &quot;client MUST send an empty packfile&quot;
* https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt#L514
    lv_pack = zcl_abapgit_git_pack=&gt;encode( lt_objects ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = c_zero
      iv_new         = iv_from
      iv_branch_name = iv_name
      iv_pack        = lv_pack ).

  ENDMETHOD.
  METHOD create_lightweight_tag.

    DATA: lt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
          lv_pack    TYPE xstring.

* &quot;client MUST send an empty packfile&quot;
* https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt#L514
    lv_pack = zcl_abapgit_git_pack=&gt;encode( lt_objects ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = c_zero
      iv_new         = is_tag-sha1
      iv_branch_name = is_tag-name
      iv_pack        = lv_pack ).

  ENDMETHOD.
  METHOD create_tag.

    IF is_tag-name CS ` `.
      zcx_abapgit_exception=&gt;raise( &apos;Tag name cannot contain blank spaces&apos; ).
    ENDIF.

    CASE is_tag-type.
      WHEN zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.

        create_annotated_tag(
          is_tag = is_tag
          iv_url = iv_url ).

      WHEN zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag.

        create_lightweight_tag(
          is_tag = is_tag
          iv_url = iv_url ).

      WHEN OTHERS.

        zcx_abapgit_exception=&gt;raise( |Invalid tag type: { is_tag-type }| ).

    ENDCASE.

  ENDMETHOD.
  METHOD delete_branch.

    DATA: lt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
          lv_pack    TYPE xstring.
* &quot;client MUST send an empty packfile&quot;
* https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt#L514
    lv_pack = zcl_abapgit_git_pack=&gt;encode( lt_objects ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = is_branch-sha1
      iv_new         = c_zero
      iv_branch_name = is_branch-name
      iv_pack        = lv_pack ).

  ENDMETHOD.
  METHOD delete_tag.

    DATA: lt_objects TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
          lv_pack    TYPE xstring.
* &quot;client MUST send an empty packfile&quot;
* https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt#L514
    lv_pack = zcl_abapgit_git_pack=&gt;encode( lt_objects ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = is_tag-sha1
      iv_new         = c_zero
      iv_branch_name = is_tag-name
      iv_pack        = lv_pack ).

  ENDMETHOD.
  METHOD find_folders.

    DATA: lt_paths TYPE TABLE OF string,
          lv_split TYPE string,
          lv_path  TYPE string.

    FIELD-SYMBOLS: &lt;ls_folder&gt; LIKE LINE OF rt_folders,
                   &lt;ls_new&gt;    LIKE LINE OF rt_folders,
                   &lt;ls_exp&gt;    LIKE LINE OF it_expanded.
    LOOP AT it_expanded ASSIGNING &lt;ls_exp&gt;.
      READ TABLE rt_folders WITH KEY path = &lt;ls_exp&gt;-path TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        APPEND INITIAL LINE TO rt_folders ASSIGNING &lt;ls_folder&gt;.
        &lt;ls_folder&gt;-path = &lt;ls_exp&gt;-path.
      ENDIF.
    ENDLOOP.

* add empty folders
    LOOP AT rt_folders ASSIGNING &lt;ls_folder&gt;.
      SPLIT &lt;ls_folder&gt;-path AT &apos;/&apos; INTO TABLE lt_paths.

      CLEAR lv_path.
      LOOP AT lt_paths INTO lv_split.
        CONCATENATE lv_path lv_split &apos;/&apos; INTO lv_path.
        READ TABLE rt_folders WITH KEY path = lv_path TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          APPEND INITIAL LINE TO rt_folders ASSIGNING &lt;ls_new&gt;.
          &lt;ls_new&gt;-path = lv_path.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    LOOP AT rt_folders ASSIGNING &lt;ls_folder&gt;.
      FIND ALL OCCURRENCES OF &apos;/&apos; IN &lt;ls_folder&gt;-path MATCH COUNT &lt;ls_folder&gt;-count.
    ENDLOOP.

  ENDMETHOD.
  METHOD full_tree.

    DATA: ls_object LIKE LINE OF it_objects,
          ls_commit TYPE zcl_abapgit_git_pack=&gt;ty_commit.
    READ TABLE it_objects INTO ls_object
      WITH KEY type COMPONENTS
        type = zif_abapgit_definitions=&gt;c_type-commit
        sha1 = iv_branch.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;commit not found&apos; ).
    ENDIF.
    ls_commit = zcl_abapgit_git_pack=&gt;decode_commit( ls_object-data ).

    rt_expanded = walk_tree( it_objects = it_objects
                             iv_tree    = ls_commit-tree
                             iv_base    = &apos;/&apos; ).

  ENDMETHOD.
  METHOD pull.

    DATA: ls_object LIKE LINE OF rs_result-objects,
          ls_commit TYPE zcl_abapgit_git_pack=&gt;ty_commit.
    zcl_abapgit_git_transport=&gt;upload_pack(
      EXPORTING
        iv_url         = iv_url
        iv_branch_name = iv_branch_name
      IMPORTING
        et_objects     = rs_result-objects
        ev_branch      = rs_result-branch ).

    READ TABLE rs_result-objects INTO ls_object
      WITH KEY type COMPONENTS
        type = zif_abapgit_definitions=&gt;c_type-commit
        sha1 = rs_result-branch.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Commit/branch not found&apos; ).
    ENDIF.
    ls_commit = zcl_abapgit_git_pack=&gt;decode_commit( ls_object-data ).

    walk( EXPORTING it_objects = rs_result-objects
                    iv_sha1 = ls_commit-tree
                    iv_path = &apos;/&apos;
          CHANGING ct_files = rs_result-files ).

  ENDMETHOD.
  METHOD push.

    DATA: lt_expanded TYPE zif_abapgit_definitions=&gt;ty_expanded_tt,
          lt_blobs    TYPE zif_abapgit_definitions=&gt;ty_files_tt,
          lv_sha1     TYPE zif_abapgit_definitions=&gt;ty_sha1,
          lv_new_tree TYPE zif_abapgit_definitions=&gt;ty_sha1,
          lt_trees    TYPE ty_trees_tt,
          lt_stage    TYPE zcl_abapgit_stage=&gt;ty_stage_tt.

    FIELD-SYMBOLS: &lt;ls_stage&gt;   LIKE LINE OF lt_stage,
                   &lt;ls_updated&gt; LIKE LINE OF rs_result-updated_files,
                   &lt;ls_exp&gt;     LIKE LINE OF lt_expanded.
    lt_expanded = full_tree( it_objects = it_old_objects
                             iv_branch  = iv_parent ).

    lt_stage = io_stage-&gt;get_all( ).
    LOOP AT lt_stage ASSIGNING &lt;ls_stage&gt;.

      &quot; Save file ref to updated files table
      APPEND INITIAL LINE TO rs_result-updated_files ASSIGNING &lt;ls_updated&gt;.
      MOVE-CORRESPONDING &lt;ls_stage&gt;-file TO &lt;ls_updated&gt;.

      CASE &lt;ls_stage&gt;-method.
        WHEN zcl_abapgit_stage=&gt;c_method-add.

          APPEND &lt;ls_stage&gt;-file TO lt_blobs.

          READ TABLE lt_expanded ASSIGNING &lt;ls_exp&gt; WITH KEY
            name = &lt;ls_stage&gt;-file-filename
            path = &lt;ls_stage&gt;-file-path.
          IF sy-subrc &lt;&gt; 0. &quot; new files
            APPEND INITIAL LINE TO lt_expanded ASSIGNING &lt;ls_exp&gt;.
            &lt;ls_exp&gt;-name  = &lt;ls_stage&gt;-file-filename.
            &lt;ls_exp&gt;-path  = &lt;ls_stage&gt;-file-path.
            &lt;ls_exp&gt;-chmod = zif_abapgit_definitions=&gt;c_chmod-file.
          ENDIF.

          lv_sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-blob
                                            iv_data = &lt;ls_stage&gt;-file-data ).
          IF &lt;ls_exp&gt;-sha1 &lt;&gt; lv_sha1.
            &lt;ls_exp&gt;-sha1 = lv_sha1.
          ENDIF.

          &lt;ls_updated&gt;-sha1 = lv_sha1.   &quot;New sha1

        WHEN zcl_abapgit_stage=&gt;c_method-rm.
          DELETE lt_expanded
            WHERE name = &lt;ls_stage&gt;-file-filename
            AND   path = &lt;ls_stage&gt;-file-path.
          ASSERT sy-subrc = 0.

          CLEAR &lt;ls_updated&gt;-sha1.       &quot; Mark as deleted

        WHEN OTHERS.
          zcx_abapgit_exception=&gt;raise( &apos;stage method not supported, todo&apos; ).
      ENDCASE.
    ENDLOOP.

    lt_trees = build_trees( lt_expanded ).

    receive_pack_push(
      EXPORTING
        is_comment     = is_comment
        it_trees       = lt_trees
        iv_branch_name = iv_branch_name
        iv_url         = iv_url
        iv_parent      = iv_parent
        iv_parent2     = io_stage-&gt;get_merge_source( )
        it_blobs       = lt_blobs
      IMPORTING
        ev_new_commit  = rs_result-branch
        et_new_objects = rs_result-new_objects
        ev_new_tree    = lv_new_tree ).

    APPEND LINES OF it_old_objects TO rs_result-new_objects.
    walk( EXPORTING it_objects = rs_result-new_objects
                    iv_sha1 = lv_new_tree
                    iv_path = &apos;/&apos;
          CHANGING ct_files = rs_result-new_files ).

  ENDMETHOD.
  METHOD receive_pack_create_tag.

    DATA: lv_tag          TYPE xstring,
          lt_objects      TYPE zif_abapgit_definitions=&gt;ty_objects_tt,
          lv_pack         TYPE xstring,
          ls_object       LIKE LINE OF lt_objects,
          ls_tag          TYPE zcl_abapgit_git_pack=&gt;ty_tag,
          lv_new_tag_sha1 TYPE zif_abapgit_definitions=&gt;ty_sha1.

* new tag
    ls_tag-object       = is_tag-sha1.
    ls_tag-type         = zif_abapgit_definitions=&gt;c_type-commit.
    ls_tag-tag          = is_tag-name.
    ls_tag-tagger_name  = is_tag-tagger_name.
    ls_tag-tagger_email = is_tag-tagger_email.
    ls_tag-message      = is_tag-message
                      &amp;&amp; |{ zif_abapgit_definitions=&gt;c_newline }|
                      &amp;&amp; |{ zif_abapgit_definitions=&gt;c_newline }|
                      &amp;&amp; is_tag-body.

    lv_tag = zcl_abapgit_git_pack=&gt;encode_tag( ls_tag ).

    lv_new_tag_sha1 = zcl_abapgit_hash=&gt;sha1(
      iv_type = zif_abapgit_definitions=&gt;c_type-tag
      iv_data = lv_tag ).

    CLEAR ls_object.
    ls_object-sha1 = lv_new_tag_sha1.
    ls_object-type = zif_abapgit_definitions=&gt;c_type-tag.
    ls_object-data = lv_tag.
    ls_object-index = 1.
    APPEND ls_object TO lt_objects.

    lv_pack = zcl_abapgit_git_pack=&gt;encode( lt_objects ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = c_zero
      iv_new         = lv_new_tag_sha1
      iv_branch_name = is_tag-name
      iv_pack        = lv_pack ).

  ENDMETHOD.
  METHOD receive_pack_push.

    DATA: lv_time   TYPE zcl_abapgit_time=&gt;ty_unixtime,
          lv_commit TYPE xstring,
          lv_pack   TYPE xstring,
          ls_object LIKE LINE OF et_new_objects,
          ls_commit TYPE zcl_abapgit_git_pack=&gt;ty_commit.
    DATA: lv_uindex     TYPE sy-index.

    FIELD-SYMBOLS: &lt;ls_tree&gt; LIKE LINE OF it_trees,
                   &lt;ls_blob&gt; LIKE LINE OF it_blobs.
    lv_time = zcl_abapgit_time=&gt;get( ).

    READ TABLE it_trees ASSIGNING &lt;ls_tree&gt; WITH KEY path = &apos;/&apos;.
    ASSERT sy-subrc = 0.

* new commit
    ls_commit-committer = |{ is_comment-committer-name
      } &lt;{ is_comment-committer-email }&gt; { lv_time }|.
    IF is_comment-author-name IS NOT INITIAL.
      ls_commit-author = |{ is_comment-author-name
        } &lt;{ is_comment-author-email }&gt; { lv_time }|.
    ELSE.
      ls_commit-author = ls_commit-committer.
    ENDIF.

    ls_commit-tree      = &lt;ls_tree&gt;-sha1.
    ls_commit-parent    = iv_parent.
    ls_commit-parent2   = iv_parent2.
    ls_commit-body      = is_comment-comment.
    lv_commit = zcl_abapgit_git_pack=&gt;encode_commit( ls_commit ).

    CLEAR ls_object.
    ls_object-sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = zif_abapgit_definitions=&gt;c_type-commit iv_data = lv_commit ).
    ls_object-type = zif_abapgit_definitions=&gt;c_type-commit.
    ls_object-data = lv_commit.
    APPEND ls_object TO et_new_objects.

    LOOP AT it_trees ASSIGNING &lt;ls_tree&gt;.
      CLEAR ls_object.
      ls_object-sha1 = &lt;ls_tree&gt;-sha1.

      READ TABLE et_new_objects
        WITH KEY type COMPONENTS
          type = zif_abapgit_definitions=&gt;c_type-tree
          sha1 = ls_object-sha1
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
* two identical trees added at the same time, only add one to the pack
        CONTINUE.
      ENDIF.

      ls_object-type = zif_abapgit_definitions=&gt;c_type-tree.
      ls_object-data = &lt;ls_tree&gt;-data.
      lv_uindex = lv_uindex + 1.
      ls_object-index = lv_uindex.
      APPEND ls_object TO et_new_objects.
    ENDLOOP.

    LOOP AT it_blobs ASSIGNING &lt;ls_blob&gt;.
      CLEAR ls_object.
      ls_object-sha1 = zcl_abapgit_hash=&gt;sha1(
        iv_type = zif_abapgit_definitions=&gt;c_type-blob
        iv_data = &lt;ls_blob&gt;-data ).

      READ TABLE et_new_objects
        WITH KEY type COMPONENTS
          type = zif_abapgit_definitions=&gt;c_type-blob
          sha1 = ls_object-sha1
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
* two identical files added at the same time, only add one blob to the pack
        CONTINUE.
      ENDIF.

      ls_object-type = zif_abapgit_definitions=&gt;c_type-blob.
*       ASSERT NOT &lt;ls_blob&gt;-data IS INITIAL. &quot;#1857 allow empty files - some more checks needed?
      ls_object-data = &lt;ls_blob&gt;-data.
      lv_uindex = lv_uindex + 1.
      ls_object-index = lv_uindex.
      APPEND ls_object TO et_new_objects.
    ENDLOOP.

    lv_pack = zcl_abapgit_git_pack=&gt;encode( et_new_objects ).

    ev_new_commit = zcl_abapgit_hash=&gt;sha1(
      iv_type = zif_abapgit_definitions=&gt;c_type-commit
      iv_data = lv_commit ).

    zcl_abapgit_git_transport=&gt;receive_pack(
      iv_url         = iv_url
      iv_old         = iv_parent
      iv_new         = ev_new_commit
      iv_branch_name = iv_branch_name
      iv_pack        = lv_pack ).

    ev_new_tree = ls_commit-tree.

  ENDMETHOD.
  METHOD walk.

    DATA: lv_path  TYPE string,
          ls_file  LIKE LINE OF ct_files,
          lt_nodes TYPE zcl_abapgit_git_pack=&gt;ty_nodes_tt.

    FIELD-SYMBOLS: &lt;ls_tree&gt; LIKE LINE OF it_objects,
                   &lt;ls_blob&gt; LIKE LINE OF it_objects,
                   &lt;ls_node&gt; LIKE LINE OF lt_nodes.
    READ TABLE it_objects ASSIGNING &lt;ls_tree&gt;
      WITH KEY type COMPONENTS
        type = zif_abapgit_definitions=&gt;c_type-tree
        sha1 = iv_sha1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;Walk, tree not found&apos; ).
    ENDIF.

    lt_nodes = zcl_abapgit_git_pack=&gt;decode_tree( &lt;ls_tree&gt;-data ).

    LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt;.
      IF &lt;ls_node&gt;-chmod = zif_abapgit_definitions=&gt;c_chmod-file.
        READ TABLE it_objects ASSIGNING &lt;ls_blob&gt;
          WITH KEY type COMPONENTS
            type = zif_abapgit_definitions=&gt;c_type-blob
            sha1 = &lt;ls_node&gt;-sha1.
        IF sy-subrc &lt;&gt; 0.
          zcx_abapgit_exception=&gt;raise( &apos;Walk, blob not found&apos; ).
        ENDIF.

        CLEAR ls_file.
        ls_file-path     = iv_path.
        ls_file-filename = &lt;ls_node&gt;-name.
        ls_file-data     = &lt;ls_blob&gt;-data.
        ls_file-sha1     = &lt;ls_blob&gt;-sha1.
        APPEND ls_file TO ct_files.
      ENDIF.
    ENDLOOP.

    LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt; WHERE chmod = zif_abapgit_definitions=&gt;c_chmod-dir.
      CONCATENATE iv_path &lt;ls_node&gt;-name &apos;/&apos; INTO lv_path.
      walk( EXPORTING it_objects = it_objects
                      iv_sha1 = &lt;ls_node&gt;-sha1
                      iv_path = lv_path
            CHANGING ct_files = ct_files ).
    ENDLOOP.

  ENDMETHOD.
  METHOD walk_tree.

    DATA: ls_object   LIKE LINE OF it_objects,
          lt_expanded LIKE rt_expanded,
          lt_nodes    TYPE zcl_abapgit_git_pack=&gt;ty_nodes_tt.

    FIELD-SYMBOLS: &lt;ls_exp&gt;  LIKE LINE OF rt_expanded,
                   &lt;ls_node&gt; LIKE LINE OF lt_nodes.
    READ TABLE it_objects INTO ls_object
      WITH KEY type COMPONENTS
        type = zif_abapgit_definitions=&gt;c_type-tree
        sha1 = iv_tree.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( &apos;tree not found&apos; ).
    ENDIF.
    lt_nodes = zcl_abapgit_git_pack=&gt;decode_tree( ls_object-data ).

    LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt;.
      CASE &lt;ls_node&gt;-chmod.
        WHEN zif_abapgit_definitions=&gt;c_chmod-file
            OR zif_abapgit_definitions=&gt;c_chmod-executable.
          APPEND INITIAL LINE TO rt_expanded ASSIGNING &lt;ls_exp&gt;.
          &lt;ls_exp&gt;-path  = iv_base.
          &lt;ls_exp&gt;-name  = &lt;ls_node&gt;-name.
          &lt;ls_exp&gt;-sha1  = &lt;ls_node&gt;-sha1.
          &lt;ls_exp&gt;-chmod = &lt;ls_node&gt;-chmod.
        WHEN zif_abapgit_definitions=&gt;c_chmod-dir.
          lt_expanded = walk_tree(
            it_objects = it_objects
            iv_tree    = &lt;ls_node&gt;-sha1
            iv_base    = iv_base &amp;&amp; &lt;ls_node&gt;-name &amp;&amp; &apos;/&apos; ).
          APPEND LINES OF lt_expanded TO rt_expanded.
        WHEN OTHERS.
          zcx_abapgit_exception=&gt;raise( &apos;walk_tree: unknown chmod&apos; ).
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GIT_PACK IMPLEMENTATION.
  METHOD decode.

    DATA: lv_x              TYPE x,
          lv_data           TYPE xstring,
          lv_type           TYPE c LENGTH 6,
          lv_zlib           TYPE x LENGTH 2,
          lv_objects        TYPE i,
          lv_len            TYPE i,
          lv_sha1           TYPE zif_abapgit_definitions=&gt;ty_sha1,
          lv_ref_delta      TYPE zif_abapgit_definitions=&gt;ty_sha1,
          lv_compressed_len TYPE i,
          lv_compressed     TYPE xstring,
          lv_decompressed   TYPE xstring,
          lv_decompress_len TYPE i,
          lv_xstring        TYPE xstring,
          lv_expected       TYPE i,
          ls_object         LIKE LINE OF rt_objects.
    DATA: lv_uindex            TYPE sy-index.

    lv_data = iv_data.

* header
    IF NOT xstrlen( lv_data ) &gt; 4 OR lv_data(4) &lt;&gt; c_pack_start.
      zcx_abapgit_exception=&gt;raise( &apos;Unexpected pack header&apos; ).
    ENDIF.
    lv_data = lv_data+4.

* version
    IF lv_data(4) &lt;&gt; c_version.
      zcx_abapgit_exception=&gt;raise( &apos;Version not supported&apos; ).
    ENDIF.
    lv_data = lv_data+4.

* number of objects
    lv_xstring = lv_data(4).
    lv_objects = zcl_abapgit_convert=&gt;xstring_to_int( lv_xstring ).
    lv_data = lv_data+4.
    DO lv_objects TIMES.

      lv_uindex = sy-index.

      lv_x = lv_data(1).
      lv_type = get_type( lv_x ).

      get_length( IMPORTING ev_length = lv_expected
                  CHANGING cv_data = lv_data ).

      IF lv_type = zif_abapgit_definitions=&gt;c_type-ref_d.
        lv_ref_delta = lv_data(20).
        lv_data = lv_data+20.
      ENDIF.

* strip header, &apos;789C&apos;, CMF + FLG
      lv_zlib = lv_data(2).
      IF lv_zlib &lt;&gt; c_zlib AND lv_zlib &lt;&gt; c_zlib_hmm.
        zcx_abapgit_exception=&gt;raise( &apos;Unexpected zlib header&apos; ).
      ENDIF.
      lv_data = lv_data+2.

*******************************

      IF lv_zlib = c_zlib.
        cl_abap_gzip=&gt;decompress_binary(
          EXPORTING
            gzip_in     = lv_data
          IMPORTING
            raw_out     = lv_decompressed
            raw_out_len = lv_decompress_len ).

        IF lv_expected &lt;&gt; lv_decompress_len.
          zcx_abapgit_exception=&gt;raise( &apos;Decompression falied&apos; ).
        ENDIF.

        cl_abap_gzip=&gt;compress_binary(
          EXPORTING
            raw_in         = lv_decompressed
          IMPORTING
            gzip_out       = lv_compressed
            gzip_out_len   = lv_compressed_len ).

        IF lv_compressed(lv_compressed_len) &lt;&gt; lv_data(lv_compressed_len).
          &quot;Lets try with zlib before error in out for good
          &quot;This fixes issues with TFS 2017 and visualstudio.com Git repos
          zlib_decompress( CHANGING cv_data = lv_data
                                    cv_decompressed = lv_decompressed ).
        ELSE.
          lv_data = lv_data+lv_compressed_len.
        ENDIF.

      ELSEIF lv_zlib = c_zlib_hmm.
* cl_abap_gzip copmression works for header &apos;789C&apos;, but does not work for
* &apos;7801&apos;, call custom implementation of DEFLATE algorithm.
* The custom implementation could handle both, but most likely the kernel
* implementation runs faster than the custom ABAP.
        zlib_decompress( CHANGING cv_data = lv_data
                                  cv_decompressed = lv_decompressed ).
      ENDIF.

      CLEAR ls_object.
      ls_object-adler32 = lv_data(4).
      lv_data = lv_data+4. &quot; skip adler checksum

      IF lv_type = zif_abapgit_definitions=&gt;c_type-ref_d.
        ls_object-sha1 = lv_ref_delta.
        TRANSLATE ls_object-sha1 TO LOWER CASE.
      ELSE.
        ls_object-sha1 = zcl_abapgit_hash=&gt;sha1(
          iv_type = lv_type
          iv_data = lv_decompressed ).
      ENDIF.
      ls_object-type = lv_type.
      ls_object-data = lv_decompressed.
      ls_object-index = lv_uindex.
      APPEND ls_object TO rt_objects.
    ENDDO.

* check SHA1 at end of pack
    lv_len = xstrlen( iv_data ) - 20.
    lv_xstring = iv_data(lv_len).
    lv_sha1 = zcl_abapgit_hash=&gt;sha1_raw( lv_xstring ).
    IF to_upper( lv_sha1 ) &lt;&gt; lv_data.
      zcx_abapgit_exception=&gt;raise( &apos;SHA1 at end of pack doesnt match&apos; ).
    ENDIF.

    decode_deltas( CHANGING ct_objects = rt_objects ).

  ENDMETHOD.
  METHOD decode_commit.

    DATA: lv_string TYPE string,
          lv_word   TYPE string,
          lv_length TYPE i,
          lv_trash  TYPE string ##NEEDED,
          lt_string TYPE TABLE OF string.

    FIELD-SYMBOLS: &lt;lv_string&gt; LIKE LINE OF lt_string.
    lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_data ).

    SPLIT lv_string AT zif_abapgit_definitions=&gt;c_newline INTO TABLE lt_string.

    LOOP AT lt_string ASSIGNING &lt;lv_string&gt;.
      lv_length = strlen( &lt;lv_string&gt; ) + 1.
      lv_string = lv_string+lv_length.

      SPLIT &lt;lv_string&gt; AT space INTO lv_word lv_trash.
      CASE lv_word.
        WHEN &apos;tree&apos;.
          rs_commit-tree = &lt;lv_string&gt;+5.
        WHEN &apos;parent&apos;.
          IF rs_commit-parent IS INITIAL.
            rs_commit-parent = &lt;lv_string&gt;+7.
          ELSE.
            rs_commit-parent2 = &lt;lv_string&gt;+7.
          ENDIF.
        WHEN &apos;author&apos;.
          rs_commit-author = &lt;lv_string&gt;+7.
        WHEN &apos;committer&apos;.
          rs_commit-committer = &lt;lv_string&gt;+10.
          EXIT. &quot; current loop
        WHEN OTHERS.
          ASSERT 0 = 1.
      ENDCASE.
    ENDLOOP.

    rs_commit-body = lv_string+1.

    IF rs_commit-author IS INITIAL
        OR rs_commit-committer IS INITIAL
        OR rs_commit-tree IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;multiple parents? not supported&apos; ).
    ENDIF.

  ENDMETHOD.
  METHOD decode_deltas.

    DATA: ls_object   LIKE LINE OF ct_objects,
          lo_progress TYPE REF TO zcl_abapgit_progress,
          lt_deltas   LIKE ct_objects.
    LOOP AT ct_objects INTO ls_object
      USING KEY type
      WHERE type = zif_abapgit_definitions=&gt;c_type-ref_d.
      INSERT ls_object INTO TABLE lt_deltas.
    ENDLOOP.

    DELETE ct_objects
      USING KEY type
      WHERE type = zif_abapgit_definitions=&gt;c_type-ref_d.

    &quot;Restore correct Delta Order
    SORT lt_deltas BY index.

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lines( lt_deltas ).

    LOOP AT lt_deltas INTO ls_object.
      lo_progress-&gt;show( iv_current = sy-tabix
                         iv_text    = &apos;Decode deltas&apos; ) ##NO_TEXT.

      delta( EXPORTING is_object = ls_object
             CHANGING ct_objects = ct_objects ).
    ENDLOOP.

  ENDMETHOD.
  METHOD decode_tag.

    DATA: lv_string TYPE string,
          lv_word   TYPE string,
          lv_trash  TYPE string ##NEEDED,
          lt_string TYPE TABLE OF string.

    FIELD-SYMBOLS: &lt;lv_string&gt; LIKE LINE OF lt_string.
    lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( iv_data ).

    SPLIT lv_string AT zif_abapgit_definitions=&gt;c_newline INTO TABLE lt_string.

    LOOP AT lt_string ASSIGNING &lt;lv_string&gt;.

      SPLIT &lt;lv_string&gt; AT space INTO lv_word lv_trash.

      CASE lv_word.
        WHEN &apos;object&apos;.
          rs_tag-object = lv_trash.
        WHEN &apos;type&apos;.
          rs_tag-type = lv_trash.
        WHEN &apos;tag&apos;.
          rs_tag-tag = lv_trash.
        WHEN &apos;tagger&apos;.

          FIND FIRST OCCURRENCE OF REGEX `(.*)&lt;(.*)&gt;`
                     IN lv_trash
                     SUBMATCHES rs_tag-tagger_name
                                rs_tag-tagger_email.

          rs_tag-tagger_name = condense( rs_tag-tagger_name ).

        WHEN &apos;&apos;.
          &quot; ignore blank lines
          CONTINUE.
        WHEN OTHERS.

          &quot; these are the non empty line which don&apos;t start with a key word
          &quot; the first one is the message, the rest are cumulated to the body

          IF rs_tag-message IS INITIAL.
            rs_tag-message = &lt;lv_string&gt;.
          ELSE.

            IF rs_tag-body IS NOT INITIAL.
              rs_tag-body = rs_tag-body &amp;&amp; zif_abapgit_definitions=&gt;c_newline.
            ENDIF.

            rs_tag-body = rs_tag-body &amp;&amp; &lt;lv_string&gt;.

          ENDIF.

      ENDCASE.

    ENDLOOP.

  ENDMETHOD.
  METHOD decode_tree.

    CONSTANTS: lc_sha_length TYPE i VALUE 20,
               lc_null       TYPE x VALUE &apos;00&apos;.

    DATA: lv_xstring TYPE xstring,
          lv_chmod   TYPE zif_abapgit_definitions=&gt;ty_chmod,
          lv_name    TYPE string,
          lv_string  TYPE string,
          lv_len     TYPE i,
          lv_offset  TYPE i,
          lv_cursor  TYPE i,
          lv_match   TYPE i,
          ls_node    TYPE ty_node.
    DO.
      FIND FIRST OCCURRENCE OF lc_null IN SECTION OFFSET lv_cursor OF iv_data
        IN BYTE MODE MATCH OFFSET lv_match.
      IF sy-subrc &lt;&gt; 0.
        EXIT.
      ENDIF.

      lv_len = lv_match - lv_cursor.
      lv_xstring = iv_data+lv_cursor(lv_len).

      lv_string = zcl_abapgit_convert=&gt;xstring_to_string_utf8( lv_xstring ).
      SPLIT lv_string AT space INTO lv_chmod lv_name.

      CLEAR ls_node.
      ls_node-chmod = lv_chmod.
      IF ls_node-chmod &lt;&gt; zif_abapgit_definitions=&gt;c_chmod-dir
          AND ls_node-chmod &lt;&gt; zif_abapgit_definitions=&gt;c_chmod-file
          AND ls_node-chmod &lt;&gt; zif_abapgit_definitions=&gt;c_chmod-executable.
        zcx_abapgit_exception=&gt;raise( &apos;Unknown chmod&apos; ).
      ENDIF.

      lv_offset = lv_match + 1.
      ls_node-name = lv_name.
      ls_node-sha1 = iv_data+lv_offset(lc_sha_length).
      TRANSLATE ls_node-sha1 TO LOWER CASE.
      APPEND ls_node TO rt_nodes.

      lv_cursor = lv_match + 1 + lc_sha_length.
    ENDDO.

  ENDMETHOD.
  METHOD delta.

    CONSTANTS: lc_1   TYPE x VALUE &apos;01&apos;,
               lc_2   TYPE x VALUE &apos;02&apos;,
               lc_4   TYPE x VALUE &apos;04&apos;,
               lc_8   TYPE x VALUE &apos;08&apos;,
               lc_16  TYPE x VALUE &apos;10&apos;,
               lc_32  TYPE x VALUE &apos;20&apos;,
               lc_64  TYPE x VALUE &apos;40&apos;,
               lc_128 TYPE x VALUE &apos;80&apos;.

    DEFINE _eat_byte.
      lv_x = lv_delta(1).
      lv_delta = lv_delta+1.
    END-OF-DEFINITION.

    DATA: lv_delta  TYPE xstring,
          lv_base   TYPE xstring,
          lv_result TYPE xstring,
          lv_offset TYPE i,
          lv_sha1   TYPE zif_abapgit_definitions=&gt;ty_sha1,
          ls_object LIKE LINE OF ct_objects,
          lv_len    TYPE i,
          lv_org    TYPE x,
          lv_x      TYPE x.

    FIELD-SYMBOLS: &lt;ls_object&gt; LIKE LINE OF ct_objects.
    lv_delta = is_object-data.

* find base
    READ TABLE ct_objects ASSIGNING &lt;ls_object&gt;
      WITH KEY sha COMPONENTS sha1 = is_object-sha1.
    IF sy-subrc &lt;&gt; 0.
      zcx_abapgit_exception=&gt;raise( |Base not found, { is_object-sha1 }| ).
    ELSEIF &lt;ls_object&gt;-type = zif_abapgit_definitions=&gt;c_type-ref_d.
* sanity check
      zcx_abapgit_exception=&gt;raise( &apos;Delta, base eq delta&apos; ).
    ENDIF.

    lv_base = &lt;ls_object&gt;-data.

* skip the 2 headers
    delta_header( CHANGING cv_delta = lv_delta ).
    delta_header( CHANGING cv_delta = lv_delta ).

    WHILE xstrlen( lv_delta ) &gt; 0.

      _eat_byte.
      lv_org = lv_x.

      IF lv_x BIT-AND lc_128 = lc_128. &quot; MSB = 1

        lv_offset = 0.
        IF lv_org BIT-AND lc_1 = lc_1.
          _eat_byte.
          lv_offset = lv_x.
        ENDIF.
        IF lv_org BIT-AND lc_2 = lc_2.
          _eat_byte.
          lv_offset = lv_offset + lv_x * 256.
        ENDIF.
        IF lv_org BIT-AND lc_4 = lc_4.
          _eat_byte.
          lv_offset = lv_offset + lv_x * 65536.
        ENDIF.
        IF lv_org BIT-AND lc_8 = lc_8.
          _eat_byte.
          lv_offset = lv_offset + lv_x * 16777216. &quot; hmm, overflow?
        ENDIF.

        lv_len = 0.
        IF lv_org BIT-AND lc_16 = lc_16.
          _eat_byte.
          lv_len = lv_x.
        ENDIF.
        IF lv_org BIT-AND lc_32 = lc_32.
          _eat_byte.
          lv_len = lv_len + lv_x * 256.
        ENDIF.
        IF lv_org BIT-AND lc_64 = lc_64.
          _eat_byte.
          lv_len = lv_len + lv_x * 65536.
        ENDIF.

        IF lv_len = 0.
          lv_len = 65536.
        ENDIF.

        CONCATENATE lv_result lv_base+lv_offset(lv_len)
          INTO lv_result IN BYTE MODE.
      ELSE. &quot; lv_bitbyte(1) = &apos;0&apos;
* insert from delta
        lv_len = lv_x.
        CONCATENATE lv_result lv_delta(lv_len) INTO lv_result IN BYTE MODE.
        lv_delta = lv_delta+lv_len.
      ENDIF.

    ENDWHILE.

    lv_sha1 = zcl_abapgit_hash=&gt;sha1( iv_type = &lt;ls_object&gt;-type iv_data = lv_result ).

    CLEAR ls_object.
    ls_object-sha1 = lv_sha1.
    ls_object-type = &lt;ls_object&gt;-type.
    ls_object-data = lv_result.
    ls_object-index = &lt;ls_object&gt;-index. &quot;Retain sort index
    APPEND ls_object TO ct_objects.

  ENDMETHOD.
  METHOD delta_header.

    DATA: lv_bitbyte TYPE zif_abapgit_definitions=&gt;ty_bitbyte,
          lv_bits    TYPE string,
          lv_x       TYPE x.
    lv_bits = &apos;&apos;.
    DO.
      lv_x = cv_delta(1).
      cv_delta = cv_delta+1.
      lv_bitbyte = zcl_abapgit_convert=&gt;x_to_bitbyte( lv_x ).
      CONCATENATE lv_bitbyte+1 lv_bits INTO lv_bits.
      IF lv_bitbyte(1) = &apos;0&apos;.
        EXIT. &quot; current loop
      ENDIF.
    ENDDO.
    ev_header = zcl_abapgit_convert=&gt;bitbyte_to_int( lv_bits ).

  ENDMETHOD.
  METHOD encode.

    DATA: lv_sha1          TYPE x LENGTH 20,
          lv_adler32       TYPE zif_abapgit_definitions=&gt;ty_adler32,
          lv_compressed    TYPE xstring,
          lv_xstring       TYPE xstring,
          lo_progress      TYPE REF TO zcl_abapgit_progress,
          lv_objects_total TYPE i.

    FIELD-SYMBOLS: &lt;ls_object&gt;  LIKE LINE OF it_objects.
    rv_data = c_pack_start.

    CONCATENATE rv_data c_version INTO rv_data IN BYTE MODE.

    lv_xstring = zcl_abapgit_convert=&gt;int_to_xstring4( lines( it_objects ) ).
    CONCATENATE rv_data lv_xstring INTO rv_data IN BYTE MODE.

    lv_objects_total = lines( it_objects ).

    CREATE OBJECT lo_progress
      EXPORTING
        iv_total = lv_objects_total.

    LOOP AT it_objects ASSIGNING &lt;ls_object&gt;.
      IF sy-tabix MOD 200 = 0.
        lo_progress-&gt;show(
          iv_current = sy-tabix
          iv_text    = |Encoding objects ( { sy-tabix } of { lv_objects_total } )| ).
      ENDIF.

      lv_xstring = type_and_length(
        iv_type   = &lt;ls_object&gt;-type
        iv_length = xstrlen( &lt;ls_object&gt;-data ) ).
      CONCATENATE rv_data lv_xstring INTO rv_data IN BYTE MODE.

      cl_abap_gzip=&gt;compress_binary(
        EXPORTING
          raw_in   = &lt;ls_object&gt;-data
        IMPORTING
          gzip_out = lv_compressed ).

      CONCATENATE rv_data c_zlib lv_compressed INTO rv_data IN BYTE MODE.

      IF NOT &lt;ls_object&gt;-adler32 IS INITIAL.
        lv_adler32 = &lt;ls_object&gt;-adler32.
      ELSE.
        lv_adler32 = zcl_abapgit_hash=&gt;adler32( &lt;ls_object&gt;-data ).
      ENDIF.
      CONCATENATE rv_data lv_adler32 INTO rv_data IN BYTE MODE.

    ENDLOOP.

    lv_sha1 = to_upper( zcl_abapgit_hash=&gt;sha1_raw( rv_data ) ).
    CONCATENATE rv_data lv_sha1 INTO rv_data IN BYTE MODE.

  ENDMETHOD.
  METHOD encode_commit.

    DATA: lv_string       TYPE string,
          lv_tmp          TYPE string,
          lv_tree_lower   TYPE string,
          lv_parent_lower TYPE string.
    lv_tree_lower = is_commit-tree.
    TRANSLATE lv_tree_lower TO LOWER CASE.

    lv_string = &apos;&apos;.

    CONCATENATE &apos;tree&apos; lv_tree_lower INTO lv_tmp SEPARATED BY space. &quot;#EC NOTEXT
    CONCATENATE lv_string lv_tmp zif_abapgit_definitions=&gt;c_newline INTO lv_string.

    IF NOT is_commit-parent IS INITIAL.
      lv_parent_lower = is_commit-parent.
      TRANSLATE lv_parent_lower TO LOWER CASE.

      CONCATENATE &apos;parent&apos; lv_parent_lower
        INTO lv_tmp SEPARATED BY space.                     &quot;#EC NOTEXT
      CONCATENATE lv_string lv_tmp zif_abapgit_definitions=&gt;c_newline INTO lv_string.
    ENDIF.

    IF NOT is_commit-parent2 IS INITIAL.
      lv_parent_lower = is_commit-parent2.
      TRANSLATE lv_parent_lower TO LOWER CASE.

      CONCATENATE &apos;parent&apos; lv_parent_lower
        INTO lv_tmp SEPARATED BY space.                     &quot;#EC NOTEXT
      CONCATENATE lv_string lv_tmp zif_abapgit_definitions=&gt;c_newline INTO lv_string.
    ENDIF.

    CONCATENATE &apos;author&apos; is_commit-author
      INTO lv_tmp SEPARATED BY space.                       &quot;#EC NOTEXT
    CONCATENATE lv_string lv_tmp zif_abapgit_definitions=&gt;c_newline INTO lv_string.

    CONCATENATE &apos;committer&apos; is_commit-committer
      INTO lv_tmp SEPARATED BY space.                       &quot;#EC NOTEXT
    CONCATENATE lv_string lv_tmp zif_abapgit_definitions=&gt;c_newline INTO lv_string.

    CONCATENATE lv_string zif_abapgit_definitions=&gt;c_newline is_commit-body INTO lv_string.

    rv_data = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

  ENDMETHOD.
  METHOD encode_tag.

    DATA: lv_string TYPE string,
          lv_time   TYPE zcl_abapgit_time=&gt;ty_unixtime.

    lv_time = zcl_abapgit_time=&gt;get( ).

    lv_string = |object { is_tag-object }{ zif_abapgit_definitions=&gt;c_newline }|
             &amp;&amp; |type { is_tag-type }{ zif_abapgit_definitions=&gt;c_newline }|
             &amp;&amp; |tag { zcl_abapgit_tag=&gt;remove_tag_prefix( is_tag-tag ) }{ zif_abapgit_definitions=&gt;c_newline }|
             &amp;&amp; |tagger { is_tag-tagger_name } &lt;{ is_tag-tagger_email }&gt; { lv_time }|
             &amp;&amp; |{ zif_abapgit_definitions=&gt;c_newline }|
             &amp;&amp; |{ zif_abapgit_definitions=&gt;c_newline }|
             &amp;&amp; |{ is_tag-message }|.

    rv_data = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

  ENDMETHOD.
  METHOD encode_tree.

    CONSTANTS: lc_null TYPE x VALUE &apos;00&apos;.

    DATA: lv_string  TYPE string,
          lt_nodes   LIKE it_nodes,
          lv_hex20   TYPE x LENGTH 20,
          lv_xstring TYPE xstring.

    FIELD-SYMBOLS: &lt;ls_node&gt; LIKE LINE OF it_nodes.
    lt_nodes = sort_tree( it_nodes ).

    LOOP AT lt_nodes ASSIGNING &lt;ls_node&gt;.
      ASSERT NOT &lt;ls_node&gt;-chmod IS INITIAL.
      ASSERT NOT &lt;ls_node&gt;-name IS INITIAL.
      ASSERT NOT &lt;ls_node&gt;-sha1 IS INITIAL.

      CONCATENATE &lt;ls_node&gt;-chmod &lt;ls_node&gt;-name INTO lv_string SEPARATED BY space.
      lv_xstring = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

      lv_hex20 = to_upper( &lt;ls_node&gt;-sha1 ).
      CONCATENATE rv_data lv_xstring lc_null lv_hex20 INTO rv_data IN BYTE MODE.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_length.

    DATA: lv_x           TYPE x,
          lv_length_bits TYPE string,
          lv_bitbyte     TYPE zif_abapgit_definitions=&gt;ty_bitbyte.
    lv_x = cv_data(1).
    lv_bitbyte = zcl_abapgit_convert=&gt;x_to_bitbyte( lv_x ).

    cv_data = cv_data+1.
    lv_length_bits = lv_bitbyte+4.

    WHILE lv_bitbyte(1) &lt;&gt; &apos;0&apos;.
      lv_x = cv_data(1).
      lv_bitbyte = zcl_abapgit_convert=&gt;x_to_bitbyte( lv_x ).
      cv_data = cv_data+1.
      CONCATENATE lv_bitbyte+1 lv_length_bits INTO lv_length_bits.
    ENDWHILE.

    ev_length = zcl_abapgit_convert=&gt;bitbyte_to_int( lv_length_bits ).

  ENDMETHOD.
  METHOD get_type.

    CONSTANTS: lc_mask TYPE x VALUE 112.
    DATA: lv_xtype TYPE x.

    lv_xtype = iv_x BIT-AND lc_mask.

    CASE lv_xtype.
      WHEN 16.
        rv_type = zif_abapgit_definitions=&gt;c_type-commit.
      WHEN 32.
        rv_type = zif_abapgit_definitions=&gt;c_type-tree.
      WHEN 48.
        rv_type = zif_abapgit_definitions=&gt;c_type-blob.
      WHEN 64.
        rv_type = zif_abapgit_definitions=&gt;c_type-tag.
      WHEN 112.
        rv_type = zif_abapgit_definitions=&gt;c_type-ref_d.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;Todo, unknown type&apos; ).
    ENDCASE.

  ENDMETHOD.
  METHOD sort_tree.

    TYPES: BEGIN OF ty_sort,
             sort TYPE string,
             node TYPE ty_node,
           END OF ty_sort.

    DATA: lt_sort TYPE STANDARD TABLE OF ty_sort WITH DEFAULT KEY.

    FIELD-SYMBOLS: &lt;ls_sort&gt; LIKE LINE OF lt_sort,
                   &lt;ls_node&gt; LIKE LINE OF it_nodes.
    LOOP AT it_nodes ASSIGNING &lt;ls_node&gt;.
      APPEND INITIAL LINE TO lt_sort ASSIGNING &lt;ls_sort&gt;.
      IF &lt;ls_node&gt;-chmod = zif_abapgit_definitions=&gt;c_chmod-dir.
        CONCATENATE &lt;ls_node&gt;-name &apos;/&apos; INTO &lt;ls_sort&gt;-sort.
      ELSE.
        &lt;ls_sort&gt;-sort = &lt;ls_node&gt;-name.
      ENDIF.
      &lt;ls_sort&gt;-node = &lt;ls_node&gt;.
    ENDLOOP.

* following has to be done, or unpack will fail on server side
    SORT lt_sort BY sort ASCENDING.

    LOOP AT lt_sort ASSIGNING &lt;ls_sort&gt;.
      APPEND &lt;ls_sort&gt;-node TO rt_nodes.
    ENDLOOP.

  ENDMETHOD.
  METHOD type_and_length.

* see http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/#pack_file_objects

    DATA: lv_type   TYPE i,
          lv_length TYPE i,
          lv_hex    TYPE x LENGTH 1.
    CASE iv_type.
      WHEN zif_abapgit_definitions=&gt;c_type-commit.
        lv_type = 16.
      WHEN zif_abapgit_definitions=&gt;c_type-tree.
        lv_type = 32.
      WHEN zif_abapgit_definitions=&gt;c_type-blob.
        lv_type = 48.
      WHEN zif_abapgit_definitions=&gt;c_type-tag.
        lv_type = 64.
      WHEN zif_abapgit_definitions=&gt;c_type-ref_d.
        lv_type = 112.
      WHEN OTHERS.
        zcx_abapgit_exception=&gt;raise( &apos;Unexpected object type while encoding pack&apos; ).
    ENDCASE.

    lv_length = iv_length.

* first byte
    IF lv_length &gt; 15.
      lv_hex = 128.
    ENDIF.
    lv_hex = lv_hex + lv_type + lv_length MOD 16.
    rv_xstring = lv_hex.
    lv_length = lv_length DIV 16.

* subsequent bytes
    WHILE lv_length &gt;= 128.
      lv_hex = 128 + lv_length MOD 128.
      CONCATENATE rv_xstring lv_hex INTO rv_xstring IN BYTE MODE.
      lv_length = lv_length DIV 128.
    ENDWHILE.

* last byte
    IF lv_length &gt; 0.
      lv_hex = lv_length.
      CONCATENATE rv_xstring lv_hex INTO rv_xstring IN BYTE MODE.
    ENDIF.

  ENDMETHOD.
  METHOD zlib_decompress.

    DATA: ls_data           TYPE zcl_abapgit_zlib=&gt;ty_decompress,
          lv_compressed_len TYPE i,
          lv_adler32        TYPE zif_abapgit_definitions=&gt;ty_adler32.
    ls_data = zcl_abapgit_zlib=&gt;decompress( cv_data ).
    lv_compressed_len = ls_data-compressed_len.
    cv_decompressed = ls_data-raw.

    IF lv_compressed_len IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Decompression falied :o/&apos; ).
    ENDIF.

    cv_data = cv_data+lv_compressed_len.

    lv_adler32 = zcl_abapgit_hash=&gt;adler32( cv_decompressed ).
    IF cv_data(4) &lt;&gt; lv_adler32.
      cv_data = cv_data+1.
    ENDIF.
    IF cv_data(4) &lt;&gt; lv_adler32.
      cv_data = cv_data+1.
    ENDIF.
    IF cv_data(4) &lt;&gt; lv_adler32.
      zcx_abapgit_exception=&gt;raise( &apos;Wrong Adler checksum&apos; ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_GIT_BRANCH_LIST IMPLEMENTATION.
  METHOD complete_heads_branch_name.
    IF iv_branch_name CP &apos;refs/heads/*&apos;.
      rv_name = iv_branch_name.
    ELSE.
      rv_name = &apos;refs/heads/&apos; &amp;&amp; iv_branch_name.
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    parse_branch_list(
      EXPORTING iv_data        = iv_data
      IMPORTING et_list        = me-&gt;mt_branches
                ev_head_symref = me-&gt;mv_head_symref ).
  ENDMETHOD.
  METHOD find_by_name.

    IF iv_branch_name IS INITIAL.
      zcx_abapgit_exception=&gt;raise( &apos;Branch name empty&apos; ) ##NO_TEXT.
    ENDIF.

    IF iv_branch_name CP |refs/tags/*|.
      rs_branch = find_tag_by_name( iv_branch_name ).
    ELSE.

      READ TABLE mt_branches INTO rs_branch
        WITH KEY name = iv_branch_name.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( |Branch not found: { iv_branch_name }| ).
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD find_tag_by_name.

    DATA: lv_branch_name TYPE string.

    lv_branch_name = iv_branch_name &amp;&amp; &apos;^{}&apos;.

    READ TABLE mt_branches INTO rs_branch
        WITH KEY name = lv_branch_name.
    IF sy-subrc &lt;&gt; 0.

      READ TABLE mt_branches INTO rs_branch
        WITH KEY name = iv_branch_name.
      IF sy-subrc &lt;&gt; 0.
        zcx_abapgit_exception=&gt;raise( &apos;Branch not found&apos; ) ##NO_TEXT.
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD get_branches_only.
    FIELD-SYMBOLS &lt;ls_branch&gt; LIKE LINE OF mt_branches.

    LOOP AT mt_branches ASSIGNING &lt;ls_branch&gt;.
      IF &lt;ls_branch&gt;-type = zif_abapgit_definitions=&gt;c_git_branch_type-branch.
        APPEND &lt;ls_branch&gt; TO rt_branches.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_display_name.
    rv_display_name = iv_branch_name.

    IF rv_display_name CP &apos;refs/heads/*&apos;.
      REPLACE FIRST OCCURRENCE OF &apos;refs/heads/&apos; IN rv_display_name WITH &apos;&apos;.
    ELSEIF rv_display_name CP &apos;refs/tags/*&apos;.
      REPLACE FIRST OCCURRENCE OF &apos;refs/&apos; IN rv_display_name WITH &apos;&apos;.
    ENDIF.

  ENDMETHOD.
  METHOD get_head.

    IF mv_head_symref IS NOT INITIAL.
      rs_branch = find_by_name( mv_head_symref ).
    ELSE.
      rs_branch = find_by_name( zif_abapgit_definitions=&gt;c_head_name ).
    ENDIF.

  ENDMETHOD.
  METHOD get_head_symref.
    rv_head_symref = mv_head_symref.
  ENDMETHOD.
  METHOD get_tags_only.
    FIELD-SYMBOLS &lt;ls_branch&gt; LIKE LINE OF mt_branches.

    LOOP AT mt_branches ASSIGNING &lt;ls_branch&gt;
                        WHERE type = zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag
                           OR type = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.
      APPEND &lt;ls_branch&gt; TO rt_tags.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_type.

    DATA: lv_annotated_tag_with_suffix TYPE string.

    FIELD-SYMBOLS: &lt;lv_result&gt; TYPE LINE OF stringtab.

    rv_type = zif_abapgit_definitions=&gt;c_git_branch_type-other.

    IF iv_branch_name CP &apos;refs/heads/*&apos; OR iv_branch_name = zif_abapgit_definitions=&gt;c_head_name.
      rv_type = zif_abapgit_definitions=&gt;c_git_branch_type-branch.
      RETURN.
    ENDIF.

    IF iv_branch_name CP &apos;refs/tags/*&apos;.

      lv_annotated_tag_with_suffix = iv_branch_name &amp;&amp; &apos;^{}&apos;.

      READ TABLE it_result ASSIGNING &lt;lv_result&gt;
                           INDEX iv_current_row_index + 1.
      IF sy-subrc = 0 AND &lt;lv_result&gt; CP &apos;*&apos; &amp;&amp; lv_annotated_tag_with_suffix.
        rv_type = zif_abapgit_definitions=&gt;c_git_branch_type-annotated_tag.
      ELSE.
        rv_type = zif_abapgit_definitions=&gt;c_git_branch_type-lightweight_tag.
      ENDIF.

    ENDIF.

  ENDMETHOD.
  METHOD is_ignored.

    IF iv_branch_name = &apos;refs/heads/gh-pages&apos;. &quot; Github pages
      rv_ignore = abap_true.
    ENDIF.

    IF iv_branch_name CP &apos;refs/pull/*&apos;
        OR iv_branch_name CP &apos;refs/merge-requests/*&apos;
        OR iv_branch_name CP &apos;refs/keep-around/*&apos;
        OR iv_branch_name CP &apos;refs/tmp/*&apos;.
      rv_ignore = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD normalize_branch_name.

    rv_name = iv_branch_name. &quot; Force convert to string
    REPLACE ALL OCCURRENCES OF ` ` IN rv_name WITH &apos;-&apos;. &quot; Disallow space in branch name

  ENDMETHOD.
  METHOD parse_branch_list.

    DATA: lt_result            TYPE TABLE OF string,
          lv_hash              TYPE zif_abapgit_definitions=&gt;ty_sha1,
          lv_name              TYPE string,
          lv_head_params       TYPE string,
          lv_char              TYPE c,
          lv_data              LIKE LINE OF lt_result,
          lv_current_row_index TYPE syst-tabix.

    FIELD-SYMBOLS: &lt;ls_branch&gt; LIKE LINE OF et_list.

    CLEAR: et_list, ev_head_symref.

    lv_data = skip_first_pkt( iv_data ).
    SPLIT lv_data AT zif_abapgit_definitions=&gt;c_newline INTO TABLE lt_result.

    LOOP AT lt_result INTO lv_data.
      lv_current_row_index = sy-tabix.

      IF sy-tabix = 1 AND strlen( lv_data ) &gt; 49.
        lv_hash = lv_data+8.
        lv_name = lv_data+49.
        lv_char = zcl_abapgit_git_utils=&gt;get_null( ).

        SPLIT lv_name AT lv_char INTO lv_name lv_head_params.
        ev_head_symref = parse_head_params( lv_head_params ).
      ELSEIF sy-tabix &gt; 1 AND strlen( lv_data ) &gt; 45.
        lv_hash = lv_data+4.
        lv_name = lv_data+45.
      ELSEIF sy-tabix = 1 AND strlen( lv_data ) = 8 AND lv_data(8) = &apos;00000000&apos;.
        zcx_abapgit_exception=&gt;raise( &apos;No branches, create branch manually by adding file&apos; ) ##NO_TEXT.
      ELSE.
        CONTINUE.
      ENDIF.

      CHECK is_ignored( lv_name ) = abap_false.
      ASSERT lv_name IS NOT INITIAL.

      APPEND INITIAL LINE TO et_list ASSIGNING &lt;ls_branch&gt;.
      &lt;ls_branch&gt;-sha1         = lv_hash.
      &lt;ls_branch&gt;-name         = lv_name.
      &lt;ls_branch&gt;-display_name = get_display_name( lv_name ).
      &lt;ls_branch&gt;-type         = get_type( iv_branch_name       = lv_name
                                           it_result            = lt_result
                                           iv_current_row_index = lv_current_row_index ).
      IF &lt;ls_branch&gt;-name = zif_abapgit_definitions=&gt;c_head_name OR &lt;ls_branch&gt;-name = ev_head_symref.
        &lt;ls_branch&gt;-is_head    = abap_true.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD parse_head_params.

    DATA: ls_match    TYPE match_result,
          ls_submatch LIKE LINE OF ls_match-submatches.

    FIND FIRST OCCURRENCE OF REGEX &apos;\ssymref=HEAD:([^\s]+)&apos; IN iv_data RESULTS ls_match.
    READ TABLE ls_match-submatches INTO ls_submatch INDEX 1.
    IF sy-subrc IS INITIAL.
      rv_head_symref = iv_data+ls_submatch-offset(ls_submatch-length).
    ENDIF.

  ENDMETHOD.
  METHOD skip_first_pkt.

    DATA: lv_hex    TYPE x LENGTH 1,
          lv_length TYPE i,
          lv_0a_pos TYPE i.
* channel
    ASSERT iv_data(2) = &apos;00&apos;.

    lv_hex = to_upper( iv_data+2(2) ).
    lv_0a_pos = lv_hex - 1.
    IF iv_data+lv_0a_pos(1) = cl_abap_char_utilities=&gt;newline.
      lv_length = lv_hex.
    ELSE.
      lv_length = lv_hex.
    ENDIF.

    rv_data = iv_data+lv_length.

  ENDMETHOD.
ENDCLASS.
CLASS zcl_abapgit_git_add_patch IMPLEMENTATION.
  METHOD calculate_patch.

    FIELD-SYMBOLS: &lt;ls_diff&gt; TYPE zif_abapgit_definitions=&gt;ty_diff.

    LOOP AT mt_diff ASSIGNING &lt;ls_diff&gt;.

      CASE &lt;ls_diff&gt;-result.
        WHEN &apos; &apos;.

          INSERT &lt;ls_diff&gt;-new INTO TABLE rt_patch.

        WHEN zif_abapgit_definitions=&gt;c_diff-insert.

          IF &lt;ls_diff&gt;-patch_flag = abap_true.
            INSERT &lt;ls_diff&gt;-new INTO TABLE rt_patch.
          ENDIF.

        WHEN zif_abapgit_definitions=&gt;c_diff-delete.

          IF &lt;ls_diff&gt;-patch_flag = abap_false.
            INSERT &lt;ls_diff&gt;-old INTO TABLE rt_patch.
          ENDIF.

        WHEN zif_abapgit_definitions=&gt;c_diff-update.

          IF &lt;ls_diff&gt;-patch_flag = abap_true.
            INSERT &lt;ls_diff&gt;-new INTO TABLE rt_patch.
          ELSE.
            INSERT &lt;ls_diff&gt;-old INTO TABLE rt_patch.
          ENDIF.

        WHEN OTHERS.

          zcx_abapgit_exception=&gt;raise( |Unknown result| ).

      ENDCASE.

    ENDLOOP.

  ENDMETHOD.
  METHOD constructor.

    mt_diff = it_diff.

  ENDMETHOD.
  METHOD get_patch.

    IF mt_patch IS INITIAL.
      mt_patch = calculate_patch( ).
    ENDIF.

    rt_patch = mt_patch.

  ENDMETHOD.
  METHOD get_patch_binary.

    DATA: lv_string TYPE string.

    IF mt_patch IS INITIAL.
      mt_patch = calculate_patch( ).
    ENDIF.

    CONCATENATE LINES OF mt_patch INTO lv_string SEPARATED BY zif_abapgit_definitions=&gt;c_newline.
    lv_string = lv_string &amp;&amp; zif_abapgit_definitions=&gt;c_newline.

    rv_patch_binary = zcl_abapgit_convert=&gt;string_to_xstring_utf8( lv_string ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_BACKGROUND_PUSH_FI IMPLEMENTATION.
  METHOD build_comment.

    DATA: lt_objects TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
          lv_str     TYPE string.

    FIELD-SYMBOLS: &lt;ls_local&gt; LIKE LINE OF is_files-local.
    LOOP AT is_files-local ASSIGNING &lt;ls_local&gt;.
      lv_str = |{ &lt;ls_local&gt;-item-obj_type } { &lt;ls_local&gt;-item-obj_name }|.
      APPEND lv_str TO lt_objects.
    ENDLOOP.

    SORT lt_objects AS TEXT.
    DELETE ADJACENT DUPLICATES FROM lt_objects.

    IF lines( lt_objects ) = 1.
      rv_comment = |BG: { lv_str }|.
    ELSE.
      rv_comment = &apos;BG: Multiple objects&apos; ##NO_TEXT.
      LOOP AT lt_objects INTO lv_str.
        CONCATENATE rv_comment zif_abapgit_definitions=&gt;c_newline lv_str INTO rv_comment.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD push_fixed.

    DATA: ls_comment TYPE zif_abapgit_definitions=&gt;ty_comment,
          ls_files   TYPE zif_abapgit_definitions=&gt;ty_stage_files,
          lo_stage   TYPE REF TO zcl_abapgit_stage.

    FIELD-SYMBOLS: &lt;ls_local&gt;  LIKE LINE OF ls_files-local,
                   &lt;ls_remote&gt; LIKE LINE OF ls_files-remote.
    ls_files = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( io_repo ).
    ASSERT lines( ls_files-local ) &gt; 0
        OR lines( ls_files-remote ) &gt; 0.

    CREATE OBJECT lo_stage.

    LOOP AT ls_files-local ASSIGNING &lt;ls_local&gt;.
      mo_log-&gt;add_info( |stage: {
        &lt;ls_local&gt;-file-path } {
        &lt;ls_local&gt;-file-filename }| ).
      lo_stage-&gt;add( iv_path     = &lt;ls_local&gt;-file-path
                     iv_filename = &lt;ls_local&gt;-file-filename
                     iv_data     = &lt;ls_local&gt;-file-data ).
    ENDLOOP.

    LOOP AT ls_files-remote ASSIGNING &lt;ls_remote&gt;.

      mo_log-&gt;add_info( |removed: {
        &lt;ls_remote&gt;-path } {
        &lt;ls_remote&gt;-filename }| ).

      lo_stage-&gt;rm( iv_path     = &lt;ls_remote&gt;-path
                    iv_filename = &lt;ls_remote&gt;-filename ).

    ENDLOOP.

    ls_comment-committer-name  = iv_name.
    ls_comment-committer-email = iv_email.
    ls_comment-comment         = build_comment( ls_files ).

    io_repo-&gt;push( is_comment = ls_comment
                   io_stage   = lo_stage ).

  ENDMETHOD.
  METHOD zif_abapgit_background~get_description.

    rv_description = &apos;Automatic push, fixed author&apos; ##NO_TEXT.

  ENDMETHOD.
  METHOD zif_abapgit_background~get_settings.

    DATA: ls_setting LIKE LINE OF ct_settings.
    READ TABLE ct_settings WITH KEY key = c_settings-name INTO ls_setting.
    IF sy-subrc &lt;&gt; 0.
      ls_setting-key = c_settings-name.
      ls_setting-value = &apos;foobar&apos;.
      APPEND ls_setting TO ct_settings.
    ENDIF.

    READ TABLE ct_settings WITH KEY key = c_settings-email INTO ls_setting.
    IF sy-subrc &lt;&gt; 0.
      ls_setting-key = c_settings-email.
      ls_setting-value = &apos;foobar@localhost&apos;.
      APPEND ls_setting TO ct_settings.
    ENDIF.

  ENDMETHOD.
  METHOD zif_abapgit_background~run.

    DATA: ls_files   TYPE zif_abapgit_definitions=&gt;ty_stage_files,
          ls_setting LIKE LINE OF it_settings,
          lv_name    TYPE string,
          lv_email   TYPE string.

    mo_log = io_log.
    ls_files = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( io_repo ).

    IF lines( ls_files-local ) = 0 AND lines( ls_files-remote ) = 0.
      io_log-&gt;add_info( &apos;Nothing to stage&apos; ).
      RETURN.
    ENDIF.

    READ TABLE it_settings WITH KEY key = c_settings-name INTO ls_setting. &quot;#EC CI_SUBRC
    lv_name = ls_setting-value.

    READ TABLE it_settings WITH KEY key = c_settings-email INTO ls_setting. &quot;#EC CI_SUBRC
    lv_email = ls_setting-value.

    push_fixed(
      io_repo  = io_repo
      iv_name  = lv_name
      iv_email = lv_email ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_BACKGROUND_PUSH_AU IMPLEMENTATION.
  METHOD build_comment.

    DATA: lt_objects TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
          lv_str     TYPE string.

    FIELD-SYMBOLS: &lt;ls_local&gt; LIKE LINE OF is_files-local.
    LOOP AT is_files-local ASSIGNING &lt;ls_local&gt;.
      lv_str = |{ &lt;ls_local&gt;-item-obj_type } { &lt;ls_local&gt;-item-obj_name }|.
      APPEND lv_str TO lt_objects.
    ENDLOOP.

    SORT lt_objects AS TEXT.
    DELETE ADJACENT DUPLICATES FROM lt_objects.

    IF lines( lt_objects ) = 1.
      rv_comment = |BG: { lv_str }|.
    ELSE.
      rv_comment = &apos;BG: Multiple objects&apos; ##NO_TEXT.
      LOOP AT lt_objects INTO lv_str.
        CONCATENATE rv_comment zif_abapgit_definitions=&gt;c_newline lv_str INTO rv_comment.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD determine_user_details.

    DATA: lo_user_master_record TYPE REF TO zcl_abapgit_user_master_record.
    lo_user_master_record = zcl_abapgit_user_master_record=&gt;get_instance( iv_changed_by ).
    rs_user-name = lo_user_master_record-&gt;get_name( ).
    rs_user-email = lo_user_master_record-&gt;get_email( ).

*   If no email, fall back to localhost/default email
    IF rs_user-email IS INITIAL.
      rs_user-email = |{ iv_changed_by }@localhost|.
    ENDIF.

*   If no full name maintained, just use changed by user name
    IF rs_user-name IS INITIAL.
      rs_user-name  = iv_changed_by.
    ENDIF.

  ENDMETHOD.
  METHOD push_auto.

    TYPES: BEGIN OF ty_changed,
             filename   TYPE string,
             path       TYPE string,
             changed_by TYPE xubname,
           END OF ty_changed.

    DATA: ls_comment    TYPE zif_abapgit_definitions=&gt;ty_comment,
          ls_files      TYPE zif_abapgit_definitions=&gt;ty_stage_files,
          lt_changed    TYPE STANDARD TABLE OF ty_changed WITH DEFAULT KEY,
          lt_users      TYPE STANDARD TABLE OF xubname WITH DEFAULT KEY,
          ls_user_files LIKE ls_files,
          lv_changed_by LIKE LINE OF lt_users,
          lo_stage      TYPE REF TO zcl_abapgit_stage.

    FIELD-SYMBOLS: &lt;ls_changed&gt; LIKE LINE OF lt_changed,
                   &lt;ls_remote&gt;  LIKE LINE OF ls_files-remote,
                   &lt;ls_local&gt;   LIKE LINE OF ls_files-local.
    ls_files = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( io_repo ).

    LOOP AT ls_files-local ASSIGNING &lt;ls_local&gt;.
      lv_changed_by = zcl_abapgit_objects=&gt;changed_by( &lt;ls_local&gt;-item ).
      APPEND lv_changed_by TO lt_users.
      APPEND INITIAL LINE TO lt_changed ASSIGNING &lt;ls_changed&gt;.
      &lt;ls_changed&gt;-changed_by = lv_changed_by.
      &lt;ls_changed&gt;-filename   = &lt;ls_local&gt;-file-filename.
      &lt;ls_changed&gt;-path       = &lt;ls_local&gt;-file-path.
    ENDLOOP.

    SORT lt_users ASCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_users.

    LOOP AT lt_users INTO lv_changed_by.
      CLEAR: ls_comment.

*     Fill user details
      ls_comment-committer = determine_user_details( lv_changed_by ).

      CREATE OBJECT lo_stage.

      CLEAR ls_user_files.

      LOOP AT ls_files-local ASSIGNING &lt;ls_local&gt;.
        READ TABLE lt_changed WITH KEY
          path = &lt;ls_local&gt;-file-path
          filename = &lt;ls_local&gt;-file-filename
          changed_by = lv_changed_by
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          mo_log-&gt;add_info( |stage: {
            ls_comment-committer-name } {
            &lt;ls_local&gt;-file-path } {
            &lt;ls_local&gt;-file-filename }| ).

          lo_stage-&gt;add( iv_path     = &lt;ls_local&gt;-file-path
                         iv_filename = &lt;ls_local&gt;-file-filename
                         iv_data     = &lt;ls_local&gt;-file-data ).

          APPEND &lt;ls_local&gt; TO ls_user_files-local.

          LOOP AT ls_files-remote ASSIGNING &lt;ls_remote&gt;
              WHERE filename = &lt;ls_local&gt;-file-filename
              AND path &lt;&gt; &lt;ls_local&gt;-file-path
              AND filename &lt;&gt; &apos;package.devc.xml&apos;.
            mo_log-&gt;add_info( |rm: {
              &lt;ls_remote&gt;-path } {
              &lt;ls_remote&gt;-filename }| ).

* rm old file when object has moved
            lo_stage-&gt;rm(
              iv_path     = &lt;ls_remote&gt;-path
              iv_filename = &lt;ls_remote&gt;-filename ).
            EXIT. &quot; assumption: only one file
          ENDLOOP.
        ENDIF.
      ENDLOOP.

      ls_comment-comment = build_comment( ls_user_files ).

      io_repo-&gt;push( is_comment = ls_comment
                     io_stage   = lo_stage ).
    ENDLOOP.

    IF lines( ls_files-remote ) &gt; 0.
      push_deletions( io_repo  = io_repo
                      is_files = ls_files ).
    ENDIF.

  ENDMETHOD.
  METHOD push_deletions.

    DATA: lo_stage   TYPE REF TO zcl_abapgit_stage,
          ls_comment TYPE zif_abapgit_definitions=&gt;ty_comment.

    FIELD-SYMBOLS: &lt;ls_remote&gt; LIKE LINE OF is_files-remote.

    ASSERT lines( is_files-remote ) &gt; 0.

    CREATE OBJECT lo_stage.

    LOOP AT is_files-remote ASSIGNING &lt;ls_remote&gt;.

      mo_log-&gt;add_info( |removed: {
        &lt;ls_remote&gt;-path } {
        &lt;ls_remote&gt;-filename }| ).

      lo_stage-&gt;rm( iv_path     = &lt;ls_remote&gt;-path
                    iv_filename = &lt;ls_remote&gt;-filename ).

    ENDLOOP.

    ls_comment-committer-name  = &apos;Deletion&apos; ##NO_TEXT.
    ls_comment-committer-email = &apos;deletion@localhost&apos;.
    ls_comment-comment         = build_comment( is_files ).

    io_repo-&gt;push( is_comment = ls_comment
                   io_stage   = lo_stage ).

  ENDMETHOD.
  METHOD zif_abapgit_background~get_description.

    rv_description = &apos;Automatic push, auto author&apos; ##NO_TEXT.

  ENDMETHOD.
  METHOD zif_abapgit_background~get_settings.

    RETURN.

  ENDMETHOD.
  METHOD zif_abapgit_background~run.

    DATA: ls_files TYPE zif_abapgit_definitions=&gt;ty_stage_files.

    mo_log = io_log.
    ls_files = zcl_abapgit_factory=&gt;get_stage_logic( )-&gt;get( io_repo ).

    IF lines( ls_files-local ) = 0 AND lines( ls_files-remote ) = 0.
      io_log-&gt;add_info( &apos;Nothing to stage&apos; ) ##NO_TEXT.
      RETURN.
    ENDIF.

    push_auto( io_repo ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_BACKGROUND_PULL IMPLEMENTATION.
  METHOD zif_abapgit_background~get_description.

    rv_description = &apos;Automatic pull&apos; ##NO_TEXT.

  ENDMETHOD.
  METHOD zif_abapgit_background~get_settings.
    RETURN.
  ENDMETHOD.
  METHOD zif_abapgit_background~run.

    DATA: ls_checks TYPE zif_abapgit_definitions=&gt;ty_deserialize_checks.
* todo, set defaults in ls_checks
    io_repo-&gt;deserialize( ls_checks ).

  ENDMETHOD.
ENDCLASS.
CLASS ZCL_ABAPGIT_BACKGROUND IMPLEMENTATION.
  METHOD list_methods.

    DATA: ls_method       LIKE LINE OF rt_methods,
          ls_key          TYPE seoclskey,
          lt_implementing TYPE seor_implementing_keys,
          ls_implementing LIKE LINE OF lt_implementing.

    FIELD-SYMBOLS: &lt;ls_method&gt; LIKE LINE OF rt_methods.
* in order to handle local classes in the compiled report
    ls_method-class = &apos;ZCL_ABAPGIT_BACKGROUND_PULL&apos;.
    INSERT ls_method INTO TABLE rt_methods.
    ls_method-class = &apos;ZCL_ABAPGIT_BACKGROUND_PUSH_AU&apos;.
    INSERT ls_method INTO TABLE rt_methods.
    ls_method-class = &apos;ZCL_ABAPGIT_BACKGROUND_PUSH_FI&apos;.
    INSERT ls_method INTO TABLE rt_methods.

    ls_key-clsname = &apos;ZIF_ABAPGIT_BACKGROUND&apos;.

    CALL FUNCTION &apos;SEO_INTERFACE_IMPLEM_GET_ALL&apos;
      EXPORTING
        intkey       = ls_key
      IMPORTING
        impkeys      = lt_implementing
      EXCEPTIONS
        not_existing = 1
        OTHERS       = 2 ##FM_SUBRC_OK.
    LOOP AT lt_implementing INTO ls_implementing.
      ls_method-class = ls_implementing-clsname.
      INSERT ls_method INTO TABLE rt_methods.
    ENDLOOP.

    LOOP AT rt_methods ASSIGNING &lt;ls_method&gt;.
      CALL METHOD (&lt;ls_method&gt;-class)=&gt;zif_abapgit_background~get_description
        RECEIVING
          rv_description = &lt;ls_method&gt;-description.
    ENDLOOP.

  ENDMETHOD.
  METHOD run.

    CONSTANTS: lc_enq_type TYPE c LENGTH 12 VALUE &apos;BACKGROUND&apos;.

    DATA: lo_per        TYPE REF TO zcl_abapgit_persist_background,
          lo_repo       TYPE REF TO zcl_abapgit_repo_online,
          lt_list       TYPE zcl_abapgit_persist_background=&gt;tt_background,
          li_background TYPE REF TO zif_abapgit_background,
          lo_log        TYPE REF TO zcl_abapgit_log,
          lv_repo_name  TYPE string.

    FIELD-SYMBOLS: &lt;ls_list&gt; LIKE LINE OF lt_list.
    CALL FUNCTION &apos;ENQUEUE_EZABAPGIT&apos;
      EXPORTING
        mode_zabapgit  = &apos;E&apos;
        type           = lc_enq_type
        _scope         = &apos;3&apos;
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc &lt;&gt; 0.
      WRITE: / &apos;Another intance of the program is already running&apos; ##NO_TEXT.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_per.
    lt_list = lo_per-&gt;list( ).

    WRITE: / &apos;Background mode&apos; ##NO_TEXT.

    LOOP AT lt_list ASSIGNING &lt;ls_list&gt;.
      lo_repo ?= zcl_abapgit_repo_srv=&gt;get_instance( )-&gt;get( &lt;ls_list&gt;-key ).
      lv_repo_name = lo_repo-&gt;get_name( ).
      WRITE: / &lt;ls_list&gt;-method, lv_repo_name.

      zcl_abapgit_login_manager=&gt;set(
        iv_uri      = lo_repo-&gt;get_url( )
        iv_username = &lt;ls_list&gt;-username
        iv_password = &lt;ls_list&gt;-password ).

      CREATE OBJECT lo_log.
      CREATE OBJECT li_background TYPE (&lt;ls_list&gt;-method).

      li_background-&gt;run(
        io_repo     = lo_repo
        io_log      = lo_log
        it_settings = &lt;ls_list&gt;-settings ).

      lo_log-&gt;write( ).
    ENDLOOP.

    IF lines( lt_list ) = 0.
      WRITE: / &apos;Nothing configured&apos; ##NO_TEXT.
    ENDIF.

    CALL FUNCTION &apos;DEQUEUE_EZABAPGIT&apos;
      EXPORTING
        type = lc_enq_type.

  ENDMETHOD.
ENDCLASS.
SELECTION-SCREEN BEGIN OF SCREEN 1001.
* dummy for triggering screen on Java SAP GUI
SELECTION-SCREEN END OF SCREEN 1001.

****************************************************
* abapmerge - ZABAPGIT_PASSWORD_DIALOG
****************************************************
*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZABAPGIT_PASSWORD_DIALOG
*&amp;---------------------------------------------------------------------*
TABLES sscrfields.

SELECTION-SCREEN BEGIN OF SCREEN 1002 TITLE s_title.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(10) s_url FOR FIELD p_url.
PARAMETERS: p_url  TYPE string LOWER CASE VISIBLE LENGTH 40 ##SEL_WRONG.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(10) s_user FOR FIELD p_user.
PARAMETERS: p_user TYPE string LOWER CASE VISIBLE LENGTH 40 ##SEL_WRONG.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(10) s_pass FOR FIELD p_pass.
PARAMETERS: p_pass TYPE string LOWER CASE VISIBLE LENGTH 40 ##SEL_WRONG.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF SCREEN 1002.

*-----------------------------------------------------------------------
* LCL_PASSWORD_DIALOG
*-----------------------------------------------------------------------
CLASS lcl_password_dialog DEFINITION FINAL.

**************
* This class will remain local in the report
**************

  PUBLIC SECTION.
    CONSTANTS c_dynnr TYPE char4 VALUE &apos;1002&apos;.

    CLASS-METHODS popup
      IMPORTING
        iv_repo_url TYPE string
      CHANGING
        cv_user     TYPE string
        cv_pass     TYPE string.

    CLASS-METHODS on_screen_init.
    CLASS-METHODS on_screen_output.
    CLASS-METHODS on_screen_event
      IMPORTING
        iv_ucomm TYPE syucomm.

  PRIVATE SECTION.
    CLASS-DATA gv_confirm TYPE abap_bool.
    CLASS-METHODS enrich_title_by_hostname
      IMPORTING
        iv_repo_url TYPE string.

ENDCLASS.

CLASS lcl_password_dialog IMPLEMENTATION.

  METHOD popup.

    CLEAR p_pass.
    p_url      = iv_repo_url.
    p_user     = cv_user.
    gv_confirm = abap_false.
    enrich_title_by_hostname( iv_repo_url ).

    CALL SELECTION-SCREEN c_dynnr STARTING AT 5 5 ENDING AT 60 8.

    IF gv_confirm = abap_true.
      cv_user = p_user.
      cv_pass = p_pass.
    ELSE.
      CLEAR: cv_user, cv_pass.
    ENDIF.

    CLEAR: p_url, p_user, p_pass.

  ENDMETHOD.

  METHOD on_screen_init.
    s_title = &apos;Login&apos;     ##NO_TEXT.
    s_url   = &apos;Repo URL&apos;  ##NO_TEXT.
    s_user  = &apos;User&apos;      ##NO_TEXT.
    s_pass  = &apos;Password&apos;  ##NO_TEXT.
  ENDMETHOD.

  METHOD on_screen_output.
    DATA lt_ucomm TYPE TABLE OF sy-ucomm.

    ASSERT sy-dynnr = c_dynnr.

    LOOP AT SCREEN.
      IF screen-name = &apos;P_URL&apos;.
        screen-input       = &apos;0&apos;.
        screen-intensified = &apos;1&apos;.
        screen-display_3d  = &apos;0&apos;.
        MODIFY SCREEN.
      ENDIF.
      IF screen-name = &apos;P_PASS&apos;.
        screen-invisible   = &apos;1&apos;.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

    &quot; Program RSSYSTDB, GUI Status %_CSP
    PERFORM set_pf_status IN PROGRAM rsdbrunt IF FOUND.
    APPEND &apos;NONE&apos; TO lt_ucomm.  &quot;Button Check
    APPEND &apos;SPOS&apos; TO lt_ucomm.  &quot;Save as Variant

    CALL FUNCTION &apos;RS_SET_SELSCREEN_STATUS&apos;
      EXPORTING
        p_status  = sy-pfkey
      TABLES
        p_exclude = lt_ucomm.

    IF p_user IS NOT INITIAL.
      SET CURSOR FIELD &apos;P_PASS&apos;.
    ENDIF.

  ENDMETHOD.

  METHOD on_screen_event.
    ASSERT sy-dynnr = c_dynnr.

    &quot; CRET   - F8
    &quot; OTHERS - simulate Enter press
    CASE iv_ucomm.
      WHEN &apos;CRET&apos;.
        gv_confirm = abap_true.
      WHEN OTHERS. &quot;TODO REFACTOR !!! A CLUTCH !
        &quot; This will work unless any new specific logic appear
        &quot; for other commands. The problem is that the password dialog
        &quot; does not have Enter event (or I don&apos;t know how to activate it ;)
        &quot; so Enter issues previous command from previous screen
        &quot; But for now this works :) Fortunately Esc produces another flow
        gv_confirm = abap_true.
        LEAVE TO SCREEN 0.
    ENDCASE.

  ENDMETHOD.
  METHOD enrich_title_by_hostname.

    DATA lv_host TYPE string.

    FIND REGEX &apos;https?://([^/^:]*)&apos; IN iv_repo_url SUBMATCHES lv_host.
    IF lv_host IS NOT INITIAL AND lv_host &lt;&gt; space.
      CLEAR s_title.
      CONCATENATE &apos;Login:&apos; lv_host INTO s_title IN CHARACTER MODE SEPARATED BY space.
    ENDIF.

  ENDMETHOD.

ENDCLASS.
* create class ZCL_ABAPGIT_AUTH_EXIT implementing ZIF_ABAPGIT_AUTH in following include,
* if using the development version of abapGit create a global class instead
* place the object in a different package than ZABAPGIT
INCLUDE zabapgit_authorizations_exit IF FOUND.

* create class ZCL_ABAPGIT_USER_EXIT implementing ZIF_ABAPGIT_EXIT in following include,
* if using the development version of abapGit create a global class instead
* place the object in a different package than ZABAPGIT
INCLUDE zabapgit_user_exit IF FOUND.

INCLUDE zabapgit_gui_pages_userexit IF FOUND.

****************************************************
* abapmerge - ZABAPGIT_FORMS
****************************************************
*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZABAPGIT_FORMS
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp;      Form  run
*&amp;---------------------------------------------------------------------*
FORM run.

  DATA: lx_exception TYPE REF TO zcx_abapgit_exception,
        lv_ind       TYPE t000-ccnocliind.
  SELECT SINGLE ccnocliind FROM t000 INTO lv_ind
    WHERE mandt = sy-mandt.
  IF sy-subrc = 0
      AND lv_ind &lt;&gt; &apos; &apos;
      AND lv_ind &lt;&gt; &apos;1&apos;. &quot; check changes allowed
    WRITE: / &apos;Wrong client, changes to repository objects not allowed&apos;. &quot;#EC NOTEXT
    RETURN.
  ENDIF.

  TRY.
      zcl_abapgit_migrations=&gt;run( ).
      PERFORM open_gui.
    CATCH zcx_abapgit_exception INTO lx_exception.
      MESSAGE lx_exception TYPE &apos;E&apos;.
  ENDTRY.

ENDFORM.                    &quot;run

FORM open_gui RAISING zcx_abapgit_exception.

  IF sy-batch = abap_true.
    zcl_abapgit_background=&gt;run( ).
  ELSE.

    zcl_abapgit_services_abapgit=&gt;prepare_gui_startup( ).
    zcl_abapgit_ui_factory=&gt;get_gui( )-&gt;go_home( ).
    CALL SELECTION-SCREEN 1001. &quot; trigger screen

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  branch_popup
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;TT_FIELDS      text
*      --&gt;PV_CODE        text
*      --&gt;CS_ERROR       text
*      --&gt;CV_SHOW_POPUP  text
*      --&gt;RAISING        text
*      --&gt;zcx_abapgit_exception  text
*      --&gt;##CALLED       text
*      --&gt;##NEEDED       text
*----------------------------------------------------------------------*
FORM branch_popup TABLES   tt_fields TYPE zif_abapgit_definitions=&gt;ty_sval_tt
                  USING    pv_code TYPE clike
                  CHANGING cs_error TYPE svale
                           cv_show_popup TYPE c
                  RAISING zcx_abapgit_exception ##called ##needed.
* called dynamically from function module POPUP_GET_VALUES_USER_BUTTONS

  DATA: lx_error  TYPE REF TO zcx_abapgit_exception,
        li_popups TYPE REF TO zif_abapgit_popups.

  TRY.
      li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
      li_popups-&gt;branch_popup_callback(
        EXPORTING
          iv_code       = pv_code
        CHANGING
          ct_fields     = tt_fields[]
          cs_error      = cs_error
          cv_show_popup = cv_show_popup ).

    CATCH zcx_abapgit_exception INTO lx_error.
      MESSAGE lx_error TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
  ENDTRY.

ENDFORM.                    &quot;branch_popup

FORM package_popup TABLES   tt_fields TYPE zif_abapgit_definitions=&gt;ty_sval_tt
                   USING    pv_code TYPE clike
                   CHANGING cs_error TYPE svale
                            cv_show_popup TYPE c
                   RAISING  zcx_abapgit_exception ##called ##needed.
* called dynamically from function module POPUP_GET_VALUES_USER_BUTTONS

  DATA: lx_error  TYPE REF TO zcx_abapgit_exception,
        li_popups TYPE REF TO zif_abapgit_popups.

  TRY.
      li_popups = zcl_abapgit_ui_factory=&gt;get_popups( ).
      li_popups-&gt;package_popup_callback(
        EXPORTING
          iv_code       = pv_code
        CHANGING
          ct_fields     = tt_fields[]
          cs_error      = cs_error
          cv_show_popup = cv_show_popup ).

    CATCH zcx_abapgit_exception INTO lx_error.
      MESSAGE lx_error TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
  ENDTRY.

ENDFORM.                    &quot;package_popup

FORM output.
  DATA: lt_ucomm TYPE TABLE OF sy-ucomm.

  PERFORM set_pf_status IN PROGRAM rsdbrunt IF FOUND.

  APPEND &apos;CRET&apos; TO lt_ucomm.  &quot;Button Execute

  CALL FUNCTION &apos;RS_SET_SELSCREEN_STATUS&apos;
    EXPORTING
      p_status  = sy-pfkey
    TABLES
      p_exclude = lt_ucomm.

ENDFORM.

FORM exit RAISING zcx_abapgit_exception.
  CASE sy-ucomm.
    WHEN &apos;CBAC&apos;.  &quot;Back
      IF zcl_abapgit_ui_factory=&gt;get_gui( )-&gt;back( ) IS INITIAL.
        LEAVE TO SCREEN 1001.
      ENDIF.
  ENDCASE.
ENDFORM.

FORM password_popup
      USING
        iv_repo_url TYPE string
      CHANGING
        cv_user     TYPE string
        cv_pass     TYPE string.

  lcl_password_dialog=&gt;popup(
    EXPORTING
      iv_repo_url     = iv_repo_url
    CHANGING
      cv_user         = cv_user
      cv_pass         = cv_pass ).

ENDFORM.
**********************************************************************
INITIALIZATION.
  lcl_password_dialog=&gt;on_screen_init( ).

START-OF-SELECTION.
  PERFORM run.

* Hide Execute button from screen
AT SELECTION-SCREEN OUTPUT.
  IF sy-dynnr = lcl_password_dialog=&gt;c_dynnr.
    lcl_password_dialog=&gt;on_screen_output( ).
  ELSE.
    PERFORM output.
  ENDIF.

* SAP back command re-direction
AT SELECTION-SCREEN ON EXIT-COMMAND.
  PERFORM exit.

AT SELECTION-SCREEN.
  IF sy-dynnr = lcl_password_dialog=&gt;c_dynnr.
    lcl_password_dialog=&gt;on_screen_event( sscrfields-ucomm ).
  ENDIF.
****************************************************
* abapmerge undefined - 2018-12-04T05:35:29.680Z
****************************************************</source>
 </PROG>
 <PROG NAME="ZABAPGIT_TEST_SSL" VARCL="X" SUBC="1" RMAND="200" RLOAD="1" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="1">
    <textElement ID="R" ENTRY="zabapgit_test_ssl" LENGTH="17 "/>
   </language>
  </textPool>
  <source>REPORT zabapgit_test_ssl.

* See https://github.com/larshp/abapGit/

PARAMETERS: p_url1 TYPE swc_value DEFAULT &apos;https://github.com&apos;,
            p_url2 TYPE swc_value DEFAULT &apos;https://api.github.com&apos;,
            p_id   TYPE ssfapplssl DEFAULT &apos;ANONYM&apos;.
* api.github.com is used when pushing code back to github

SELECTION-SCREEN BEGIN OF BLOCK proxy WITH FRAME.
* proxy settings, fill if your system is behind a proxy
PARAMETERS: p_proxy  TYPE string,
            p_pxport TYPE string,
            p_puser  TYPE string,
            p_ppwd   TYPE string.
SELECTION-SCREEN END OF BLOCK proxy.

START-OF-SELECTION.
  PERFORM run USING p_url1.
  WRITE: /, &apos;----&apos;, /.
  PERFORM run USING p_url2.

FORM run USING iv_url TYPE swc_value.

  DATA: lv_code          TYPE i,
        lv_url           TYPE string,
        li_client        TYPE REF TO if_http_client,
        lt_errors        TYPE TABLE OF string,
        lv_error_message TYPE string.

  IF iv_url IS INITIAL.
    RETURN.
  ENDIF.

  lv_url = iv_url.
  cl_http_client=&gt;create_by_url(
    EXPORTING
      url           = lv_url
      ssl_id        = p_id
      proxy_host    = p_proxy
      proxy_service = p_pxport
    IMPORTING
      client        = li_client ).

  IF NOT p_puser IS INITIAL.
    li_client-&gt;authenticate(
      proxy_authentication = abap_true
      username             = p_puser
      password             = p_ppwd ).
  ENDIF.

  li_client-&gt;send( ).
  li_client-&gt;receive(
    EXCEPTIONS
      http_communication_failure = 1
      http_invalid_state         = 2
      http_processing_failed     = 3
      OTHERS                     = 4 ).
  IF sy-subrc &lt;&gt; 0.
    WRITE: / &apos;Error Number&apos;, sy-subrc, /.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    li_client-&gt;get_last_error(
      IMPORTING
        message = lv_error_message ).
    SPLIT lv_error_message AT cl_abap_char_utilities=&gt;newline INTO TABLE lt_errors.
    LOOP AT lt_errors INTO lv_error_message.
      WRITE: / lv_error_message.
    ENDLOOP.
    WRITE: / &apos;Also check transaction SMICM -&gt; Goto -&gt; Trace File -&gt; Display End&apos;.
    RETURN.
  ENDIF.

* if SSL Handshake fails, make sure to also check https://launchpad.support.sap.com/#/notes/510007

  li_client-&gt;response-&gt;get_status(
    IMPORTING
      code = lv_code ).
  IF lv_code = 200.
    WRITE: / lv_url, &apos;: ok&apos;.
  ELSE.
    WRITE: / &apos;Error&apos;, lv_code.
  ENDIF.

ENDFORM.</source>
 </PROG>
</nugget>
